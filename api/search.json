[{"id":"03a1af7058cec8bb8efe418ed228e157","title":"正则表达式","content":"正则表达式正则表达式: regular expression &#x3D;&gt; RegExp\n思维导图\n\n引入:为什么要学习正则表达式\n\n快速入门假设content已经是通过爬虫抓取的文本，从中获取ip地址。通过正则表达式即可很方便的获取\njavapublic static void main(String[] args) &#123;\n    String content = &quot;私有地址（Private address）属于非注册地址，专门为组织机构内部使用。\\n&quot; +\n            &quot;以下列出留用的内部私有地址\\n&quot; +\n            &quot;A类 10.0.0.0--10.255.255.255\\n&quot; +\n            &quot;B类 172.16.0.0--172.31.255.255\\n&quot; +\n            &quot;C类 192.168.0.0--192.168.255.255&quot;;\n    //(1). 传统方法. 使用遍历方式，代码量大，效率不高\n    //(2). 正则表达式技术\n    //1. \\\\d表示一个任意数字\n    Pattern pattern = Pattern.compile(&quot;\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+&quot;);\n    //2. 创建模式对象[即正则表达式对象]\n    //理解： 就是 matcher 匹配器按照 pattern(模式/样式), 到 content 文本中去匹配\n    //找到就返回true, 否则就返回false\n    int no = 0;\n    //3. 创建匹配器\n    //创建匹配器matcher，按照 正则表达式的规则 去匹配，content字符串\n    Matcher matcher = pattern.matcher(content);\n    //4. 可以开始循环匹配\n    while (matcher.find()) &#123;\n        //匹配内容，文本，放到 m.group(0)\n        System.out.println(&quot;找到: &quot; + (++no) + &quot; &quot; +matcher.group(0));\n    &#125;\n&#125;输出效果如图所示\n结论: 为了解决上述问题，Java提供了正则表达式技术，专门用于处理类似文本问题。正则表达式是对字符串执行模式匹配的技术。\n\n(重要)底层实现目标：匹配所有四个数字\n假设String字符串如下\njavaString content = &quot;1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了&quot; +\n        &quot;第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型&quot; +\n        &quot;版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的&quot; +\n        &quot;标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应&quot; +\n        &quot;用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个&quot; +\n        &quot;里程碑，标志着Java的应用开始普及9889 &quot;;matcher.find考虑分组情况： 比如  (\\d\\d)(\\d\\d) ,正则表达式中有() 表示分组,第1个()表示第1组,第2个()表示第2组…\n1、根据指定的规则，定位满足规则的子字符串(比如(19)(98))\n2、找到后，将 子字符串的开始的索引 和 子字符串的结束的索引+1 记录到 matcher对象属性 int[] groups。如果没有分组则只有2.1，如果含有分组则按顺序执行。\n​\t\t2.1  groups[0]  记录开始的索引位置，groups[1]  记录子字符串的结束的索引+1的值（举例: 1998-&gt; groups[0] &#x3D; 0, groups[1] &#x3D; 4）\n​\t\t2.2 groups[2]  记录第一组开始的索引的位置，groups[3]  记录第一组结束的索引+1的值（举例: (19) - &gt; groups[2] &#x3D; 0, groups[3] &#x3D; 2）\n​\t\t2.3 groups[4]  记录第二组开始的索引的位置，groups[5] 记录第二组结束的索引+1的值（举例: (98) - &gt; groups[4] &#x3D; 2, groups[5] &#x3D; 4）\n​\t\t2.4  更多分组同理…..\n​\t3、同时记录oldLast的值为 子字符串结束的索引+1的值，即下次执行find时，就从oldLast开始匹配（举例: 1999-&gt;oldLast&#x3D;35，下次find从35索引开始匹配 ）\nmatcher.group1、如果没有分组，直接执行matcher.group(0)即可打印结果。\n2、如果有分组，如下(条件: 分组的数不能越界)\n​\t2.1 group(0) 表示匹配到的子字符串\n​\t2.2 group(1) 表示匹配到的子字符串的第1组字串\n​\t2.3 group(2) 表示匹配到的子字符串的第2组字串\n源码\njavamatcher.group源码:\npublic String group(int group) &#123;\n        if (first &lt; 0)\n            throw new IllegalStateException(&quot;No match found&quot;);\n        if (group &lt; 0 || group &gt; groupCount())\n            throw new IndexOutOfBoundsException(&quot;No group &quot; + group);\n        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))\n            return null;\n        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();\n&#125;举例说明:  \n根据 groups[0]&#x3D;31 和 groups[1]&#x3D;35 的记录的位置，从content开始截取子字符串返回就是 [31,35) 包含 31 但是不包含索引为 35的位置\n底层分析\n\n正则表达式语法基本介绍如果要想灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为:\n1、限定符\n2、选择匹配符\n3、分组组合和反向引用符\n4、特殊字符\t\n5、字符匹配符\t\n6、定位符\n贪婪匹配和非贪婪匹配贪婪匹配：java匹配默认贪婪匹配，而默认的”贪心的”模式是匹配搜索到的、尽可能长的的字符串。\n非贪婪匹配：针对 ?  字符，当此字符紧随任何其他限定符 ( *、+、?、{n}、{n,m} )  之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串。\n例如: 在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有的”o”。\n“o+”输出结果\ntxt找到=oooo“o+?”输出结果\ntxt找到=o\n找到=o\n找到=o\n找到=o元字符-转义号 \\\\需要用到转义符号:\t. * + ( ) $ &#x2F; \\ ? [ ] ^ { } 共14个\n\\\\符号说明: \t在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果，甚至会报错。在Java的正则表达式中，两个\\\\代表其他语言中的一个\\\n 问题: 用 $ 匹配 “abc$(“ 会怎样? 用 ( 匹配 “abc$(“ 会怎样? \n解答: 会报错，因此使用转义符\n代码演示\njavapublic static void main(String[] args) &#123;\n    String content = &quot;abc$(a.bc(123( )&quot;;\n    //匹配( =&gt; \\\\(\n    //匹配. =&gt; \\\\.\n    String regStr = &quot;\\\\.&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到 &quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到 .元字符-字符匹配符\n\n\n符号\n符号\n示例\n解释\n匹配输入\n\n\n\n[ ]\n可接受的字符列表\n[efgh]\ne、f、g、h中的任意1个字符\ne\n\n\n[^]\n不接收的字符列表\n[^abc]\n除a、b、c之外的任意1个字符，包括数字和特殊符号\nd\n\n\n-\n连字符\nA-Z\n任意单个大写字母\nA\n\n\n.\n匹配除 \\n 以外的任何字符\na..b\n以a开头，b结尾，中间包括2个任意字符的长度为4的字符串\naaab、aefb、a35b、a#*b\n\n\n\\\\d\n匹配单个数字字符，相当于[0-9]\n\\\\d{3}(\\\\d)?\n包含3个或4个数字的字符串\n123、9876\n\n\n\\\\D\n匹配单个非数字字符，相当于[ ^0-9]\n\\\\D(\\\\d)*\n以单个非数字字符开头，后接任意个数字字符串\na、A342\n\n\n\\\\w\n匹配单个数字，大小写字母字符，下划线，相当于[0-9a-zA-Z_]\n\\\\d{3}\\\\w{4}\n以3个数字字符开头的长度为7的数字字母字符串\n234abcd、12345Pe\n\n\n\\\\W\n匹配单个非 数字，大小写字母字符，下划线，相当于[ ^0-9a-zA-Z_]\n\\\\W+\\\\d{2}\n以至少一个非数字字母字符开头，2个数字字符结尾的字符串\n#29、#?@10\n\n\n\\\\s\n匹配任何空白字符(空格, 制表符等)\na @\n\n“ “(一个空格)\n\n\n\\\\S与\\\\s相反\nString regStr &#x3D;  “.” 匹配除了 \\n 的所有字符\nString regStr &#x3D; “[.]” 匹配 . 本身 \n应用案例案例一\n[a-z]： 匹配 a-z之间任意一个字符\nabc：匹配 abc 字符串[默认区分大小写]\njavapublic static void main(String[] args) &#123;\n    String content = &quot;a11c8&quot;;\n    String regStr = &quot;[a-z]&quot;; //匹配 a-z之间任意一个字符\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到&quot; + matcher.group(0));\n    &#125;\n&#125;运行结果\ntxt找到a\n找到c案例二\n[^a-z]：匹配不在a-z之间的任意一个字符\n因为加了Pattern.CASE_INSENSITIVE参数所以不区分大小写，只输出数据。\njavapublic static void main(String[] args) &#123;\n    String content = &quot;a11c8ABC&quot;;\n    String regStr = &quot;[^a-z]&quot;; //匹配 a-z之间任意一个字符\n    Pattern pattern = Pattern.compile(regStr, Pattern.CASE_INSENSITIVE);\n    Matcher matcher = pattern.matcher(content);\n\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到&quot; + matcher.group(0));\n    &#125;\n&#125;运行结果\ntxt找到1\n找到1\n找到8区分大小写java正则表达式默认是区分字母大小写的，如何实现不区分大小写。\n1、(?i)abc :表示abc都不区分大小写\n2、a(?i)bc :表示bc不区分大小写\n3、a((?i)b)c : 表示只有b不区分大小写\n4、设置参数 :Pattern pat &#x3D; Pattern.compile(regEx, Pattern.CASE_INSENSITIVE) 则表示匹配时不区分大小写\n元字符-选择匹配符 |在匹配某个字符串的时候是选择性的，这时就需要 选择匹配字符 |\n\n\n\n符号\n符号\n示例\n解释\n\n\n\n|\n匹配”|” 之前或之后的表达式\nab|cd\nab或cd\n\n\n元字符-限定符用于指定其前面的字符和组合项连续出现多少次\n\n\n\n符号\n含义\n示例\n说明\n匹配输入\n\n\n\n*\n指定符号重复0次或n次 (无要求)\n(abc)*\n仅包含任意abc的字符串，等效于\\w*\nabc、abcabcabc\n\n\n+\n指定字符重复1次或n次 (至少一次)  1到多\nm + (abc)*\n以至少1个m开头，后接任意个abc的字符串\nm、mabc、mabcabc\n\n\n?\n指定字符重复0次或1次 (最多一次) 0到1\nm + abc?\n以至少1个m开头，后接ab或abc的字符串\nmab、mabc、mmmab、mmabc\n\n\n{n}\n只能输入n个字符\n[abcd]{3}\n以abcd中字母组成的任意长度为3的字符串\nabc、dbc、adc\n\n\n{n,}\n指定至少n个匹配\n[abcd]{3,}\n由abcd中字母组成的任意长度不小于3的字符串\naab、dbc、aaabdc\n\n\n{n,m}\n指定至少n个单不多于m个匹配\n[abcd]{3,5}\n由abcd中字母组成的任意长度不小于3，不大于5的字符串\nabc、abcd、aaaaa、bcdab\n\n\njava匹配默认贪婪匹配，即尽可能匹配多的。\n“?”紧随任何其他限定符之后时，匹配模式是非贪婪匹配。\n例如:\tcontent &#x3D; “aaaabc”， \t规则为 a[3, 4]\t，结果返回aaaa，索引定位到b。\n例如:\tcontent &#x3D; “111111a”，\t规则为1+\t\t，结果返回111111，索引定位到a\n例如:\tcontent &#x3D; “a111111b”，\t规则为a1?\t，结果返回a111111，索引定位到b\n元字符-定位符定位符，规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置。\n\n\n\n符号\n含义\n示例\n说明\n匹配输入\n\n\n\n^\n指定起始字符\n^[0-9] + [a-z]*\n以至少1个数字开头，后接任意个小写字母的字符串\n123、6aa、555edf\n\n\n$\n指定结束字符\n^[0-9] \\\\- [a-z] + $\n以1个数字开头后接连字符”-“，并以至少1个小写字母结尾的字符串\n1-a\n\n\n\\\\b\n匹配目标字符串的边界\nhan\\\\b\n这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置\nsphan nnhan\n\n\n\\\\B\n匹配目标字符串的非边界\nhan\\\\B\n和\\b的含义刚好相反\nhansss sphan nnhan\n\n\n例如:\tcontent &#x3D; “123abc12”，\t规则为 ^[0-9] + [a-z]*\t，结果返回123abc。\n例如:\tcontent &#x3D; “123abc12”，\t规则为^[0-9] + [a-z] + $\t，没有结果返回。如果把content修改为 “123abc”，结果返回123abc\n例如:\tcontent &#x3D; “hansss sphan nnhan”，\t规则为han\\\\b\t，结果返回han，han。因为sphan和nnhan匹配成功。\n例如:\tcontent &#x3D; “hansss sphan nnhan”，\t规则为han\\\\B\t，结果返回han。因为hansss匹配成功。\n常用、特别分组常用分组(捕获分组):\t(pattern)，(?&lt;name&gt;pattern) \n特别分组(非捕获分组):\t(?:pattern)，(?&#x3D;pattern)，(?!pattern)\n非捕获分组: 不能matcher.group(1)来获取分组\n\n\n\n分组构造形式\n说明\n\n\n\n(pattern)\n非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其他捕获结果则根据左括号的顺序从1开始自动编号。(1，2，3)\n\n\n(?&lt;name&gt;pattern)\n命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号代替尖括号，例如(?’name’)\n\n\n(?:pattern)\n匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储以后使用的匹配。这对于用”or”字符( | )组合模式部件的情况很有用。例如: industr(?:y | ies) 是比 ‘industry | industries’ 更经济的表达式。\n\n\n(?&#x3D;pattern)\n它是一个非捕获匹配。例如: ‘Windows(?&#x3D;95 | 98 | NT | 2000)’ 匹配 “Windows 2000”中的”Windows”，但不匹配”Windows 3.1” 中的 “Windows”。\n\n\n(?!pattern)\n该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如: ‘Windows (?! 95 | 98 | NT 2000)’ 匹配 “Windows 3.1” 中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。\n\n\n常用分组代码演示(pattern) \nmatcher.group() 传入编号\njavapublic static void main(String[] args) &#123;\n    String content = &quot;sasas s7888 nn1189han&quot;;\n    //下面是非命名分组,说明\n    //1. matcher.group(0) 得到匹配的字符串\n    //2. matcher.group(1) 得到匹配到的字符串的第1个分组内容\n    //3. matcher.group(2) 得到匹配到的字符串的第2个分组内容\n    //4. ....\n    String regStr = &quot;(\\\\d\\\\d)(\\\\d)(\\\\d)&quot;; //匹配四个数字\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while(matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n        System.out.println(&quot;第1个分组=&quot; + matcher.group(1));\n        System.out.println(&quot;第2组分组=&quot; + matcher.group(2));\n        System.out.println(&quot;第3组分组=&quot; + matcher.group(3));\n    &#125;\n&#125;输出结果\ntxt找到=7888\n第1个分组=78\n第2组分组=8\n第3组分组=8\n找到=1189\n第1个分组=11\n第2组分组=8\n第3组分组=9(?&lt;name&gt;pattern) \nmatcher.group() 传入组名\njavapublic static void main(String[] args) &#123;\n    String content = &quot;sasas s7888 nn1189han&quot;;\n    //命名分组: 即可以给分组取名\n    String regStr = &quot;(?&lt;g1&gt;\\\\d\\\\d)(?&lt;g2&gt;\\\\d\\\\d)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n\n    while(matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n        System.out.println(&quot;第1个分组[通过组名]=&quot; + matcher.group(&quot;g1&quot;));\n        System.out.println(&quot;第2组分组[通过组名]=&quot; + matcher.group(&quot;g2&quot;));\n    &#125;\n&#125;输出结果\ntxt找到=7888\n第1个分组[通过组名]=78\n第2组分组[通过组名]=88\n找到=1189\n第1个分组[通过组名]=11\n第2组分组[通过组名]=89特别分组代码演示非捕获分组: 不能matcher.group(1)来获取分组\n(?:pattern)  匹配 pattern 但不捕获该匹配的子表达式\nString regStr &#x3D; “小猫吃鱼 | 小猫抓老鼠 | 小猫乱跑” 等价于”小猫(?:吃鱼|抓老鼠|乱跑)” 是非捕获分组。\njavapublic static void main(String[] args) &#123;\n    String content = &quot;小猫吃鱼 小猫抓老鼠 小猫乱跑&quot;;\n    String regStr = &quot;小猫(?:吃鱼|抓老鼠|乱跑)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到=小猫吃鱼\n找到=小猫抓老鼠\n找到=小猫乱跑(?&#x3D;pattern) 匹配满足?&#x3D;pattern的表达式\n举例: 匹配规则 “小猫(?&#x3D;吃鱼|抓老鼠)” 只匹配后缀是吃鱼和抓老鼠的小猫 \njavapublic static void main(String[] args) &#123;\n    String content = &quot;小猫吃鱼 小猫抓老鼠 小猫乱跑&quot;;\n    String regStr = &quot;小猫(?=吃鱼|抓老鼠)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到=小猫\n找到=小猫(?!pattern) 与(?&#x3D;pattern)匹配规则相反\n举例: 匹配规则 “小猫(?!吃鱼|抓老鼠)” 匹配除了后缀是吃鱼和抓老鼠的小猫\njavapublic static void main(String[] args) &#123;\n    String content = &quot;小猫吃鱼 小猫抓老鼠 小猫乱跑&quot;;\n    String regStr = &quot;小猫(?!吃鱼|抓老鼠)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到=小猫正则应用实例代码样式模板\njavapublic static void main(String[] args) &#123;\n    String content = &quot;&quot;;\t//需要匹配的文本\n    String regStr = &quot;&quot;;\t\t//匹配规则\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while(matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\t//根据需求查询\n    &#125;\n    /*\n    if(matcher.find()) &#123;\n        System.out.println(&quot;满足格式&quot;);\n    &#125;else &#123;\n        System.out.println(&quot;不满足格式&quot;);\n    &#125;\n    */\n&#125;示例问题举例\n\n解答\n1、regStr &#x3D; “^[\\u0391-\\uffe5]+$“ \t\n举例: content &#x3D; “小猫爱吃鱼” sout  &#x3D; “满足格式”  或  content &#x3D; “小猫x吃鱼” sout &#x3D; “不满足格式”\n2、regStr &#x3D; “^[1-9]\\\\d{5}$“\n举例: content &#x3D; “123890” sout  &#x3D; “满足格式”\n3、regStr &#x3D; “^[1-9]\\\\d{4,9}$“\n举例: content &#x3D; “1238990” sout &#x3D; “满足格式”  或  content &#x3D; “1238a990” sout &#x3D; “不满足格式”\n4、regStr &#x3D; “^1[3 | 4 | 5 | 8]\\\\d{9}$“\n举例: content  &#x3D; “13588889999”  sout &#x3D; “满足格式”  或  content &#x3D; “1238990” sout &#x3D; “不满足格式”\n5、验证url地址\n思路分析\n1、先确定url开始部分 https:&#x2F;&#x2F; | http:&#x2F;&#x2F; \t规则-&gt; ^((https | http):&#x2F;&#x2F;)\n2、然后匹配ip地址 www.bilbil.com\t规则-&gt;www. 和bilbil. 匹配 ([\\\\w-]+\\\\.)+ \tcom 匹配的是 [\\\\w-]+\n3、&#x2F;video&#x2F;BV1Qj41177e9&#x2F;?spm_id_from&#x3D;333\t规则-&gt; (\\/[\\\\w-?&#x3D;&amp;&#x2F;%.#]*)?$\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;https://&quot; +\n            &quot;www.bilibili.com&quot; +\n            &quot;/video/BV1Qj41177e9/?spm_id_from=333.1007.tianma.1-3-3.click&amp;vd_source=68ae6e90dea85507b9aca2772fb25cd8&quot;; //url地址\n    /**\n     * 思路\n     * 1. 先确定url开始部分 https:// | http:// -&gt; ^((https|http)://)\n     * 2. 然后匹配ip地址 www.bilibili.com -&gt; www.和bilbil.匹配的是 ([\\w-]+\\.) com匹配的是[\\w-]+\n     * 3. /video/BV1Qj41177e9/?spm_id_from=333 匹配 (\\/[\\w-?=&amp;/%.#]*)?\n     */\n    String regStr = &quot;^((https|http)://)([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w-?=&amp;/%.#]*)?$&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    if(matcher.find()) &#123;\n        System.out.println(&quot;满足格式&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;不满足格式&quot;);\n    &#125;\n&#125;\n正则表达式常用类常用类包括以下三个类\njava.util.regex 包主要包括以下三个类 Pattern类、Matcher类和PatternSyntaxException类\nPattern类基本介绍pattern对象是一个正则表达式对象。Pattern类没有公共构造方法。要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数，比如 Pattern r &#x3D; Pattern.compile(pattern);\n常用方法matches用于整体匹配，在验证输入的字符串是否满足条件使用。返回类型boolean\n区别: 在url判别中，使用原来的方法必须要加 ^ 和 $ 符号锁定开头和结尾。如果不加的话，那么10https…也会匹配成功。但如果使用了matches整体匹配的话，匹配规则可以是  “((https|http):&#x2F;&#x2F;)([\\w-]+\\.)+[\\w-]+(\\&#x2F;[\\w-?&#x3D;&amp;&#x2F;%.#]*)?”  ，就可以不用加定位符 “^” 和 “$”。\njava/**\n * 演示matches方法，用于整体匹配，在验证输入的字符串是否满足条件使用\n */\npublic class PatternMethod &#123;\n    public static void main(String[] args) &#123;\n        String content = &quot;hello abc 吖吖&quot;;\n        String regStr = &quot;hello&quot;; //false\n        String regStr = &quot;hello.*&quot;; //true\n        boolean matches = Pattern.matches(regStr, content);\n        System.out.println(&quot;整体匹配=&quot; + matches);\n    &#125;\n&#125;Matcher类基本介绍Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。\n方法一览\n\n\n方法\n说明\n\n\n\npublic int start()\n返回匹配的初始索引\n\n\npublic int start(int group)\n返回在匹配操作期间，由给定组所捕获的子序列的初始索引\n\n\npublic int end()\n返回最后匹配字符之后的偏移量，也就是匹配的最后一位+1\n\n\npublic int end(int group)\n返回在匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量\n\n\npublic boolean lookingAt()\n尝试将从区域开头开始的输入序列与该模式匹配\n\n\npublic boolean find()\n尝试查找与该模式匹配的输入序列的下一个子序列\n\n\npublic boolean find(int start)\n重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列\n\n\npublic boolean matches()\n尝试将整个区域与模式匹配\n\n\npublic String replaceAll(String replacement)\n替换模式与给定替换字符串相匹配的输入序列的每个子序列\n\n\n代码演示start、end、matches演示\njavapublic static void main(String[] args) &#123;\n    String content = &quot;hello edu jack tom hello smith hello&quot;;\n    String regStr = &quot;hello&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;=================&quot;);\n        System.out.println(matcher.start());\n        System.out.println(matcher.end());\n        System.out.println(&quot;找到=&quot; + content.substring(matcher.start(), matcher.end()));\n    &#125;\n    //整体匹配，检验某个字符串是否满足某个规则\n    System.out.println(&quot;整体匹配=&quot; + matcher.matches());\n&#125;结果演示\ntxt=================\n0\n5\n找到=hello\n=================\n19\n24\n找到=hello\n=================\n31\n36\n找到=hello\n整体匹配=falsereplaceAll(String replacement)  演示\n注意：返回的字符串才是替换后的字符串，原来的content并不会发生变化。\njavapublic static void main(String[] args) &#123;\n    String content = &quot;hello edu jack tom hello smith hello&quot;;\n    String regStr = &quot;hello&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n\n    //注意: 返回的字符串才是替换后的字符串 原来的content不变化\n    String newContent = matcher.replaceAll(&quot;你好&quot;);\n    System.out.println(&quot;newContent= &quot; + newContent);\n    System.out.println(&quot;content= &quot; + content);\n&#125;输出结果\ntxtnewContent= 你好 edu jack tom 你好 smith 你好\ncontent= hello edu jack tom hello smith helloPatternSyntaxException类PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n分组、捕获、反向引用提出需求问题: 给一段文本，请找出所有四个数字连在一起的子串，并且这四个数字要满足\n①第1位与第4位相同\n②第2为与第3为相同\n比如1221，5775……..\n基本介绍\n案例举例\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;hello jack14 tom11 jack22 yyy xxx&quot;;\n    //匹配两个连续相同的数字 (\\\\d)\\\\1\n    String regStr = &quot;(\\\\d)\\\\1&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到= &quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到= 11\n找到= 22额外题\n\n经典题目\n思路分析\n1、去掉所有的.\t匹配所有的’’.’，将’.’替换成””\n2.1、去掉重复的字\t用**(.)\\\\1+**匹配重复的字，因为’+’会得到1-多，所以至少找到两个重复的字。\n2.2、使用反向引用$1来替换匹配到的内容\n代码实现\njavapublic static void main(String[] args) &#123;\n        //通过正则表达式修改成 &quot;我要学编程java&quot;\n        String content = &quot;我...我要.....学学学...编程java!&quot;;\n        //思路:\n        //1. 去掉所有的.\n        Pattern pattern = Pattern.compile(&quot;\\\\.&quot;);\n        Matcher matcher = pattern.matcher(content);\n        content = matcher.replaceAll(&quot;&quot;);\n//        System.out.println(&quot;content=&quot; + content);\n//        //2. 去掉重复的字\n//        //(1) 使用(.)\\\\1+ 匹配重复的字，因为&#39;+&#39;会得到1-多,所以至少找到两个重复的字,满足需求\n//        pattern = Pattern.compile(&quot;(.)\\\\1+&quot;);\n//        matcher = pattern.matcher(content);\n//        while (matcher.find()) &#123;\n//            System.out.println(&quot;找到=&quot; + matcher.group(0));\n//        &#125;\n//        //使用 反向引用$1 来替换匹配到的内容\n//        content = matcher.replaceAll(&quot;$1&quot;);\n//        System.out.println(&quot;content=&quot; + content);\n        //使用一条语句\n        content = Pattern.compile(&quot;(.)\\\\1+&quot;).matcher(content).replaceAll(&quot;$1&quot;);\n        System.out.println(content);\n    &#125;输出结果\ntxt我要学编程java!\nString类使用正则表达式replaceAll替换功能\n\nmatches验证功能\n\nsplit分割功能\n\n\n正则表达式练习问题一\n\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;2312@tsinghua.org.cn&quot;;\n    String regStr = &quot;[\\\\w-]+[@]([a-zA-z]+\\\\.)+[a-zA-z]+&quot;;\n\n    if (content.matches(regStr)) &#123; //String的matches方法是整体匹配\n        System.out.println(&quot;匹配成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;匹配失败&quot;);\n    &#125;\n&#125;问题二\n\n代码实现\n1、先写出简单的正则表达式\n2、再逐步完善\njavapublic static void main(String[] args) &#123;\n        //要求验证是不是整数或者小数\n        //提示: 考虑正数和负数\n        //比如: 123 -345 34.89 -87.9 -0.01 0.45\n        String content = &quot;-23.11&quot;;\n        String regStr = &quot;^[-+]?([1-9]\\\\d*|0)(\\\\.\\\\d+)?$&quot;;\n        if (content.matches(regStr)) &#123; //String的matches方法是整体匹配\n            System.out.println(&quot;匹配成功&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;匹配失败&quot;);\n        &#125;\n&#125;问题三\n\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;http://www.sohu.com:8080/abc/xxx/index.htm&quot;;\n    String regStr = &quot;^([a-zA-z]+)://([a-zA-Z.]+):(\\\\d+)[\\\\w-/]*/([\\\\w.]+)$&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    if(matcher.matches()) &#123; //整体匹配，如果匹配成功，可以通过group(x)，获得对应分组内容\n        System.out.println(&quot;整体匹配=&quot; + matcher.group(0));\n        System.out.println(&quot;协议: &quot; + matcher.group(1));\n        System.out.println(&quot;域名: &quot; + matcher.group(2));\n        System.out.println(&quot;端口: &quot; + matcher.group(3));\n        System.out.println(&quot;文件: &quot; + matcher.group(4));\n    &#125; else &#123;\n        System.out.println(&quot;匹配失败&quot;);\n    &#125;\n&#125;\nJava正则表达式大全(参考)一、校验数字的表达式\n1 数字：^[0-9]*$\n2 n位的数字：^\\d{n}$\n3 至少n位的数字：^\\d{n,}$\n4 m-n位的数字：^\\d{m,n}$\n5 零和非零开头的数字：^(0|[1-9][0-9]*)$\n6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\n7 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$\n8 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$\n9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\n10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\n11 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$\n12 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$\n13 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n14 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n15 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0$\n16 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d*[1-9]\\d*))|0?.0+|0$\n17 正浮点数：^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$\n18 负浮点数：^-([1-9]\\d.\\d|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$\n19 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0)$\n二、校验字符的表达式\n1 汉字：^[\\u4e00-\\u9fa5]{0,}$\n2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\n3 长度为3-20的所有字符：^.{3,20}$\n4 由26个英文字母组成的字符串：^[A-Za-z]+$\n5 由26个大写英文字母组成的字符串：^[A-Z]+$\n6 由26个小写英文字母组成的字符串：^[a-z]+$\n7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\n9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n11 可以输入含有^%&amp;’,;&#x3D;?$&quot;等字符：[^%&amp;’,;&#x3D;?$\\x22]+\n12 禁止输入含有的字符：[^\\x22]+\n三、特殊需求表达式\n1 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$\n2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+&#x2F;.?\n3 InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\\s]* 或 ^https:&#x2F;&#x2F;([\\w-]+.)+[\\w-]+(&#x2F;[\\w-.&#x2F;?%&amp;&#x3D;]*)?$\n4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ \n6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\n7 身份证号：\n​    15或18位身份证：^\\d{15}|\\d{18}$\n​    15位身份证：^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$\n​    18位身份证：^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{4}$\n8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.\\d)(?&#x3D;.[a-z])(?&#x3D;.*[A-Z]).{8,10}$ \n12 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ \n15 钱的输入格式：\n16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ \n17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ \n18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ \n19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ \n20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ \n21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ \n22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ \n23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ \n24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$\n26 中文字符的正则表达式：[\\u4e00-\\u9fa5]\n27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)\n29 HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]&gt;.?|&lt;.*? &#x2F;&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n30 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)\n32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)\n33 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用)\n","slug":"正则表达式","date":"2023-11-25T17:20:00.000Z","categories_index":"正则表达式","tags_index":"java","author_index":"白"},{"id":"9828133175dbd4abfb8bc2b5ec3d15b8","title":"满汉楼小作业","content":"Mysql满汉楼小作业简要说明技术要求: java + jdbc(druid) + mysql\n项目目标: 训练对mysql和jdbc的能力\n1、去掉界面和事件处理，使用控制台界面\n2、完成 登陆、订座、点餐和结账、查看账单等功能\n怎么开始: 根据程序框架图从底层到业务层逐步构建。\n程序框架图\n\n\n\n1、准备工具类Utility搭建项目的整体结构\n1、新建项目mhl\n2、将整体结构搭建出来。dao包，domain包，service包，utils包，view包\n准备工具类Utility\n1、将三个jar包导入。分别是mysql，druid，Apache-DBUtils相关的jar包。\n2、将JDBCUtilsByDruid，Utility类导入utils包中。(Utility类负责控制输入，JDBCUtilsByDruid类负责连接druid连接池)。\n3、将配置文件druid.properties导入src目录下。!!!注意修改配置文件中的参数,确保数据库正确。\n4、测试Utility类和JDBCUtilsByDruid类。(从其他地方导入可能会出现问题)\nBasicDAO\n针对表进行的操作。\ndml方法-&gt;update\n返回多行结果-&gt;queryMulti\n返回单行结果-&gt;querySingle\n返回单个对象-&gt;queryScaler\njava/**\n * 开发BasicDAO,是其他DAO的父类\n */\npublic class BasicDAO&lt;T&gt; &#123; //泛型指定具体类型\n    private QueryRunner qr = new QueryRunner();\n    //开发通用dml方法，针对任意的表\n    public int update(String sql, Object... parameters) &#123; //sql语句， 参数\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            //返回受影响的行数\n            int update = qr.update(connection, sql, parameters);\n            return update;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //返回多个对象(即查询的结果是多行),针对任意表\n    /**\n     * @param sql sql语句,可以有?\n     * @param clazz 传入一个类的Class对象,比如Actor.class\n     * @param parameters 传入?的具体的值,可以是多个\n     * @return 根据Actor.class 返回对应的ArrayList集合\n     */\n    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; clazz, Object...parameters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(clazz), parameters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行结果的通用方法\n    public T querySingle(String sql, Class&lt;T&gt; clazz, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(clazz), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行单列的方法,即返回单值的方法\n    public Object queryScaler(String sql, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new ScalarHandler(), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n&#125;效果如下图\n\n\n2、显示主菜单、二级菜单和退出系统功能1、代码部分略\n2、显示框架如下\n\n\n3、用户登录要求: 用户登陆时输入id和pwd要和用户表进行匹配。匹配成功可以登陆，失败就退出\n1、创建用户表sql--用户表\nCREATE TABLE employee (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增\n    empId VARCHAR(50) UNIQUE NOT NULL DEFAULT &#39;&#39;, #员工号\n    pwd CHAR(32) NOT NULL DEFAULT &#39;&#39;, #密码md5\n    name VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #姓名\n    job VARCHAR(50) NOT NULL DEFAULT &#39;&#39; #岗位\n)CHARSET=utf8;\n\n--添加测试语句\nINSERT INTO employee VALUES(NULL, &#39;6668612&#39;, MD5(&#39;123456&#39;), &#39;张三丰&#39;, &#39;经理&#39;);\nINSERT INTO employee VALUES(NULL, &#39;6668622&#39;, MD5(&#39;123456&#39;), &#39;小龙女&#39;, &#39;服务员&#39;);\nINSERT INTO employee VALUES(NULL, &#39;6668633&#39;, MD5(&#39;123456&#39;), &#39;张无忌&#39;, &#39;收银员&#39;);\nINSERT INTO employee VALUES(NULL, &#39;666666&#39;, MD5(&#39;123456&#39;), &#39;老虎&#39;, &#39;经理&#39;);2、domian包: Employee根据程序框架图要设置一个与mysql表对应的domain类。\n该类是javabean和emoloyeee对应\njavapublic class Employee &#123;\n    private Integer id;\n    private String empId;\n    private String pwd;\n    private String name;\n    private String job; \n    public Employee() &#123; //无参构造器,反射需要\n    &#125;\n    public Employee(Integer id, String empId, String pwd, String name, String job) &#123;\n        this.id = id;\n        this.empId = empId;\n        this.pwd = pwd;\n        this.name = name;\n        this.job = job;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n&#125;3、DAO包: EmployeeDAO根据程序框架图设置一个能操作employee表的类。\n该类继承BasicDAO类\njavapackage com.mhl.dao;\n\nimport com.mhl.domain.Employee;\n\npublic class EmployeeDAO extends BasicDAO&lt;Employee&gt; &#123;\n    //可以写特有的操作\n&#125;4、(业务层)service包: EmployeeService功能: 根据empId和pwd返回一个Employee对象,如果未匹配则返回null\n根据程序框架图设置一个业务层的employeeservice类，负责组织sql语句完成业务需要。\njava/**\n * 该类完成对employee表的各种操作\n * 通过调用EmployeeDAO对象完成\n */\npublic class EmployeeService &#123;\n    //定义一个 EmployeeDAO\n    private EmployeeDAO employeeDAO = new EmployeeDAO();\n\n    //方法，根据empId和pwd返回一个Employee对象\n    public Employee getEmployeeByIdAndPwd(String empId, String pwd) &#123;\n        return employeeDAO.querySingle(&quot;select * from employee where empId=? and pwd=md5(?)&quot;, Employee.class, empId, pwd);\n    &#125;\n&#125;5、MHLView在主菜单界面调用该方法使用: 调用该方法就必须拥有一个该类的对象，因此创建一个该类的对象。\njava//定义EmployeeService 属性\nprivate EmployeeService employeeService = new EmployeeService();效果演示\n\n4、显示餐桌要求: 显示餐桌编号和餐桌当前状态\n1、创建餐桌表sql--创建diningTable 表(id, state, orderName, orderTel ...)\nCREATE TABLE diningTable (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增,表示餐桌编号\n    state VARCHAR(20) NOT NULL DEFAULT &#39;&#39;, #餐桌的状态\n    orderName VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #预定人的名字\n    orderTel VARCHAR(20) NOT NULL DEFAULT &#39;&#39;\n)CHARSET=utf8;\n\n--添加测试语句\nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); \nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); \nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); 2、domain包:  DiningTablejavabean和diningTable表对应\njavapublic class DiningTable &#123;\n    private Integer id;\n    private String state;\n    private String orderName;\n    private String orderTel;\n\n    public DiningTable() &#123;\n    &#125;\n\n    public DiningTable(Integer id, String state, String orderName, String orderTel) &#123;\n        this.id = id;\n        this.state = state;\n        this.orderName = orderName;\n        this.orderTel = orderTel;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return id + &quot;\\t\\t\\t&quot; + state;\n    &#125;\n&#125;3、DAO包: DiningTableDAOjavapublic class EmployeeDAO extends BasicDAO&lt;Employee&gt; &#123;\n    //可以写特有的操作\n&#125;4、service包: DiningTableService功能: 返回所有的餐桌信息\njavapublic class DiningTableService &#123; //业务层\n    //定义一个DiningTableDAO对象\n    private DiningTableDAO diningTableDAO = new DiningTableDAO();\n    //返回所有餐桌信息\n    public List&lt;DiningTable&gt; list() &#123;\n       return diningTableDAO.queryMulti(&quot;select id, state from diningTable&quot;, DiningTable.class);\n    &#125;\n&#125;5、MHLView在MHLView中封装方法，用于显示所有餐桌的状态。\njava//显示所有餐桌状态\npublic void listDiningTable() &#123;\n    List&lt;DiningTable&gt; list = diningTableService.list();\n    System.out.println(&quot;\\n餐桌编号\\t\\t餐桌状态&quot;);\n    for (DiningTable diningTable : list) &#123;\n        System.out.println(diningTable);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n5、满汉楼订座要求: 实现用户订座，如果座位状态不为空则显示不能订座。\n1、功能分析定制功能建立在diningTable表上，因此订座功能应当在DiningTableService类(针对DiningTable的服务)中实现\n2、DiningTableService扩展扩展两个方法\ngetDiningTableById:  根据传入的id判断餐桌是否存在。若不存在返回null。\norderDiningTable: 根据传入的形参对diningTable表进行更新。成功返回true，失败返回false\njava//根据id, 查询对应的餐桌DiningTable对象\n//如果返回null,表示id编号对应的餐桌不存在\npublic DiningTable getDiningTableById(int id) &#123;\n    //可以直接执行sql语句去测试是否正确\n    return diningTableDAO.querySingle(&quot;select * from diningTable where id = ?&quot;, DiningTable.class, id);\n&#125;\n//如果可以预定,调用方法对diningTable表进行更新\n/**\n * @param id 餐桌id\n * @param orderName 预订人姓名\n * @param orderTel 预订人电话\n * @return\n */\npublic boolean orderDiningTable(int id, String orderName, String orderTel) &#123;\n    int update =\n            diningTableDAO.update(&quot;update diningTable set state=&#39;已经预定&#39;, orderName=?, orderTel=? where id = ?&quot;, orderName, orderTel, id);\n    return update &gt; 0;\n&#125;3、MHLView在MHLView封装方法，实现订座功能。\njava//完成订座\npublic void orderDiningTable() &#123;\n    System.out.println(&quot;==============预定餐桌============&quot;);\n    System.out.print(&quot;请选择要预定的餐桌编号(-1退出): &quot;);\n    int orderId = Utility.readInt();\n    if (orderId == -1) &#123;\n        System.out.println(&quot;==============取消预订餐桌============&quot;);\n        return;\n    &#125;\n    //该方法得到的是 Y 或者 N\n    char key = Utility.readConfirmSelection();\n    if (key == &#39;Y&#39;) &#123;//要预定\n\n        //根据orderId 返回 对应DiningTable对象, 如果为null, 说明该对象不存在\n        DiningTable diningTable = diningTableService.getDiningTableById(orderId);\n        if (diningTable == null) &#123;//\n            System.out.println(&quot;==============预订餐桌不存在============&quot;);\n            return;\n        &#125;\n        //判断该餐桌的状态是否 &quot;空&quot;\n        if (!(&quot;空&quot;.equals(diningTable.getState()))) &#123;//说明当前这个餐桌不是 &quot;空&quot; 状态\n            System.out.println(&quot;==============该餐桌已经预定或者就餐中============&quot;);\n            return;\n        &#125;\n        //接收预定信息\n        System.out.print(&quot;预定人的名字: &quot;);\n        String orderName = Utility.readString(50);\n        System.out.print(&quot;预定人的电话: &quot;);\n        String orderTel = Utility.readString(50);\n\n        //更新餐桌状态\n        if (diningTableService.orderDiningTable(orderId, orderName, orderTel)) &#123;\n            System.out.println(&quot;==============预订餐桌成功============&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;==============预订餐桌失败============&quot;);\n        &#125;\n\n    &#125; else &#123;\n        System.out.println(&quot;==============取消预订餐桌============&quot;);\n    &#125;\n&#125;效果演示\n\n\n6、满汉楼菜单要求: 显示菜单表。\n1、创建菜单表sql--创建menu表(id, name, type, price)\n#菜单\nCREATE TABLE menu (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增,菜单编号\n    name VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #菜名\n    type VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #菜品种类\n    price DOUBLE NOT NULL DEFAULT 0 #价格\n)CHARSET=utf8;\n\n--添加测试数据\nINSERT INTO menu VALUES(NULL, &#39;八宝饭&#39;, &#39;主食&#39;, 10);\nINSERT INTO menu VALUES(NULL, &#39;叉烧包&#39;, &#39;主食&#39;, 20);\nINSERT INTO menu VALUES(NULL, &#39;宫保鸡丁&#39;, &#39;热菜&#39;, 30);\nINSERT INTO menu VALUES(NULL, &#39;山药拔鱼&#39;, &#39;凉菜&#39;, 14);\nINSERT INTO menu VALUES(NULL, &#39;银丝卷&#39;, &#39;甜食&#39;, 9);\nINSERT INTO menu VALUES(NULL, &#39;水煮鱼&#39;, &#39;热菜&#39;, 26);\nINSERT INTO menu VALUES(NULL, &#39;甲鱼汤&#39;, &#39;汤类&#39;, 100);\nINSERT INTO menu VALUES(NULL, &#39;鸡蛋汤&#39;, &#39;汤类&#39;, 16);2、domain包: Menujava/**\n * 该类(javabean)和menu表\n */\npublic class Menu &#123;\n    private Integer id;\n    private String name;\n    private String type;\n    private Double price;\n\n    public Menu() &#123;\n    &#125;\n\n    public Menu(Integer id, String name, String type, Double price) &#123;\n        this.id = id;\n        this.name = name;\n        this.type = type;\n        this.price = price;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return id + &quot;\\t\\t&quot; + name + &quot;\\t\\t&quot; + type + &quot;\\t\\t&quot; + price;\n    &#125;\n&#125;3、DAO包: MenuDAOjavapublic class MenuDAO extends BasicDAO&lt;Menu&gt;&#123;&#125;4、service包: MenuService功能: 返回menu表所有内容\njava/**\n * 完成对menu表的各种操作(通过调用MenuDAO)\n */\npublic class MenuService &#123;\n    //定义MenuDAO属性\n    private MenuDAO menuDAO = new MenuDAO();\n    //返回所有菜品\n    public List&lt;Menu&gt; list() &#123;\n        return menuDAO.queryMulti(&quot;select * from menu&quot;, Menu.class);\n    &#125;\n&#125;5、MHLView在MHLView中封装方法，用于显示所有菜品。\njava//显示所有菜品\npublic void listMenu() &#123;\n    List&lt;Menu&gt; list = menuService.list();\n    System.out.println(&quot;\\n菜品编号\\t\\t菜品名\\t\\t类别\\t\\t价格&quot;);\n    for (Menu menu : list) &#123;\n        System.out.println(menu);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n7、满汉楼点餐要求: 对餐桌号，菜单编号，做合理性校验，如果不合理，给出提示信息。\n思路分析1、餐桌号，菜单编号 校验。\n2、点餐成功，需要修改餐桌状态。\n3、生成账单 -&gt; 创建账单表\n1、创建账单表sql#表bill账单表(id, billId, menuId, nums, billDate, money, state, diningTableId)\nCREATE TABLE bill (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增主键\n    billId VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #账单号 可以安装自己规则生成 UUID\n    menuId INT NOT NULL DEFAULT 0, #菜单编号,可以用外键\n    nums INT NOT NULL DEFAULT 0, #份数\n    money DOUBLE NOT NULL DEFAULT 0, #金额\n    diningTableId INT NOT NULL DEFAULT 0, #餐桌\n    billDate DATE NOT NULL, #订单日期\n    state VARCHAR(50) NOT NULL DEFAULT &#39;&#39; #状态 &#39;未结账&#39;, &#39;已结账&#39;, &#39;挂单&#39;\n)CHARSET=utf8;2、domain包: BillBill是javabean和bill表对应\njava/**\n * 该类(javabean)和bill表对应\n */\npublic class Bill &#123;\n    private Integer id;\n    private String billId;\n    private Integer menuId;\n    private Integer nums;\n    private Double money;\n    private Integer diningTableId;\n    private Date billDate;\n    private String state;\n\n    public Bill() &#123; //无参构造器,用于反射\n    &#125;\n\n    public Bill(Integer id, String billId, Integer menuId, Integer nums, Double money, Integer diningTableId, Date billDate, String state) &#123;\n        this.id = id;\n        this.billId = billId;\n        this.menuId = menuId;\n        this.nums = nums;\n        this.money = money;\n        this.diningTableId = diningTableId;\n        this.billDate = billDate;\n        this.state = state;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return &quot;Bill&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, billId=&#39;&quot; + billId + &#39;\\&#39;&#39; +\n                &quot;, menuId=&quot; + menuId +\n                &quot;, nums=&quot; + nums +\n                &quot;, money=&quot; + money +\n                &quot;, diningTableId=&quot; + diningTableId +\n                &quot;, billDate=&quot; + billDate +\n                &quot;, state=&#39;&quot; + state + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;3、DAO包: BillDAOjavapublic class BillDAO extends BasicDAO&lt;Bill&gt;&#123;&#125;4、service包: BillService功能: 处理和账单相关的业务逻辑\nBillService类\n1、生成账单\n注意事项: 1、生成账单需要计算金额，因此从MenuService中获取menu对象进而得到金额。\n​\t\t\t\t\t2、当生成订单后需要将餐桌状态更新，因此需要DiningTableService属性改变餐桌状态。\n​\t\t\t\t\t综上,MenuService和DiningTableService需要新增方法。\njava/**\n * 处理和账单相关的业务逻辑\n */\npublic class BillService &#123;\n    //定义BillDAO属性\n    private BillDAO billDAO = new BillDAO();\n    //定义一个MenuService属性\n    private MenuService menuService = new MenuService();\n    //定义一个DiningTableService属性\n    private DiningTableService diningTableService = new DiningTableService();\n    //点餐的方法 成功返回true 失败false\n    //1. 生成账单\n    //2. 更新餐桌状态\n    public boolean orderMenu(int menuId, int nums, int diningTableId) &#123;\n        //生成一个账单号,UUID\n        String billId = UUID.randomUUID().toString();\n\n        //将账单生成到bill表,要求直接计算账单金额\n        int update = billDAO.update(&quot;insert into bill values(null,?,?,?,?,?,now(),&#39;未结账&#39;)&quot;,\n                billId, menuId, nums, (menuService.getMenuById(menuId).getPrice() * nums), diningTableId);\n        if(update &lt;= 0) &#123;\n            return false;\n        &#125;\n        //更新餐桌状态\n        return diningTableService.updateDiningTableState(diningTableId, &quot;就餐中&quot;);\n    &#125;\n&#125;MenuService新增方法\njava//方法,根据id,返回Menu对象\npublic Menu getMenuById(int id) &#123;\n    return menuDAO.querySingle(&quot;select * from menu where id = ?&quot;, Menu.class, id);\n&#125;DiningTableService新增方法\njava//方法,更新餐桌状态的方法\npublic boolean updateDiningTableState(int id, String state) &#123;\n    int update = diningTableDAO.update(&quot;update diningTable set state=? where id=?&quot;, state, id);\n    return update &gt; 0;\n&#125;5、MHLView在MHLView封装方法，实现点餐功能。\n验证餐桌号是否存在: 通过diningTableService.getDiningTableById可以判断餐桌是否存在。\n验证菜品编号: 通过menuService.getMenuById判断此id对应的对象是否存在\n点餐: billService.orderMenu创建账单,创建失败则返回false\njava//完成点餐\npublic void orderMenu() &#123;\n    System.out.println(&quot;==============点餐服务============&quot;);\n    System.out.print(&quot;请输入点餐的桌号(-1退出): &quot;);\n    int orderDiningTableId = Utility.readInt();\n    if (orderDiningTableId == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;请输入点餐的菜品号(-1退出): &quot;);\n    int orderMenuId = Utility.readInt();\n    if (orderMenuId == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;请输入点餐的菜品量(-1退出): &quot;);\n    int orderNums = Utility.readInt();\n    if (orderNums == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n\n    //验证餐桌号是否存在.\n    DiningTable diningTable = diningTableService.getDiningTableById(orderDiningTableId);\n    if (diningTable == null) &#123;\n        System.out.println(&quot;==============餐桌号不存在============&quot;);\n        return;\n    &#125;\n    //验证菜品编号\n    Menu menu = menuService.getMenuById(orderMenuId);\n    if (menu == null) &#123;\n        System.out.println(&quot;==============菜品号不存在============&quot;);\n        return;\n    &#125;\n\n    //点餐\n    if (orderMenu(orderMenuId, orderNums, orderDiningTableId)) &#123;\n        System.out.println(&quot;==============点餐成功============&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;==============点餐失败============&quot;);\n    &#125;\n&#125;效果演示\n\n\n8、满汉楼显示账单要求: 显示所有账单\n1、BillService新增功能java//返回所有账单\npublic List&lt;Bill&gt; list() &#123;\n    return billDAO.queryMulti(&quot;select * from bill&quot;, Bill.class);\n&#125;2、MHLViewjava//显示账单信息\npublic void listBill() &#123;\n    List&lt;Bill&gt; bills = billService.list();\n    System.out.println(&quot;\\n编号\\t\\t菜品号\\t\\t菜品量\\t\\t金额\\t\\t桌号\\t\\t日期\\t\\t\\t\\t\\t\\t\\t状态&quot;);\n    for (Bill bill : bills) &#123;\n        System.out.println(bill);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n9、满汉楼结账要求: 实现满汉楼结账\n思路分析1、对餐桌号进行校验\n2、修改bill表的state\n3、修改diningTable信息，结完账就清空\n4、不需要增加新表，不需要增加新类，需要增加方法\n1、BillService新增功能hasPayBillByDiningTableId: 查看未结账账单\npayBill: 完成结账[如果餐桌存在，并且该餐桌有未结账的账单]\njava//查看某个餐桌是否有未结账的账单\npublic boolean hasPayBillByDiningTableId(int diningTableId) &#123;\n\n    Bill bill =\n            billDAO.querySingle(&quot;SELECT * FROM bill WHERE diningTableId=? AND state = &#39;未结账&#39; LIMIT 0, 1&quot;, Bill.class, diningTableId);\n    return bill != null;\n&#125;\n//完成结账[如果餐桌存在，并且该餐桌有未结账的账单]\n//如果成功，返回true, 失败返回 false\npublic boolean payBill(int diningTableId, String payMode) &#123;\n    //如果这里使用事务的话，需要用ThreadLocal来解决 , 框架中比如mybatis 提供了事务支持\n    //1. 修改bill表\n    int update = billDAO.update(&quot;update bill set state=? where diningTableId=? and state=&#39;未结账&#39;&quot;, payMode, diningTableId);\n\n    if(update &lt;= 0) &#123; //如果更新没有成功，则表示失败...\n        return false;\n    &#125;\n    //2. 修改diningTable表\n    //注意：不要直接在这里操作，而应该调用DiningTableService 方法,完成更新，体现各司其职\n    if(!diningTableService.updateDiningTableToFree(diningTableId, &quot;空&quot;)) &#123;\n        return false;\n    &#125;\n    return true;\n&#125;2、DiningTableService新增功能updateDiningTableToFree: 将餐桌设置为空闲状态\njava//提供方法，将指定的餐桌设置为空闲状态\npublic boolean updateDiningTableToFree(int id, String state) &#123;\n    int update = diningTableDAO.update(&quot;update diningTable set state=?,orderName=&#39;&#39;,orderTel=&#39;&#39; where id=?&quot;, state, id);\n    return update &gt; 0;\n&#125;3、MHLViewMHLView封装方法完成结账\n1、判断餐桌是否存在: diningTableService.getDiningTableById\n2、判断该餐桌是否有需要结账的账单: billService.hasPayBillByDiningTableId\n3、完成结账: 调用payBill方法完成结账\njava//完成结账\npublic void payBill() &#123;\n    System.out.println(&quot;==============结账服务============&quot;);\n    System.out.print(&quot;请选择要结账的餐桌编号(-1退出): &quot;);\n    int diningTableId = Utility.readInt();\n    if (diningTableId == -1) &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n        return;\n    &#125;\n    //验证餐桌是否存在\n    DiningTable diningTable = diningTableService.getDiningTableById(diningTableId);\n    if (diningTable == null) &#123;\n        System.out.println(&quot;=============结账的餐桌不存在============&quot;);\n        return;\n    &#125;\n    //验证餐桌是否有需要结账的账单\n    if (!billService.hasPayBillByDiningTableId(diningTableId)) &#123;\n        System.out.println(&quot;=============该餐位没有未结账账单============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;结账方式(现金/支付宝/微信)回车表示退出: &quot;);\n    String payMode = Utility.readString(20, &quot;&quot;);//说明如果回车，就是返回 &quot;&quot;\n    if (&quot;&quot;.equals(payMode)) &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n        return;\n    &#125;\n    char key = Utility.readConfirmSelection();\n    if (key == &#39;Y&#39;) &#123; //结账\n\n        //调用我们写的方法\n        if (billService.payBill(diningTableId, payMode)) &#123;\n            System.out.println(&quot;=============完成结账============&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;=============结账失败============&quot;);\n        &#125;\n\n    &#125; else &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n    &#125;\n&#125;效果演示\n\n10、多表查询注意事项:  1、domain构建MultiTableBean类，属性是通过反射调用set方法赋值，因此无参构造器是必须的。\n​\t\t\t\t\t 2、不查询price值的话，price的值为null，不会对程序造成影响。\n​\t\t\t\t \t3、属性名是否一定要和表的列名保持一致。可以不一致，但是需要sql做相应的修改, 规范需要保持一致.\n细节:  如果sql语句写出如下形式，那么会通过反射找setName2方法来给MultiTableBean类中的属性赋值。因此如果两个表设计到重复名字的话，可以设置别名区分。\n例如: a表设置为name1，b表设置为name2，在MultiTableBean类中分别给name1和name2设置set和get方法就可以区分两个表。\n\n举例:\nMultiTableBean类: private String name2;\nBillSerbvice类: \njava//返回所有的账单并带有菜品名,价格， 提供给View调用\npublic List&lt;MultiTableBean&gt; list2() &#123;\n    return multiTableDAO.queryMulti(&quot;SELECT bill.*, NAME as name2,price &quot; +\n            &quot;FROM bill, menu &quot; +\n            &quot;WHERE bill.menuId = menu.id&quot;, MultiTableBean.class);\n&#125;如果如上设计，那么list2返回的表中name2就不会为null\n1、MultiTableBean类从原先的bill表新增属性，重新设计一个多表类\njavaprivate Integer id;\nprivate String billId;\nprivate Integer menuId;\nprivate Integer nums;\nprivate Double money;\nprivate Integer diningTableId;\nprivate Date billDate;\nprivate String state;\n//增加一个来自menu表的列 name\n//思考 这里的属性名是否一定要和表的列名保持一致.\n//答: 可以不一致，但是需要sql做相应的修改, 规范需要保持一致.\nprivate String name;\n//增加来自menu表的列 price\nprivate Double price;//默认值 nulll2、MultiTableDAO类javapublic class MultiTableDAO extends BasicDAO&lt;MultiTableBean&gt; &#123;&#125;3、BillService类注意:  用String连接mysql语句时要注意空格，否则sql语句不通过\njava//返回所有的账单并带有菜品名,价格， 提供给View调用\npublic List&lt;MultiTableBean&gt; list2() &#123;\n    return multiTableDAO.queryMulti(&quot;SELECT bill.*, NAME,price &quot; +\n            &quot;FROM bill, menu &quot; +\n            &quot;WHERE bill.menuId = menu.id&quot;, MultiTableBean.class);\n&#125;4、MHLView从新建的multiTableBeans类获取list集合，可获得menu表中的name和price值。\nprice值可以为null，不会对程序造成影响。\njava//显示账单信息\n    public void listBill() &#123;\n        List&lt;MultiTableBean&gt; multiTableBeans = billService.list2();\n        System.out.println(&quot;\\n编号\\t\\t菜品号\\t\\t菜品量\\t\\t金额\\t\\t桌号\\t\\t日期\\t\\t\\t\\t\\t\\t\\t状态\\t\\t菜品名\\t\\t价格&quot;);\n        for (MultiTableBean bill : multiTableBeans) &#123;\n            System.out.println(bill);\n        &#125;\n        System.out.println(&quot;==============显示完毕============&quot;);\n    &#125;效果演示\n\n\n总结1、思路路程根据程序框架图从底层开始搭建。\n1、首先设置好utils工具类，druid配置文件\n2、domain层: 例如创建Menu表对应一个domian类-Menu类。Menu类含有无参构造器-&gt;反射需要。含有Menu表该有的属性和tostring方法。\n3、DAO层: 在DAO层构建一个MenuDAO类，负责对Menu表的增删改查和特有的操作。该层的类都会继承BasicDAO类，BasicDAO中是通用的方法。\n4、service层: 构建MenuService类，负责组织sql语句，并调用MenuDAO对象完成综合的需求。\n5、View层: MHLView界面层调用service层的类，得到结果，显示数据。\n","slug":"Mysql章节满汉楼项目","date":"2023-11-24T16:25:00.000Z","categories_index":"满汉楼","tags_index":"Mysql","author_index":"白"},{"id":"fb7466e40a0c693c18329664f28f2eb5","title":"JDBC和数据库连接池","content":"Mysql学习笔记一、Mysql简要说明使用命令行窗口连接 MYSQL 数据库\n\n操作示意图\n\n二、创建数据库txt\\#使用指令创建数据库\n\nCREATE DATABASE hsp_db01;\n\n\\#删除数据库指令\n\nDROP DATABASE hsp_db01\n\n\\#创建一个使用 utf8 字符集的 hsp_db02 数据库\n\nCREATE DATABASE hsp_db02 CHARACTER SET utf8\n\n\\#创建一个使用 utf8 字符集，并带校对规则的 hsp_db03 数据库\n\nCREATE DATABASE hsp_db03 CHARACTER SET utf8 COLLATE utf8_bin\n\n\\#校对规则 utf8_bin 区分大小 默认 utf8_general_ci 不区分大小写\n章节: JDBC和数据库连接池一、JDBC 连接 MySQL准备工作将下载的mysql-connector-java.jar 放入在目录里面的 libs 里面（如果没有就自己创建一个，记得要打包文件）\n右键选中加载到库中\n\n\n二、介绍JDBC1、JDBC 的概念 JDBC 是 Java DataBase Connectivity (Java 数据连接)技术的简称，是一种可用于执行 SQL 语句的 Java API。它由一些 java 语言编写的类和接口组成；程序员通过使用 jdbc 可以方便地将 SQL 语句传送给几乎任何一种数据库。\n2、JDBC 的功能(1) 与数据库建立连接。(2) 向数据库发送 SQL 语句并执行这些语句。(3) 处理数据返回的结果。\n3、JDBC 的常用接口和类(1) Driver 接口:加载驱动程序。(2) DriverManager 类:装人所需的 JDBC 驱动程序，编程时调用它的方法来创建连接。(3) Connection 接口:编程时使用该类对象创建 Statement 对象。(4) Statement 接口:编程时使用该类对象得到 ResultSet 对象。(5) ResultSet 类:负责保存 Statement 执行后所产生的查询结果。\n\n三、连接 MySQL小提示：\n1.mysql驱动5.1.6可以无需CLass.forName(“com.mysql.jdbc.Driver”);\n2.从jkd1.5以后使用jdbc4，不再需要显示调用class.forName()注册驱动而是自动调用驱动jar包下META-INF\\services\\java.sql.Driver文本中的类名称去注册\n3.建议还是写上Class.forName(“com.mysql.cj.jdbc.Driver”),更加明确\n\n(1)、注册驱动使用反射加载Driver类\ntxtClass.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);(2)、获取连接方法一:  DriverManager.getConnection() 传入形参 String url ,Properties info\n方法二:  DriverManager.getConnection() 传入形参 String url ,String user, String password\ntxt Connection com = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/hspeducode&quot;, &quot;root&quot;, &quot;123456&quot;);(3)、获取执行者连接txtStatement stat = com.createStatement();(4)、执行 SQL 语句，并接受结果txtString sql = &quot;SELECT * FROM user&quot;;\n\nResultSet rs = stat.executeQuery(sql);(5)、处理结果txtwhile (rs.next())&#123;\n        System.out.println(rs.getInt(&quot;id&quot;) + &quot;\\t&quot; + rs.getString(&quot;name&quot;));\n&#125;(6)、释放资源txtcom.close();\nstat.close();\ncom.close();（重要）通过不同方式连接mysql方式一：映射之后连接mysqljavapublic void connect01() throws ClassNotFoundException, SQLException &#123;\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(&quot;方式一: &quot;+connection);\n&#125;方式二：通过读取配置文件来连接mysql\njavapublic void connect02() throws IOException, ClassNotFoundException, SQLException &#123;\n    //通过Properties对象获取配置文件\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n    //获取相关的值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    String driver = properties.getProperty(&quot;driver&quot;);\n\n    Class.forName(driver);//建议写上\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(&quot;方式二: &quot; + connection);\n&#125;\n四、ResultSet[结果集]1.基本介绍1.表示数据库结果集的数据库，通常通过执行查询数据库的语句生成\n2.ResultSet对象保持一个光标指向其当前的数据行。最初，光标位于第一行之前\n3.next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环来遍历结果集\n2.ResultSet图像说明\n3.ResultSet底层\n4.代码举例演示javapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        //1. 加载驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        //创建url和user和password\n        String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n        String user = &quot;root&quot;;\n        String password = &quot;20031214gr&quot;;\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n        //3. 得到Statement\n        Statement statement = connection.createStatement();\n        //4. 组织sql\n        String sql = &quot;select id, name, sex, borndate, phone from actor&quot;;\n        //执行给定的SQL语句,该语句返回单个ResultSet对象\n        ResultSet resultSet = statement.executeQuery(sql);\n        //5. 使用while取出数据\n        while (resultSet.next()) &#123; //让光标向下移动,如果没有更多信息,返回false\n            int id = resultSet.getInt(1); //获取该行的第1列\n            String name = resultSet.getString(2); //获取该行第2列\n            String sex = resultSet.getString(3); //获取该行第3列\n            Date borndate = resultSet.getDate(4); //获取该行第4列\n            String phone = resultSet.getString(5); //获取该行第5列\n\n            System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + borndate + &quot;\\t&quot; + phone);\n        &#125;\n        //6. 关闭连接\n        resultSet.close();\n        connection.close();\n        statement.close();\n    &#125;​\t\t输出演示\ntxt1\t周星驰\t男\t1970-11-11\t110\n2\t刘德华\t男\t1970-11-11\t110\n五、Statement接口1.基本介绍\n2.sql注入​\t\t前置准备\ntxt-- 创建一张表\n\nCREATE TABLE admin ( -- 管理员表\n\nNAME VARCHAR(32) NOT NULL UNIQUE, \n\npwd VARCHAR(32) NOT NULL DEFAULT &#39;&#39;) CHARACTER SET utf8; \n\n-- 添加数据\n\nINSERT INTO admin VALUES(&#39;tom&#39;, &#39;123&#39;);​\t\t正常查询\ntxtSELECT *\n\nFROM admin\n\nWHERE NAME = &#39;tom&#39; AND pwd = &#39;123&#39;​\t\tSQL注入\ntxt-- 输入用户名 为 1&#39; or\n\n-- 输入万能密码 为 or &#39;1&#39;= &#39;1\n\nSELECT *\n\nFROM admin\n\nWHERE NAME = &#39;1&#39; OR&#39; AND pwd = &#39;OR &#39;1&#39;= &#39;1&#39; \n-- &#39;1&#39; = &#39;1&#39;一定成立,因此有隐患\n\nSELECT * FROM admin3.代码举例演示sql注入​\t\t代码内容演示\njavapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n    Scanner scanner = new Scanner(System.in);\n    //next(): 当接收到 空格 或者 &#39; 就是表示结束\n    //nextLine(): 接受到 回车 表示结束\n    System.out.print(&quot;请输入管理员的名字: &quot;);\n    String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n    System.out.print(&quot;请输入管理员的密码: &quot;);\n    String admin_pws = scanner.nextLine();\n    //1. 加载驱动\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    //3. 得到Statement\n    Statement statement = connection.createStatement();\n    //4. 组织sql\n    String sql = &quot;select name, pwd from admin where name = &#39;&quot;\n            + admin_name + &quot;&#39; and pwd = &#39;&quot; +admin_pws+ &quot;&#39;&quot;;\n    //执行给定的SQL语句,该语句返回单个ResultSet对象\n    ResultSet resultSet = statement.executeQuery(sql);\n    //5.查询表\n    if(resultSet.next()) &#123;\n        System.out.println(&quot;恭喜,登陆成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;抱歉,登录失败&quot;);\n    &#125;\n\n    //6. 关闭连接\n    resultSet.close();\n    connection.close();\n    statement.close();\n&#125;​\t\t演示sql注入的结果\n\n\n六、PreparedStatement接口[预处理]1.基本介绍\n​\t\tsql语句编写\ntxtString sql = &quot;SELECT COUNT(*) FROM admin WHERE username =? AND PASSWORD =?&quot;2.预处理的好处 \n3.代码举例演示预处理javapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n    Scanner scanner = new Scanner(System.in);\n    //next(): 当接收到 空格 或者 &#39; 就是表示结束\n    //nextLine(): 接受到 回车 表示结束\n    System.out.print(&quot;请输入管理员的名字: &quot;);\n    String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n    System.out.print(&quot;请输入管理员的密码: &quot;);\n    String admin_pws = scanner.nextLine();\n\n    //1. 加载驱动\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    //3. 得到PreparedStatement\n    //3.1 组织sql,sql语句的 ?相当于占位符\n    String sql = &quot;select name, pwd from admin where name =? and pwd =?&quot;;\n    //3.2 preparedStatement对象实现了PreparedStatement接口的实现类的对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //3.3 给?赋值\n    preparedStatement.setString(1, admin_name);\n    preparedStatement.setString(2, admin_pws);\n\n    //4. 执行select语句使用 executeQuery\n    //   如果执行的是 dml语句(update, insert, delete) executeUpdate()\n    //   这里执行executeQuery不用再写sql语句,因为已经被PreparedStatement处理过了\n    //\t 除非sql语句不含?,才可以写在executeQuery里面\n    ResultSet resultSet = preparedStatement.executeQuery();\n    //5. 查询表\n    if(resultSet.next()) &#123;\n        System.out.println(&quot;恭喜,登陆成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;抱歉,登录失败&quot;);\n    &#125;\n\n    //6. 关闭连接\n    resultSet.close();\n    preparedStatement.close();\n    connection.close();\n&#125;​\t\t演示sql注入的结果\n\n4.演示使用DML语句DML语句(update, insert, delete)使用  executeUpdate()\nselect语句使用 executeQuery()\njavapublic static void main(String[] args) throws Exception &#123;\n    //看 PreparedStatement 类图\n    Scanner scanner = new Scanner(System.in);\n    //让用户输入管理员名和密码\n    System.out.print(&quot;请输删除管理员的名字: &quot;); //next(): 当接收到 空格或者 &#39;就是表示结束\n    String admin_name = scanner.nextLine(); // 老师说明，如果希望看到 SQL 注入，这里需要用 nextLine\n    // System.out.print(&quot;请输入管理员的新密码: &quot;);\n    // String admin_pwd = scanner.nextLine();\n    //通过 Properties 对象获取配置文件的信息\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;javacode\\\\src\\\\mysql.properties&quot;));\n    //获取相关的值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String driver = properties.getProperty(&quot;driver&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    //1. 注册驱动\n    Class.forName(driver);//建议写上\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n***主要部分\n    //3. 得到 PreparedStatement\n    //3.1 组织 SqL , Sql 语句的 ? 就相当于占位符\n    //添加记录\n    //String sql = &quot;insert into admin values(?, ?)&quot;;\n    //String sql = &quot;update admin set pwd = ? where name = ?&quot;; 此刻 setString(1, admin_p)\n    String sql = &quot;delete from admin where name = ?&quot;;\n    //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //3.3 给 ? 赋值 此处要对应?赋正确的值\n    preparedStatement.setString(1, admin_name);\n    //preparedStatement.setString(2, admin_name);\n    //4. 执行 dml 语句使用 executeUpdate\n    int rows = preparedStatement.executeUpdate();\n    System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);\n***    \n    //关闭连接\n    preparedStatement.close();\n    connection.close();\n&#125;\n七、例题练习1、题目要求\n2、问题解析2.使用PreparedStatement添加5条数据javapublic class PreparedStatementwork1 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        Scanner scanner = new Scanner(System.in);\n        //next(): 当接收到 空格 或者 &#39; 就是表示结束\n        //nextLine(): 接受到 回车 表示结束\n        System.out.print(&quot;请输入管理员的名字: &quot;);\n        String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n        System.out.print(&quot;请输入管理员的密码: &quot;);\n        String admin_pws = scanner.nextLine();\n\n        //1. 加载驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n        String user = &quot;root&quot;;\n        String password = &quot;20031214gr&quot;;\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        //3. 得到PreparedStatement\n        //3.1 设置sql语句\n        String sql = &quot;insert into admin values(?, ?)&quot;;\n        //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //3.3 给 ? 赋值\n        preparedStatement.setString(1, admin_name);\n        preparedStatement.setString(2, admin_pws);\n\n        //4. 执行dml 语句使用 executeUpdate\n        int rows = preparedStatement.executeUpdate();\n        System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);\n\n        //关闭连接\n        preparedStatement.close();\n        connection.close();\n    &#125;\n&#125;3.修改tom的记录, 将username改成 kingjava//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;update admin set name = &#39;king&#39; where name =? &quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n//3.3 给 ? 赋值\npreparedStatement.setString(1, admin_name);\n\n//4. 执行dml 语句使用 executeUpdate\nint rows = preparedStatement.executeUpdate();\nSystem.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);4.删除 一条 记录java//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;delete from admin where name = ?&quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n//3.3 给 ? 赋值\npreparedStatement.setString(1, admin_name);\n\n//4. 执行dml 语句使用 executeUpdate\nint rows = preparedStatement.executeUpdate();\nSystem.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);5.查询全部记录，并显示在控制台使用select语句应该用executeQuery方法, 并且用ResultSet结果集接收, 在末尾要关闭ResultSet\njava//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;select * from admin&quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n\n//4. 执行select 语句使用 executeQuery\nResultSet resultSet = preparedStatement.executeQuery();\n\n//5. 使用while取出数据\nwhile(resultSet.next()) &#123; //让光标向下移动\n    String name = resultSet.getString(1);\n    String pwd = resultSet.getString(2);\n    System.out.println(name + &quot;\\t&quot; + pwd);\n&#125;\n//关闭连接\npreparedStatement.close();\nresultSet.close();\nconnection.close();\n八、JDBC的API小结\n\n\n九、封装 JDBC[关闭连接,得到连接]1.封装JDBCUtils[关闭连接, 得到连接]说明：在JDBC操作中，获取连接 和 释放资源 是经常使用到的，可以将其封装JDBC连接到的工具类 JDBCUtils\nJDBCUtils代码：\njavapackage com.JDBC.utils;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * 这是一个工具类,完成mysql的连接和关闭资源\n */\npublic class JDBCUtils &#123;\n    //定义相关属性(4个),只需要一份,做成static\n    private static String user; //用户名\n    private static String password; //密码\n    private static String url; //url\n    private static String driver; //驱动名\n\n    //在static代码块去初始化\n    static &#123;\n        try &#123;\n            Properties properties = new Properties();\n            properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n            //获取相关的属性值\n            user = properties.getProperty(&quot;user&quot;);\n            password = properties.getProperty(&quot;password&quot;);\n            url = properties.getProperty(&quot;url&quot;);\n            driver = properties.getProperty(&quot;driver&quot;);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n\n    //连接数据库,返回Connection\n    public static Connection getConnection() &#123;\n        try &#123;\n            return DriverManager.getConnection(url, user, password);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    //关闭相关资源\n    /*\n        1. ResultSet 结果集\n        2. Statement 或者 PreparedStatement\n        3. Connection\n        4. 如果关闭资源,就传入对象,否则传入null\n     */\n    public static void close(ResultSet set, Statement statement, Connection connection) &#123;\n        //判断是否为null\n        try &#123;\n            if(set != null) &#123;\n                set.close();\n            &#125;\n            if(statement != null) &#123;\n                statement.close();\n            &#125;\n            if(connection != null) &#123;\n                connection.close();\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;2.演示如何使用JDBCUtils类1、使用JDBCUtils执行DML语句javapublic void testDML() &#123; //insert, update, delete\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update actor set name = ? where id = ?&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null; //为了在finally关闭资源,扩大作用域\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        preparedStatement = connection.prepareStatement(sql);\n        //给占位符赋值\n        preparedStatement.setString(1, &quot;蘑菇&quot;);\n        preparedStatement.setInt(2, 1);\n        //执行sql语句 update属于 dml语句\n        preparedStatement.executeUpdate();\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        //关闭资源\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;2、使用JDBCUtils执行select语句javapublic void testSelect() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql语句\n    String sql = &quot;select * from actor&quot;;\n    //3. 创建一个PreparedStament 对象\n    PreparedStatement preparedStatement = null;\n    ResultSet resultSet = null;\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句返回一个ResultSet结果集\n        resultSet = preparedStatement.executeQuery();\n        //通过while循环取出resultSet\n        while (resultSet.next()) &#123;\n            int id = resultSet.getInt(1);\n            String name = resultSet.getString(2);\n            String sex = resultSet.getString(3);\n            Date borndate = resultSet.getDate(4);\n            String phone = resultSet.getString(5);\n            System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + borndate + &quot;\\t&quot; + phone);\n        &#125;\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        JDBCUtils.close(resultSet, preparedStatement, connection);\n    &#125;\n&#125;\n十、事务1.简要说明\n2.应用实例: 模拟经典的转账业务1.模拟数据库txt-- 创建案例表\ncreate table account(\n    id int primary key auto_increment,\n    name varchar(32) not null default &#39;&#39;,\n    balance double not null default 0)\n    character set utf8;\n-- 插入数据\ninsert into account values(null, &#39;马云&#39;, 3000);\ninsert into account values(null, &#39;马化腾&#39;, 10000);2.不使用事务可能出现的问题模拟​\t在默认情况下,connection会自动提交。当执行到 int i &#x3D; 1&#x2F;0的时候,抛出异常,则不会继续执行try块后面的内容,就会使甲方转出了钱，但是乙方没有收到钱，这显然是不合理的，因此需要使用事务处理。\njavapublic void noTransaction() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update account set balance = balance - 100 where id = 1&quot;;\n    String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null;\n    try &#123;\n        connection = JDBCUtils.getConnection(); //在默认情况下,connection会自动提交\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句\n        preparedStatement.executeUpdate();\n\n        int i = 1/0; //抛出异常\n        //执行sql2语句\n        preparedStatement = connection.prepareStatement(sql2);\n        preparedStatement.executeUpdate();\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;3.使用事务解决上述问题​\t首先，先将connection设置为不自动提交，当设置后就表示开启了事务。如果发生异常就要回滚，所以在catch块中设置connection.rollback() 该方法默认回滚到事务开始的地方。在语句全部执行完后才提交事务connection.commit()。\njavapublic void userTransaction() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update account set balance = balance - 100 where id = 1&quot;;\n    String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null;\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        //将connection设置为不自动提交\n        connection.setAutoCommit(false); //开启了事务\n\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句\n        preparedStatement.executeUpdate();\n\n        //int i = 1/0; //抛出异常\n        //执行sql2语句\n        preparedStatement = connection.prepareStatement(sql2);\n        preparedStatement.executeUpdate();\n        //提交事务\n        connection.commit();\n\n    &#125; catch (SQLException e) &#123;\n        //在这里进行回滚，即撤销执行sql\n        System.out.println(&quot;执行发生了异常,撤销执行的sql语句&quot;);\n        try &#123;\n            connection.rollback(); //默认回滚到事务开始的地方\n        &#125; catch (SQLException ex) &#123;\n            throw new RuntimeException(ex);\n        &#125;\n        e.printStackTrace();\n    &#125; finally &#123;\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;\n十一、批处理1.基本介绍\n2.批处理底层实际上是一个集合存储sql语句，满了之后扩容。  |  扩容之后如下。\n\n3.源码分析将 sql 语句加入到批处理包中 -&gt; 看源码\n1、第一就创建 ArrayList - elementData &#x3D;&gt; Object[]\n2、elementData &#x3D;&gt; Object[] 就会存放我们预处理的 sql 语句\n3、当 elementData 满后,就按照 1.5 倍扩容\n4、当添加到指定的值后，就 executeBatch\n5、批量处理会减少我们发送 sql 语句的网络开销，而且减少编译次数，因此效率提高\njavapublic void addBatch() throws SQLException &#123;\n    synchronized(this.checkClosed().getConnectionMutex()) &#123;\n    if (this.batchedArgs == null) &#123;\n        this.batchedArgs = new ArrayList();\n    &#125;\n    for(int i = 0; i &lt; this.parameterValues.length; ++i) &#123;\n        this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);\n    &#125;\n    this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));\n    &#125;\n&#125;4.使用批处理一定要在url中加入参数 ?rewriteBatchedStatements&#x3D;true\n配置文件内容:\ntxtuser=root\npassword=20031214gr\nurl=jdbc:mysql://localhost:3306/hspeducode?rewriteBatchedStatements=true\ndriver=com.mysql.cj.jdbc.Driver代码实现批处理操作sql语句\njavapublic void batch() throws SQLException &#123;\n    Connection connection = JDBCUtils.getConnection();\n    String sql = &quot;insert into admin2 values(null, ?, ?)&quot;;\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    System.out.println(&quot;开始执行&quot;);\n    long start = System.currentTimeMillis(); //开始时间\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        preparedStatement.setString(1, &quot;jack&quot;+i);\n        preparedStatement.setString(2, &quot;123&quot;);\n        //将sql语句加入到批处理包中\n        preparedStatement.addBatch();\n        //当有1000条时，再批量执行\n        if((i + 1) % 1000 == 0) &#123;\n            preparedStatement.executeBatch();\n            //清空语句\n            preparedStatement.clearBatch();\n        &#125;\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;批量处理 耗时时间: &quot; + (end - start));\n    //关闭连接\n    JDBCUtils.close(null, preparedStatement, connection);\n&#125;\n十二、数据库连接池1.提出问题问题：java程序频繁的连接数据库，需要得到多次连接\n传统连接数据库：\n\n多次连接数据库：\n\n传统方式连接mysql5000次代码模拟\njava//连接 mysql 5000 次\npublic void testCon() &#123;\n    //看看连接-关闭 connection 会耗用多久\n    long start = System.currentTimeMillis();\n    System.out.println(&quot;开始连接.....&quot;);\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //使用传统的 jdbc 方式，得到连接\n        Connection connection = JDBCUtils.getConnection();\n        //做一些工作，比如得到 PreparedStatement ，发送 sql\n        //.......... //关闭\n        JDBCUtils.close(null, null, connection);\n    &#125;\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;传统方式 5000 次 耗时=&quot; + (end - start));//传统方式 5000 次 耗时=7099\n    &#125;\n&#125;2.传统获取Connection问题分析\n3.数据库连接池基本介绍\n4.数据库连接池示意图1、当连接被占用时进入等待队列，等待连接可用。如果连接没有被占用，则可以直接获得连接，不需要等待。\n2、放回连接池是指把连接的引用断开，连接对象任然还在。\n\n5.数据库连接池的种类\n\nC3P0数据库连接池1.使用C3P0数据库连接池的准备工作添加jar包并且添加到库里。\n\n2.使用C3P0数据库连接池(代码实现)方式一: 在程序中指定user, url, password等java//方式一: 相关参数，在程序中指定user, url, password等\npublic void testC3P0_01() throws Exception &#123;\n    //1. 创建一个数据源对象\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();\n    //2. 通过配置文件(mysql.properties)获取相关连接的信息\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n    //读取相关属性值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    String diver = properties.getProperty(&quot;diver&quot;);\n\n    //给数据源 comboPooledDataSource 设置相关参数\n    //注意: 连接管理是由 comboPooledDataSource 来管理\n    comboPooledDataSource.setDriverClass(diver);\n    comboPooledDataSource.setJdbcUrl(url);\n    comboPooledDataSource.setUser(user);\n    comboPooledDataSource.setPassword(password);\n\n    //设置初始化连接数\n    comboPooledDataSource.setInitialPoolSize(10);\n    //设置最大连接数\n    comboPooledDataSource.setMaxPoolSize(50);\n    //测试连接池的效率、测试对mysql 5000次操作\n    long start = System.currentTimeMillis(); //开始时间\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //得到连接池的连接\n        Connection connection = comboPooledDataSource.getConnection(); //从DataSource接口实现的连接\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;C3P0 5000次连接mysql耗时: &quot; + (end- start)); //C3P0 5000次连接mysql耗时: 509\n&#125;方式二: 使用配置文件模板来完成1、将C3P0提供的c3p0.config.xml文件拷贝到src目录下\n2、该文件指定了连接数据库和连接池的相关参数\n3、在xml中配置好参数\njava//方式二: 使用配置文件模板来完成\n//1. 将c3p0提供的c3p0.config.xml拷贝到src目录下\n//2. 该文件指定了连接数据库和连接池的相关参数\npublic void testC3P0_02() throws SQLException &#123;\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(&quot;hsp_edu&quot;);\n    long start = System.currentTimeMillis(); //开始时间\n    //测试5000次连接mysql\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //直接连接\n        Connection connection = comboPooledDataSource.getConnection();\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;C3P0方式二 5000次连接mysql耗时: &quot; + (end -start)); //C3P0方式二 5000次连接mysql耗时: 461\n&#125;\nDruid(德鲁伊)数据库连接池1.使用Druid数据库连接池的准备工作1.添加jar包并且添加到库里。 加入配置文件druid.properties文件到src目录下\n2.配置druid.properties的参数\n2.使用Druid数据库连接池(代码实现)javapublic void testDruid() throws Exception &#123;\n    //1. 加入Druid jar包\n    //2. 加入配置文件 druid.properties, 将该文件拷贝项目的src目录\n    //3. 创建Properties对象,读取配置文件\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));\n    //4. 创建一个指定参数的数据库连接池, Druid连接池\n    DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n    long start = System.currentTimeMillis();\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //获取连接\n        Connection connection = dataSource.getConnection();\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;Druid连接池的耗时: &quot; + (end - start)); //Druid连接池的耗时: 603\n&#125;\nApache-DBUtils1.问题提出:1、关闭connection后，resultSet结果集无法使用\n2、resultSet不利于数据的管理\n3、示意图 \n因此将结果集记录封装到ArrayList&lt;&gt;集合中方便数据的管理和使用\n\n2.基本介绍\n3.准备工作略: 引入commons-dbutils-1.3.jar包到libs目录下并添加到库中\n4.代码实现​\t(要确保mysql中设置的类型和Actor类中对象类型保持一致,否则会报错)\n1、查询多行记录(返回ArrayList集合)​\t\t使用的是new BeanListHandler&lt;&gt;(Actor.class)\n​\t\t解读queryRunner.query\n(1) query方法就是执行一个sql语句得到一个resultset –封装到 –&gt; ArrayList集合中(2) 返回集合(3) connection: 连接(4) sql: 执行的sql语句(5) new BeanListHandler&lt;&gt;(Actor.class): 将resultset -取出-&gt; Actor对象 -封装-&gt; ArraryList集合.底层使用反射机制 去获取Actor类的属性,然后封装(6) 1: 就是给sql中的?赋值,可以有多个值(例如1,2,3) 因为是可变参数Object… params(7) 底层得到的resultset,会在query方法关闭,还会关闭PreparedStatement\njava//使用apache-DBUtils工具类 + druid完成对表的crud操作\npublic void testQueryMany() throws SQLException &#123; //返回结果是多行的情况\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 就可以执行相关的方法,返回ArrayList 结果集\n    String sql = &quot;select * from actor where id &gt;= 1&quot;;\n    //解读:\n    //(1) query方法就是执行一个sql语句得到一个resultset --封装到 --&gt; ArrayList集合中\n    //(2) 返回集合\n    //(3) connection: 连接\n    //(4) sql: 执行的sql语句\n    //(5) new BeanListHandler&lt;&gt;(Actor.class): 将resultset -取出-&gt; Actor对象 -封装-&gt; ArraryList集合\n    //    底层使用反射机制 去获取Actor类的属性,然后封装\n    //(6) 1: 就是给sql中的?赋值,可以有多个值(例如1,2,3) 因为是可变参数Object... params\n    //(7) 底层得到的resultset,会在query方法关闭,还会关闭PreparedStatement\n    List&lt;Actor&gt; list =\n            queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(Actor.class));\n    //迭代器遍历\n    System.out.println(&quot;输出集合的信息&quot;);\n    for (Actor actor : list) &#123;\n        System.out.println(actor);\n    &#125;\n    \n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;​\t\t输出结果\ntxt输出集合的信息\nActor&#123;id=1, name=&#39;蘑菇&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;\nActor&#123;id=2, name=&#39;刘德华&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;2、查询单行记录(返回单个对象)​\t\t使用的是new BeanHandler&lt;&gt;(Actor.class) \n​\t\t如果没有查到的话，输出actor返回的是 null\njava//演示apache-dbutils + druid 完成 返回的结果是单行记录(单个对象)\npublic void testQuerySingle() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 执行相关方法,返回单个对象\n    String sql = &quot;select * from actor where id = ?&quot;;\n    //解读:\n    //因为返回的是单行记录&lt;--&gt;单个对象, 使用的是Handler 是BeanHandler\n    Actor actor = queryRunner.query(connection, sql, new BeanHandler&lt;&gt;(Actor.class), 1);\n    System.out.println(actor);\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;​\t\t输出结果\ntxtActor&#123;id=1, name=&#39;蘑菇&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;3、查询单行单列(返回Object)​\t\t使用的是new ScalarHandler()\t输出结果:略\njava//演示apache-dbutils + druid 完成查询结果是单行单列-返回的是object\npublic void testScalar() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 执行相关方法,返回单行单列,返回的是object\n    String sql = &quot;select name from actor where id = ?&quot;;\n    //解读: 因为返回的是一个对象, 使用的handler 是 ScalarHandler\n    Object object = queryRunner.query(connection, sql, new ScalarHandler(), 1);\n    System.out.println(object);\n\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;4、DML语句操作​\t\t使用的是queryRunner.update()\n​\t\t注意事项: “小明”, 1 是用来替换 sql 中的 ? \njava//演示apache-dbutils + druid 完成 dml (update, insert, delete)\npublic void testDML() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n\n    //4. 这里组织sql 完成 updatae, insert, delete(此处只演示update)\n    String sql = &quot;update actor set name = ? where id = ?&quot;;\n    //解读:\n    //(1) 执行dml 操作是queryRunner.update()\n    //(2) 返回的值是受影响的行数\n    int affectedRow = queryRunner.update(connection, sql, &quot;小明&quot;, 1);\n    System.out.println(affectedRow &gt; 0 ? &quot;执行成功&quot; : &quot;执行sql没有影响到表&quot;);\n\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;\n表和JavaBean类型的映射关系\n\nBasicDaoDAO和增删改查的通用方法-BasicDao\n1.问题提出apache-dbutils+Druid简化了JDBC开发，但还有不足:\n1、SQL语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查。\n2、对应select操作，如果有返回值，返回类型不能固定，需要使用泛型。\n3、将来的表很多，业务需求复杂，不可能只靠一个java类完成。\n4、引出&#x3D;》 BasicDAO\n2.简单的BasicDAO示意图\n\n3.基本说明1、DAO: data access object数据访问对象\n2、这样的通用类，称为BasicDao，是专门和数据库交互的，即完成对数据库(表)的crud操作。\n3、在BaiscDao的基础上，实现一张表对应一个Dao，更好的完成功能。(比如Cusromer表-下面是代码演示)\n4.代码实现1、简单设计1.com.dao_.utils &#x2F;&#x2F;工具类\n2.com.dao_.domain &#x2F;&#x2F;javabean\n3.com.dao_.dao &#x2F;&#x2F;存放XxxDAO 和BasicDAO\n4.com.dao_.test &#x2F;&#x2F;写测试类\n2、utils包​\t\t使用了druid数据库连接池\njavapackage com.dao_.utils;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\n/**\n * 基于druid数据库连接池的工具类\n */\npublic class JDBCUtilsByDruid &#123;\n    private static DataSource ds;\n    //在静态代码块完成ds的初始化\n    static &#123;\n        Properties properties = new Properties();\n        try &#123;\n            properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));\n            ds = DruidDataSourceFactory.createDataSource(properties);\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    //编写getConnection方法\n    public static Connection getConnection() throws SQLException &#123;\n        return ds.getConnection();\n    &#125;\n    //关闭连接  在数据库连接池中,close方法不是真正断掉连接\n    // 而是把使用的Connection对象放回连接池\n    public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;\n        try &#123;\n            if(resultSet != null) &#123;\n                resultSet.close();\n            &#125;\n            if(statement != null) &#123;\n                statement.close();\n            &#125;\n            if(connection != null) &#123;\n                connection.close();\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;3、domain包javapackage com.dao_.domain;\n\nimport java.util.Date;\n\n/**\n * Actor对象和actor表的记录对应\n */\npublic class Actor &#123; //Javaben, POJO, Domain对象\n    private Integer id;\n    private String name;\n    private String sex;\n    private Date borndate;\n    private String phone;\n\n    public Actor() &#123; //一定要给一个无参构造器[反射需要]\n    &#125;\n\n    public Actor(Integer id, String name, String sex, Date borndate, String phone) &#123;\n        this.id = id;\n        this.name = name;\n        this.sex = sex;\n        this.borndate = borndate;\n        this.phone = phone;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    public Date getBorndate() &#123;\n        return borndate;\n    &#125;\n\n    public void setBorndate(Date borndate) &#123;\n        this.borndate = borndate;\n    &#125;\n\n    public String getPhone() &#123;\n        return phone;\n    &#125;\n\n    public void setPhone(String phone) &#123;\n        this.phone = phone;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Actor&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, sex=&#39;&quot; + sex + &#39;\\&#39;&#39; +\n                &quot;, borndate=&quot; + borndate +\n                &quot;, phone=&#39;&quot; + phone + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;4、dao包注意: 每个方法中返回不同类型的值所调用的API不同\n​\t\tBasicDAO类: 是其他DAO的父类 \njavapackage com.dao_.dao;\n\nimport com.JDBC.utils.JDBCUtilsByDruid;\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\n/**\n * 开发BasicDAO,是其他DAO的父类\n */\npublic class BasicDAO&lt;T&gt; &#123; //泛型指定具体类型\n    private QueryRunner qr = new QueryRunner();\n    //开发通用dml方法，针对任意的表\n    public int update(String sql, Object... parameters) &#123; //sql语句， 参数\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            //返回受影响的行数\n            int update = qr.update(connection, sql, parameters);\n            return update;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //返回多个对象(即查询的结果是多行),针对任意表\n    /**\n     * @param sql sql语句,可以有?\n     * @param clazz 传入一个类的Class对象,比如Actor.class\n     * @param parameters 传入?的具体的值,可以是多个\n     * @return 根据Actor.class 返回对应的ArrayList集合\n     */\n    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; clazz, Object...parameters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(clazz), parameters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行结果的通用方法\n    public T querySingle(String sql, Class&lt;T&gt; clazz, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(clazz), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行单列的方法,即返回单值的方法\n    public Object queryScaler(String sql, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new ScalarHandler(), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n&#125;​\t\tActorDAO类: 继承BasicDAO类\njavapackage com.dao_.dao;\n\nimport com.dao_.domain.Actor;\n\npublic class ActorDAO extends BasicDAO&lt;Actor&gt; &#123;\n    //1. 继承拥有BasicDAO的方法\n    //2. 根据业务需要，可以编写特有的方法\n&#125;5、testdao包在DAO包底层会自动把连接关闭 JDBCUtilsByDruid.close(null, null, connection);\n​\t\tTestDAO类: 演示如何使用ActorDAO对actor表进行crud操作\njavapackage com.dao_.test;\n\nimport com.dao_.dao.ActorDAO;\nimport com.dao_.domain.Actor;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\npublic class TestDAO &#123;\n    @Test\n    //测试ActorDAO 对actor表的crud操作\n    public void testActorDAO() &#123;\n        ActorDAO actorDAO = new ActorDAO();\n        //1. 查询\n        List&lt;Actor&gt; actors = actorDAO.queryMulti(&quot;select * from actor where id &gt;= ?&quot;, Actor.class, 1);\n        System.out.println(&quot;==查询结果==&quot;);\n        for (Actor actor : actors) &#123;\n            System.out.println(actor);\n        &#125;\n        //2. 查询单行记录\n        Actor actor = actorDAO.querySingle(&quot;select * from actor where id = ?&quot;, Actor.class, 2);\n        System.out.println(&quot;==查询单行结果==&quot;);\n        System.out.println(actor);\n        //3. 查询单行单列\n        Object object = actorDAO.queryScaler(&quot;select name from actor where id = ?&quot;, 1);\n        System.out.println(&quot;==查询单行单列结果==&quot;);\n        System.out.println(object);\n        //4. dml操作 insert,update, delete\n        int update = actorDAO.update(&quot;insert into actor values(null, ?, ?, ?, ?)&quot;, &quot;张飞&quot;, &quot;男&quot;, &quot;2000-11-11&quot;, &quot;9999&quot;);\n        System.out.println(update &gt; 0 ? &quot;执行成功&quot; : &quot;执行没有影响表&quot;);\n    &#125;\n&#125;","slug":"Mysql章节JDBC和数据库连接池","date":"2023-11-23T15:28:20.000Z","categories_index":"JDBC和数据库连接池","tags_index":"Mysql","author_index":"白"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2023-11-21T11:10:22.100Z","categories_index":"","tags_index":"","author_index":"白"}]