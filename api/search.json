[{"id":"03a1af7058cec8bb8efe418ed228e157","title":"正则表达式","content":"正则表达式","slug":"正则表达式","date":"2023-11-25T17:20:00.000Z","categories_index":"正则表达式","tags_index":"正则表达式","author_index":"白"},{"id":"9828133175dbd4abfb8bc2b5ec3d15b8","title":"满汉楼小作业","content":"Mysql满汉楼小作业简要说明技术要求: java + jdbc(druid) + mysql\n项目目标: 训练对mysql和jdbc的能力\n1、去掉界面和事件处理，使用控制台界面\n2、完成 登陆、订座、点餐和结账、查看账单等功能\n怎么开始: 根据程序框架图从底层到业务层逐步构建。\n程序框架图\n\n\n\n1、准备工具类Utility搭建项目的整体结构\n1、新建项目mhl\n2、将整体结构搭建出来。dao包，domain包，service包，utils包，view包\n准备工具类Utility\n1、将三个jar包导入。分别是mysql，druid，Apache-DBUtils相关的jar包。\n2、将JDBCUtilsByDruid，Utility类导入utils包中。(Utility类负责控制输入，JDBCUtilsByDruid类负责连接druid连接池)。\n3、将配置文件druid.properties导入src目录下。!!!注意修改配置文件中的参数,确保数据库正确。\n4、测试Utility类和JDBCUtilsByDruid类。(从其他地方导入可能会出现问题)\nBasicDAO\n针对表进行的操作。\ndml方法-&gt;update\n返回多行结果-&gt;queryMulti\n返回单行结果-&gt;querySingle\n返回单个对象-&gt;queryScaler\njava/**\n * 开发BasicDAO,是其他DAO的父类\n */\npublic class BasicDAO&lt;T&gt; &#123; //泛型指定具体类型\n    private QueryRunner qr = new QueryRunner();\n    //开发通用dml方法，针对任意的表\n    public int update(String sql, Object... parameters) &#123; //sql语句， 参数\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            //返回受影响的行数\n            int update = qr.update(connection, sql, parameters);\n            return update;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //返回多个对象(即查询的结果是多行),针对任意表\n    /**\n     * @param sql sql语句,可以有?\n     * @param clazz 传入一个类的Class对象,比如Actor.class\n     * @param parameters 传入?的具体的值,可以是多个\n     * @return 根据Actor.class 返回对应的ArrayList集合\n     */\n    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; clazz, Object...parameters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(clazz), parameters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行结果的通用方法\n    public T querySingle(String sql, Class&lt;T&gt; clazz, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(clazz), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行单列的方法,即返回单值的方法\n    public Object queryScaler(String sql, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new ScalarHandler(), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n&#125;效果如下图\n\n\n2、显示主菜单、二级菜单和退出系统功能1、代码部分略\n2、显示框架如下\n\n\n3、用户登录要求: 用户登陆时输入id和pwd要和用户表进行匹配。匹配成功可以登陆，失败就退出\n1、创建用户表sql--用户表\nCREATE TABLE employee (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增\n    empId VARCHAR(50) UNIQUE NOT NULL DEFAULT &#39;&#39;, #员工号\n    pwd CHAR(32) NOT NULL DEFAULT &#39;&#39;, #密码md5\n    name VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #姓名\n    job VARCHAR(50) NOT NULL DEFAULT &#39;&#39; #岗位\n)CHARSET=utf8;\n\n--添加测试语句\nINSERT INTO employee VALUES(NULL, &#39;6668612&#39;, MD5(&#39;123456&#39;), &#39;张三丰&#39;, &#39;经理&#39;);\nINSERT INTO employee VALUES(NULL, &#39;6668622&#39;, MD5(&#39;123456&#39;), &#39;小龙女&#39;, &#39;服务员&#39;);\nINSERT INTO employee VALUES(NULL, &#39;6668633&#39;, MD5(&#39;123456&#39;), &#39;张无忌&#39;, &#39;收银员&#39;);\nINSERT INTO employee VALUES(NULL, &#39;666666&#39;, MD5(&#39;123456&#39;), &#39;老虎&#39;, &#39;经理&#39;);2、domian包: Employee根据程序框架图要设置一个与mysql表对应的domain类。\n该类是javabean和emoloyeee对应\njavapublic class Employee &#123;\n    private Integer id;\n    private String empId;\n    private String pwd;\n    private String name;\n    private String job; \n    public Employee() &#123; //无参构造器,反射需要\n    &#125;\n    public Employee(Integer id, String empId, String pwd, String name, String job) &#123;\n        this.id = id;\n        this.empId = empId;\n        this.pwd = pwd;\n        this.name = name;\n        this.job = job;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n&#125;3、DAO包: EmployeeDAO根据程序框架图设置一个能操作employee表的类。\n该类继承BasicDAO类\njavapackage com.mhl.dao;\n\nimport com.mhl.domain.Employee;\n\npublic class EmployeeDAO extends BasicDAO&lt;Employee&gt; &#123;\n    //可以写特有的操作\n&#125;4、(业务层)service包: EmployeeService功能: 根据empId和pwd返回一个Employee对象,如果未匹配则返回null\n根据程序框架图设置一个业务层的employeeservice类，负责组织sql语句完成业务需要。\njava/**\n * 该类完成对employee表的各种操作\n * 通过调用EmployeeDAO对象完成\n */\npublic class EmployeeService &#123;\n    //定义一个 EmployeeDAO\n    private EmployeeDAO employeeDAO = new EmployeeDAO();\n\n    //方法，根据empId和pwd返回一个Employee对象\n    public Employee getEmployeeByIdAndPwd(String empId, String pwd) &#123;\n        return employeeDAO.querySingle(&quot;select * from employee where empId=? and pwd=md5(?)&quot;, Employee.class, empId, pwd);\n    &#125;\n&#125;5、MHLView在主菜单界面调用该方法使用: 调用该方法就必须拥有一个该类的对象，因此创建一个该类的对象。\njava//定义EmployeeService 属性\nprivate EmployeeService employeeService = new EmployeeService();效果演示\n\n4、显示餐桌要求: 显示餐桌编号和餐桌当前状态\n1、创建餐桌表sql--创建diningTable 表(id, state, orderName, orderTel ...)\nCREATE TABLE diningTable (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增,表示餐桌编号\n    state VARCHAR(20) NOT NULL DEFAULT &#39;&#39;, #餐桌的状态\n    orderName VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #预定人的名字\n    orderTel VARCHAR(20) NOT NULL DEFAULT &#39;&#39;\n)CHARSET=utf8;\n\n--添加测试语句\nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); \nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); \nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); 2、domain包:  DiningTablejavabean和diningTable表对应\njavapublic class DiningTable &#123;\n    private Integer id;\n    private String state;\n    private String orderName;\n    private String orderTel;\n\n    public DiningTable() &#123;\n    &#125;\n\n    public DiningTable(Integer id, String state, String orderName, String orderTel) &#123;\n        this.id = id;\n        this.state = state;\n        this.orderName = orderName;\n        this.orderTel = orderTel;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return id + &quot;\\t\\t\\t&quot; + state;\n    &#125;\n&#125;3、DAO包: DiningTableDAOjavapublic class EmployeeDAO extends BasicDAO&lt;Employee&gt; &#123;\n    //可以写特有的操作\n&#125;4、service包: DiningTableService功能: 返回所有的餐桌信息\njavapublic class DiningTableService &#123; //业务层\n    //定义一个DiningTableDAO对象\n    private DiningTableDAO diningTableDAO = new DiningTableDAO();\n    //返回所有餐桌信息\n    public List&lt;DiningTable&gt; list() &#123;\n       return diningTableDAO.queryMulti(&quot;select id, state from diningTable&quot;, DiningTable.class);\n    &#125;\n&#125;5、MHLView在MHLView中封装方法，用于显示所有餐桌的状态。\njava//显示所有餐桌状态\npublic void listDiningTable() &#123;\n    List&lt;DiningTable&gt; list = diningTableService.list();\n    System.out.println(&quot;\\n餐桌编号\\t\\t餐桌状态&quot;);\n    for (DiningTable diningTable : list) &#123;\n        System.out.println(diningTable);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n5、满汉楼订座要求: 实现用户订座，如果座位状态不为空则显示不能订座。\n1、功能分析定制功能建立在diningTable表上，因此订座功能应当在DiningTableService类(针对DiningTable的服务)中实现\n2、DiningTableService扩展扩展两个方法\ngetDiningTableById:  根据传入的id判断餐桌是否存在。若不存在返回null。\norderDiningTable: 根据传入的形参对diningTable表进行更新。成功返回true，失败返回false\njava//根据id, 查询对应的餐桌DiningTable对象\n//如果返回null,表示id编号对应的餐桌不存在\npublic DiningTable getDiningTableById(int id) &#123;\n    //可以直接执行sql语句去测试是否正确\n    return diningTableDAO.querySingle(&quot;select * from diningTable where id = ?&quot;, DiningTable.class, id);\n&#125;\n//如果可以预定,调用方法对diningTable表进行更新\n/**\n * @param id 餐桌id\n * @param orderName 预订人姓名\n * @param orderTel 预订人电话\n * @return\n */\npublic boolean orderDiningTable(int id, String orderName, String orderTel) &#123;\n    int update =\n            diningTableDAO.update(&quot;update diningTable set state=&#39;已经预定&#39;, orderName=?, orderTel=? where id = ?&quot;, orderName, orderTel, id);\n    return update &gt; 0;\n&#125;3、MHLView在MHLView封装方法，实现订座功能。\njava//完成订座\npublic void orderDiningTable() &#123;\n    System.out.println(&quot;==============预定餐桌============&quot;);\n    System.out.print(&quot;请选择要预定的餐桌编号(-1退出): &quot;);\n    int orderId = Utility.readInt();\n    if (orderId == -1) &#123;\n        System.out.println(&quot;==============取消预订餐桌============&quot;);\n        return;\n    &#125;\n    //该方法得到的是 Y 或者 N\n    char key = Utility.readConfirmSelection();\n    if (key == &#39;Y&#39;) &#123;//要预定\n\n        //根据orderId 返回 对应DiningTable对象, 如果为null, 说明该对象不存在\n        DiningTable diningTable = diningTableService.getDiningTableById(orderId);\n        if (diningTable == null) &#123;//\n            System.out.println(&quot;==============预订餐桌不存在============&quot;);\n            return;\n        &#125;\n        //判断该餐桌的状态是否 &quot;空&quot;\n        if (!(&quot;空&quot;.equals(diningTable.getState()))) &#123;//说明当前这个餐桌不是 &quot;空&quot; 状态\n            System.out.println(&quot;==============该餐桌已经预定或者就餐中============&quot;);\n            return;\n        &#125;\n        //接收预定信息\n        System.out.print(&quot;预定人的名字: &quot;);\n        String orderName = Utility.readString(50);\n        System.out.print(&quot;预定人的电话: &quot;);\n        String orderTel = Utility.readString(50);\n\n        //更新餐桌状态\n        if (diningTableService.orderDiningTable(orderId, orderName, orderTel)) &#123;\n            System.out.println(&quot;==============预订餐桌成功============&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;==============预订餐桌失败============&quot;);\n        &#125;\n\n    &#125; else &#123;\n        System.out.println(&quot;==============取消预订餐桌============&quot;);\n    &#125;\n&#125;效果演示\n\n\n6、满汉楼菜单要求: 显示菜单表。\n1、创建菜单表sql--创建menu表(id, name, type, price)\n#菜单\nCREATE TABLE menu (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增,菜单编号\n    name VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #菜名\n    type VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #菜品种类\n    price DOUBLE NOT NULL DEFAULT 0 #价格\n)CHARSET=utf8;\n\n--添加测试数据\nINSERT INTO menu VALUES(NULL, &#39;八宝饭&#39;, &#39;主食&#39;, 10);\nINSERT INTO menu VALUES(NULL, &#39;叉烧包&#39;, &#39;主食&#39;, 20);\nINSERT INTO menu VALUES(NULL, &#39;宫保鸡丁&#39;, &#39;热菜&#39;, 30);\nINSERT INTO menu VALUES(NULL, &#39;山药拔鱼&#39;, &#39;凉菜&#39;, 14);\nINSERT INTO menu VALUES(NULL, &#39;银丝卷&#39;, &#39;甜食&#39;, 9);\nINSERT INTO menu VALUES(NULL, &#39;水煮鱼&#39;, &#39;热菜&#39;, 26);\nINSERT INTO menu VALUES(NULL, &#39;甲鱼汤&#39;, &#39;汤类&#39;, 100);\nINSERT INTO menu VALUES(NULL, &#39;鸡蛋汤&#39;, &#39;汤类&#39;, 16);2、domain包: Menujava/**\n * 该类(javabean)和menu表\n */\npublic class Menu &#123;\n    private Integer id;\n    private String name;\n    private String type;\n    private Double price;\n\n    public Menu() &#123;\n    &#125;\n\n    public Menu(Integer id, String name, String type, Double price) &#123;\n        this.id = id;\n        this.name = name;\n        this.type = type;\n        this.price = price;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return id + &quot;\\t\\t&quot; + name + &quot;\\t\\t&quot; + type + &quot;\\t\\t&quot; + price;\n    &#125;\n&#125;3、DAO包: MenuDAOjavapublic class MenuDAO extends BasicDAO&lt;Menu&gt;&#123;&#125;4、service包: MenuService功能: 返回menu表所有内容\njava/**\n * 完成对menu表的各种操作(通过调用MenuDAO)\n */\npublic class MenuService &#123;\n    //定义MenuDAO属性\n    private MenuDAO menuDAO = new MenuDAO();\n    //返回所有菜品\n    public List&lt;Menu&gt; list() &#123;\n        return menuDAO.queryMulti(&quot;select * from menu&quot;, Menu.class);\n    &#125;\n&#125;5、MHLView在MHLView中封装方法，用于显示所有菜品。\njava//显示所有菜品\npublic void listMenu() &#123;\n    List&lt;Menu&gt; list = menuService.list();\n    System.out.println(&quot;\\n菜品编号\\t\\t菜品名\\t\\t类别\\t\\t价格&quot;);\n    for (Menu menu : list) &#123;\n        System.out.println(menu);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n7、满汉楼点餐要求: 对餐桌号，菜单编号，做合理性校验，如果不合理，给出提示信息。\n思路分析1、餐桌号，菜单编号 校验。\n2、点餐成功，需要修改餐桌状态。\n3、生成账单 -&gt; 创建账单表\n1、创建账单表sql#表bill账单表(id, billId, menuId, nums, billDate, money, state, diningTableId)\nCREATE TABLE bill (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增主键\n    billId VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #账单号 可以安装自己规则生成 UUID\n    menuId INT NOT NULL DEFAULT 0, #菜单编号,可以用外键\n    nums INT NOT NULL DEFAULT 0, #份数\n    money DOUBLE NOT NULL DEFAULT 0, #金额\n    diningTableId INT NOT NULL DEFAULT 0, #餐桌\n    billDate DATE NOT NULL, #订单日期\n    state VARCHAR(50) NOT NULL DEFAULT &#39;&#39; #状态 &#39;未结账&#39;, &#39;已结账&#39;, &#39;挂单&#39;\n)CHARSET=utf8;2、domain包: BillBill是javabean和bill表对应\njava/**\n * 该类(javabean)和bill表对应\n */\npublic class Bill &#123;\n    private Integer id;\n    private String billId;\n    private Integer menuId;\n    private Integer nums;\n    private Double money;\n    private Integer diningTableId;\n    private Date billDate;\n    private String state;\n\n    public Bill() &#123; //无参构造器,用于反射\n    &#125;\n\n    public Bill(Integer id, String billId, Integer menuId, Integer nums, Double money, Integer diningTableId, Date billDate, String state) &#123;\n        this.id = id;\n        this.billId = billId;\n        this.menuId = menuId;\n        this.nums = nums;\n        this.money = money;\n        this.diningTableId = diningTableId;\n        this.billDate = billDate;\n        this.state = state;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return &quot;Bill&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, billId=&#39;&quot; + billId + &#39;\\&#39;&#39; +\n                &quot;, menuId=&quot; + menuId +\n                &quot;, nums=&quot; + nums +\n                &quot;, money=&quot; + money +\n                &quot;, diningTableId=&quot; + diningTableId +\n                &quot;, billDate=&quot; + billDate +\n                &quot;, state=&#39;&quot; + state + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;3、DAO包: BillDAOjavapublic class BillDAO extends BasicDAO&lt;Bill&gt;&#123;&#125;4、service包: BillService功能: 处理和账单相关的业务逻辑\nBillService类\n1、生成账单\n注意事项: 1、生成账单需要计算金额，因此从MenuService中获取menu对象进而得到金额。\n​\t\t\t\t\t2、当生成订单后需要将餐桌状态更新，因此需要DiningTableService属性改变餐桌状态。\n​\t\t\t\t\t综上,MenuService和DiningTableService需要新增方法。\njava/**\n * 处理和账单相关的业务逻辑\n */\npublic class BillService &#123;\n    //定义BillDAO属性\n    private BillDAO billDAO = new BillDAO();\n    //定义一个MenuService属性\n    private MenuService menuService = new MenuService();\n    //定义一个DiningTableService属性\n    private DiningTableService diningTableService = new DiningTableService();\n    //点餐的方法 成功返回true 失败false\n    //1. 生成账单\n    //2. 更新餐桌状态\n    public boolean orderMenu(int menuId, int nums, int diningTableId) &#123;\n        //生成一个账单号,UUID\n        String billId = UUID.randomUUID().toString();\n\n        //将账单生成到bill表,要求直接计算账单金额\n        int update = billDAO.update(&quot;insert into bill values(null,?,?,?,?,?,now(),&#39;未结账&#39;)&quot;,\n                billId, menuId, nums, (menuService.getMenuById(menuId).getPrice() * nums), diningTableId);\n        if(update &lt;= 0) &#123;\n            return false;\n        &#125;\n        //更新餐桌状态\n        return diningTableService.updateDiningTableState(diningTableId, &quot;就餐中&quot;);\n    &#125;\n&#125;MenuService新增方法\njava//方法,根据id,返回Menu对象\npublic Menu getMenuById(int id) &#123;\n    return menuDAO.querySingle(&quot;select * from menu where id = ?&quot;, Menu.class, id);\n&#125;DiningTableService新增方法\njava//方法,更新餐桌状态的方法\npublic boolean updateDiningTableState(int id, String state) &#123;\n    int update = diningTableDAO.update(&quot;update diningTable set state=? where id=?&quot;, state, id);\n    return update &gt; 0;\n&#125;5、MHLView在MHLView封装方法，实现点餐功能。\n验证餐桌号是否存在: 通过diningTableService.getDiningTableById可以判断餐桌是否存在。\n验证菜品编号: 通过menuService.getMenuById判断此id对应的对象是否存在\n点餐: billService.orderMenu创建账单,创建失败则返回false\njava//完成点餐\npublic void orderMenu() &#123;\n    System.out.println(&quot;==============点餐服务============&quot;);\n    System.out.print(&quot;请输入点餐的桌号(-1退出): &quot;);\n    int orderDiningTableId = Utility.readInt();\n    if (orderDiningTableId == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;请输入点餐的菜品号(-1退出): &quot;);\n    int orderMenuId = Utility.readInt();\n    if (orderMenuId == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;请输入点餐的菜品量(-1退出): &quot;);\n    int orderNums = Utility.readInt();\n    if (orderNums == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n\n    //验证餐桌号是否存在.\n    DiningTable diningTable = diningTableService.getDiningTableById(orderDiningTableId);\n    if (diningTable == null) &#123;\n        System.out.println(&quot;==============餐桌号不存在============&quot;);\n        return;\n    &#125;\n    //验证菜品编号\n    Menu menu = menuService.getMenuById(orderMenuId);\n    if (menu == null) &#123;\n        System.out.println(&quot;==============菜品号不存在============&quot;);\n        return;\n    &#125;\n\n    //点餐\n    if (orderMenu(orderMenuId, orderNums, orderDiningTableId)) &#123;\n        System.out.println(&quot;==============点餐成功============&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;==============点餐失败============&quot;);\n    &#125;\n&#125;效果演示\n\n\n8、满汉楼显示账单要求: 显示所有账单\n1、BillService新增功能java//返回所有账单\npublic List&lt;Bill&gt; list() &#123;\n    return billDAO.queryMulti(&quot;select * from bill&quot;, Bill.class);\n&#125;2、MHLViewjava//显示账单信息\npublic void listBill() &#123;\n    List&lt;Bill&gt; bills = billService.list();\n    System.out.println(&quot;\\n编号\\t\\t菜品号\\t\\t菜品量\\t\\t金额\\t\\t桌号\\t\\t日期\\t\\t\\t\\t\\t\\t\\t状态&quot;);\n    for (Bill bill : bills) &#123;\n        System.out.println(bill);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n9、满汉楼结账要求: 实现满汉楼结账\n思路分析1、对餐桌号进行校验\n2、修改bill表的state\n3、修改diningTable信息，结完账就清空\n4、不需要增加新表，不需要增加新类，需要增加方法\n1、BillService新增功能hasPayBillByDiningTableId: 查看未结账账单\npayBill: 完成结账[如果餐桌存在，并且该餐桌有未结账的账单]\njava//查看某个餐桌是否有未结账的账单\npublic boolean hasPayBillByDiningTableId(int diningTableId) &#123;\n\n    Bill bill =\n            billDAO.querySingle(&quot;SELECT * FROM bill WHERE diningTableId=? AND state = &#39;未结账&#39; LIMIT 0, 1&quot;, Bill.class, diningTableId);\n    return bill != null;\n&#125;\n//完成结账[如果餐桌存在，并且该餐桌有未结账的账单]\n//如果成功，返回true, 失败返回 false\npublic boolean payBill(int diningTableId, String payMode) &#123;\n    //如果这里使用事务的话，需要用ThreadLocal来解决 , 框架中比如mybatis 提供了事务支持\n    //1. 修改bill表\n    int update = billDAO.update(&quot;update bill set state=? where diningTableId=? and state=&#39;未结账&#39;&quot;, payMode, diningTableId);\n\n    if(update &lt;= 0) &#123; //如果更新没有成功，则表示失败...\n        return false;\n    &#125;\n    //2. 修改diningTable表\n    //注意：不要直接在这里操作，而应该调用DiningTableService 方法,完成更新，体现各司其职\n    if(!diningTableService.updateDiningTableToFree(diningTableId, &quot;空&quot;)) &#123;\n        return false;\n    &#125;\n    return true;\n&#125;2、DiningTableService新增功能updateDiningTableToFree: 将餐桌设置为空闲状态\njava//提供方法，将指定的餐桌设置为空闲状态\npublic boolean updateDiningTableToFree(int id, String state) &#123;\n    int update = diningTableDAO.update(&quot;update diningTable set state=?,orderName=&#39;&#39;,orderTel=&#39;&#39; where id=?&quot;, state, id);\n    return update &gt; 0;\n&#125;3、MHLViewMHLView封装方法完成结账\n1、判断餐桌是否存在: diningTableService.getDiningTableById\n2、判断该餐桌是否有需要结账的账单: billService.hasPayBillByDiningTableId\n3、完成结账: 调用payBill方法完成结账\njava//完成结账\npublic void payBill() &#123;\n    System.out.println(&quot;==============结账服务============&quot;);\n    System.out.print(&quot;请选择要结账的餐桌编号(-1退出): &quot;);\n    int diningTableId = Utility.readInt();\n    if (diningTableId == -1) &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n        return;\n    &#125;\n    //验证餐桌是否存在\n    DiningTable diningTable = diningTableService.getDiningTableById(diningTableId);\n    if (diningTable == null) &#123;\n        System.out.println(&quot;=============结账的餐桌不存在============&quot;);\n        return;\n    &#125;\n    //验证餐桌是否有需要结账的账单\n    if (!billService.hasPayBillByDiningTableId(diningTableId)) &#123;\n        System.out.println(&quot;=============该餐位没有未结账账单============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;结账方式(现金/支付宝/微信)回车表示退出: &quot;);\n    String payMode = Utility.readString(20, &quot;&quot;);//说明如果回车，就是返回 &quot;&quot;\n    if (&quot;&quot;.equals(payMode)) &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n        return;\n    &#125;\n    char key = Utility.readConfirmSelection();\n    if (key == &#39;Y&#39;) &#123; //结账\n\n        //调用我们写的方法\n        if (billService.payBill(diningTableId, payMode)) &#123;\n            System.out.println(&quot;=============完成结账============&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;=============结账失败============&quot;);\n        &#125;\n\n    &#125; else &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n    &#125;\n&#125;效果演示\n\n10、多表查询注意事项:  1、domain构建MultiTableBean类，属性是通过反射调用set方法赋值，因此无参构造器是必须的。\n​\t\t\t\t\t 2、不查询price值的话，price的值为null，不会对程序造成影响。\n​\t\t\t\t \t3、属性名是否一定要和表的列名保持一致。可以不一致，但是需要sql做相应的修改, 规范需要保持一致.\n细节:  如果sql语句写出如下形式，那么会通过反射找setName2方法来给MultiTableBean类中的属性赋值。因此如果两个表设计到重复名字的话，可以设置别名区分。\n例如: a表设置为name1，b表设置为name2，在MultiTableBean类中分别给name1和name2设置set和get方法就可以区分两个表。\n\n举例:\nMultiTableBean类: private String name2;\nBillSerbvice类: \njava//返回所有的账单并带有菜品名,价格， 提供给View调用\npublic List&lt;MultiTableBean&gt; list2() &#123;\n    return multiTableDAO.queryMulti(&quot;SELECT bill.*, NAME as name2,price &quot; +\n            &quot;FROM bill, menu &quot; +\n            &quot;WHERE bill.menuId = menu.id&quot;, MultiTableBean.class);\n&#125;如果如上设计，那么list2返回的表中name2就不会为null\n1、MultiTableBean类从原先的bill表新增属性，重新设计一个多表类\njavaprivate Integer id;\nprivate String billId;\nprivate Integer menuId;\nprivate Integer nums;\nprivate Double money;\nprivate Integer diningTableId;\nprivate Date billDate;\nprivate String state;\n//增加一个来自menu表的列 name\n//思考 这里的属性名是否一定要和表的列名保持一致.\n//答: 可以不一致，但是需要sql做相应的修改, 规范需要保持一致.\nprivate String name;\n//增加来自menu表的列 price\nprivate Double price;//默认值 nulll2、MultiTableDAO类javapublic class MultiTableDAO extends BasicDAO&lt;MultiTableBean&gt; &#123;&#125;3、BillService类注意:  用String连接mysql语句时要注意空格，否则sql语句不通过\njava//返回所有的账单并带有菜品名,价格， 提供给View调用\npublic List&lt;MultiTableBean&gt; list2() &#123;\n    return multiTableDAO.queryMulti(&quot;SELECT bill.*, NAME,price &quot; +\n            &quot;FROM bill, menu &quot; +\n            &quot;WHERE bill.menuId = menu.id&quot;, MultiTableBean.class);\n&#125;4、MHLView从新建的multiTableBeans类获取list集合，可获得menu表中的name和price值。\nprice值可以为null，不会对程序造成影响。\njava//显示账单信息\n    public void listBill() &#123;\n        List&lt;MultiTableBean&gt; multiTableBeans = billService.list2();\n        System.out.println(&quot;\\n编号\\t\\t菜品号\\t\\t菜品量\\t\\t金额\\t\\t桌号\\t\\t日期\\t\\t\\t\\t\\t\\t\\t状态\\t\\t菜品名\\t\\t价格&quot;);\n        for (MultiTableBean bill : multiTableBeans) &#123;\n            System.out.println(bill);\n        &#125;\n        System.out.println(&quot;==============显示完毕============&quot;);\n    &#125;效果演示\n\n\n总结1、思路路程根据程序框架图从底层开始搭建。\n1、首先设置好utils工具类，druid配置文件\n2、domain层: 例如创建Menu表对应一个domian类-Menu类。Menu类含有无参构造器-&gt;反射需要。含有Menu表该有的属性和tostring方法。\n3、DAO层: 在DAO层构建一个MenuDAO类，负责对Menu表的增删改查和特有的操作。该层的类都会继承BasicDAO类，BasicDAO中是通用的方法。\n4、service层: 构建MenuService类，负责组织sql语句，并调用MenuDAO对象完成综合的需求。\n5、View层: MHLView界面层调用service层的类，得到结果，显示数据。\n","slug":"Mysql章节满汉楼项目","date":"2023-11-24T16:25:00.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"白"},{"id":"fb7466e40a0c693c18329664f28f2eb5","title":"JDBC和数据库连接池","content":"Mysql学习笔记一、Mysql简要说明使用命令行窗口连接 MYSQL 数据库\n\n操作示意图\n\n二、创建数据库txt\\#使用指令创建数据库\n\nCREATE DATABASE hsp_db01;\n\n\\#删除数据库指令\n\nDROP DATABASE hsp_db01\n\n\\#创建一个使用 utf8 字符集的 hsp_db02 数据库\n\nCREATE DATABASE hsp_db02 CHARACTER SET utf8\n\n\\#创建一个使用 utf8 字符集，并带校对规则的 hsp_db03 数据库\n\nCREATE DATABASE hsp_db03 CHARACTER SET utf8 COLLATE utf8_bin\n\n\\#校对规则 utf8_bin 区分大小 默认 utf8_general_ci 不区分大小写\n章节: JDBC 和数据库连接池一、JDBC 连接 MySQL准备工作将下载的mysql-connector-java.jar 放入在目录里面的 libs 里面（如果没有就自己创建一个，记得要打包文件）\n右键选中加载到库中\n\n\n二、介绍JDBC1、JDBC 的概念 JDBC 是 Java DataBase Connectivity (Java 数据连接)技术的简称，是一种可用于执行 SQL 语句的 Java API。它由一些 java 语言编写的类和接口组成；程序员通过使用 jdbc 可以方便地将 SQL 语句传送给几乎任何一种数据库。\n2、JDBC 的功能(1) 与数据库建立连接。(2) 向数据库发送 SQL 语句并执行这些语句。(3) 处理数据返回的结果。\n3、JDBC 的常用接口和类(1) Driver 接口:加载驱动程序。(2) DriverManager 类:装人所需的 JDBC 驱动程序，编程时调用它的方法来创建连接。(3) Connection 接口:编程时使用该类对象创建 Statement 对象。(4) Statement 接口:编程时使用该类对象得到 ResultSet 对象。(5) ResultSet 类:负责保存 Statement 执行后所产生的查询结果。\n\n三、连接 MySQL小提示：\n1.mysql驱动5.1.6可以无需CLass.forName(“com.mysql.jdbc.Driver”);\n2.从jkd1.5以后使用jdbc4，不再需要显示调用class.forName()注册驱动而是自动调用驱动jar包下META-INF\\services\\java.sql.Driver文本中的类名称去注册\n3.建议还是写上Class.forName(“com.mysql.cj.jdbc.Driver”),更加明确\n\n(1)、注册驱动使用反射加载Driver类\ntxtClass.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);(2)、获取连接方法一:  DriverManager.getConnection() 传入形参 String url ,Properties info\n方法二:  DriverManager.getConnection() 传入形参 String url ,String user, String password\ntxt Connection com = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/hspeducode&quot;, &quot;root&quot;, &quot;123456&quot;);(3)、获取执行者连接txtStatement stat = com.createStatement();(4)、执行 SQL 语句，并接受结果txtString sql = &quot;SELECT * FROM user&quot;;\n\nResultSet rs = stat.executeQuery(sql);(5)、处理结果txtwhile (rs.next())&#123;\n        System.out.println(rs.getInt(&quot;id&quot;) + &quot;\\t&quot; + rs.getString(&quot;name&quot;));\n&#125;(6)、释放资源txtcom.close();\nstat.close();\ncom.close();（重要）通过不同方式连接mysql方式一：映射之后连接mysqljavapublic void connect01() throws ClassNotFoundException, SQLException &#123;\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(&quot;方式一: &quot;+connection);\n&#125;方式二：通过读取配置文件来连接mysql\njavapublic void connect02() throws IOException, ClassNotFoundException, SQLException &#123;\n    //通过Properties对象获取配置文件\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n    //获取相关的值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    String driver = properties.getProperty(&quot;driver&quot;);\n\n    Class.forName(driver);//建议写上\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(&quot;方式二: &quot; + connection);\n&#125;\n四、ResultSet[结果集]1.基本介绍1.表示数据库结果集的数据库，通常通过执行查询数据库的语句生成\n2.ResultSet对象保持一个光标指向其当前的数据行。最初，光标位于第一行之前\n3.next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环来遍历结果集\n2.ResultSet图像说明\n3.ResultSet底层\n4.代码举例演示javapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        //1. 加载驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        //创建url和user和password\n        String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n        String user = &quot;root&quot;;\n        String password = &quot;20031214gr&quot;;\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n        //3. 得到Statement\n        Statement statement = connection.createStatement();\n        //4. 组织sql\n        String sql = &quot;select id, name, sex, borndate, phone from actor&quot;;\n        //执行给定的SQL语句,该语句返回单个ResultSet对象\n        ResultSet resultSet = statement.executeQuery(sql);\n        //5. 使用while取出数据\n        while (resultSet.next()) &#123; //让光标向下移动,如果没有更多信息,返回false\n            int id = resultSet.getInt(1); //获取该行的第1列\n            String name = resultSet.getString(2); //获取该行第2列\n            String sex = resultSet.getString(3); //获取该行第3列\n            Date borndate = resultSet.getDate(4); //获取该行第4列\n            String phone = resultSet.getString(5); //获取该行第5列\n\n            System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + borndate + &quot;\\t&quot; + phone);\n        &#125;\n        //6. 关闭连接\n        resultSet.close();\n        connection.close();\n        statement.close();\n    &#125;​\t\t输出演示\ntxt1\t周星驰\t男\t1970-11-11\t110\n2\t刘德华\t男\t1970-11-11\t110\n五、Statement接口1.基本介绍\n2.sql注入​\t\t前置准备\ntxt-- 创建一张表\n\nCREATE TABLE admin ( -- 管理员表\n\nNAME VARCHAR(32) NOT NULL UNIQUE, \n\npwd VARCHAR(32) NOT NULL DEFAULT &#39;&#39;) CHARACTER SET utf8; \n\n-- 添加数据\n\nINSERT INTO admin VALUES(&#39;tom&#39;, &#39;123&#39;);​\t\t正常查询\ntxtSELECT *\n\nFROM admin\n\nWHERE NAME = &#39;tom&#39; AND pwd = &#39;123&#39;​\t\tSQL注入\ntxt-- 输入用户名 为 1&#39; or\n\n-- 输入万能密码 为 or &#39;1&#39;= &#39;1\n\nSELECT *\n\nFROM admin\n\nWHERE NAME = &#39;1&#39; OR&#39; AND pwd = &#39;OR &#39;1&#39;= &#39;1&#39; \n-- &#39;1&#39; = &#39;1&#39;一定成立,因此有隐患\n\nSELECT * FROM admin3.代码举例演示sql注入​\t\t代码内容演示\njavapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n    Scanner scanner = new Scanner(System.in);\n    //next(): 当接收到 空格 或者 &#39; 就是表示结束\n    //nextLine(): 接受到 回车 表示结束\n    System.out.print(&quot;请输入管理员的名字: &quot;);\n    String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n    System.out.print(&quot;请输入管理员的密码: &quot;);\n    String admin_pws = scanner.nextLine();\n    //1. 加载驱动\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    //3. 得到Statement\n    Statement statement = connection.createStatement();\n    //4. 组织sql\n    String sql = &quot;select name, pwd from admin where name = &#39;&quot;\n            + admin_name + &quot;&#39; and pwd = &#39;&quot; +admin_pws+ &quot;&#39;&quot;;\n    //执行给定的SQL语句,该语句返回单个ResultSet对象\n    ResultSet resultSet = statement.executeQuery(sql);\n    //5.查询表\n    if(resultSet.next()) &#123;\n        System.out.println(&quot;恭喜,登陆成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;抱歉,登录失败&quot;);\n    &#125;\n\n    //6. 关闭连接\n    resultSet.close();\n    connection.close();\n    statement.close();\n&#125;​\t\t演示sql注入的结果\n\n\n六、PreparedStatement接口[预处理]1.基本介绍\n​\t\tsql语句编写\ntxtString sql = &quot;SELECT COUNT(*) FROM admin WHERE username =? AND PASSWORD =?&quot;2.预处理的好处 \n3.代码举例演示预处理javapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n    Scanner scanner = new Scanner(System.in);\n    //next(): 当接收到 空格 或者 &#39; 就是表示结束\n    //nextLine(): 接受到 回车 表示结束\n    System.out.print(&quot;请输入管理员的名字: &quot;);\n    String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n    System.out.print(&quot;请输入管理员的密码: &quot;);\n    String admin_pws = scanner.nextLine();\n\n    //1. 加载驱动\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    //3. 得到PreparedStatement\n    //3.1 组织sql,sql语句的 ?相当于占位符\n    String sql = &quot;select name, pwd from admin where name =? and pwd =?&quot;;\n    //3.2 preparedStatement对象实现了PreparedStatement接口的实现类的对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //3.3 给?赋值\n    preparedStatement.setString(1, admin_name);\n    preparedStatement.setString(2, admin_pws);\n\n    //4. 执行select语句使用 executeQuery\n    //   如果执行的是 dml语句(update, insert, delete) executeUpdate()\n    //   这里执行executeQuery不用再写sql语句,因为已经被PreparedStatement处理过了\n    //\t 除非sql语句不含?,才可以写在executeQuery里面\n    ResultSet resultSet = preparedStatement.executeQuery();\n    //5. 查询表\n    if(resultSet.next()) &#123;\n        System.out.println(&quot;恭喜,登陆成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;抱歉,登录失败&quot;);\n    &#125;\n\n    //6. 关闭连接\n    resultSet.close();\n    preparedStatement.close();\n    connection.close();\n&#125;​\t\t演示sql注入的结果\n\n4.演示使用DML语句DML语句(update, insert, delete)使用  executeUpdate()\nselect语句使用 executeQuery()\njavapublic static void main(String[] args) throws Exception &#123;\n    //看 PreparedStatement 类图\n    Scanner scanner = new Scanner(System.in);\n    //让用户输入管理员名和密码\n    System.out.print(&quot;请输删除管理员的名字: &quot;); //next(): 当接收到 空格或者 &#39;就是表示结束\n    String admin_name = scanner.nextLine(); // 老师说明，如果希望看到 SQL 注入，这里需要用 nextLine\n    // System.out.print(&quot;请输入管理员的新密码: &quot;);\n    // String admin_pwd = scanner.nextLine();\n    //通过 Properties 对象获取配置文件的信息\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;javacode\\\\src\\\\mysql.properties&quot;));\n    //获取相关的值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String driver = properties.getProperty(&quot;driver&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    //1. 注册驱动\n    Class.forName(driver);//建议写上\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n***主要部分\n    //3. 得到 PreparedStatement\n    //3.1 组织 SqL , Sql 语句的 ? 就相当于占位符\n    //添加记录\n    //String sql = &quot;insert into admin values(?, ?)&quot;;\n    //String sql = &quot;update admin set pwd = ? where name = ?&quot;; 此刻 setString(1, admin_p)\n    String sql = &quot;delete from admin where name = ?&quot;;\n    //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //3.3 给 ? 赋值 此处要对应?赋正确的值\n    preparedStatement.setString(1, admin_name);\n    //preparedStatement.setString(2, admin_name);\n    //4. 执行 dml 语句使用 executeUpdate\n    int rows = preparedStatement.executeUpdate();\n    System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);\n***    \n    //关闭连接\n    preparedStatement.close();\n    connection.close();\n&#125;\n七、例题练习1、题目要求\n2、问题解析2.使用PreparedStatement添加5条数据javapublic class PreparedStatementwork1 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        Scanner scanner = new Scanner(System.in);\n        //next(): 当接收到 空格 或者 &#39; 就是表示结束\n        //nextLine(): 接受到 回车 表示结束\n        System.out.print(&quot;请输入管理员的名字: &quot;);\n        String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n        System.out.print(&quot;请输入管理员的密码: &quot;);\n        String admin_pws = scanner.nextLine();\n\n        //1. 加载驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n        String user = &quot;root&quot;;\n        String password = &quot;20031214gr&quot;;\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        //3. 得到PreparedStatement\n        //3.1 设置sql语句\n        String sql = &quot;insert into admin values(?, ?)&quot;;\n        //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //3.3 给 ? 赋值\n        preparedStatement.setString(1, admin_name);\n        preparedStatement.setString(2, admin_pws);\n\n        //4. 执行dml 语句使用 executeUpdate\n        int rows = preparedStatement.executeUpdate();\n        System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);\n\n        //关闭连接\n        preparedStatement.close();\n        connection.close();\n    &#125;\n&#125;3.修改tom的记录, 将username改成 kingjava//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;update admin set name = &#39;king&#39; where name =? &quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n//3.3 给 ? 赋值\npreparedStatement.setString(1, admin_name);\n\n//4. 执行dml 语句使用 executeUpdate\nint rows = preparedStatement.executeUpdate();\nSystem.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);4.删除 一条 记录java//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;delete from admin where name = ?&quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n//3.3 给 ? 赋值\npreparedStatement.setString(1, admin_name);\n\n//4. 执行dml 语句使用 executeUpdate\nint rows = preparedStatement.executeUpdate();\nSystem.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);5.查询全部记录，并显示在控制台使用select语句应该用executeQuery方法, 并且用ResultSet结果集接收, 在末尾要关闭ResultSet\njava//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;select * from admin&quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n\n//4. 执行select 语句使用 executeQuery\nResultSet resultSet = preparedStatement.executeQuery();\n\n//5. 使用while取出数据\nwhile(resultSet.next()) &#123; //让光标向下移动\n    String name = resultSet.getString(1);\n    String pwd = resultSet.getString(2);\n    System.out.println(name + &quot;\\t&quot; + pwd);\n&#125;\n//关闭连接\npreparedStatement.close();\nresultSet.close();\nconnection.close();\n八、JDBC的API小结\n\n\n九、封装 JDBC[关闭连接,得到连接]1.封装JDBCUtils[关闭连接, 得到连接]说明：在JDBC操作中，获取连接 和 释放资源 是经常使用到的，可以将其封装JDBC连接到的工具类 JDBCUtils\nJDBCUtils代码：\njavapackage com.JDBC.utils;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * 这是一个工具类,完成mysql的连接和关闭资源\n */\npublic class JDBCUtils &#123;\n    //定义相关属性(4个),只需要一份,做成static\n    private static String user; //用户名\n    private static String password; //密码\n    private static String url; //url\n    private static String driver; //驱动名\n\n    //在static代码块去初始化\n    static &#123;\n        try &#123;\n            Properties properties = new Properties();\n            properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n            //获取相关的属性值\n            user = properties.getProperty(&quot;user&quot;);\n            password = properties.getProperty(&quot;password&quot;);\n            url = properties.getProperty(&quot;url&quot;);\n            driver = properties.getProperty(&quot;driver&quot;);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n\n    //连接数据库,返回Connection\n    public static Connection getConnection() &#123;\n        try &#123;\n            return DriverManager.getConnection(url, user, password);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    //关闭相关资源\n    /*\n        1. ResultSet 结果集\n        2. Statement 或者 PreparedStatement\n        3. Connection\n        4. 如果关闭资源,就传入对象,否则传入null\n     */\n    public static void close(ResultSet set, Statement statement, Connection connection) &#123;\n        //判断是否为null\n        try &#123;\n            if(set != null) &#123;\n                set.close();\n            &#125;\n            if(statement != null) &#123;\n                statement.close();\n            &#125;\n            if(connection != null) &#123;\n                connection.close();\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;2.演示如何使用JDBCUtils类1、使用JDBCUtils执行DML语句javapublic void testDML() &#123; //insert, update, delete\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update actor set name = ? where id = ?&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null; //为了在finally关闭资源,扩大作用域\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        preparedStatement = connection.prepareStatement(sql);\n        //给占位符赋值\n        preparedStatement.setString(1, &quot;蘑菇&quot;);\n        preparedStatement.setInt(2, 1);\n        //执行sql语句 update属于 dml语句\n        preparedStatement.executeUpdate();\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        //关闭资源\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;2、使用JDBCUtils执行select语句javapublic void testSelect() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql语句\n    String sql = &quot;select * from actor&quot;;\n    //3. 创建一个PreparedStament 对象\n    PreparedStatement preparedStatement = null;\n    ResultSet resultSet = null;\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句返回一个ResultSet结果集\n        resultSet = preparedStatement.executeQuery();\n        //通过while循环取出resultSet\n        while (resultSet.next()) &#123;\n            int id = resultSet.getInt(1);\n            String name = resultSet.getString(2);\n            String sex = resultSet.getString(3);\n            Date borndate = resultSet.getDate(4);\n            String phone = resultSet.getString(5);\n            System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + borndate + &quot;\\t&quot; + phone);\n        &#125;\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        JDBCUtils.close(resultSet, preparedStatement, connection);\n    &#125;\n&#125;\n十、事务1.简要说明\n2.应用实例: 模拟经典的转账业务1.模拟数据库txt-- 创建案例表\ncreate table account(\n    id int primary key auto_increment,\n    name varchar(32) not null default &#39;&#39;,\n    balance double not null default 0)\n    character set utf8;\n-- 插入数据\ninsert into account values(null, &#39;马云&#39;, 3000);\ninsert into account values(null, &#39;马化腾&#39;, 10000);2.不使用事务可能出现的问题模拟​\t在默认情况下,connection会自动提交。当执行到 int i &#x3D; 1&#x2F;0的时候,抛出异常,则不会继续执行try块后面的内容,就会使甲方转出了钱，但是乙方没有收到钱，这显然是不合理的，因此需要使用事务处理。\njavapublic void noTransaction() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update account set balance = balance - 100 where id = 1&quot;;\n    String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null;\n    try &#123;\n        connection = JDBCUtils.getConnection(); //在默认情况下,connection会自动提交\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句\n        preparedStatement.executeUpdate();\n\n        int i = 1/0; //抛出异常\n        //执行sql2语句\n        preparedStatement = connection.prepareStatement(sql2);\n        preparedStatement.executeUpdate();\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;3.使用事务解决上述问题​\t首先，先将connection设置为不自动提交，当设置后就表示开启了事务。如果发生异常就要回滚，所以在catch块中设置connection.rollback() 该方法默认回滚到事务开始的地方。在语句全部执行完后才提交事务connection.commit()。\njavapublic void userTransaction() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update account set balance = balance - 100 where id = 1&quot;;\n    String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null;\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        //将connection设置为不自动提交\n        connection.setAutoCommit(false); //开启了事务\n\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句\n        preparedStatement.executeUpdate();\n\n        //int i = 1/0; //抛出异常\n        //执行sql2语句\n        preparedStatement = connection.prepareStatement(sql2);\n        preparedStatement.executeUpdate();\n        //提交事务\n        connection.commit();\n\n    &#125; catch (SQLException e) &#123;\n        //在这里进行回滚，即撤销执行sql\n        System.out.println(&quot;执行发生了异常,撤销执行的sql语句&quot;);\n        try &#123;\n            connection.rollback(); //默认回滚到事务开始的地方\n        &#125; catch (SQLException ex) &#123;\n            throw new RuntimeException(ex);\n        &#125;\n        e.printStackTrace();\n    &#125; finally &#123;\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;\n十一、批处理1.基本介绍\n2.批处理底层实际上是一个集合存储sql语句，满了之后扩容。  |  扩容之后如下。\n\n3.源码分析将 sql 语句加入到批处理包中 -&gt; 看源码\n1、第一就创建 ArrayList - elementData &#x3D;&gt; Object[]\n2、elementData &#x3D;&gt; Object[] 就会存放我们预处理的 sql 语句\n3、当 elementData 满后,就按照 1.5 倍扩容\n4、当添加到指定的值后，就 executeBatch\n5、批量处理会减少我们发送 sql 语句的网络开销，而且减少编译次数，因此效率提高\njavapublic void addBatch() throws SQLException &#123;\n    synchronized(this.checkClosed().getConnectionMutex()) &#123;\n    if (this.batchedArgs == null) &#123;\n        this.batchedArgs = new ArrayList();\n    &#125;\n    for(int i = 0; i &lt; this.parameterValues.length; ++i) &#123;\n        this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);\n    &#125;\n    this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));\n    &#125;\n&#125;4.使用批处理一定要在url中加入参数 ?rewriteBatchedStatements&#x3D;true\n配置文件内容:\ntxtuser=root\npassword=20031214gr\nurl=jdbc:mysql://localhost:3306/hspeducode?rewriteBatchedStatements=true\ndriver=com.mysql.cj.jdbc.Driver代码实现批处理操作sql语句\njavapublic void batch() throws SQLException &#123;\n    Connection connection = JDBCUtils.getConnection();\n    String sql = &quot;insert into admin2 values(null, ?, ?)&quot;;\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    System.out.println(&quot;开始执行&quot;);\n    long start = System.currentTimeMillis(); //开始时间\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        preparedStatement.setString(1, &quot;jack&quot;+i);\n        preparedStatement.setString(2, &quot;123&quot;);\n        //将sql语句加入到批处理包中\n        preparedStatement.addBatch();\n        //当有1000条时，再批量执行\n        if((i + 1) % 1000 == 0) &#123;\n            preparedStatement.executeBatch();\n            //清空语句\n            preparedStatement.clearBatch();\n        &#125;\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;批量处理 耗时时间: &quot; + (end - start));\n    //关闭连接\n    JDBCUtils.close(null, preparedStatement, connection);\n&#125;\n十二、数据库连接池1.提出问题问题：java程序频繁的连接数据库，需要得到多次连接\n传统连接数据库：\n\n多次连接数据库：\n\n传统方式连接mysql5000次代码模拟\njava//连接 mysql 5000 次\npublic void testCon() &#123;\n    //看看连接-关闭 connection 会耗用多久\n    long start = System.currentTimeMillis();\n    System.out.println(&quot;开始连接.....&quot;);\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //使用传统的 jdbc 方式，得到连接\n        Connection connection = JDBCUtils.getConnection();\n        //做一些工作，比如得到 PreparedStatement ，发送 sql\n        //.......... //关闭\n        JDBCUtils.close(null, null, connection);\n    &#125;\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;传统方式 5000 次 耗时=&quot; + (end - start));//传统方式 5000 次 耗时=7099\n    &#125;\n&#125;2.传统获取Connection问题分析\n3.数据库连接池基本介绍\n4.数据库连接池示意图1、当连接被占用时进入等待队列，等待连接可用。如果连接没有被占用，则可以直接获得连接，不需要等待。\n2、放回连接池是指把连接的引用断开，连接对象任然还在。\n\n5.数据库连接池的种类\n\nC3P0数据库连接池1.使用C3P0数据库连接池的准备工作添加jar包并且添加到库里。\n\n2.使用C3P0数据库连接池(代码实现)方式一: 在程序中指定user, url, password等java//方式一: 相关参数，在程序中指定user, url, password等\npublic void testC3P0_01() throws Exception &#123;\n    //1. 创建一个数据源对象\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();\n    //2. 通过配置文件(mysql.properties)获取相关连接的信息\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n    //读取相关属性值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    String diver = properties.getProperty(&quot;diver&quot;);\n\n    //给数据源 comboPooledDataSource 设置相关参数\n    //注意: 连接管理是由 comboPooledDataSource 来管理\n    comboPooledDataSource.setDriverClass(diver);\n    comboPooledDataSource.setJdbcUrl(url);\n    comboPooledDataSource.setUser(user);\n    comboPooledDataSource.setPassword(password);\n\n    //设置初始化连接数\n    comboPooledDataSource.setInitialPoolSize(10);\n    //设置最大连接数\n    comboPooledDataSource.setMaxPoolSize(50);\n    //测试连接池的效率、测试对mysql 5000次操作\n    long start = System.currentTimeMillis(); //开始时间\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //得到连接池的连接\n        Connection connection = comboPooledDataSource.getConnection(); //从DataSource接口实现的连接\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;C3P0 5000次连接mysql耗时: &quot; + (end- start)); //C3P0 5000次连接mysql耗时: 509\n&#125;方式二: 使用配置文件模板来完成1、将C3P0提供的c3p0.config.xml文件拷贝到src目录下\n2、该文件指定了连接数据库和连接池的相关参数\n3、在xml中配置好参数\njava//方式二: 使用配置文件模板来完成\n//1. 将c3p0提供的c3p0.config.xml拷贝到src目录下\n//2. 该文件指定了连接数据库和连接池的相关参数\npublic void testC3P0_02() throws SQLException &#123;\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(&quot;hsp_edu&quot;);\n    long start = System.currentTimeMillis(); //开始时间\n    //测试5000次连接mysql\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //直接连接\n        Connection connection = comboPooledDataSource.getConnection();\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;C3P0方式二 5000次连接mysql耗时: &quot; + (end -start)); //C3P0方式二 5000次连接mysql耗时: 461\n&#125;\nDruid(德鲁伊)数据库连接池1.使用Druid数据库连接池的准备工作1.添加jar包并且添加到库里。 加入配置文件druid.properties文件到src目录下\n2.配置druid.properties的参数\n2.使用Druid数据库连接池(代码实现)javapublic void testDruid() throws Exception &#123;\n    //1. 加入Druid jar包\n    //2. 加入配置文件 druid.properties, 将该文件拷贝项目的src目录\n    //3. 创建Properties对象,读取配置文件\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));\n    //4. 创建一个指定参数的数据库连接池, Druid连接池\n    DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n    long start = System.currentTimeMillis();\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //获取连接\n        Connection connection = dataSource.getConnection();\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;Druid连接池的耗时: &quot; + (end - start)); //Druid连接池的耗时: 603\n&#125;\nApache-DBUtils1.问题提出:1、关闭connection后，resultSet结果集无法使用\n2、resultSet不利于数据的管理\n3、示意图 \n因此将结果集记录封装到ArrayList&lt;&gt;集合中方便数据的管理和使用\n\n2.基本介绍\n3.准备工作略: 引入commons-dbutils-1.3.jar包到libs目录下并添加到库中\n4.代码实现​\t(要确保mysql中设置的类型和Actor类中对象类型保持一致,否则会报错)\n1、查询多行记录(返回ArrayList集合)​\t\t使用的是new BeanListHandler&lt;&gt;(Actor.class)\n​\t\t解读queryRunner.query\n(1) query方法就是执行一个sql语句得到一个resultset –封装到 –&gt; ArrayList集合中(2) 返回集合(3) connection: 连接(4) sql: 执行的sql语句(5) new BeanListHandler&lt;&gt;(Actor.class): 将resultset -取出-&gt; Actor对象 -封装-&gt; ArraryList集合.底层使用反射机制 去获取Actor类的属性,然后封装(6) 1: 就是给sql中的?赋值,可以有多个值(例如1,2,3) 因为是可变参数Object… params(7) 底层得到的resultset,会在query方法关闭,还会关闭PreparedStatement\njava//使用apache-DBUtils工具类 + druid完成对表的crud操作\npublic void testQueryMany() throws SQLException &#123; //返回结果是多行的情况\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 就可以执行相关的方法,返回ArrayList 结果集\n    String sql = &quot;select * from actor where id &gt;= 1&quot;;\n    //解读:\n    //(1) query方法就是执行一个sql语句得到一个resultset --封装到 --&gt; ArrayList集合中\n    //(2) 返回集合\n    //(3) connection: 连接\n    //(4) sql: 执行的sql语句\n    //(5) new BeanListHandler&lt;&gt;(Actor.class): 将resultset -取出-&gt; Actor对象 -封装-&gt; ArraryList集合\n    //    底层使用反射机制 去获取Actor类的属性,然后封装\n    //(6) 1: 就是给sql中的?赋值,可以有多个值(例如1,2,3) 因为是可变参数Object... params\n    //(7) 底层得到的resultset,会在query方法关闭,还会关闭PreparedStatement\n    List&lt;Actor&gt; list =\n            queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(Actor.class));\n    //迭代器遍历\n    System.out.println(&quot;输出集合的信息&quot;);\n    for (Actor actor : list) &#123;\n        System.out.println(actor);\n    &#125;\n    \n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;​\t\t输出结果\ntxt输出集合的信息\nActor&#123;id=1, name=&#39;蘑菇&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;\nActor&#123;id=2, name=&#39;刘德华&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;2、查询单行记录(返回单个对象)​\t\t使用的是new BeanHandler&lt;&gt;(Actor.class) \n​\t\t如果没有查到的话，输出actor返回的是 null\njava//演示apache-dbutils + druid 完成 返回的结果是单行记录(单个对象)\npublic void testQuerySingle() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 执行相关方法,返回单个对象\n    String sql = &quot;select * from actor where id = ?&quot;;\n    //解读:\n    //因为返回的是单行记录&lt;--&gt;单个对象, 使用的是Handler 是BeanHandler\n    Actor actor = queryRunner.query(connection, sql, new BeanHandler&lt;&gt;(Actor.class), 1);\n    System.out.println(actor);\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;​\t\t输出结果\ntxtActor&#123;id=1, name=&#39;蘑菇&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;3、查询单行单列(返回Object)​\t\t使用的是new ScalarHandler()\t输出结果:略\njava//演示apache-dbutils + druid 完成查询结果是单行单列-返回的是object\npublic void testScalar() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 执行相关方法,返回单行单列,返回的是object\n    String sql = &quot;select name from actor where id = ?&quot;;\n    //解读: 因为返回的是一个对象, 使用的handler 是 ScalarHandler\n    Object object = queryRunner.query(connection, sql, new ScalarHandler(), 1);\n    System.out.println(object);\n\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;4、DML语句操作​\t\t使用的是queryRunner.update()\n​\t\t注意事项: “小明”, 1 是用来替换 sql 中的 ? \njava//演示apache-dbutils + druid 完成 dml (update, insert, delete)\npublic void testDML() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n\n    //4. 这里组织sql 完成 updatae, insert, delete(此处只演示update)\n    String sql = &quot;update actor set name = ? where id = ?&quot;;\n    //解读:\n    //(1) 执行dml 操作是queryRunner.update()\n    //(2) 返回的值是受影响的行数\n    int affectedRow = queryRunner.update(connection, sql, &quot;小明&quot;, 1);\n    System.out.println(affectedRow &gt; 0 ? &quot;执行成功&quot; : &quot;执行sql没有影响到表&quot;);\n\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;\n表和JavaBean类型的映射关系\n\nBasicDaoDAO和增删改查的通用方法-BasicDao\n1.问题提出apache-dbutils+Druid简化了JDBC开发，但还有不足:\n1、SQL语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查。\n2、对应select操作，如果有返回值，返回类型不能固定，需要使用泛型。\n3、将来的表很多，业务需求复杂，不可能只靠一个java类完成。\n4、引出&#x3D;》 BasicDAO\n2.简单的BasicDAO示意图\n\n3.基本说明1、DAO: data access object数据访问对象\n2、这样的通用类，称为BasicDao，是专门和数据库交互的，即完成对数据库(表)的crud操作。\n3、在BaiscDao的基础上，实现一张表对应一个Dao，更好的完成功能。(比如Cusromer表-下面是代码演示)\n4.代码实现1、简单设计1.com.dao_.utils &#x2F;&#x2F;工具类\n2.com.dao_.domain &#x2F;&#x2F;javabean\n3.com.dao_.dao &#x2F;&#x2F;存放XxxDAO 和BasicDAO\n4.com.dao_.test &#x2F;&#x2F;写测试类\n2、utils包​\t\t使用了druid数据库连接池\njavapackage com.dao_.utils;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\n/**\n * 基于druid数据库连接池的工具类\n */\npublic class JDBCUtilsByDruid &#123;\n    private static DataSource ds;\n    //在静态代码块完成ds的初始化\n    static &#123;\n        Properties properties = new Properties();\n        try &#123;\n            properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));\n            ds = DruidDataSourceFactory.createDataSource(properties);\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    //编写getConnection方法\n    public static Connection getConnection() throws SQLException &#123;\n        return ds.getConnection();\n    &#125;\n    //关闭连接  在数据库连接池中,close方法不是真正断掉连接\n    // 而是把使用的Connection对象放回连接池\n    public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;\n        try &#123;\n            if(resultSet != null) &#123;\n                resultSet.close();\n            &#125;\n            if(statement != null) &#123;\n                statement.close();\n            &#125;\n            if(connection != null) &#123;\n                connection.close();\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;3、domain包javapackage com.dao_.domain;\n\nimport java.util.Date;\n\n/**\n * Actor对象和actor表的记录对应\n */\npublic class Actor &#123; //Javaben, POJO, Domain对象\n    private Integer id;\n    private String name;\n    private String sex;\n    private Date borndate;\n    private String phone;\n\n    public Actor() &#123; //一定要给一个无参构造器[反射需要]\n    &#125;\n\n    public Actor(Integer id, String name, String sex, Date borndate, String phone) &#123;\n        this.id = id;\n        this.name = name;\n        this.sex = sex;\n        this.borndate = borndate;\n        this.phone = phone;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    public Date getBorndate() &#123;\n        return borndate;\n    &#125;\n\n    public void setBorndate(Date borndate) &#123;\n        this.borndate = borndate;\n    &#125;\n\n    public String getPhone() &#123;\n        return phone;\n    &#125;\n\n    public void setPhone(String phone) &#123;\n        this.phone = phone;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Actor&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, sex=&#39;&quot; + sex + &#39;\\&#39;&#39; +\n                &quot;, borndate=&quot; + borndate +\n                &quot;, phone=&#39;&quot; + phone + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;4、dao包注意: 每个方法中返回不同类型的值所调用的API不同\n​\t\tBasicDAO类: 是其他DAO的父类 \njavapackage com.dao_.dao;\n\nimport com.JDBC.utils.JDBCUtilsByDruid;\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\n/**\n * 开发BasicDAO,是其他DAO的父类\n */\npublic class BasicDAO&lt;T&gt; &#123; //泛型指定具体类型\n    private QueryRunner qr = new QueryRunner();\n    //开发通用dml方法，针对任意的表\n    public int update(String sql, Object... parameters) &#123; //sql语句， 参数\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            //返回受影响的行数\n            int update = qr.update(connection, sql, parameters);\n            return update;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //返回多个对象(即查询的结果是多行),针对任意表\n    /**\n     * @param sql sql语句,可以有?\n     * @param clazz 传入一个类的Class对象,比如Actor.class\n     * @param parameters 传入?的具体的值,可以是多个\n     * @return 根据Actor.class 返回对应的ArrayList集合\n     */\n    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; clazz, Object...parameters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(clazz), parameters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行结果的通用方法\n    public T querySingle(String sql, Class&lt;T&gt; clazz, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(clazz), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行单列的方法,即返回单值的方法\n    public Object queryScaler(String sql, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new ScalarHandler(), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n&#125;​\t\tActorDAO类: 继承BasicDAO类\njavapackage com.dao_.dao;\n\nimport com.dao_.domain.Actor;\n\npublic class ActorDAO extends BasicDAO&lt;Actor&gt; &#123;\n    //1. 继承拥有BasicDAO的方法\n    //2. 根据业务需要，可以编写特有的方法\n&#125;5、testdao包在DAO包底层会自动把连接关闭 JDBCUtilsByDruid.close(null, null, connection);\n​\t\tTestDAO类: 演示如何使用ActorDAO对actor表进行crud操作\njavapackage com.dao_.test;\n\nimport com.dao_.dao.ActorDAO;\nimport com.dao_.domain.Actor;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\npublic class TestDAO &#123;\n    @Test\n    //测试ActorDAO 对actor表的crud操作\n    public void testActorDAO() &#123;\n        ActorDAO actorDAO = new ActorDAO();\n        //1. 查询\n        List&lt;Actor&gt; actors = actorDAO.queryMulti(&quot;select * from actor where id &gt;= ?&quot;, Actor.class, 1);\n        System.out.println(&quot;==查询结果==&quot;);\n        for (Actor actor : actors) &#123;\n            System.out.println(actor);\n        &#125;\n        //2. 查询单行记录\n        Actor actor = actorDAO.querySingle(&quot;select * from actor where id = ?&quot;, Actor.class, 2);\n        System.out.println(&quot;==查询单行结果==&quot;);\n        System.out.println(actor);\n        //3. 查询单行单列\n        Object object = actorDAO.queryScaler(&quot;select name from actor where id = ?&quot;, 1);\n        System.out.println(&quot;==查询单行单列结果==&quot;);\n        System.out.println(object);\n        //4. dml操作 insert,update, delete\n        int update = actorDAO.update(&quot;insert into actor values(null, ?, ?, ?, ?)&quot;, &quot;张飞&quot;, &quot;男&quot;, &quot;2000-11-11&quot;, &quot;9999&quot;);\n        System.out.println(update &gt; 0 ? &quot;执行成功&quot; : &quot;执行没有影响表&quot;);\n    &#125;\n&#125;","slug":"Mysql章节JDBC和数据库连接池","date":"2023-11-23T15:28:20.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"白"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2023-11-21T11:10:22.100Z","categories_index":"","tags_index":"","author_index":"白"}]