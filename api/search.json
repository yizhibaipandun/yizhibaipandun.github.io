[{"id":"792b0f013dc05ca44c4e67ee30010b77","title":"算法-二叉树篇","content":"算法学习_二叉树篇学习至：代码随想录 (programmercarl.com)\n二叉树理论基础篇二叉树的种类在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。\n满二叉树满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。\n如图所示：\n\n这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。\n完全二叉树什么是完全二叉树？\n完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。\n大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。\n我来举一个典型的例子如题：\n\n相信不少同学最后一个二叉树是不是完全二叉树都中招了。\n之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。\n二叉搜索树前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。\n\n若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n它的左、右子树也分别为二叉排序树\n\n下面这两棵树都是搜索树\n\n平衡二叉搜索树平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n如图：\n\n最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。\nC++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。\n所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！\n二叉树的存储方式二叉树可以链式存储，也可以顺序存储。\n那么链式存储方式就用指针， 顺序存储的方式就是用数组。\n顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。\n链式存储如图：\n\n链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？\n其实就是用数组来存储二叉树，顺序存储的方式如图：\n\n用数组来存储二叉树如何遍历的呢？\n如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。\n但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。\n所以大家要了解，用数组依然可以表示二叉树。\n二叉树的遍历方式关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。\n一些同学用做了很多二叉树的题目了，可能知道前中后序遍历，可能知道层序遍历，但是却没有框架。\n我这里把二叉树的几种遍历方式列出来，大家就可以一一串起来了。\n二叉树主要有两种遍历方式：\n\n深度优先遍历：先往深走，遇到叶子节点再往回走。\n广度优先遍历：一层一层的去遍历。\n\n这两种遍历是图论中最基本的两种遍历方式，后面在介绍图论的时候 还会介绍到。\n那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：\n\n深度优先遍历\n前序遍历（递归法，迭代法）\n中序遍历（递归法，迭代法）\n后序遍历（递归法，迭代法）\n\n\n广度优先遍历\n层次遍历（迭代法）\n\n\n\n在深度优先遍历中：有三个顺序，前中后序遍历， 有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。\n这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。\n看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式\n\n前序遍历：中左右\n中序遍历：左中右\n后序遍历：左右中\n\n大家可以对着如下图，看看自己理解的前后中序有没有问题。\n\n最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。\n之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。\n而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。\n\n二叉树的递归遍历本篇将介绍前后中序的递归写法，一些同学可能会感觉很简单，其实不然，我们要通过简单题目把方法论确定下来，有了方法论，后面才能应付复杂的递归。\n这里帮助大家确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！\n\n确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n\n\n144.二叉树的前序遍历(opens new window)\n145.二叉树的后序遍历(opens new window)\n94.二叉树的中序遍历\n\n代码实现\njava// 前序遍历·递归·LC144_二叉树的前序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n        preorder(root, result);\n        return result;\n    &#125;\n    \n    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        result.add(root.val); //中\n        preorder(root.left, result); //左\n        preorder(root.right, result); //右\n    &#125;\n&#125;\n// 中序遍历·递归·LC94_二叉树的中序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        inorder(root, res);\n        return res;\n    &#125;\n\n    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        inorder(root.left, list); //左\n        list.add(root.val);       //中      // 注意这一句\n        inorder(root.right, list); //右\n    &#125;\n&#125;\n// 后序遍历·递归·LC145_二叉树的后序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        postorder(root, res);\n        return res;\n    &#125;\n\n    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        postorder(root.left, list);\t//左\n        postorder(root.right, list); //右\n        list.add(root.val);          //中   // 注意这一句\n    &#125;\n&#125;\n二叉树的迭代遍历144.二叉树的前序遍历(opens new window)\n145.二叉树的后序遍历(opens new window)\n94.二叉树的中序遍历\n前序遍历（迭代法）我们先看一下前序遍历。\n前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。\n为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。\n动画如下：\n\n不难写出如下代码: （注意代码中空节点不入栈）\njavaclass Solution144 &#123;\n    //非递归遍历(迭代遍历)\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        //使用栈存储遍历的节点\n        Stack&lt;TreeNode&gt; stack = new Stack();\n        //使用数组作为返回\n        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();\n        //为空直接返回\n        if(root == null) &#123;\n            return result;\n        &#125;\n        stack.push(root);\n        //前序遍历二叉树\n        while (!stack.isEmpty()) &#123;\n            //获取栈顶结点\n            TreeNode node = stack.pop();\n            result.add(node.val);\n            //将右子树压入栈,出栈的顺序就会变成 中左右\n            if(node.right != null) &#123;\n                stack.push(node.right);\n            &#125;\n            //将左子树压入栈\n            if(node.left != null) &#123;\n                stack.push(node.left);\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;会发现貌似使用迭代法写出前序遍历并不难，确实不难。\n此时是不是想改一点前序遍历代码顺序就把中序遍历搞出来了？\n其实还真不行！\n但接下来，再用迭代法写中序遍历的时候，会发现套路又不一样了，目前的前序遍历的逻辑无法直接应用到中序遍历上。\n中序遍历（迭代法）为了解释清楚，刚刚在迭代的过程中，其实我们有两个操作：\n\n处理：将元素放进result数组中\n访问：遍历节点\n\n分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。\n那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。\n那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。\n动画如下：\n\n中序遍历，可以写出如下代码：\njavaclass Solution94 &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n        if(root == null) &#123;\n            return result;\n        &#125;\n\n        //设置一个临时的节点来遍历子树\n        TreeNode cur = root;\n        //遍历二叉树\n        while (cur != null || !stack.isEmpty()) &#123;\n            //先访问到最底层\n            if (cur != null) &#123;\n                stack.push(cur);\n                cur = cur.left; //左\n            &#125; else &#123;\n                //从栈里弹出的数据就是要处理的数据\n                cur = stack.pop(); //同时将数据从栈移除\n                result.add(cur.val); //中\n                cur = cur.right; //右\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;后序遍历（迭代法）再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：\n\n所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：\njavaclass Solution145 &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        //使用栈存储遍历的节点\n        Stack&lt;TreeNode&gt; stack = new Stack();\n        //使用数组作为返回\n        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();\n        //为空直接返回\n        if(root == null) &#123;\n            return result;\n        &#125;\n        stack.push(root);\n        //前序遍历二叉树\n        while (!stack.isEmpty()) &#123;\n            //获取栈顶结点\n            TreeNode node = stack.pop();\n            result.add(node.val);\n            //将左子树压入栈\n            if(node.left != null) &#123;\n                stack.push(node.left);\n            &#125;\n            //将右子树压入栈\n            if(node.right != null) &#123;\n                stack.push(node.right);\n            &#125;\n        &#125;\n        //反转数组\n        Collections.reverse(result);\n        return result;\n    &#125;\n&#125;\n二叉树的统一迭代法思路\n将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。\n如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法。\n动画(中序遍历)：\n\n动画中，result数组就是最终结果集。可以看出我们将访问的节点直接加入到栈中，但如果是处理的节点则后面放入一个空节点， 这样只有空节点弹出的时候，才将下一个节点放进结果集。\n迭代法前序遍历\njavaclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();\n        Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();\n        if (root != null) st.push(root);\n        while (!st.empty()) &#123;\n            TreeNode node = st.peek();\n            if (node != null) &#123;\n                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中\n                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）\n                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）\n                \n                st.push(node);                          // 添加中节点\n                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n                \n            &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集\n                st.pop();           // 将空节点弹出\n                node = st.peek();    // 重新取出栈中元素\n                st.pop();\n                result.add(node.val); // 加入到结果集\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;迭代法中序遍历\njavaclass Solution &#123;\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();\n        Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();\n        if (root != null) st.push(root);\n        while (!st.empty()) &#123;\n            TreeNode node = st.peek();\n            if (node != null) &#123;\n                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中\n                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）\n                \n                st.push(node);                          // 添加中节点\n                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n\n                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）\n            &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集\n                st.pop();           // 将空节点弹出\n                node = st.peek();    // 重新取出栈中元素\n                st.pop();\n                result.add(node.val); // 加入到结果集\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;迭代法后序遍历\njavaclass Solution &#123;\n   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();\n        Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();\n        if (root != null) st.push(root);\n        while (!st.empty()) &#123;\n            TreeNode node = st.peek();\n            if (node != null) &#123;\n                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中\n                st.push(node);                          // 添加中节点\n                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。\n                \n                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）\n                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）         \n                               \n            &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集\n                st.pop();           // 将空节点弹出\n                node = st.peek();    // 重新取出栈中元素\n                st.pop();\n                result.add(node.val); // 加入到结果集\n            &#125;\n        &#125;\n        return result;\n   &#125;\n&#125;\n二叉树层序遍历\n102.二叉树的层序遍历(opens new window)\n107.二叉树的层次遍历II(opens new window)\n199.二叉树的右视图(opens new window)\n637.二叉树的层平均值(opens new window)\n429.N叉树的层序遍历(opens new window)\n515.在每个树行中找最大值(opens new window)\n116.填充每个节点的下一个右侧节点指针(opens new window)\n117.填充每个节点的下一个右侧节点指针II(opens new window)\n104.二叉树的最大深度(opens new window)\n111.二叉树的最小深度\n\n二叉树的层序遍历102. 二叉树的层序遍历 - 力扣（LeetCode）\n题目\n给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n示例 1：\n\ntxt输入：root = [3,9,20,null,null,15,7]\n输出：[[3],[9,20],[15,7]]示例 2：\ntxt输入：root = [1]\n输出：[[1]]示例 3：\ntxt输入：root = []\n输出：[]思路\n需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。\n而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。\n使用队列实现二叉树广度优先遍历，动画如下：\n\n这样就实现了层序从左到右遍历二叉树。\nDFS–递归方式\n\n记录当前层数 deep++;\n构建当前层的第一维数组，根据层数加入对应的第一维数组中。 resList.get(deep - 1).add(node.val);\n递归左右子树，并且同时传入他们当前所在层数。\n\njavaclass Solution102 &#123;\n    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    \n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        //DFS递归遍历法\n        checkFun01(root, 0);\n        //BFS迭代遍历-借助队列\n        //checkFun02(root);\n\n        return resList;\n    &#125;\n    //DFS--递归方式\n    public void checkFun01(TreeNode node, Integer deep) &#123;\n        //叶子结点直接返回\n        if (node == null) return;\n\n        //当前层数\n        deep++;\n\n        //构建当前层的数组\n        if (resList.size() &lt; deep) &#123;\n            //当层级增加时，list的Item也会增加，利用list索引值进行层级界定\n            List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;();\n            resList.add(item);\n        &#125;\n        //记录层序遍历的元素\n        resList.get(deep - 1).add(node.val);\n        //访问左右子树\n        checkFun01(node.left, deep);\n        checkFun01(node.right, deep);\n    &#125;\n&#125;BFS–迭代方式–借助队列\n对于层序遍历，使用队列先进先出即可完成\n\n先获取二叉树的根节点\n设置一个数组用来记录每一层的元素\n获取队列长度，用于遍历每一层。\n在遍历当前层的时候，用数组记录元素，同时添加他们的左右子结点。\n遍历完当前层就把数组添加到resList中。\n\njavaclass Solution102 &#123;\n\n    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        //DFS递归遍历法\n        //checkFun01(root, 0);\n        //BFS迭代遍历-借助队列\n        checkFun02(root);\n\n        return resList;\n    &#125;\n    \n    //BFS--迭代方式--借助队列\n    public void checkFun02(TreeNode node) &#123;\n        if(node == null) return;\n\n        //队列先进先出符合一层一层遍历的逻辑\n        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();\n        que.offer(node);\n\n        while (!que.isEmpty()) &#123;\n            //创建存储每一层元素的数组\n            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n            //记录当前层长度\n            int len = que.size();\n\n            //添加当前层的元素到队列,然后添加到resList中\n            while (len &gt; 0) &#123;\n                TreeNode temp = que.poll();\n                list.add(temp.val);\n\n                //添加左右子树到队列\n                if(temp.left != null) que.offer(temp.left);\n                if(temp.right != null) que.offer(temp.right);\n\n                len--;\n            &#125;\n            //添加每一层数组到resList\n            resList.add(list);\n        &#125;\n    &#125;\n&#125;二叉树的层次遍历 II107. 二叉树的层序遍历 II - 力扣（LeetCode）\n相对于102.二叉树的层序遍历，就是最后把result数组反转一下就可以了。\njavaclass Solution &#123;\n    //作为返回的数组\n    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;&gt;();\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;\n        checkFun02(root);\n        //反转数组\n        Collections.reverse(resList);\n        return resList;\n    &#125;\n\n    //BFS--递归方式--借助队列\n    public void checkFun02(TreeNode node) &#123;\n        if(node == null) return;\n\n        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();\n        que.offer(node);\n\n        //遍历队列\n        while (!que.isEmpty()) &#123;\n            //记录当前层所含元素个数\n            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n            int len = que.size();\n\n            //添加当前层的元素到队列,然后添加到resList中\n            while (len &gt; 0) &#123;\n                TreeNode temp = que.poll();\n                list.add(temp.val);\n\n                //添加左右子树到队列\n                if(temp.left != null) que.offer(temp.left);\n                if(temp.right != null) que.offer(temp.right);\n\n                len--;\n            &#125;\n            resList.add(list);\n        &#125;\n    &#125;\n&#125;二叉树的右视图199. 二叉树的右视图 - 力扣（LeetCode）\n题目\n给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n示例 1:\n\ntxt输入: [1,2,3,null,5,null,4]\n输出: [1,3,4]示例 2:\ntxt输入: [1,null,3]\n输出: [1,3]示例 3:\ntxt输入: []\n输出: [] 思路\n层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。\njavaclass Solution199 &#123;\n    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;\n        //层序遍历,每次判断是否遍历到单层的最后面的元素,是就加入到数组\n        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        //借助队列进行层序遍历,BFS\n        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();\n\n        if(root == null) return list;\n\n        que.offer(root);\n        while (!que.isEmpty()) &#123;\n            //获取当前层长度\n            int len = que.size();\n\n            //遍历层\n            while (len &gt; 0) &#123;\n                //从队列取出元素\n                TreeNode temp = que.poll();\n\n                //只有遍历到最后面元素才加入数组\n                if(len == 1) &#123;\n                    list.add(temp.val);\n                &#125;\n\n                //添加左右子树\n                if(temp.left != null) que.offer(temp.left);\n                if(temp.right != null) que.offer(temp.right);\n\n                len--;\n            &#125;\n        &#125;\n        return list;\n    &#125;\n&#125;二叉树的层平均值637. 二叉树的层平均值 - 力扣（LeetCode）\n题目\n给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。\n示例 1：\n\ntxt输入：root = [3,9,20,null,null,15,7]\n输出：[3.00000,14.50000,11.00000]\n解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。\n因此返回 [3, 14.5, 11] 。示例 2:\n\ntxt输入：root = [3,9,20,15,7]\n输出：[3.00000,14.50000,11.00000]思路\n本题就是层序遍历的时候把一层求个总和在取一个均值。\njavaclass Solution &#123;\n    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;\n        List&lt;Double&gt; list = new ArrayList&lt;&gt;();\n        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();\n\n        if(root == null) return list;\n\n        que.offer(root);\n        while (!que.isEmpty()) &#123;\n            double sum = 0;\n            int len1 = que.size();\n            int len2 = len1;\n\n            while (len1 &gt; 0) &#123;\n                TreeNode temp = que.poll();\n                //统计总数\n                sum += temp.val;\n\n                //添加左右子树\n                if(temp.left != null) que.offer(temp.left);\n                if(temp.right != null) que.offer(temp.right);\n\n                len1--;\n            &#125;\n\n            list.add(sum/len2);\n        &#125;\n        return list;\n    &#125;\n&#125;N叉树的层序遍历429. N 叉树的层序遍历 - 力扣（LeetCode）\n题目\n给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。\n树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n示例 1：\n\ntxt输入：root = [1,null,3,2,4,null,5,6]\n输出：[[1],[3,2,4],[5,6]]示例 2：\n\ntxt输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] 思路\n这道题依旧是模板题，只不过一个节点有多个孩子了\n代码实现\njavaclass Solution429 &#123;\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;\n        List&lt;List&lt;Integer&gt;&gt; reslist = new ArrayList&lt;&gt;();\n        Deque&lt;Node&gt; que = new LinkedList&lt;&gt;();\n\n        if(root == null) return reslist;\n\n        que.offerLast(root);\n        while (!que.isEmpty()) &#123;\n            //记录每一层数据的数组\n            List&lt;Integer&gt; levellist = new ArrayList&lt;&gt;();\n            int len = que.size();\n\n            for(int i = 0; i &lt; len; i++) &#123;\n                Node t = que.poll();\n\n                levellist.add(t.val);\n\n                List&lt;Node&gt; children = t.children;\n                if (children == null || children.size() == 0) &#123;\n                    continue;\n                &#125;\n                //添加子结点到队列\n                for (Node child :children) &#123;\n                    if(child != null) &#123;\n                        que.offerLast(child);\n                    &#125;\n                &#125;\n                len--;\n            &#125;\n            reslist.add(levellist);\n        &#125;\n        return reslist;\n    &#125;\n&#125;在每个树行中找最大值","slug":"算法-二叉树","date":"2024-04-03T16:00:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"白"},{"id":"be859635f151ca20a3e77438b59e35bf","title":"SpringMVC篇","content":"SpringMVC学习笔记使用到的知识\n\nJavaSE\nHTML+CSS+JavaScript\nVue\nAJAX + axios\nThymeleaf\nServlet\nMaven\nSpring\n\n一、SpringMVC简介1、什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分\nM ：Model，模型层，指工程中的JavaBean，作用是处理数据\nJavaBean分为两类：\n\n一类称为实体类Bean：专门存储业务数据的，如 Student、User 等\n一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。\n\nV ：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据\nC ：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器\n应用为什么要被分为三块，优点是什么？\n\n低耦合，扩展能力增强\n代码复用性增强\n代码可维护性增强\n高内聚，让程序员更加专注业务的开发\n\nMVC将应用分为三块，每一块各司其职，都有自己专注的事情要做，他们属于分工协作，互相配合：\n\nModel ：负责业务处理及数据的收集。\nView ：负责数据的展示\nController ：负责调度。它是一个调度中心，它来决定什么时候调用Model来处理业务，什么时候调用View视图来展示数据。\n\nMVC架构模式如下所示：\n\n面试题：什么是三层模型，并说一说MVC架构模式与三层模型的区别？\n\n\n\n\n\n\n\n\n\n三层模型\n\n\n答：\n\nMVC 和三层模型都采用了分层结构来设计应用程序，都是降低耦合度，提高扩展力，提高组件复用性。区别在于：他们的关注点不同，三层模型更加关注业务逻辑组件的划分。\nMVC架构模式关注的是整个应用程序的层次关系和分离思想。现代的开发方式大部分都是MVC架构模式结合三层模型一起用。\n\n2、什么是SpringMVCSpringMVC概述SpringMVC是一个实现了MVC架构模式的Web框架，底层基于Servlet实现。SpringMVC已经将MVC架构模式实现了，因此只要我们是基于SpringMVC框架写代码，编写的程序就是符合MVC架构模式的。（MVC的架子搭好了，我们只需要添添补补）Spring框架中有一个子项目叫做Spring Web，Spring Web子项目当中包含很多模块，例如：\n\nSpring MVC\nSpring WebFlux\nSpring Web Services\nSpring Web Flow\nSpring WebSocket\nSpring Web Services Client\n\n可见 SpringMVC是Spring Web子项目当中的一个模块。因此也可以说SpringMVC是Spring框架的一部分。所以学习SpringMVC框架之前要先学习Spring框架中的IoC和AOP等内容。另外，使用SpringMVC框架的时候同样也可以使用IoC和AOP。以下就是Spring官方给出的Spring架构图，其中Web中的servlet指的就是Spring MVC：\n\nSpringMVC帮我们做了什么SpringMVC框架帮我们做了什么，与纯粹的Servlet开发有什么区别？\n\n入口控制 ：SpringMVC框架通过DispatcherServlet作为入口控制器，负责接收请求和分发请求。而在Servlet开发中，需要自己编写Servlet程序，并在web.xml中进行配置，才能接受和处理请求。 \n在SpringMVC中，表单提交时可以自动将表单数据绑定到相应的JavaBean对象中，只需要在控制器方法的参数列表中声明该JavaBean对象即可，无需手动获取和赋值表单数据。而在纯粹的Servlet开发中，这些都是需要自己手动完成的。\nIoC容器 ：SpringMVC框架通过IoC容器管理对象，只需要在配置文件中进行相应的配置即可获取实例对象，而在Servlet开发中需要手动创建对象实例。 \n统一处理请求 ：SpringMVC框架提供了拦截器、异常处理器等统一处理请求的机制，并且可以灵活地配置这些处理器。而在Servlet开发中，需要自行编写过滤器、异常处理器等，增加了代码的复杂度和开发难度。 \n视图解析 ：SpringMVC框架提供了多种视图模板，如JSP、Freemarker、Velocity等，并且支持国际化、主题等特性。而在Servlet开发中需要手动处理视图层，增加了代码的复杂度。\n\n总之，与Servlet开发相比，SpringMVC框架可以帮我们节省很多时间和精力，减少代码的复杂度，更加专注于业务开发。同时，也提供了更多的功能和扩展性，可以更好地满足企业级应用的开发需求。\n3、SpringMVC框架的特点\n轻量级 ：相对于其他Web框架，Spring MVC框架比较小巧轻便。（只有几个几百KB左右的Jar包文件） \n模块化 ：请求处理过程被分成多个模块，以模块化的方式进行处理。 \n控制器模块：Controller\n业务逻辑模块：Model\n视图模块：View\n\n\n依赖注入 ：Spring MVC框架利用Spring框架的依赖注入功能实现对象的管理，实现松散耦合。 \n易于扩展 ：提供了很多口子，允许开发者根据需要插入自己的代码，以扩展实现应用程序的特殊需求。 \nSpring MVC框架允许开发人员通过自定义模块和组件来扩展和增强框架的功能。\nSpring MVC框架与其他Spring框架及第三方框架集成得非常紧密，这使得开发人员可以非常方便地集成其他框架，以获得更好的功能。\n\n\n易于测试 ：支持单元测试框架，提高代码质量和可维护性。 （对SpringMVC中的Controller测试时，不需要依靠Web服务器。）\n自动化配置 ：提供自动化配置，减少配置细节。 \nSpring MVC框架基于约定大于配置的原则，对常用的配置约定进行自动化配置。\n\n\n灵活性 ：Spring MVC框架支持多种视图技术，如JSP、FreeMarker、Thymeleaf、FreeMarker等，针对不同的视图配置不同的视图解析器即可。\n\n学习springMVC使用版本如下\n\nJDK版本：Java21\nMaven版本：3.9.6\nTomcat版本：10\nSpring版本：6.1.4\nSpringMVC版本：6.1.4\nIDEA版本：2023.3\nThymeleaf版本：3.1.2\n\n\n二、快速入门SpringMVC第一个SpringMVC程序SpringMVC开发流程\n\n\n\n\n\n\n\n\n\n1、创建Maven模块\n\n创建一个空的工程springmvc\n设置JDK版本\n设置Maven\n创建Maven模块\n在pom文件中设置打包方式：war\n引入依赖\nspringmvc依赖\nlogback依赖\nthymeleaf和spring6整合依赖\nservlet依赖(设置为provided，表示这个依赖最终由第三方容器来提供)\n\n\n\n\n\n\n\n\n\n\n\n\n2、给Maven模块添加web支持\n\n给模块下的src\\main目录下新建webapp目录（默认是带有小蓝点的，如果没有添加Web支持）在添加web支持的时候，需要添加web.xml文件，注意添加的路径。\n\n\n\n\n\n\n\n\n\n\n3、在web.xml文件中配置\n在web.xml文件中配置前端控制器(SpringMVC框架内置的一个类：DIspatcherServlet)，所有请求都应该经过这个DispatcherServlet的处理。\n\n重点：&lt;url-pattern&gt;/&lt;/url-pattern&gt;\n这里的/表示：除xx.jsp结尾的请求路径之外的所有请求路径。\n也就是说，只要不是JSP请求路径，一定会走DIspatcherServlet\n\n\n\n\n\n\n\n\n\n\n4、编写FirstController\n\n在类上标注@Controller注解，纳入IOC容器管理。\n也可以采用@Component注解进行标注。\n@Controller只是@Component注解的别名。\n\n\n\n\n\n\n\n\n\n\n5、配置&#x2F;编写 SpringMVC框架自己的配置文件\n\n这个配置文件有默认的名字：&lt;servlet-name&gt;-servlet.xml\n这个配置文件有默认的存放位置：WEB-INF目录下\n\n\n\n\n\n\n\n\n\n\n6、提供视图\n\n在&#x2F;WEB-INF&#x2F;templates目录下新建first.thymeleaf文件\n在该文件中编写符合Thymeleaf语法格式的字符串（编写Thymeleaf的模板语句）\n\n\n\n\n\n\n\n\n\n\n7、提供请求映射\njava@RequestMapping(&quot;/test&quot;)\npublic String hehe()&#123;\n    //处理业务逻辑\n    //返回一个逻辑视图名称\n    return &quot;first&quot;;\n&#125;\n最终会将逻辑视图名称转换为物理视图名称\n逻辑视图名称：first\n物理视图名称：前掇 + first + 后缀\n最终路径是：/WEB-INF/templates/first.thymeleaf\n\n使用Thymeleaf模板引擎，将/WEB-INF/templates/first.thymeleaf转换成htmL代码，最终响应给浏览器。\n创建Maven模块第一步：创建Empty Project，起名：springmvc。\n\n第二步：设置springmvc工程的JDK版本：Java21。\n\n第三步：设置maven。\n\n第四步：创建Maven模块\n\n\n第五步：将pom.xml文件中的打包方式修改为war\nxml&lt;groupId&gt;com.powernode.springmvc&lt;/groupId&gt;\n&lt;artifactId&gt;springmvc-001&lt;/artifactId&gt;\n&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;!-- 打包方式设置为war方式 --&gt;\n&lt;packaging&gt;war&lt;/packaging&gt;第六步：添加以下依赖\nxml&lt;dependencies&gt;\n    &lt;!-- Spring MVC依赖 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n        &lt;version&gt;6.1.4&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!--日志框架Logback依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n        &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n        &lt;version&gt;1.5.3&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!--Servlet依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;\n        &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;\n        &lt;version&gt;6.0.0&lt;/version&gt;\n        &lt;scope&gt;provided&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;!--Spring6和Thymeleaf整合依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;\n        &lt;artifactId&gt;thymeleaf-spring6&lt;/artifactId&gt;\n        &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;添加web支持第一步：在main目录下创建一个webapp目录\n\n第二步：添加web.xml配置文件\n\n注意 web.xml 文件的位置：E:\\Spring MVC\\code\\springmvc\\springmvc-001\\src\\main\\webapp\\WEB-INF\\web.xml注意版本选择：6.0\n\n添加web支持后的目录结构：\n\n配置web.xml文件Spring MVC是一个web框架，在javaweb中谁来负责接收请求，处理请求，以及响应呢？当然是Servlet。在SpringMVC框架中已经为我们写好了一个Servlet，它的名字叫做：DispatcherServlet，我们称其为前端控制器。既然是Servlet，那么它就需要在web.xml文件中进行配置：\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&quot;\n         version=&quot;6.0&quot;&gt;\n\n    &lt;!--SpringMVC提供的前端控制器--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n        &lt;!-- /* 表示任何一个请求都交给DispatcherServlet来处理 --&gt;\n        &lt;!-- / 表示当请求不是xx.jsp的时候，DispatcherServlet来负责处理本次请求--&gt;\n        &lt;!-- jsp本质就是Servlet，因此如果请求是jsp的话，应该走它自己的Servlet，而不应该走DispatcherServlet --&gt;\n        &lt;!-- 因此我们的 url-pattern 使用 / --&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;DispatcherServlet是SpringMVC框架为我们提供的最核心的类，它是整个SpringMVC框架的前端控制器，负责接收HTTP请求、将请求路由到处理程序、处理响应信息，最终将响应返回给客户端。DispatcherServlet是Web应用程序的主要入口点之一，它的职责包括：\n\n接收客户端的HTTP请求：DispatcherServlet监听来自Web浏览器的HTTP请求，然后根据请求的URL将请求数据解析为Request对象。 \n处理请求的URL：DispatcherServlet将请求的URL（Uniform Resource Locator）与处理程序进行匹配，确定要调用哪个控制器（Controller）来处理此请求。 \n调用相应的控制器：DispatcherServlet将请求发送给找到的控制器处理，控制器将执行业务逻辑，然后返回一个模型对象（Model）。 \n渲染视图：DispatcherServlet将调用视图引擎，将模型对象呈现为用户可以查看的HTML页面。 \n返回响应给客户端：DispatcherServlet将为用户生成的响应发送回浏览器，响应可以包括表单、JSON、XML、HTML以及其它类型的数据\n\n编写控制器FirstControllerDispatcherServlet接收到请求之后，会根据请求路径分发到对应的Controller，Controller来负责处理请求的核心业务。在SpringMVC框架中Controller是一个普通的Java类（一个普通的POJO类，不需要继承任何类或实现任何接口），需要注意的是：POJO类要纳入IoC容器来管理，POJO类的生命周期由Spring来管理，因此要使用注解标注：\njavapackage com.powernode.springmvc.controller;\n\nimport org.springframework.stereotype.Controller;\n\n@Controller\npublic class FirstController &#123;\n&#125;\n配置springmvc-servlet.xml文件SpringMVC框架有它自己的配置文件，该配置文件的名字默认为：&lt;servlet-name&gt;-servlet.xml，默认存放的位置是WEB-INF 目录下：\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n    &lt;!--组件扫描--&gt;\n    &lt;context:component-scan base-package=&quot;com.powernode.springmvc.controller&quot;/&gt;\n    &lt;!--视图解析器--&gt;\n    &lt;bean id=&quot;thymeleafViewResolver&quot; class=&quot;org.thymeleaf.spring6.view.ThymeleafViewResolver&quot;&gt;\n        &lt;!--作用于视图渲染的过程中，可以设置视图渲染后输出时采用的编码字符集--&gt;\n        &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;\n        &lt;!--如果配置多个视图解析器，它来决定优先使用哪个视图解析器，它的值越小优先级越高--&gt;\n        &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;\n        &lt;!--当 ThymeleafViewResolver 渲染模板时，会使用该模板引擎来解析、编译和渲染模板--&gt;\n        &lt;property name=&quot;templateEngine&quot;&gt;\n            &lt;bean class=&quot;org.thymeleaf.spring6.SpringTemplateEngine&quot;&gt;\n                &lt;!--用于指定 Thymeleaf 模板引擎使用的模板解析器。模板解析器负责根据模板位置、模板资源名称、文件编码等信息，加载模板并对其进行解析--&gt;\n                &lt;property name=&quot;templateResolver&quot;&gt;\n                    &lt;bean class=&quot;org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver&quot;&gt;\n                        &lt;!--设置模板文件的位置（前缀）--&gt;\n                        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;\n                        &lt;!--设置模板文件后缀（后缀），Thymeleaf文件扩展名不一定是html，也可以是其他，例如txt，大部分都是html--&gt;\n                        &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt;\n                        &lt;!--设置模板类型，例如：HTML,TEXT,JAVASCRIPT,CSS等--&gt;\n                        &lt;property name=&quot;templateMode&quot; value=&quot;HTML&quot;/&gt;\n                        &lt;!--用于模板文件在读取和解析过程中采用的编码字符集--&gt;\n                        &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;\n                    &lt;/bean&gt;\n                &lt;/property&gt;\n            &lt;/bean&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;在WEB-INF目录下新建springmvc-servlet.xml文件，并且提供以上配置信息。\n\n以上配置主要两项：\n\n第一项：组件扫描。spring扫描这个包中的类，将这个包中的类实例化并纳入IoC容器的管理。\n第二项：视图解析器。视图解析器（View Resolver）的作用主要是将Controller方法返回的逻辑视图名称解析成实际的视图对象。视图解析器将解析出的视图对象返回给DispatcherServlet，并最终由DispatcherServlet将该视图对象转化为响应结果，呈现给用户。\n\n注意：如果采用了其它视图，请配置对应的视图解析器，例如：\n\nJSP的视图解析器：InternalResourceViewResolver\nFreeMarker视图解析器：FreeMarkerViewResolver\nVelocity视图解析器：VelocityViewResolver\n\n提供视图在WEB-INF目录下新建templates目录，在templates目录中新建html文件，例如：first.html，并提供以下代码：\nhtml&lt;!DOCTYPE html&gt;\n&lt;!--指定 th 命名空间，让 Thymeleaf 标准表达式可以被解析和执行--&gt;\n&lt;!--th不是固定的，可以指定其它的命名空间，只不过大部分情况下用th--&gt;\n&lt;!--表示程序中出现的 th 开头的后面代码都是 Thymeleaf语法，需要被 Thymeleaf识别--&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;first springmvc&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;我的第一个Spring MVC程序&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;对于每一个Thymeleaf文件来说 xmlns:th=&quot;http://www.thymeleaf.org&quot; 是必须要写的，为了方便后续开发，可以将其添加到html模板文件中：\n\n控制器FirstController处理请求返回逻辑视图名称javapackage com.powernode.springmvc.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class FirstController &#123;\n    //请求映射\n    //该方法是一个实例方法\n    //这个方法目前返回一个String字符串\n    //返回值代表一个逻辑视图名称\n    @RequestMapping(value=&quot;/haha&quot;)\n    public String 名字随意()&#123;\n        System.out.println(&quot;正在处理请求....&quot;);\n        // 返回逻辑视图名称（决定跳转到哪个页面）\n        return &quot;first&quot;;\n    &#125;\n&#125;测试\n第一步：配置Tomcat服务器\n\n第二步：部署web模块到Tomcat服务器\n\n第三步：启动Tomcat服务器。如果在控制台输出的信息有中文乱码，请修改tomcat服务器配置文件：apache-tomcat-10.1.19\\conf\\logging.properties\n\n第四步：打开浏览器，在浏览器地址栏上输入地址：http://localhost:8080/springmvc/haha\n\n后端控制台输出：\n\n执行流程总结\n浏览器发送请求：http://localhost:8080/springmvc/haha\nSpringMVC的前端控制器DispatcherServlet接收到请求\nDispatcherServlet根据请求路径 &#x2F;haha 映射到 FirstController#名字随意()，调用该方法\nFirstController#名字随意() 处理请求\nFirstController#名字随意() 返回逻辑视图名称 first 给视图解析器\n视图解析器找到 &#x2F;WEB-INF&#x2F;templates&#x2F;first.html 文件，并进行解析，生成视图解析对象返回给前端控制器DispatcherServlet\n前端控制器DispatcherServlet响应结果到浏览器。\n\n一个Controller可以编写多个方法一个Controller可以提供多个方法，每个方法通常是处理对应的请求，例如：\njava@Controller\npublic class FirstController &#123;\n    @RequestMapping(value=&quot;/haha&quot;)\n    public String 名字随意()&#123;\n        System.out.println(&quot;正在处理请求....&quot;);\n        // 返回逻辑视图名称（决定跳转到哪个页面）\n        return &quot;first&quot;;\n    &#125;\n    \n    @RequestMapping(&quot;/other&quot;)\n    public String other()&#123;\n        System.out.println(&quot;正在处理其它请求...&quot;);\n        return &quot;other&quot;;\n    &#125;\n&#125;提供 other.html 文件\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;other&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;other ...&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;在 first.html 文件中，添加超链接，用超链接发送 &#x2F;other 请求：\nhtml&lt;!DOCTYPE html&gt;\n&lt;!--指定 th 命名空间，让 Thymeleaf 标准表达式可以被解析和执行--&gt;\n&lt;!--th不是固定的，可以指定其它的命名空间，只不过大部分情况下用th--&gt;\n&lt;!--表示程序中出现的 th 开头的后面代码都是 Thymeleaf语法，需要被 Thymeleaf识别--&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;first springmvc&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;我的第一个Spring MVC程序&lt;/h1&gt;\n&lt;!-- th: 表示后面的代码可以编写Thymeleaf语法，可以被Thymeleaf语法解析 --&gt;\n&lt;!-- Thymeleaf检测到以 / 开始，表示绝对路径，自动会将webapp的上下文路径加上去 --&gt;\n&lt;!-- 最终的效果是：href=&quot;/springmvc/other&quot; --&gt;\n&lt;a th:href=&quot;@&#123;/other&#125;&quot;&gt;other请求&lt;/a&gt;\n&lt;/body&gt;\n&lt;/html&gt;启动Tomcat，打开浏览器，输入请求路径：http://localhost:8080/springmvc/haha\n\n点击超链接：other请求\n\n\n\n\n\n\n\n\n\n\nSpringMVC中的配置文件，名字是可以指定的，位置也是可以指定的。\nxml&lt;!--设置DispatcherServlet的初始化参数--&gt;\n&lt;init-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;!--指定了Spring MVC配置文件的名字是：springmvc.xml--&gt;\n    &lt;!--指定了Spring MVC配置文件存放的路径是：类的根路径--&gt;\n    &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;\n&lt;/init-param&gt; 建议在web服务器启动时，初始化DispatcherServlet，这样用户第一次发送请求时，效率较高。\nxml&lt;load-on-startup&gt;0&lt;/load-on-startup&gt;\n三、RequestMapping注解1、RequestMapping的作用@RequestMapping 注解是 Spring MVC 框架中的一个控制器映射注解，用于将请求映射到相应的处理方法上。具体来说，它可以将指定 URL 的请求绑定到一个特定的方法或类上，从而实现对请求的处理和响应。\n2、RequestMapping的出现位置通过RequestMapping的源码可以看到RequestMapping注解只能出现在类上或者方法上。\n\n3、类上与方法上结合使用\n\n\n\n\n\n\n\n\n笔记\n@RequestMapping注解可以出现在类上，也可以出现在方法上，例如：\n前端浏览器发送的请求路径是/a/b时，则执行UserController#index()方法。\njava@Controller\n@RequestMapping(&quot;/a&quot;)\npublic class UserController&#123;\n    @RequestMapping(&quot;/b&quot;)\n    public String index()&#123;\n        return &quot;index&quot;;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n正文\n我们先来看，在同一个web应用中，是否可以有两个完全一样的RequestMapping。测试一下：假设两个RequestMapping，其中一个是展示用户详细信息，另一个是展示商品详细信息。提供两个Controller，一个是UserController，另一个是ProductController。如下：\njavapackage com.powernode.springmvc.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class UserController &#123;\n    @RequestMapping(&quot;/detail&quot;)\n    public String toDetail()&#123;\n        return &quot;detail&quot;;\n    &#125;\n&#125;\njavapackage com.powernode.springmvc.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class ProductController &#123;\n    @RequestMapping(&quot;/detail&quot;)\n    public String toDetail()&#123;\n        return &quot;detail&quot;;\n    &#125;\n&#125;\n以上两个Controller的RequestMapping相同，都是”&#x2F;detail”，我们来启动服务器看会不会出现问题：异常发生了，异常信息如下\njavaorg.springframework.beans.factory.BeanCreationException: \nError creating bean with name &#39;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&#39;: \nAmbiguous mapping. Cannot map &#39;userController&#39; method \ncom.powernode.springmvc.controller.UserController#toDetail()\nto &#123; [/detail]&#125;: There is already &#39;productController&#39; bean method\ncom.powernode.springmvc.controller.ProductController#toDetail() mapped.以上异常信息大致的意思是：不明确的映射。无法映射UserController中的toDetail()方法，因为已经在ProductController中映射过了！！！！通过测试得知，在同一个webapp中，RequestMapping必须具有唯一性。怎么解决以上问题？两种解决方案：\n\n第一种方案：将方法上RequestMapping的映射路径修改的不一样。\n第二种方案：在类上添加RequestMapping的映射路径，以类上的RequestMapping作为命名空间，来加以区分两个不同的映射。\n\n第一种方案将方法上RequestMapping的映射路径修改的不一样。\njava@RequestMapping(&quot;/user/detail&quot;)\npublic String toDetail()&#123;\n    return &quot;/user/detail&quot;;\n&#125;java@RequestMapping(&quot;/product/detail&quot;)\npublic String toDetail()&#123;\n    return &quot;/product/detail&quot;;\n&#125;再次启动web服务器，会发现没有再报错了。为这两个请求分别提供对应的视图页面：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;商品详情页面&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;商品详情&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;html&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;用户详情页面&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;用户详情&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;在首页面添加两个超链接：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;index page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;index page&lt;/h1&gt;\n&lt;a th:href=&quot;@&#123;/user/detail&#125;&quot;&gt;用户详情&lt;/a&gt;&lt;br&gt;\n&lt;a th:href=&quot;@&#123;/product/detail&#125;&quot;&gt;商品详情&lt;/a&gt;&lt;br&gt;\n&lt;/body&gt;\n&lt;/html&gt;启动Tomcat服务器，并测试：http://localhost:8080/springmvc/点击用户详情，点击商品详情，都可以正常显示：\n第二种方案在类上和方法上都使用RequestMapping注解来进行路径的映射。假设在类上映射的路径是”&#x2F;a”，在方法上映射的路径是”&#x2F;b”，那么整体表示映射的路径就是：”&#x2F;a&#x2F;b”在第一种方案中，假设UserController类中有很多方法，每个方法的 RequestMapping注解中都需要以”&#x2F;user”开始，显然比较啰嗦，干脆将”&#x2F;user”提升到类级别上，例如：\njavapackage com.powernode.springmvc.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\n@RequestMapping(&quot;/user&quot;)\npublic class UserController &#123;\n    @RequestMapping(&quot;/detail&quot;)\n    public String toDetail()&#123;\n        return &quot;/user/detail&quot;;\n    &#125;\n&#125;\njavapackage com.powernode.springmvc.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\n@RequestMapping(&quot;/product&quot;)\npublic class ProductController &#123;\n    @RequestMapping(&quot;/detail&quot;)\n    public String toDetail()&#123;\n        return &quot;/product/detail&quot;;\n    &#125;\n&#125;\n经过测试，程序可以正常执行！！！\n4、value属性value属性的使用\n\n\n\n\n\n\n\n\n笔记\n关于@RequestMapping注解的valuel属性\n\nvalue属性本身是一个String[]字符串数组，说明多个请求路径可以映射同一个处理器方法\n如果注解的属性是数组，并且在使用注解的时候，该数组中只有一个元素，大括号可以省略。\n如果使用某个注解的时候，如果只使用了一个valve,属性，那么valve也是可以省路的。 \nvalve,属性的别名是path。\npath属性的别名是valve。\n\n\n\n\n\n\n\n\n\n\n正文\nvalue属性是该注解最核心的属性，value属性填写的是请求路径，也就是说通过该请求路径与对应的控制器的方法绑定在一起。另外通过源码可以看到value属性是一个字符串数组：既然是数组，就表示可以提供多个路径，也就是说，在SpringMVC中，多个不同的请求路径可以映射同一个控制器的同一个方法：编写新的控制器：\njavapackage com.powernode.springmvc.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class RequestMappingTestController &#123;\n    @RequestMapping(value = &#123;&quot;/testValue1&quot;, &quot;/testValue2&quot;&#125;)\n    public String testValue()&#123;\n        return &quot;testValue&quot;;\n    &#125;\n&#125;\n提供视图页面：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;test Value&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Test RequestMapping&#39;s Value&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;在index.html文件中添加两个超链接：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;index page&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;index page&lt;/h1&gt;\n&lt;a th:href=&quot;@&#123;/user/detail&#125;&quot;&gt;用户详情&lt;/a&gt;&lt;br&gt;\n&lt;a th:href=&quot;@&#123;/product/detail&#125;&quot;&gt;商品详情&lt;/a&gt;&lt;br&gt;\n\n&lt;!--测试RequestMapping的value属性--&gt;\n&lt;a th:href=&quot;@&#123;/testValue1&#125;&quot;&gt;testValue1&lt;/a&gt;&lt;br&gt;\n&lt;a th:href=&quot;@&#123;/testValue2&#125;&quot;&gt;testValue2&lt;/a&gt;&lt;br&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;启动服务器，测试，点击以下的两个超链接，发送请求，都可以正常访问到同一个控制器上的同一个方法：\nAnt风格的value\n\n\n\n\n\n\n\n\n笔记\nRequestMapping的value属性支持Ant风格的，支特模糊匹配的路径\n\n?表示任意一个字符。（除 /  ？之外的其它字符），注意：一定是一个字符哦。不能空着。\n*表示0到N个任意字符。（除/ ？之外的其它字符）。\n**表示0到N个任意字符。并且路径中可以出现/\n但是**在使用的时侯需要注意，**左边只能是/。\n\n注意：\n\n如果使用Spring5以及之前的版本，这样写是没问题的：@RequestMapping(valve=&quot;/**/testAntValue&quot;)\n如果使用Spring6以及之后的版本，这样写是报错的：@ReqvestMapping(value=&quot;/**/testAntValue&quot;)\n在Spring6当中，**通配符只能作为路径的末尾出现。\n\n\n\n\n\n\n\n\n\n\n正文\nvalue是可以用来匹配路径的，路径支持模糊匹配，我们把这种模糊匹配称之为Ant风格。关于路径中的通配符包括：\n\n?，代表任意一个字符\n*，代表0到N个任意字符\n**，代表0到N个任意字符，并且路径中可以出现路径分隔符 /\n\n注意：**通配符在使用时，左右不能出现字符，只能是 /\n测试一下这些通配符，在 RequestMappingTestController 中添加以下方法：\njava@RequestMapping(&quot;/x?z/testValueAnt&quot;)\npublic String testValueAnt()&#123;\n    return &quot;testValueAnt&quot;;\n&#125;提供视图页面：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;test Value Ant&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;测试RequestMapping注解的value属性支持模糊匹配&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;在index.html页面中编写超链接：\nhtml&lt;!--测试RequestMapping注解的value属性支持模糊匹配--&gt;\n&lt;a th:href=&quot;@&#123;/xyz/testValueAnt&#125;&quot;&gt;测试value属性的模糊匹配&lt;/a&gt;&lt;br&gt;测试结果如下：\n通过修改浏览器地址栏上的路径，可以反复测试通配符 ? 的语法：\n将 ? 通配符修改为 * 通配符：\njava//@RequestMapping(&quot;/x?z/testValueAnt&quot;)\n@RequestMapping(&quot;/x*z/testValueAnt&quot;)\npublic String testValueAnt()&#123;\n    return &quot;testValueAnt&quot;;\n&#125;打开浏览器直接在地址栏上输入路径进行测试：\n将 * 通配符修改为 ** 通配符：\njava@RequestMapping(&quot;/x**z/testValueAnt&quot;)\npublic String testValueAnt()&#123;\n    return &quot;testValueAnt&quot;;\n&#125;注意：/x**z/ 实际上并没有使用通配符 **，本质上还是使用的 *，因为通配符 ** 在使用的时候，左右两边都不能有任何字符，必须是 &#x2F;。\njava@RequestMapping(&quot;/**/testValueAnt&quot;)\npublic String testValueAnt()&#123;\n    return &quot;testValueAnt&quot;;\n&#125;启动服务器发现报错了：以上写法在Spring5的时候是支持的，但是在Spring6中进行了严格的规定，** 通配符只能出现在路径的末尾，例如：\njava@RequestMapping(&quot;/testValueAnt/**&quot;)\npublic String testValueAnt()&#123;\n    return &quot;testValueAnt&quot;;\n&#125;测试结果：\nvalue中的占位符（重点）\n\n\n\n\n\n\n\n\n笔记\n关于@RequestMapping注解的value属性上的占位符（重点）\n\n传统的URL:/springmvc/login?username=admin&amp;password=123\n现在的开发比较流行使用RESTFUL风格的URL:/springmvc/login/admin/123\n在SpringMVC当中，如果请求的URL使用的是RESTFul风格的\n\n那么这个数据应该在java程序中如何获取呢？使用占位符方式。\njava@RequestMapping(value =&quot;/login/&#123;a&#125;/&#123;b&#125;&quot;) \npublic String testRESTFULURL(\n        @PathVariable(&quot;a&quot;) \n        String username,\n        @PathVariable(&quot;b&quot;) \n        String password)&#123; \n    System.out.println(&quot;用户名：&quot;+username+&quot;,密码：&quot;+password); \n    return &quot;ok&quot;;\n&#125;\n\n\n\n\n\n\n\n\n正文\n到目前为止，我们的请求路径是这样的格式：uri?name1&#x3D;value1&amp;name2&#x3D;value2&amp;name3&#x3D;value3其实除了这种方式，还有另外一种格式的请求路径，格式为：uri&#x2F;value1&#x2F;value2&#x2F;value3，我们将这样的请求路径叫做 RESTful 风格的请求路径。RESTful风格的请求路径在现代的开发中使用较多。\n普通的请求路径：http://localhost:8080/springmvc/login?username=admin&amp;password=123&amp;age=20RESTful风格的请求路径：http://localhost:8080/springmvc/login/admin/123/20\n如果使用RESTful风格的请求路径，在控制器中应该如何获取请求中的数据呢？可以在value属性中使用占位符，例如：&#x2F;login&#x2F;{id}&#x2F;{username}&#x2F;{password}\n在 RequestMappingTestController 类中添加一个方法：\njava@RequestMapping(value=&quot;/testRESTful/&#123;id&#125;/&#123;username&#125;/&#123;age&#125;&quot;)\npublic String testRESTful(\n        @PathVariable(&quot;id&quot;)\n        int id,\n        @PathVariable(&quot;username&quot;)\n        String username,\n        @PathVariable(&quot;age&quot;)\n        int age)&#123;\n    System.out.println(id + &quot;,&quot; + username + &quot;,&quot; + age);\n    return &quot;testRESTful&quot;;\n&#125;提供视图页面：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;test RESTful&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;测试value属性使用占位符&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;在 index.html 页面中添加超链接：\nhtml&lt;!--测试RequestMapping注解的value属性支持占位符--&gt;\n&lt;a th:href=&quot;@&#123;/testRESTful/1/zhangsan/20&#125;&quot;&gt;测试value属性使用占位符&lt;/a&gt;启动服务器测试：\n5、method属性method属性的作用\n\n\n\n\n\n\n\n\n笔记\n关于@RequestMapping注角解的method属性，通过该属性可以限制前端发送的请求方式。如果前端发送的请求方式与后端的处理方式不同，则出现405错误\njava@Controller \npublic class UserController&#123;\n    @RequestMapping(value=&quot;/user/login&quot;,method=RequestMethod.POST) \n    public String userLogin()&#123; \n        return &quot;ok&quot;;\n    &#125;\n&#125;表示：当前端发送的请求路径是/user/login,并且请求方式是P0ST的时候，才能映射到UserController#userLogin()方法上。\n只要有一个不满足，则无法映射。例如：请求路径对应不上，或者请求方式对应不上，都是无法映射的\n\n\n\n\n\n\n\n\n\n正文\n在Servlet当中，如果后端要求前端必须发送一个post请求，后端可以通过重写doPost方法来实现。后端要求前端必须发送一个get请求，后端可以通过重写doGet方法来实现。当重写的方法是doPost时，前端就必须发送post请求，当重写doGet方法时，前端就必须发送get请求。如果前端发送请求的方式和后端的处理方式不一致时，会出现405错误。\nHTTP状态码405，这种机制的作用是：限制客户端的请求方式，以保证服务器中数据的安全。\n假设后端程序要处理的请求是一个登录请求，为了保证登录时的用户名和密码不被显示到浏览器的地址栏上，后端程序有义务要求前端必须发送一个post请求，如果前端发送get请求，则应该拒绝。\n那么在SpringMVC框架中应该如何实现这种机制呢？可以使用RequestMapping注解的method属性来实现。\n通过RequestMapping源码可以看到，method属性也是一个数组：数组中的每个元素是 RequestMethod，而RequestMethod是一个枚举类型的数据：因此如果要求前端发送POST请求，该注解应该这样用：\njava@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)\npublic String login()&#123;\n    return &quot;success&quot;;\n&#125;接下来，我们来测试一下：在RequestMappingTestController类中添加以下方法：\njava@RequestMapping(value=&quot;/login&quot;, method = RequestMethod.POST)\npublic String testMethod()&#123;\n    return &quot;testMethod&quot;;\n&#125;提供视图页面：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;test Method&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Login Success!!!&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;在index.html页面中提供一个登录的form表单，后端要求发送post请求，则form表单的method属性应设置为post：\nhtml&lt;!--测试RequestMapping的method属性--&gt;\n&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt;\n    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;\n&lt;/form&gt;启动服务器，测试：\n通过测试，前端发送的请求方式post，后端处理请求的方式也是post，就不会有问题。当然，如果后端要求前端必须发送post请求，而前端发送了get请求，则会出现405错误，将index.html中form表单提交方式修改为get：\nhtml&lt;!--测试RequestMapping的method属性--&gt;\n&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;get&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt;\n    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;\n&lt;/form&gt;再次测试：\n因此，可以看出，对于RequestMapping注解来说，多一个属性，就相当于多了一个映射的条件，如果value和method属性都有，则表示只有前端发送的请求路径 + 请求方式都满足时才能与控制器上的方法建立映射关系，只要有一个不满足，则无法建立映射关系。例如：@RequestMapping(value&#x3D;”&#x2F;login”, method &#x3D; RequestMethod.POST) 表示当前端发送的请求路径是 &#x2F;login，并且发送请求的方式是POST的时候才会建立映射关系。如果前端发送的是get请求，或者前端发送的请求路径不是 &#x2F;login，则都是无法建立映射的。\n衍生Mapping\n\n\n\n\n\n\n\n\n笔记\n\n@PostMapping注解代替的是：@RequestMapping(value=&quot;&quot;, method=RequestMethod.POST)\n@GetMapping注解代替的是：@RequestMapping(value=&quot;&quot;, method=RequestMethod.GET)\n@PutMapping \n@DeleteMapping\n@PatchMapping\n….\n\n\n\n\n\n\n\n\n\n\n正文\n对于以上的程序来说，SpringMVC提供了另一个注解，使用这个注解更加的方便，它就是：PostMapping，使用该注解时，不需要指定method属性，因为它默认采用的就是POST处理方式：修改RequestMappingTestController代码如下\njava//@RequestMapping(value=&quot;/login&quot;, method = RequestMethod.POST)\n@PostMapping(&quot;/login&quot;)\npublic String testMethod()&#123;\n    return &quot;testMethod&quot;;\n&#125;当前端发送get请求时，测试一下：\n\n当前端发送post请求时，测试一下：\n在SpringMVC中不仅提供了 PostMaping注解，像这样的注解还有四个，包括：\n\nGetMapping：要求前端必须发送get请求\nPutMapping：要求前端必须发送put请求\nDeleteMapping：要求前端必须发送delete请求\nPatchMapping：要求前端必须发送patch请求\n\nweb的请求方式\n\n\n\n\n\n\n\n\n笔记\n比较常用的： \n\nGET POST PUT DELETE HEAD \nGET:适合查询\nP0ST:适合新增 \nPUT:适合修改 \nDELETE:适合删除 \nHEAD:适合获取响应头信息。\n\n注意：使用form表单提交时，如果method设置为put delete head对不起，发送的请求还是get请求。\n如果要发送put delete headi请求，请发送ajax请求才可以。\n\n\n\n\n\n\n\n\n\n正文\n​\t前端向服务器发送请求的方式包括哪些？共9种，前5种常用，后面作为了解：\n\nGET：获取资源，只允许读取数据，不影响数据的状态和功能。使用 URL 中传递参数或者在 HTTP 请求的头部使用参数，服务器返回请求的资源。\nPOST：向服务器提交资源，可能还会改变数据的状态和功能。通过表单等方式提交请求体，服务器接收请求体后，进行数据处理。\nPUT：更新资源，用于更新指定的资源上所有可编辑内容。通过请求体发送需要被更新的全部内容，服务器接收数据后，将被更新的资源进行替换或修改。\nDELETE：删除资源，用于删除指定的资源。将要被删除的资源标识符放在 URL 中或请求体中。\nHEAD：请求服务器返回资源的头部，与 GET 命令类似，但是所有返回的信息都是头部信息，不能包含数据体。主要用于资源检测和缓存控制。\nPATCH：部分更改请求。当被请求的资源是可被更改的资源时，请求服务器对该资源进行部分更新，即每次更新一部分。\nOPTIONS：请求获得服务器支持的请求方法类型，以及支持的请求头标志。“OPTIONS *”则返回支持全部方法类型的服务器标志。\nTRACE：服务器响应输出客户端的 HTTP 请求，主要用于调试和测试。\nCONNECT：建立网络连接，通常用于加密 SSL&#x2F;TLS 连接。\n\n注意：\n\n使用超链接以及原生的form表单只能提交get和post请求，put、delete、head请求可以使用发送ajax请求的方式来实现。\n使用超链接发送的是get请求\n使用form表单，如果没有设置method，发送get请求\n使用form表单，设置method&#x3D;”get”，发送get请求\n使用form表单，设置method&#x3D;”post”，发送post请求\n使用form表单，设置method&#x3D;”put&#x2F;delete&#x2F;head”，发送get请求。（针对这种情况，可以测试一下）\n\n将index.html中登录表单的提交方式method设置为put：\nhtml&lt;!--测试RequestMapping的method属性--&gt;\n&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;put&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt;\n    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;\n&lt;/form&gt;修改RequestMappingTestController类的代码：\njava@RequestMapping(value=&quot;/login&quot;, method = RequestMethod.PUT)\n//@PostMapping(&quot;/login&quot;)\npublic String testMethod()&#123;\n    return &quot;testMethod&quot;;\n&#125;测试结果：通过测试得知，即使form中method设置为put方式，但仍然采用get方式发送请求。再次修改RequestMappingTestController：\njava@RequestMapping(value=&quot;/login&quot;, method = RequestMethod.GET)\n//@PostMapping(&quot;/login&quot;)\npublic String testMethod()&#123;\n    return &quot;testMethod&quot;;\n&#125;再次测试：\nGET和POST的区别HTTP请求协议之GET请求：\ntxtGET /springmvc/login?username=lucy&amp;userpwd=1111 HTTP/1.1                           请求行\nHost: localhost:8080                                                                    请求头\nConnection: keep-alive\nsec-ch-ua: &quot;Google Chrome&quot;;v=&quot;95&quot;, &quot;Chromium&quot;;v=&quot;95&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot;\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: &quot;Windows&quot;\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: http://localhost:8080/springmvc/index.html\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\n                                                                                        空白行\n                                                                                        请求体HTTP请求协议之POST请求：\ntxtPOST /springmvc/login HTTP/1.1                                                  请求行\nHost: localhost:8080                                                                  请求头\nConnection: keep-alive\nContent-Length: 25\nCache-Control: max-age=0\nsec-ch-ua: &quot;Google Chrome&quot;;v=&quot;95&quot;, &quot;Chromium&quot;;v=&quot;95&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot;\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: &quot;Windows&quot;\nUpgrade-Insecure-Requests: 1\nOrigin: http://localhost:8080\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: http://localhost:8080/springmvc/index.html\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\n                                                                                      空白行\nusername=lisi&amp;userpwd=123                                                             请求体区别是什么\nget请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个“?”，”?”后面是数据。这样会导致发送的数据回显在浏览器的地址栏上。\n\nhttp://localhost:8080/springmvc/login?username=zhangsan&userpwd=1111\n\npost请求发送数据的时候，在请求体当中发送。不会回显到浏览器的地址栏上。也就是说post发送的数据，在浏览器地址栏上看不到。\nget请求只能发送普通的字符串。并且发送的字符串长度有限制，不同的浏览器限制不同。这个没有明确的规范。get请求无法发送大数据量。\npost请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片。post请求可以发送大数据量，理论上没有长度限制。\nget请求在W3C中是这样说的：get请求比较适合从服务器端获取数据。\npost请求在W3C中是这样说的：post请求比较适合向服务器端传送数据。\nget请求是安全的。因为在正确使用get请求的前提下，get请求只是为了从服务器上获取数据，不会对服务器数据进行修改。\npost请求是危险的。因为post请求是修改服务器端的资源。\nget请求支持缓存。 也就是说当第二次发送get请求时，会走浏览器上次的缓存结果，不再真正的请求服务器。（有时需要避免，怎么避免：在get请求路径后添加时间戳）\npost请求不支持缓存。每一次发送post请求都会真正的走服务器。\n\n怎么选择\n如果你是想从服务器上获取资源，建议使用GET请求，如果你这个请求是为了向服务器提交数据，建议使用POST请求。\n大部分的form表单提交，都是post方式，因为form表单中要填写大量的数据，这些数据是收集用户的信息，一般是需要传给服务器，服务器将这些数据保存&#x2F;修改等。\n如果表单中有敏感信息，建议使用post请求，因为get请求会回显敏感信息到浏览器地址栏上。（例如：密码信息）\n做文件上传，一定是post请求。要传的数据不是普通文本。\n其他情况大部分都是使用get请求。\n\n6、params属性\n\n\n\n\n\n\n\n\n笔记\n关于RequestMapping注解的params属性\njava@RequestMapping(value=&quot;/testParams&quot;,params=&#123;&quot;username&quot;,&quot;password&quot;&#125;) \npublic String testParams()&#123; \n    return &quot;ok&quot;;\n&#125;\n当RequestMapping:注解中添动加了params,则表示又添加了新的约束条件。\n当请求路径是/testParams,并且请求携带的参数有username和password的时候，才能映射成功！\n关于thymeleaf中，怎么发送请求的时侯携带数据：\n&lt;a th:href=&quot;/testParams?name=value&amp;name=value&quot;&gt;&lt;/a&gt;\n&lt;a th:href=&quot;/testParams(name=&#39;admin&#39;,password=&#39;1234&#39;)&quot;&gt;&lt;/a&gt;\n\n\n\nparams属性的理解params属性用来设置通过请求参数来映射请求。对于RequestMapping注解来说：\n\nvalue属性是一个数组，只要满足数组中的任意一个路径，就能映射成功\nmethod属性也是一个数组，只要满足数组中任意一个请求方式，就能映射成功。\nparams属性也是一个数组，不过要求请求参数必须和params数组中要求的所有参数完全一致后，才能映射成功。\n\n\nparams属性的4种用法\n@RequestMapping(value&#x3D;”&#x2F;login”, params&#x3D;{“username”, “password”}) 表示：请求参数中必须包含 username 和 password，才能与当前标注的方法进行映射。\n@RequestMapping(value&#x3D;”&#x2F;login”, params&#x3D;{“!username”, “password”}) 表示：请求参数中不能包含username参数，但必须包含password参数，才能与当前标注的方法进行映射。\n@RequestMapping(value&#x3D;”&#x2F;login”, params&#x3D;{“username&#x3D;admin”, “password”}) 表示：请求参数中必须包含username参数，并且参数的值必须是admin，另外也必须包含password参数，才能与当前标注的方法进行映射。\n@RequestMapping(value&#x3D;”&#x2F;login”, params&#x3D;{“username!&#x3D;admin”, “password”}) 表示：请求参数中必须包含username参数，但参数的值不能是admin，另外也必须包含password参数，才能与当前标注的方法进行映射。\n\n注意：如果前端提交的参数，和后端要求的请求参数不一致，则出现400错误！！！HTTP状态码400的原因：请求参数格式不正确而导致的。\n测试params属性在 RequestMappingTestController 类中添加如下方法：\njava@RequestMapping(value=&quot;/testParams&quot;, params = &#123;&quot;username&quot;, &quot;password&quot;&#125;)\npublic String testParams()&#123;\n    return &quot;testParams&quot;;\n&#125;提供视图页面：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;testParams&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;测试RequestMapping注解的Params属性&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;在index.html文件中添加超链接：\nhtml&lt;!--测试RequestMapping的params属性--&gt;\n&lt;a th:href=&quot;@&#123;/testParams(username=&#39;admin&#39;,password=&#39;123&#39;)&#125;&quot;&gt;测试params属性&lt;/a&gt;当然，你也可以这样写：这样写IDEA会报错，但不影响使用。\nhtml&lt;a th:href=&quot;@&#123;/testParams?username=admin&amp;password=123&#125;&quot;&gt;测试params属性&lt;/a&gt;&lt;br&gt;启动服务器，测试：\n假如发送请求时，没有传递username参数会怎样？\nhtml&lt;a th:href=&quot;@&#123;/testParams(password=&#39;123&#39;)&#125;&quot;&gt;测试params属性&lt;/a&gt;&lt;br&gt;启动服务器，测试：提示无效的请求参数，服务器无法或不会处理当前请求。params属性剩下的三种情况，自行测试！！！！\n7、headers属性\n\n\n\n\n\n\n\n\n笔记\n关于RequestMapping注解的headers.属性：也是一个数组。用来设置请求头的映射。\njava@RequestMapping(value=&quot;/login&quot;,headers=&#123;&quot;Referer&quot;,&quot;Host&quot;) \npublic String testHeaders()&#123; \n    return &quot;ok&quot;; \n&#125;当请求路径是/login,并且请求头中包含Referer,也包含Host的时候，映射成功。\n认识headers属性headers和params原理相同，用法也相同。当前端提交的请求头信息和后端要求的请求头信息一致时，才能映射成功。请求头信息怎么查看？在chrome浏览器中，F12打开控制台，找到Network，可以查看具体的请求协议和响应协议。在请求协议中可以看到请求头信息，例如：请求头信息和请求参数信息一样，都是键值对形式，例如上图中：\n\nReferer: http://localhost:8080/springmvc/     键是Referer，值是http://localhost:8080/springmvc/\nHost: localhost:8080     键是Host，值是localhost:8080\n\nheaders属性的4种用法\n@RequestMapping(value=&quot;/login&quot;, headers=&#123;&quot;Referer&quot;, &quot;Host&quot;&#125;) 表示：请求头信息中必须包含Referer和Host，才能与当前标注的方法进行映射。\n@RequestMapping(value=&quot;/login&quot;, headers=&#123;&quot;Referer&quot;, &quot;!Host&quot;&#125;) 表示：请求头信息中必须包含Referer，但不包含Host，才能与当前标注的方法进行映射。\n@RequestMapping(value=&quot;/login&quot;, headers=&#123;&quot;Referer=http://localhost:8080/springmvc/&quot;, &quot;Host&quot;&#125;) 表示：请求头信息中必须包含Referer和Host，并且Referer的值必须是http://localhost:8080/springmvc/，才能与当前标注的方法进行映射。\n@RequestMapping(value=&quot;/login&quot;, headers=&#123;&quot;Referer!=http://localhost:8080/springmvc/&quot;, &quot;Host&quot;&#125;) 表示：请求头信息中必须包含Referer和Host，并且Referer的值不是http://localhost:8080/springmvc/，才能与当前标注的方法进行映射。\n\n注意：如果前端提交的请求头信息，和后端要求的请求头信息不一致，则出现404错误！！！\n测试headers属性在 RequestMappingTestController 类中添加以下方法：\njava@RequestMapping(value=&quot;/testHeaders&quot;, headers = &#123;&quot;Referer=http://localhost:8080/springmvc/&quot;&#125;)\npublic String testHeaders()&#123;\n    return &quot;testHeaders&quot;;\n&#125;提供视图页面：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;test Headers&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;测试RequestMapping注解的headers属性&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;在index.html页面中添加超链接：\nhtml&lt;!--测试RequestMapping的headers属性--&gt;\n&lt;a th:href=&quot;@&#123;/testHeaders&#125;&quot;&gt;测试headers属性&lt;/a&gt;&lt;br&gt;启动服务器，测试结果：将后端控制器中的headers属性值进行修改：\njava@RequestMapping(value=&quot;/testHeaders&quot;, headers = &#123;&quot;Referer=http://localhost:8888/springmvc/&quot;&#125;)\npublic String testHeaders()&#123;\n    return &quot;testHeaders&quot;;\n&#125;再次测试：其他情况自行测试！！！！\n\n四、获取请求数据(重点)4.1、准备工作创建模块，添加依赖xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.powernode.springmvc&lt;/groupId&gt;\n    &lt;artifactId&gt;springmvc-003&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;dependencies&gt;\n        &lt;!--springmvc依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n            &lt;version&gt;6.1.4&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--logback依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n            &lt;version&gt;1.5.3&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--servlet依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;6.0.0&lt;/version&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!--thymeleaf和spring6整合的依赖--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;\n            &lt;artifactId&gt;thymeleaf-spring6&lt;/artifactId&gt;\n            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n\n&lt;/project&gt;添加web支持\n编写web.xml文件xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&quot;\n         version=&quot;6.0&quot;&gt;\n\n    &lt;!--前端控制器--&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n        &lt;!--通过初始化参数来指定springmvc配置文件的路径和名字。--&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;!--在服务器启动的时候初始化DispatcherServlet，提高第一次访问的效率--&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;创建UserControllerjavapackage com.powernode.springmvc.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class UserController &#123;\n    @RequestMapping(&quot;/&quot;)\n    public String toRegisterPage()&#123;\n        return &quot;register&quot;;\n    &#125;\n&#125;编写springmvc.xmlxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;!--组件扫描--&gt;\n    &lt;context:component-scan base-package=&quot;com.powernode.springmvc.controller&quot;/&gt;\n\n    &lt;!--视图解析器--&gt;\n    &lt;bean id=&quot;thymeleafViewResolver&quot; class=&quot;org.thymeleaf.spring6.view.ThymeleafViewResolver&quot;&gt;\n        &lt;!--作用于视图渲染的过程中，可以设置视图渲染后输出时采用的编码字符集--&gt;\n        &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;\n        &lt;!--如果配置多个视图解析器，它来决定优先使用哪个视图解析器，它的值越小优先级越高--&gt;\n        &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;\n        &lt;!--当 ThymeleafViewResolver 渲染模板时，会使用该模板引擎来解析、编译和渲染模板--&gt;\n        &lt;property name=&quot;templateEngine&quot;&gt;\n            &lt;bean class=&quot;org.thymeleaf.spring6.SpringTemplateEngine&quot;&gt;\n                &lt;!--用于指定 Thymeleaf 模板引擎使用的模板解析器。模板解析器负责根据模板位置、模板资源名称、文件编码等信息，加载模板并对其进行解析--&gt;\n                &lt;property name=&quot;templateResolver&quot;&gt;\n                    &lt;bean class=&quot;org.thymeleaf.spring6.templateresolver.SpringResourceTemplateResolver&quot;&gt;\n                        &lt;!--设置模板文件的位置（前缀）--&gt;\n                        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;\n                        &lt;!--设置模板文件后缀（后缀），Thymeleaf文件扩展名不一定是html，也可以是其他，例如txt，大部分都是html--&gt;\n                        &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt;\n                        &lt;!--设置模板类型，例如：HTML,TEXT,JAVASCRIPT,CSS等--&gt;\n                        &lt;property name=&quot;templateMode&quot; value=&quot;HTML&quot;/&gt;\n                        &lt;!--用于模板文件在读取和解析过程中采用的编码字符集--&gt;\n                        &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;\n                    &lt;/bean&gt;\n                &lt;/property&gt;\n            &lt;/bean&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;编写register.html文件\nxml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;用户注册&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h3&gt;用户注册&lt;/h3&gt;\n&lt;hr&gt;\n&lt;/body&gt;\n&lt;/html&gt;部署测试\n4.2、使用原生的Servlet API进行获取\n\n\n\n\n\n\n\n\n笔记\n第一种方式使用原生的Servlet API\n\n在处理器的方法参数上提供：HttpServletRequest \nSpringMVC框架会自动将Tomcat服务器创建request对象传递给处理器方法。\n我们直接在处理器方法中使用request对家即可。\n当然，HttpServletResponse,HttpSession有需要的话，也可以采用这种方式注入。\n\n\n\n\n\n\n\n\n\n\n正文\n原生的Servlet API指的是：HttpServletRequest在SpringMVC当中，一个Controller类中的方法参数上如果有HttpServletRequest，SpringMVC会自动将**当前请求对象**传递给这个参数，因此我们可以通过这个参数来获取请求提交的数据。测试一下。\n在 register.html 中准备一个注册的表单：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;用户注册&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h3&gt;用户注册&lt;/h3&gt;\n&lt;hr&gt;\n&lt;form th:action=&quot;@&#123;/register&#125;&quot; method=&quot;post&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;\n    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;\n    性别：\n        男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot;&gt;\n        女 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot;&gt;\n        &lt;br&gt;\n    爱好：\n        抽烟 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;smoke&quot;&gt;\n        喝酒 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;drink&quot;&gt;\n        烫头 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;perm&quot;&gt;\n        &lt;br&gt;\n    简介：&lt;textarea rows=&quot;10&quot; cols=&quot;60&quot; name=&quot;intro&quot;&gt;&lt;/textarea&gt;&lt;br&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;先测试这个页面是否可以正常打开，是否可以正常提交数据：\n点击注册：F12的方式查看是否提交了数据：通过测试得知：可以正常提交数据。\n接下来在控制器添加一个方法来处理这个注册的请求：\njava@PostMapping(value=&quot;/register&quot;)\npublic String register(HttpServletRequest request)&#123;\n    // 通过当前请求对象获取提交的数据\n    String username = request.getParameter(&quot;username&quot;);\n    String password = request.getParameter(&quot;password&quot;);\n    String sex = request.getParameter(&quot;sex&quot;);\n    String[] hobbies = request.getParameterValues(&quot;hobby&quot;);\n    String intro = request.getParameter(&quot;intro&quot;);\n    System.out.println(username + &quot;,&quot; + password + &quot;,&quot; + sex + &quot;,&quot; + Arrays.toString(hobbies) + &quot;,&quot; + intro);\n    return &quot;success&quot;;\n&#125;提供视图页面：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;注册成功&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;注册成功&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;测试：\n这样通过Servlet原生的API获取到提交的数据。但是这种方式不建议使用，因为方法的参数依赖Servlet原生API，Controller的测试将不能单独测试，必须依赖WEB服务器才能测试。另外，换句话说，如果在SpringMVC中使用了原生的Servlet，你为什么还要用SpringMVC框架呢！！！！！\n4.3、使用RequestParam注解标注\n\n\n\n\n\n\n\n\n笔记\n第二种方式：使用SpringMVC框架提供的一个注解：©RequestParam(请求参教) \n@RequestParam注解中的属性： \n\nvalue属性：value属性可以使用name属性代替 \nname属性：name属性可以已使用value属性代替 \nrequired属性：用来设置该参数是否为必须的。默认值是true。默认情况下这个参数是必须要传递过来的。如果前端没有提交这个参数，报错：400错误。\n这个属性有点类似于@ReqvestMapping注解中的params属性的作用。\n\n\n\njava@RequestMapping(value=&quot;/testParams&quot;,params=&#123;&quot;username&quot;,&quot;password&quot;&#125;) \npublic String testParams()&#123; \n    return &quot;ok&quot;;\n&#125; required属性可以设置为false,这样这个参数就不是必须的了。如果前端没有提供，则不会报400错误。但是由于前端没有提供这个数据，因此程序中的变量值为null\ndefaultValue属性：通过defaultValue属性可以给参数赋默认值。如果前端设有提供这样的参数，参数的默认值就起作用了。\n\n\n\n\n\n\n\n\n\n正文\n4.3.1、RequestParam注解的基本使用RequestParam注解作用：将请求参数与方法上的形参映射。\njava@PostMapping(value = &quot;/register&quot;)\npublic String register(\n        @RequestParam(value=&quot;username&quot;)\n        String a,\n        @RequestParam(value=&quot;password&quot;)\n        String b,\n        @RequestParam(value=&quot;sex&quot;)\n        String c,\n        @RequestParam(value=&quot;hobby&quot;)\n        String[] d,\n        @RequestParam(name=&quot;intro&quot;)\n        String e) &#123;\n    System.out.println(a);\n    System.out.println(b);\n    System.out.println(c);\n    System.out.println(Arrays.toString(d));\n    System.out.println(e);\n    return &quot;success&quot;;\n&#125;注意：对于@RequestParam注解来说，属性有value和name，这两个属性的作用相同，都是用来指定提交数据的name。例如：发送请求时提交的数据是：name1=value1&amp;name2=value2，则这个注解应该这样写：@RequestParam(value=&quot;name1&quot;)、@RequestParam(value=&quot;name2&quot;)\n启动服务器测试：\n一定要注意： @RequestParam(value=&quot;name2&quot;) 中value一定不要写错，写错就会出现以下问题：测试结果：\n4.3.2、RequestParam注解的required属性\n\nrequired属性用来设置该方法参数是否为必须的。\n默认情况下，这个参数为 true，表示方法参数是必需的。如果请求中缺少对应的参数，则会抛出异常。\n可以将其设置为false，false表示不是必须的，如果请求中缺少对应的参数，则方法的参数为null。\n\n测试，修改register方法，如下：\n添加了一个 age 形参，没有指定 required 属性时，默认是true，表示必需的，但前端表单中没有年龄age，我们来看报错信息：错误信息告诉我们：参数age是必需的。没有提供这个请求参数，HTTP状态码 400\n如果将 required 属性设置为 false。则该参数则不是必须的，如果请求参数仍然未提供时，我们来看结果：\n通过测试得知，如果一个参数被设置为不是必需的，当没有提交对应的请求参数时，形参默认值null。当然，如果请求参数中提供了age，则age为真实提交的数据：\n\n\n\n\n\n\n\n\n\n测试结果如下\n\n4.3.3、RequestParam注解的defaultValue属性defaultValue属性用来设置形参的默认值，当没有提供对应的请求参数或者请求参数的值是空字符串&quot;&quot;的时候，方法的形参会采用默认值。\n当前端页面没有提交email的时候：\n\n当前端页面提交的email是空字符串的时候：\n\n当前端提交的email不是空字符串的时候：\n4.4、依靠控制器方法上的形参名来接收\n\n\n\n\n\n\n\n\n笔记\n如果请求参数名和控制器方法上的形参名保持一致，那么@RequestParam注解可以省略。\n如果使用的是Springe6+版本，则需要在pom.xmL文件中添加如下编译配置：(Spring5以及之前的版本不需要。)\nxml&lt;bvild&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n            &lt;version&gt;3.12.1&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;source&gt;21&lt;/source&gt;\n                &lt;target&gt;21&lt;/target&gt;\n                &lt;compilerArgs&gt;\n                    &lt;arg&gt;-parameters&lt;/arg&gt;\n                &lt;/compilerArgs&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;注意：如果控制器方法上的形参名和请求参数名没有对应上，那么控制器方法中的形参默认值是null。\n\n\n\n\n\n\n\n\n\n正文\n@RequestParam 这个注解是可以省略的，如果方法形参的名字和提交数据时的name相同，则 @RequestParam 可以省略。\n但有一个前提：如果你采用的是Spring6+版本，你需要在pom.xml文件中指定编译参数’-parameter’，配置如下：\nxml&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n            &lt;version&gt;3.12.1&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;source&gt;21&lt;/source&gt;\n                &lt;target&gt;21&lt;/target&gt;\n                &lt;compilerArgs&gt;\n                    &lt;arg&gt;-parameters&lt;/arg&gt;\n                &lt;/compilerArgs&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;注意：如果你使用的是Spring5的版本，以上的配置是不需要的。\nController中的方法只需要这样写：形参的名字必须和提交的数据的name一致！！！！！\njava@PostMapping(value=&quot;/register&quot;)\npublic String register(String username, String password, String sex, String[] hobby, String intro)&#123;\n    System.out.println(username + &quot;,&quot; + password + &quot;,&quot; + sex + &quot;,&quot; + Arrays.toString(hobby) + &quot;,&quot; + intro);\n    return &quot;success&quot;;\n&#125;测试结果：\n如果形参名和提交的数据的name不一致时：\n另外，还有一点，对于提交的hobby数据，也可以采用String来接收，不一定使用数组方式：\njava@PostMapping(value=&quot;/register&quot;)\npublic String register(String username, String password, String sex, String hobby, String intro)&#123;\n    System.out.println(username + &quot;,&quot; + password + &quot;,&quot; + sex + &quot;,&quot; + hobby + &quot;,&quot; + intro);\n    return &quot;success&quot;;\n&#125;测试结果：根据输出结果可以看到多个hobby是采用“,”进行连接的。\n4.5、使用POJO类&#x2F;JavaBean接收请求参数(重要)\n\n\n\n\n\n\n\n\n笔记\n底层实现原理：反射机制。\n不过，使用这种方式的前提是：P0J0类的属性名必须和请求参数的参数名保持一致\n实现原理是什么？\n假设提交了一个请求，参数名是username,那么要求P0J0类当中必须有一个属性名也，叫做：username \njavaClass clazz Class.forName(&quot;com.powernode.springmvc.pojo.User&quot;);\nUser user (User)cLazz.newInstance(); \nString fieldName =&quot;username&quot;; \nString setMethodName &quot;setUsername&quot;; \nMethod setMethod clazz.getDeclaredMethod(setMethodName,....); \nsetMethod.invoke(user,&quot;zhaoliu&quot;);重点 ：底层通过反射机制调用set方法给属性赋值的。所以set方法的方法名非常重要。\n\n如果前端提交了参数是：username=zhangsan，那么必须保证P0J0类当中有一个方法名叫做：setUsername\n如果前端提交了参数是： email=zhangsan@powernode.com，那么必须保证P0J0类当中有一个方法名叫做：setEmail\n如果没有对应的set方法，将无法给对应的属性赋值。\n\n\n\n\n\n\n\n\n\n\n正文\n以上方式大家可以看到，当提交的数据非常多时，方法的形参个数会非常多，这不是很好的设计。在SpringMVC中也可以使用POJO类&#x2F;JavaBean来接收请求参数。不过有一个非常重要的要求：POJO类的属性名必须和请求参数的参数名保持一致。提供以下的JavaBean：\njavapackage com.powernode.springmvc.pojo;\n\nimport java.util.Arrays;\n\npublic class User &#123;\n    private Long id;\n    private String username;\n    private String password;\n    private String sex;\n    private String[] hobby;\n    private String intro;\n\n    public User() &#123;\n    &#125;\n\n    public User(Long id, String username, String password, String sex, String[] hobby, String intro) &#123;\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.sex = sex;\n        this.hobby = hobby;\n        this.intro = intro;\n    &#125;\n\n    public Long getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Long id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username = username;\n    &#125;\n\n    public String getPassword() &#123;\n        return password;\n    &#125;\n\n    public void setPassword(String password) &#123;\n        this.password = password;\n    &#125;\n\n    public String getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    public String[] getHobby() &#123;\n        return hobby;\n    &#125;\n\n    public void setHobby(String[] hobby) &#123;\n        this.hobby = hobby;\n    &#125;\n\n    public String getIntro() &#123;\n        return intro;\n    &#125;\n\n    public void setIntro(String intro) &#123;\n        this.intro = intro;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, username=&#39;&quot; + username + &#39;\\&#39;&#39; +\n                &quot;, password=&#39;&quot; + password + &#39;\\&#39;&#39; +\n                &quot;, sex=&#39;&quot; + sex + &#39;\\&#39;&#39; +\n                &quot;, hobby=&quot; + Arrays.toString(hobby) +\n                &quot;, intro=&#39;&quot; + intro + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n在控制器方法的形参位置上使用javabean来接收请求参数：\njava@PostMapping(&quot;/register&quot;)\npublic String register(User user)&#123;\n    System.out.println(user);\n    return &quot;success&quot;;\n&#125;执行结果：\n底层的实现原理：反射机制。先获取请求参数的名字，因为请求参数的名字就是JavaBean的属性名，通过这种方式给对应的属性赋值。\n我们来测试一下：当JavaBean的属性名和请求参数的参数名不一致时，会出现什么问题？（注意：getter和setter的方法名不修改，只修改属性名）\njavapackage com.powernode.springmvc.pojo;\n\nimport java.util.Arrays;\n\npublic class User &#123;\n    private Long id;\n    private String uname;\n    private String upwd;\n    private String usex;\n    private String[] uhobby;\n    private String uintro;\n\n    public User() &#123;\n    &#125;\n\n    public User(Long id, String username, String password, String sex, String[] hobby, String intro) &#123;\n        this.id = id;\n        this.uname = username;\n        this.upwd = password;\n        this.usex = sex;\n        this.uhobby = hobby;\n        this.uintro = intro;\n    &#125;\n\n    public Long getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Long id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getUsername() &#123;\n        return uname;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.uname = username;\n    &#125;\n\n    public String getPassword() &#123;\n        return upwd;\n    &#125;\n\n    public void setPassword(String password) &#123;\n        this.upwd = password;\n    &#125;\n\n    public String getSex() &#123;\n        return usex;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.usex = sex;\n    &#125;\n\n    public String[] getHobby() &#123;\n        return uhobby;\n    &#125;\n\n    public void setHobby(String[] hobby) &#123;\n        this.uhobby = hobby;\n    &#125;\n\n    public String getIntro() &#123;\n        return uintro;\n    &#125;\n\n    public void setIntro(String intro) &#123;\n        this.uintro = intro;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, username=&#39;&quot; + uname + &#39;\\&#39;&#39; +\n                &quot;, password=&#39;&quot; + upwd + &#39;\\&#39;&#39; +\n                &quot;, sex=&#39;&quot; + usex + &#39;\\&#39;&#39; +\n                &quot;, hobby=&quot; + Arrays.toString(uhobby) +\n                &quot;, intro=&#39;&quot; + uintro + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n测试结果：通过测试，我们得知：请求参数名可以和JavaBean的属性名不一致。\n我们继续将其中一个属性的setter和getter方法名修改一下：\n再次测试：\n通过测试可以看到：username属性没有赋上值。可见请求参数是否可以赋值到JavaBean对应的属性上，不是取决于属性名，而是setter方法名。\n4.6、RequestHeader注解该注解的作用是：将请求头信息映射到方法的形参上。和RequestParam注解功能相似，RequestParam注解的作用：将请求参数映射到方法的形参上。当然，对于RequestHeader注解来说，也有三个属性：value、required、defaultValue，和RequestParam一样，这里就不再赘述了。\n测试：\njava@PostMapping(&quot;/register&quot;)\npublic String register(User user, \n                       @RequestHeader(value=&quot;Referer&quot;, required = false, defaultValue = &quot;&quot;) \n                       String referer)&#123;\n    System.out.println(user);\n    System.out.println(referer);\n    return &quot;success&quot;;\n&#125;执行结果：\n4.7、CookieValue注解该注解的作用：将请求提交的Cookie数据映射到方法形参上同样是有三个属性：value、required、defaultValue\n前端页面中编写发送cookie的代码：\nhtml&lt;script type=&quot;text/javascript&quot;&gt;\n    function sendCookie()&#123;\n        document.cookie = &quot;id=123456789; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/&quot;;\n        document.location = &quot;/springmvc/register&quot;;\n    &#125;\n&lt;/script&gt;\n&lt;button onclick=&quot;sendCookie()&quot;&gt;向服务器端发送Cookie&lt;/button&gt;后端UserController代码：\njava    @GetMapping(&quot;/register&quot;)\n    public String register(User user,\n                           @RequestHeader(value=&quot;Referer&quot;, required = false, defaultValue = &quot;&quot;)\n                           String referer,\n                           @CookieValue(value=&quot;id&quot;, required = false, defaultValue = &quot;2222222222&quot;)\n                           String id)&#123;\n        System.out.println(user);\n        System.out.println(referer);\n        System.out.println(id);\n        return &quot;success&quot;;\n    &#125;测试结果：\n4.8、请求的中文乱码问题\n\n\n\n\n\n\n\n\n笔记\n1、关于javaweb项目中，get请求的乱码问题？\nget请求，提交的数据是在浏览器的地址栏上回显。在请求行上提交数据，例如：/springmvc/login?username=张三&amp;password=123\n怎么解决get请求乱码问题呢？\n对URI进行编码设置，在哪儿可以设置URI的编码方式呢？在Tomcat服务器的配置CATALINA_HOME/conf/server.xmL文件中：\nxml&lt;Connector port=&quot;8080&quot;protocol=&quot;HTTP/1.1&quot; \n           connectionTimeout=&quot;20000&quot; \n           redirectPort=&quot;8443&quot; \n           maxParameterCount=&quot;1000&quot; \n           URIEncoding=&quot;UTF-8&quot;\n           /&gt;\n对于Tomcat10和Tomcat9来说：get请求设有乱码。也就是说Tomcat10或者Tomcat9已经自动对URI进行编码，并且默认的编码方式就是UTF-8\n但是对于Tomcat8来说，URIEncoding的默认值是IS0-8859-I编码方式，所以在Tomcat8中，get请求是存在中文乱码问题的，怎么解决？如上所描述。\n\n2、关于javaweb项目中，post请求的乱码问题？ \npost请求乱码如何解决？ \n\n使用request.setCharacterEncoding(&quot;UTF-8&quot;);\n但是有一个前提：reqvest.setCharacterEncoding(&quot;UTF-8&quot;);这一行代码必须在String username=reqvest.getParameter(&quot;username&quot;);方法执行之前执行，才有效。\n\n在Tomcat10当中，我们是不需要考虑post请求乱码i问题，因为Tomcat10,已经自动帮助我们执行了：request.setCharacterEncoding(&quot;UTF-8&quot;);\n在哪里可以看到呢？在CATALINA_HONE&#x2F;conf&#x2F;Web.XnL文件中有这样的配置\nxml&lt;request-character-encoding&gt;UTF-8&lt;/request-character-encoding&gt;\n&lt;response-character-encoding&gt;UTF-8&lt;/response-character-encoding&gt;这个配置信息表示：请求体采用UTF-8的方式，另外响应的时候也采用UTF-8的方式，所以P0ST请求无乱码，响应也没有乱码。\n注意了：对于Tomcat9以及之前的版本来说，没有以上的配置。P0ST请求乱码问题，响应的乱码问题都需要自行解决，\n那么如果退到Tomcat9-版本，那么P0ST请求乱码应该怎么解决呢？对于SpringMVC来说，有什么好的办法吗？\n\n在request.getParameter()方法执行之前，执行：request.setCharacterEncoding(&quot;UTF-8“);，这样问题就能解决了\n第一种方案：自己编写一个过滤器！！！！过滤器Filter在Servlet执行之前执行。\n第二种方案：使用SpringMVC框架内置的字符编码过滤器即可：CharacterEncodingFilter。\n\n\n\n\n\n\n\n\n\n\n正文\nget请求乱码get请求数据在URI后面提交，这个乱码问题怎么解决呢？解决办法是找到 CATALINA_HOME&#x2F;config&#x2F;server.xml文件，找到其中配置端口号的标签，在该标签中添加  URIEncoding&#x3D;”UTF-8”。但是对于高版本的Tomcat服务器来说，是不需要设置的，例如Tomcat10，Tomcat9，有如下的默认配置，在默认情况下URIEncoding使用的就是UTF-8的编码方式。但对于低版本的Tomcat服务器，例如：Tomcat8。URIEncoding的默认配置是ISO-8859-1，因此在Tomcat8中需要手动配置server.xml文件：配置如下：\n接下来，我们测试一下，在默认情况下，Tomcat10是否已经解决了get请求乱码问题：\nhtml&lt;form th:action=&quot;@&#123;/register&#125;&quot; method=&quot;get&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;\n    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;\n    性别：\n        男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot;&gt;\n        女 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot;&gt;\n        &lt;br&gt;\n    爱好：\n        抽烟 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;smoke&quot;&gt;\n        喝酒 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;drink&quot;&gt;\n        烫头 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;perm&quot;&gt;\n        &lt;br&gt;\n    简介：&lt;textarea rows=&quot;10&quot; cols=&quot;60&quot; name=&quot;intro&quot;&gt;&lt;/textarea&gt;&lt;br&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;\n&lt;/form&gt;注意，以上表单已经修改为get请求了。\njava@GetMapping(&quot;/register&quot;)\npublic String register(User user)&#123;\n    System.out.println(user);\n    return &quot;success&quot;;\n&#125;测试结果：\npost请求乱码post请求是解决请求体的中文乱码问题。解决办法大家都知道：\njavarequest.setCharacterEncoding(&quot;UTF-8&quot;);同样，对于高版本的Tomcat10服务器来说，针对请求体中的字符编码也是配置好的，默认也是采用了UTF-8，中文乱码问题也解决了，在这个文件中配置的：apache-tomcat-10.1.19\\conf\\web.xml配置内容如下：通过以上配置可以看到，Tomcat10对请求和响应都设置了默认的字符编码方式为UTF-8一定要注意：Tomcat9以及之前的版本，以上的配置是没有的。\n我们来测试一下，针对Tomcat10来说，SpringMVC会不会有乱码问题：\nhtml&lt;form th:action=&quot;@&#123;/register&#125;&quot; method=&quot;post&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;\n    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;\n    性别：\n        男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot;&gt;\n        女 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot;&gt;\n        &lt;br&gt;\n    爱好：\n        抽烟 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;smoke&quot;&gt;\n        喝酒 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;drink&quot;&gt;\n        烫头 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;perm&quot;&gt;\n        &lt;br&gt;\n    简介：&lt;textarea rows=&quot;10&quot; cols=&quot;60&quot; name=&quot;intro&quot;&gt;&lt;/textarea&gt;&lt;br&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;\n&lt;/form&gt;注意：以上表单已经修改为post请求\njava@PostMapping(&quot;/register&quot;)\npublic String register(User user, HttpServletRequest request) throws UnsupportedEncodingException &#123;\n    System.out.println(user);\n    return &quot;success&quot;;\n&#125;测试结果：\n通过测试可以看到在Tomcat10当中，默认SpringMVC，发送POST请求，是不会出现乱码问题的。\n有可能很多同学使用的不是Tomcat10，如果不是Tomcat10，则会出现乱码问题，我们来模拟一下乱码的产生，将apache-tomcat-10.1.19\\conf\\web.xml文件中的UTF-8配置修改为ISO-8859-1：一定要重启Tomcat10，新的配置才能生效，来测试一下是否存在乱码：\n\n那么，在SpringMVC中如何解决请求体的中文乱码问题呢？当然，还是使用request.setCharacterEncoding(&quot;UTF-8&quot;)\n使用它有一个前提条件，要想解决请求体乱码问题，以上代码必须在 request.getParameter(&quot;username&quot;)执行之前执行才有效。\n也就是说以上代码如果放在Controller的相关方法中执行是无效的，因为Controller的方法在执行之前 DispatcherServlet已经调用了request.getParameter(&quot;username&quot;)方法。因此在Controller方法中使用request.setCharacterEncoding(&quot;UTF-8&quot;);无效我们来测试一下：\n\nhtml&lt;form th:action=&quot;@&#123;/register&#125;&quot; method=&quot;post&quot;&gt;\n    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;\n    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;\n    性别：\n        男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot;&gt;\n        女 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot;&gt;\n        &lt;br&gt;\n    爱好：\n        抽烟 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;smoke&quot;&gt;\n        喝酒 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;drink&quot;&gt;\n        烫头 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;perm&quot;&gt;\n        &lt;br&gt;\n    简介：&lt;textarea rows=&quot;10&quot; cols=&quot;60&quot; name=&quot;intro&quot;&gt;&lt;/textarea&gt;&lt;br&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;\n&lt;/form&gt;注意：以上表单已经修改为post请求\njava@PostMapping(&quot;/register&quot;)\npublic String register(User user, HttpServletRequest request) throws UnsupportedEncodingException &#123;\n    request.setCharacterEncoding(&quot;UTF-8&quot;);\n    System.out.println(user);\n    return &quot;success&quot;;\n&#125;测试结果：通过测试可以看到：在Controller当中调用request.setCharacterEncoding(&quot;UTF-8&quot;)是无法解决POST乱码问题的。\n那怎么办呢？怎么样才能在DispatcherServlet之前执行request.setCharacterEncoding(&quot;UTF-8&quot;)呢？没错，我相信大家想到了：过滤器Filter。过滤器Filter可以在Servlet执行之前执行。有同学又说了：监听器不行吗？不行。因为我们需要对每一次请求解决乱码，而监听器只在服务器启动阶段执行一次。因此这里解决每一次请求的乱码问题，应该使用过滤器Filter。并且，告诉大家一个好消息，SpringMVC已经将这个字符编码的过滤器提前写好了，我们直接配置好即可：CharacterEncodingFilter，我们一起看一下它的源码：\njava/*\n * Copyright 2002-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.web.filter;\n\nimport java.io.IOException;\n\nimport jakarta.servlet.FilterChain;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\n\n/**\n * Servlet Filter that allows one to specify a character encoding for requests.\n * This is useful because current browsers typically do not set a character\n * encoding even if specified in the HTML page or form.\n *\n * &lt;p&gt;This filter can either apply its encoding if the request does not already\n * specify an encoding, or enforce this filter&#39;s encoding in any case\n * (&quot;forceEncoding&quot;=&quot;true&quot;). In the latter case, the encoding will also be\n * applied as default response encoding (although this will usually be overridden\n * by a full content type set in the view).\n *\n * @author Juergen Hoeller\n * @since 15.03.2004\n * @see #setEncoding\n * @see #setForceEncoding\n * @see jakarta.servlet.http.HttpServletRequest#setCharacterEncoding\n * @see jakarta.servlet.http.HttpServletResponse#setCharacterEncoding\n */\npublic class CharacterEncodingFilter extends OncePerRequestFilter &#123;\n\n    @Nullable\n    private String encoding;\n\n    private boolean forceRequestEncoding = false;\n\n    private boolean forceResponseEncoding = false;\n\n\n    /**\n     * Create a default &#123;@code CharacterEncodingFilter&#125;,\n     * with the encoding to be set via &#123;@link #setEncoding&#125;.\n     * @see #setEncoding\n     */\n    public CharacterEncodingFilter() &#123;\n    &#125;\n\n    /**\n     * Create a &#123;@code CharacterEncodingFilter&#125; for the given encoding.\n     * @param encoding the encoding to apply\n     * @since 4.2.3\n     * @see #setEncoding\n     */\n    public CharacterEncodingFilter(String encoding) &#123;\n        this(encoding, false);\n    &#125;\n\n    /**\n     * Create a &#123;@code CharacterEncodingFilter&#125; for the given encoding.\n     * @param encoding the encoding to apply\n     * @param forceEncoding whether the specified encoding is supposed to\n     * override existing request and response encodings\n     * @since 4.2.3\n     * @see #setEncoding\n     * @see #setForceEncoding\n     */\n    public CharacterEncodingFilter(String encoding, boolean forceEncoding) &#123;\n        this(encoding, forceEncoding, forceEncoding);\n    &#125;\n\n    /**\n     * Create a &#123;@code CharacterEncodingFilter&#125; for the given encoding.\n     * @param encoding the encoding to apply\n     * @param forceRequestEncoding whether the specified encoding is supposed to\n     * override existing request encodings\n     * @param forceResponseEncoding whether the specified encoding is supposed to\n     * override existing response encodings\n     * @since 4.3\n     * @see #setEncoding\n     * @see #setForceRequestEncoding(boolean)\n     * @see #setForceResponseEncoding(boolean)\n     */\n    public CharacterEncodingFilter(String encoding, boolean forceRequestEncoding, boolean forceResponseEncoding) &#123;\n        Assert.hasLength(encoding, &quot;Encoding must not be empty&quot;);\n        this.encoding = encoding;\n        this.forceRequestEncoding = forceRequestEncoding;\n        this.forceResponseEncoding = forceResponseEncoding;\n    &#125;\n\n\n    /**\n     * Set the encoding to use for requests. This encoding will be passed into a\n     * &#123;@link jakarta.servlet.http.HttpServletRequest#setCharacterEncoding&#125; call.\n     * &lt;p&gt;Whether this encoding will override existing request encodings\n     * (and whether it will be applied as default response encoding as well)\n     * depends on the &#123;@link #setForceEncoding &quot;forceEncoding&quot;&#125; flag.\n     */\n    public void setEncoding(@Nullable String encoding) &#123;\n        this.encoding = encoding;\n    &#125;\n\n    /**\n     * Return the configured encoding for requests and/or responses.\n     * @since 4.3\n     */\n    @Nullable\n    public String getEncoding() &#123;\n        return this.encoding;\n    &#125;\n\n    /**\n     * Set whether the configured &#123;@link #setEncoding encoding&#125; of this filter\n     * is supposed to override existing request and response encodings.\n     * &lt;p&gt;Default is &quot;false&quot;, i.e. do not modify the encoding if\n     * &#123;@link jakarta.servlet.http.HttpServletRequest#getCharacterEncoding()&#125;\n     * returns a non-null value. Switch this to &quot;true&quot; to enforce the specified\n     * encoding in any case, applying it as default response encoding as well.\n     * &lt;p&gt;This is the equivalent to setting both &#123;@link #setForceRequestEncoding(boolean)&#125;\n     * and &#123;@link #setForceResponseEncoding(boolean)&#125;.\n     * @see #setForceRequestEncoding(boolean)\n     * @see #setForceResponseEncoding(boolean)\n     */\n    public void setForceEncoding(boolean forceEncoding) &#123;\n        this.forceRequestEncoding = forceEncoding;\n        this.forceResponseEncoding = forceEncoding;\n    &#125;\n\n    /**\n     * Set whether the configured &#123;@link #setEncoding encoding&#125; of this filter\n     * is supposed to override existing request encodings.\n     * &lt;p&gt;Default is &quot;false&quot;, i.e. do not modify the encoding if\n     * &#123;@link jakarta.servlet.http.HttpServletRequest#getCharacterEncoding()&#125;\n     * returns a non-null value. Switch this to &quot;true&quot; to enforce the specified\n     * encoding in any case.\n     * @since 4.3\n     */\n    public void setForceRequestEncoding(boolean forceRequestEncoding) &#123;\n        this.forceRequestEncoding = forceRequestEncoding;\n    &#125;\n\n    /**\n     * Return whether the encoding should be forced on requests.\n     * @since 4.3\n     */\n    public boolean isForceRequestEncoding() &#123;\n        return this.forceRequestEncoding;\n    &#125;\n\n    /**\n     * Set whether the configured &#123;@link #setEncoding encoding&#125; of this filter\n     * is supposed to override existing response encodings.\n     * &lt;p&gt;Default is &quot;false&quot;, i.e. do not modify the encoding.\n     * Switch this to &quot;true&quot; to enforce the specified encoding\n     * for responses in any case.\n     * @since 4.3\n     */\n    public void setForceResponseEncoding(boolean forceResponseEncoding) &#123;\n        this.forceResponseEncoding = forceResponseEncoding;\n    &#125;\n\n    /**\n     * Return whether the encoding should be forced on responses.\n     * @since 4.3\n     */\n    public boolean isForceResponseEncoding() &#123;\n        return this.forceResponseEncoding;\n    &#125;\n\n\n    @Override\n    protected void doFilterInternal(\n            HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n            throws ServletException, IOException &#123;\n\n        String encoding = getEncoding();\n        if (encoding != null) &#123;\n            if (isForceRequestEncoding() || request.getCharacterEncoding() == null) &#123;\n                request.setCharacterEncoding(encoding);\n            &#125;\n            if (isForceResponseEncoding()) &#123;\n                response.setCharacterEncoding(encoding);\n            &#125;\n        &#125;\n        filterChain.doFilter(request, response);\n    &#125;\n\n&#125;\n最核心的方法是：\njava@Override\nprotected void doFilterInternal(\n        HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n        throws ServletException, IOException &#123;\n\n    String encoding = getEncoding();\n    if (encoding != null) &#123;\n        if (isForceRequestEncoding() || request.getCharacterEncoding() == null) &#123;\n            request.setCharacterEncoding(encoding);\n        &#125;\n        if (isForceResponseEncoding()) &#123;\n            response.setCharacterEncoding(encoding);\n        &#125;\n    &#125;\n    filterChain.doFilter(request, response);\n&#125;分析以上核心方法得知该过滤器对请求和响应都设置了字符编码方式。\n\n当强行使用请求字符编码方式为true时，或者请求对象的字符编码方式为null时，设置请求的字符编码方式。\n当强行使用响应字符编码方式为true时，设置响应的字符编码方式。\n\n根据以上代码，可以得出以下配置信息，在web.xml文件中对过滤器进行如下配置：\nxml&lt;!--使用SpringMVC框架内置的字符编码过滤器--&gt;\n&lt;filter&gt;\n    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n    &lt;!--设置字符集--&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;/param-name&gt;\n        &lt;param-value&gt;UTF-8&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt;\n         &lt;!--让请求体的编码方式强行使用以上的字符集--&gt;\n        &lt;param-value&gt;true&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;\n        &lt;!--让响应体的编码方式强行使用以上的字符集--&gt;\n        &lt;param-value&gt;true&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;我们再来测试，重启Tomcat10，看看乱码是否能够解决？\n注意：针对于我们当前的Tomcat10的配置来说，它有默认的字符集ISO-8859-1，因此以下在web.xml文件中的配置是不能缺少的：\nxml&lt;init-param&gt;\n    &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt;\n    &lt;param-value&gt;true&lt;/param-value&gt;\n&lt;/init-param&gt;如果缺少它，仍然是会存在乱码问题的。自行测试一下！！！！\n\n五、三个域对象5.1、Servlet中的三个域对象\n请求域： request\n会话域： session\n应用域： application\n\n三个域都有以下三个方法：\njava// 向域中存储数据\nvoid setAttribute(String name, Object obj);\n\n// 从域中读取数据\nObject getAttribute(String name);\n\n// 删除域中的数据\nvoid removeAttribute(String name);主要是通过：setAttribute + getAttribute方法来完成在域中数据的传递和共享。\nrequest接口名：HttpServletRequest简称：requestrequest对象代表了一次请求。一次请求一个request。使用请求域的业务场景：在A资源中通过转发的方式跳转到B资源，因为是转发，因此从A到B是一次请求，如果想让A资源和B资源共享同一个数据，可以将数据存储到request域中。\nsession接口名：HttpSession简称：sessionsession对象代表了一次会话。从打开浏览器开始访问，到最终浏览器关闭，这是一次完整的会话。每个会话session对象都对应一个JSESSIONID，而JSESSIONID生成后以cookie的方式存储在浏览器客户端。浏览器关闭，JSESSIONID失效，会话结束。\n使用会话域的业务场景：\n\n在A资源中通过重定向的方式跳转到B资源，因为是重定向，因此从A到B是两次请求，如果想让A资源和B资源共享同一个数据，可以将数据存储到session域中。\n登录成功后保存用户的登录状态。\n\napplication接口名：ServletContext简称：applicationapplication对象代表了整个web应用，服务器启动时创建，服务器关闭时销毁。对于一个web应用来说，application对象只有一个。使用应用域的业务场景：记录网站的在线人数。\n5.2、request域对象\n\n\n\n\n\n\n\n\n笔记\n第一种方式：在SpringMVC中使用原生的Servlet API可以完成request域数据共享：在处理器方法上添加HttpServletRequest参数即可。\n第二种方式：在SpringMVC的处理器方法的参数上添加一个接口类型：Model\njava@RequestMapping(&quot;/testModel&quot;) \npublic String testModel(Model model)&#123;\n    //向equest:域当中存储数据 \n    model.addAttribute(&quot;name&quot;,value);\n    //转发 \n    return &quot;ok&quot;;\n&#125;第三种方式：在SpringMVC的处理器方法的梦效上漆加一个接口类型：Map \njava@RequestMapping(&quot;/testMap&quot;) \npublic String testMap(Map&lt;string,Object&gt;map)&#123;\n    //向request:域当中存储数据 \n    map.put(&quot;testRequestScope&quot;,&quot;在SpringMVC:当中使用Map接口完成request.域数据共享&quot;); \n    //转发 \n    return &quot;ok&quot;;\n&#125;第四种方式：在SpringMVC的处理器方法的参数上添加一个类型：ModelMap\njava@RequestMapping(&quot;/testModelMap&quot;) \npublic String testModelMap(ModelMap modelMap)&#123;\n    //向request域当中存储数据 \n    modelMap.addAttribute(&quot;testRequestScope&quot;,&quot;在SpringMVC:当中使用ModelMap类完成request:域数据共享&quot;)；\n    //转发 \n    return &quot;ok&quot;;\n&#125;研究一下：Model接口、Map接口、ModelMap:类，三者之间的关系？\n表面上使用的是不同的接口和不同的类。实际上底层都使用了同一个对象：org.springframework.validation,support.BindingAwareModelMap \n\nBindingAwareModelMap继承了ExtendedModelMap类 \nExtendedModelMap:继承了ModelMap类 \nExtendedModelMap实现了Model接口 \nModelMap类继承了LinkedHashMapa继承了HashMap实现了Map接口\n\n第五种方式：使用Spring MVC框架提供的ModelAndView类完成request域数据共享。\njava@RequestMapping(&quot;/testModelAndView&quot;) \npublic ModelAndView testModelAndView()&#123;\n    //创建模型视图对家 \n    ModelAndView mav new ModelAndview();\n    //给模型视图对象绑定数据 \n    mav.addObject(&quot;testRequestScope&quot;,&quot;在SpringMVC当中使用ModelAndView类完成equest域数据共享&quot;)；\n    //给模型视图对家绑定视图（绑定逻辑视图名称） \n    mav.setviewName(&quot;ok&quot;);\n    //返回模型视图对象 \n    return mav;\n&#125;细谈处理器 ：对于处理器方法来说，不管你使用的参数是Model接口，还是Map接口，还是ModelMap类，还是ModelAndView类，最终处理器方法执行结束之后，返回的都是ModeLAndView对象。这个返回的ModeLAndView对象给DispatcherServlet类了。\n\n当请求路径不是JSP的时候，都会走前端控制器DispatcherServlet。 \nDispatcherServlet中有一个核心方法doDispatch(),这个方法用来通过请求路径找到对应的处理器方法\n然后调用处理器方法，处理器方法返回一个逻辑视图名称（可能也会直接返回一个ModeLAndView对象）\n底层会将逻辑视图名称转换为View对象，然后将View对象结合Model对象，封装一个ModelAndView对象\n然后将该对象返回给DispatcherServlet类了。\n\n5.2.1、使用原生Servlet API方式在Controller的方法上使用HttpServletRequest：\njavapackage com.powernode.springmvc.controller;\n\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class RequestScopeTestController &#123;\n\n    @RequestMapping(&quot;/testServletAPI&quot;)\n    public String testServletAPI(HttpServletRequest request)&#123;\n        // 向request域中存储数据\n        request.setAttribute(&quot;testRequestScope&quot;, &quot;在SpringMVC中使用原生Servlet API实现request域数据共享&quot;);\n        return &quot;view&quot;;\n    &#125;\n&#125;页面：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;view&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div th:text=&quot;$&#123;testRequestScope&#125;&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;超链接：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;index&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Index Page&lt;/h1&gt;\n&lt;a th:href=&quot;@&#123;/testServletAPI&#125;&quot;&gt;在SpringMVC中使用原生Servlet API实现request域数据共享&lt;/a&gt;&lt;br&gt;\n&lt;/body&gt;\n&lt;/html&gt;测试结果：\n这种方式当然可以，用SpringMVC框架，不建议使用原生Servlet API。\n5.2.2、使用Model接口java@RequestMapping(&quot;/testModel&quot;)\npublic String testModel(Model model)&#123;\n    // 向request域中存储数据\n    model.addAttribute(&quot;testRequestScope&quot;, &quot;在SpringMVC中使用Model接口实现request域数据共享&quot;);\n    return &quot;view&quot;;\n&#125;5.2.3、使用Map接口java@RequestMapping(&quot;/testMap&quot;)\npublic String testMap(Map&lt;String, Object&gt; map)&#123;\n    // 向request域中存储数据\n    map.put(&quot;testRequestScope&quot;, &quot;在SpringMVC中使用Map接口实现request域数据共享&quot;);\n    return &quot;view&quot;;\n&#125;5.2.4、使用ModelMap类java@RequestMapping(&quot;/testModelMap&quot;)\npublic String testModelMap(ModelMap modelMap)&#123;\n    // 向request域中存储数据\n    modelMap.addAttribute(&quot;testRequestScope&quot;, &quot;在SpringMVC中使用ModelMap实现request域数据共享&quot;);\n    return &quot;view&quot;;\n&#125;Model、Map、ModelMap的关系可以在以上Model、Map、ModelMap的测试程序中将其输出，看看输出什么：看不出来什么区别，从输出结果上可以看到都是一样的。可以将其运行时类名输出：通过输出结果可以看出，无论是Model、Map还是ModelMap，底层实例化的对象都是：BindingAwareModelMap。\n可以查看BindingAwareModelMap的继承结构：通过继承结构可以看出：BindingAwareModelMap继承了ModelMap，而ModelMap又实现了Map接口。另外，请看以下源码：可以看出ModelMap又实现了Model接口。因此表面上是采用了不同方式，底层本质上是相同的。SpringMVC之所以提供了这些方式，目的就是方便程序员的使用，提供了多样化的方式，可见它的重要性。\n5.2.5、使用ModelAndView类在SpringMVC框架中为了更好的体现MVC架构模式，提供了一个类：ModelAndView。这个类的实例封装了Model和View。也就是说这个类既封装业务处理之后的数据，也体现了跳转到哪个视图。使用它也可以完成request域数据共享。\njava@RequestMapping(&quot;/testModelAndView&quot;)\npublic ModelAndView testModelAndView()&#123;\n    // 创建“模型与视图对象”\n    ModelAndView modelAndView = new ModelAndView();\n    // 绑定数据\n    modelAndView.addObject(&quot;testRequestScope&quot;, &quot;在SpringMVC中使用ModelAndView实现request域数据共享&quot;);\n    // 绑定视图\n    modelAndView.setViewName(&quot;view&quot;);\n    // 返回\n    return modelAndView;\n&#125;这种方式需要注意的是：\n\n方法的返回值类型不是String，而是ModelAndView对象。\nModelAndView不是出现在方法的参数位置，而是在方法体中new的。\n需要调用addObject向域中存储数据。\n需要调用setViewName设置视图的名字。\n\nModelAndView源码分析以上我们通过了五种方式完成了request域数据共享，包括：原生Servlet API，Model、Map、ModelMap、ModelAndView其中后四种：Model、Map、ModelMap、ModelAndView。这四种方式在底层DispatcherServlet调用我们的Controller之后，返回的对象都是ModelAndView，这个可以通过源码进行分析。\n在以上四种方式中，拿Model举例，添加断点进行调试：启动服务器，发送请求，走到断点：查看VM Stack信息：查看DispatcherServlet的1089行，源码如下：可以看到这里，无论你使用哪种方式，最终都要返回一个ModelAndView对象。\n提醒：可以通过以下断点调试方式，采用一级一级返回，最终可以看到都会返回ModelAndView对象。\n5.3、session域对象\n\n\n\n\n\n\n\n\n笔记\n第一种方式：使用原生的Servlet API实现。（在处理器方法的参数上添加一个HttpSession参数，SpringMVC会自动将session对象传递给这个参数。）\n第二种方式：使用@SessionAttributes注解标注Controller\n\n\n\n\n\n\n\n\n\n正文\n在SpringMVC中使用session域共享数据，实现方式有多种，其中比较常见的两种方式：\n\n使用原生Servlet API\n使用SessionAttributes注解\n\n使用原生Servlet APIjavapackage com.powernode.springmvc.controller;\n\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpSession;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class SessionScopeTestController &#123;\n\n    @RequestMapping(&quot;/testSessionScope1&quot;)\n    public String testServletAPI(HttpSession session) &#123;\n        // 向会话域中存储数据\n        session.setAttribute(&quot;testSessionScope1&quot;, &quot;使用原生Servlet API实现session域共享数据&quot;);\n        return &quot;view&quot;;\n    &#125;\n\n&#125;视图页面：\nhtml&lt;div th:text=&quot;$&#123;session.testSessionScope1&#125;&quot;&gt;&lt;/div&gt;超链接：\nhtml&lt;a th:href=&quot;@&#123;/testSessionScope1&#125;&quot;&gt;在SpringMVC中使用原生Servlet API实现session域共享数据&lt;/a&gt;&lt;br&gt;使用SessionAttributes注解使用SessionAttributes注解标注Controller：\njavapackage com.powernode.springmvc.controller;\n\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpSession;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.ModelMap;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.SessionAttributes;\n\n@Controller\n@SessionAttributes(value = &#123;&quot;x&quot;, &quot;y&quot;&#125;)\npublic class SessionScopeTestController &#123;\n\n    @RequestMapping(&quot;/testSessionScope2&quot;)\n    public String testSessionAttributes(ModelMap modelMap)&#123;\n        // 向session域中存储数据\n        modelMap.addAttribute(&quot;x&quot;, &quot;我是埃克斯&quot;);\n        modelMap.addAttribute(&quot;y&quot;, &quot;我是歪&quot;);\n\n        return &quot;view&quot;;\n    &#125;\n&#125;注意：SessionAttributes注解使用在Controller类上。标注了当key是 x 或者 y 时，数据将被存储到会话session中。如果没有 SessionAttributes注解，默认存储到request域中。\n5.4、application域对象\n\n\n\n\n\n\n\n\n笔记\n这个域使用较少，如果使用的话，一般是采用ServletAPI的方式使用。\njava@RequestMapping(&quot;/testApplicationScope&quot;) \npublic String testApplicationScope(HttpServletRequest request)&#123; \n    ServletContext application request.getServletContext(); \n    application.setAttribute(&quot;testApplicationScope&quot;,&quot;在SpringMVC中使用ServletAPI实现application:域共享&quot;); \n    return &quot;ok&quot;;\n&#125;\n\n\n\n\n\n\n\n\n正文\n在SpringMVC实现application域数据共享，最常见的方案就是直接使用Servlet API了：\njavapackage com.powernode.springmvc.controller;\n\nimport jakarta.servlet.ServletContext;\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class ApplicationScopeTestController &#123;\n\n    @RequestMapping(&quot;/testApplicationScope&quot;)\n    public String testApplicationScope(HttpServletRequest request)&#123;\n        \n        // 获取ServletContext对象\n        ServletContext application = request.getServletContext();\n\n        // 向应用域中存储数据\n        application.setAttribute(&quot;applicationScope&quot;, &quot;我是应用域当中的一条数据&quot;);\n\n        return &quot;view&quot;;\n    &#125;\n&#125;\n视图页面：\nhtml&lt;div th:text=&quot;$&#123;application.applicationScope&#125;&quot;&gt;&lt;/div&gt;超链接：\nhtml&lt;a th:href=&quot;@&#123;/testApplicationScope&#125;&quot;&gt;在SpringMVC中使用ServletAPI实现application域共享数据&lt;/a&gt;&lt;br&gt;\n六、视图View","slug":"SpringMVC","date":"2024-04-01T16:00:00.000Z","categories_index":"微服务核心","tags_index":"微服务核心","author_index":"白"},{"id":"296ab6abbec13485535e694ff062888e","title":"算法学习_栈与队列篇","content":"算法学习_栈与队列篇学习至：代码随想录 (programmercarl.com)\n用栈实现队列力扣题目链接\n题目\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n说明：\n\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n示例 1：\nshell输入：\n[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false思路\n这是一道模拟题，不涉及到具体算法，考察的就是对栈和队列的掌握程度。使用栈来模式队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈一个输入栈，一个输出栈，这里要注意输入栈和输出栈的关系。\n下面动画模拟以下队列的执行过程：\n执行语句：\n\nqueue.push(1);\nqueue.push(2);\nqueue.pop(); 注意此时的输出栈的操作\nqueue.push(3);\nqueue.push(4);\nqueue.pop();\nqueue.pop();注意此时的输出栈的操作\nqueue.pop();\nqueue.empty();\n\n\n在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。\n最后如何判断队列为空呢？如果进栈和出栈都为空的话，说明模拟的队列为空了。\n在代码实现的时候，会发现pop() 和 peek()两个函数功能类似，代码实现上也是类似的，可以思考一下如何把代码抽象一下。\n代码实现\njavaclass MyQueue &#123;\n    //使用栈实现队列\n    Stack&lt;Integer&gt; stackIn;\n    Stack&lt;Integer&gt; stackOut;\n\n    public MyQueue() &#123;\n        stackIn = new Stack&lt;&gt;(); //负责入栈操作\n        stackOut = new Stack&lt;&gt;(); //负责出栈操作\n    &#125;\n\n    public void push(int x) &#123;\n        stackIn.push(x);\n    &#125;\n\n    public int pop() &#123;\n        dumpstackIn();\n        return stackOut.pop();\n    &#125;\n\n    public int peek() &#123;\n        dumpstackIn();\n        return stackOut.peek();\n    &#125;\n\n    public boolean empty() &#123;\n        return stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();\n    &#125;\n\n    //如果stackOut为空,那么将stackIn中的元素全部放到stackOut中\n    private void dumpstackIn()&#123;\n        if(!stackOut.isEmpty()) return;\n        while (!stackIn.isEmpty())&#123;\n            stackOut.push(stackIn.pop());\n        &#125;\n    &#125;\n&#125;\n用队列实现栈力扣题目链接\n题目\n请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\n实现 MyStack 类：\n\nvoid push(int x) 将元素 x 压入栈顶。\nint pop() 移除并返回栈顶元素。\nint top() 返回栈顶元素。\nboolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n注意：\n\n你只能使用队列的标准操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。\n你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n\n示例：\nshell输入：\n[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 2, 2, false]\n\n解释：\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // 返回 2\nmyStack.pop(); // 返回 2\nmyStack.empty(); // 返回 False思路一\n\n队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。\n所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。\n但是依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，而是另一个队列完全用来备份的！\n如下面动画所示，用两个队列que1和que2实现队列的功能，que2其实完全就是一个备份的作用，把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。\n\n模拟的队列执行语句如下：\ncppqueue.push(1);        \nqueue.push(2);        \nqueue.pop();   // 注意弹出的操作       \nqueue.push(3);        \nqueue.push(4);       \nqueue.pop();  // 注意弹出的操作    \nqueue.pop();    \nqueue.pop();    \nqueue.empty();    \n代码实现\njavaclass MyStack &#123;\n\n    Queue&lt;Integer&gt; queue1; //和栈中保持一样元素的队列\n    Queue&lt;Integer&gt; queue2; //辅助队列\n\n    public MyStack() &#123;\n        queue1 = new LinkedList&lt;&gt;();\n        queue2 = new LinkedList&lt;&gt;();\n    &#125;\n\n    public void push(int x) &#123;\n        //将新元素放入辅助队列，再把原队列的数据加载到辅助队列，最后交换两个队列实现\n        queue2.offer(x);\n        while (!queue1.isEmpty()) &#123;\n            queue2.offer(queue1.poll());\n        &#125;\n        //交换两个队列\n        Queue&lt;Integer&gt; queueTemp;\n        queueTemp = queue1;\n        queue1 = queue2;\n        queue2 = queueTemp;\n    &#125;\n\n    public int pop() &#123;\n        return queue1.poll();\n    &#125;\n\n    public int top() &#123;\n        return queue1.peek();\n    &#125;\n\n    public boolean empty() &#123;\n        return queue1.isEmpty();\n    &#125;\n&#125;思路二\n一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。\n代码实现\njavaclass MyStack &#123;\n\n    Queue&lt;Integer&gt; queue1; //队列\n\n    public MyStack() &#123;\n        queue1 = new LinkedList&lt;&gt;();\n    &#125;\n\n    public void push(int x) &#123;\n        queue1.offer(x);\n    &#125;\n\n    public int pop() &#123;\n        rePosition();\n        return queue1.poll();\n    &#125;\n\n    public int top() &#123;\n        rePosition();\n        int result = queue1.poll();\n        queue1.offer(result);\n        return result;\n    &#125;\n\n    public boolean empty() &#123;\n        return queue1.isEmpty();\n    &#125;\n\n    private void rePosition() &#123;\n        //除了最后一个元素弹出，前面的元素重新加入队列就行了\n        int size = queue1.size() - 1;\n        //size减1就可以让前面的元素重新加入到后面\n        while (size-- &gt; 0) &#123;\n            queue1.offer(queue1.poll());\n        &#125;\n    &#125;\n&#125;\n有效的括号20. 有效的括号 - 力扣（LeetCode）\n题目\n给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。\n\n示例 1：\ntxt输入：s = &quot;()&quot;\n输出：true示例 2：\ntxt输入：s = &quot;()[]&#123;&#125;&quot;\n输出：true示例 3：\ntxt输入：s = &quot;(]&quot;\n输出：false思路\n\n由于栈结构的特殊性，非常适合做对称匹配类的题目。\n首先要弄清楚，字符串里的括号不匹配有几种情况。\n建议在写代码之前要分析好有哪几种不匹配的情况，如果不在动手之前分析好，写出的代码也会有很多问题。\n\n先来分析一下 这里有三种不匹配的情况，\n\n第一种情况，字符串里左方向的括号多余了 ，所以不匹配。 \n第二种情况，括号没有多余，但是 括号的类型没有匹配上。 \n第三种情况，字符串里右方向的括号多余了，所以不匹配。 \n\n我们的代码只要覆盖了这三种不匹配的情况，就不会出问题，可以看出 动手之前分析好题目的重要性。\n动画如下：\n\n第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false\n第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false\n第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false\n那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。\n分析完之后，代码其实就比较好写了，但还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！\n代码实现\njavaclass Solution &#123;\n    public boolean isValid(String s) &#123;\n        //设置一个栈来存储符号\n        Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;();\n        //ch表示当前字符\n        char ch;\n        //遍历字符串\n        for (int i = 0; i &lt; s.length(); i++) &#123;\n            ch = s.charAt(i);\n            //如果是左括号就将他对应的右括号进栈\n            if (ch == &#39;(&#39;) &#123;\n                deque.push(&#39;)&#39;);\n            &#125; else if (ch == &#39;&#123;&#39;) &#123;\n                deque.push(&#39;&#125;&#39;);\n            &#125; else if (ch == &#39;[&#39;) &#123;\n                deque.push(&#39;]&#39;);\n            &#125;//如果是右括号就与栈顶符号匹配\n            else if (deque.isEmpty() || deque.peek() != ch)&#123;\n                //匹配失败直接返回false\n                return false;\n            &#125; else &#123; //匹配成功将栈顶元素出栈\n                deque.pop();\n            &#125;\n        &#125;\n        //最后判断栈中是否还有元素\n        return deque.isEmpty();\n    &#125;\n&#125;\n删除字符串中的所有相邻重复项1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）\n题目\n给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。\n在 S 上反复执行重复项删除操作，直到无法继续删除。\n在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n示例：\ntxt输入：&quot;abbaca&quot;\n输出：&quot;ca&quot;\n解释：\n例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。思路\n我们在删除相邻重复项的时候，其实就是要知道当前遍历的这个元素，我们在前一位是不是遍历过一样数值的元素，那么如何记录前面遍历过的元素呢？\n所以就是用栈来存放，那么栈的目的，就是存放遍历过的元素，当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素。\n然后再去做对应的消除操作。 如动画所示：\n\n从栈中弹出剩余元素，此时是字符串ac，因为从栈里弹出的元素是倒序的，所以再对字符串进行反转一下，就得到了最终的结果。\n代码实现\njavaclass Solution &#123;\n    public String removeDuplicates(String s) &#123;\n        //设置栈操作字符串\n        ArrayDeque&lt;Character&gt; deque = new ArrayDeque&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) &#123;\n            char ch = s.charAt(i);\n            //判断进栈字符是否与栈顶字符相同,相同则出栈\n            if (deque.isEmpty() || ch != deque.peek()) &#123;\n                deque.push(ch);\n            &#125; else &#123;\n                deque.pop();\n            &#125;\n        &#125;\n        String str = &quot;&quot;;\n        //提前栈内字符添加到str中\n        while (!deque.isEmpty()) &#123;\n            str = deque.pop() + str;\n        &#125;\n        return str;\n    &#125;\n&#125;\n逆波兰表达式求值150. 逆波兰表达式求值 - 力扣（LeetCode）\n题目\n给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。\n请你计算该表达式。返回一个表示表达式值的整数。\n注意：\n\n有效的算符为 &#39;+&#39;、&#39;-&#39;、&#39;*&#39; 和 &#39;/&#39; 。\n每个操作数（运算对象）都可以是一个整数或者另一个表达式。\n两个整数之间的除法总是 向零截断 。\n表达式中不含除零运算。\n输入是一个根据逆波兰表示法表示的算术表达式。\n答案及所有中间计算结果可以用 32 位 整数表示。\n\n示例 1：\ntxt输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n输出：9\n解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9示例 2：\ntxt输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\n输出：6\n解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6示例 3：\ntxt输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n输出：22\n解释：该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22思路\n其实逆波兰表达式相当于是二叉树中的后序遍历。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。\n但我们没有必要从二叉树的角度去解决这个问题，只要知道逆波兰表达式是用后序遍历的方式把二叉树序列化了，就可以了。\n在进一步看，本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么这岂不就是一个相邻字符串消除的过程\n如动画所示： \n\n\n滑动窗口最大值239. 滑动窗口最大值 - 力扣（LeetCode）\n题目\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n示例 1：\ntxt输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7示例 2：\ntxt输入：nums = [1], k = 1\n输出：[1]思路\n使用单调队列的经典题目。\n\n\n\n\n\n\n\n\n\n我们希望每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。然后再分析一下，队列里的元素一定是要排序的，而且要最大值放在出队口，要不然怎么知道最大值呢。但如果把窗口里的元素都放进队列里，窗口移动的时候，队列需要弹出元素。那么问题来了，已经排序之后的队列 怎么能把窗口要移除的元素（这个元素可不一定是最大值）弹出呢。\n其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。\n那么这个维护元素单调递减的队列就叫做单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来实现一个单调队列\n不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。\n单调队列如何维护队列里的元素。\n动画如下：\n\n对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。\n设计单调队列的时候，pop，和push操作要保持如下规则：\n\npop(value) ：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作\npush(value) ：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止\n\n保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。\n为了更直观的感受到单调队列的工作过程，以题目示例为例，输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3，动画如下：\n\n用deque实现了一个单调队列，接下来解决滑动窗口最大值的问题就很简单了\njava//自定义数组(单调队列)\nclass MyQueue &#123;\n    //设置自定义方法,注意此时该队列是双端队列\n    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();\n\n    //弹出元素时,比较当前弹出的数值是否等于队列出口的数值,如果相等则弹出\n    void poll(int val) &#123;\n        if (!deque.isEmpty() &amp;&amp; val == deque.peek()) &#123;\n            deque.poll();\n        &#125;\n    &#125;\n\n    //添加元素时,如果添加的元素大于入口处的元素,则将入口元素弹出\n    //保证队列元素单调递减\n    //比如此时队列元素3,1 2将要入队,比1大,所以1弹出,此时队列为3,2\n    void add(int val) &#123;\n        while (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;\n            deque.removeLast();\n        &#125;\n        deque.add(val);\n    &#125;\n\n    //队列队顶元素为最大值\n    int peek() &#123;\n        return deque.peek();\n    &#125;\n&#125;代码实现\njava//自定义数组(单调队列)\nclass MyQueue &#123;\n    //设置自定义方法,注意此时该队列是双端队列\n    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();\n\n    //弹出元素时,比较当前弹出的数值是否等于队列出口的数值,如果相等则弹出\n    void poll(int val) &#123;\n        if (!deque.isEmpty() &amp;&amp; val == deque.peek()) &#123;\n            deque.poll();\n        &#125;\n    &#125;\n\n    //添加元素时,如果添加的元素大于入口处的元素,则将入口元素弹出\n    //保证队列元素单调递减\n    //比如此时队列元素3,1 2将要入队,比1大,所以1弹出,此时队列为3,2\n    void add(int val) &#123;\n        while (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;\n            deque.removeLast();\n        &#125;\n        deque.add(val);\n    &#125;\n\n    //队列队顶元素为最大值\n    int peek() &#123;\n        return deque.peek();\n    &#125;\n&#125;\nclass Solution &#123;\n    public int[] maxSlidingWindow(int[] nums, int k) &#123;\n        if (nums.length == 1) &#123;\n            return nums;\n        &#125;\n        //计算返回数组的长度\n        int len = nums.length - k + 1;\n        //设置返回数组\n        int[] result = new int[len];\n        int num = 0;\n        //创建单调队列,对数组操作\n        MyQueue myQueue = new MyQueue();\n\n        //先添加第一个滑动窗口,然后再遍历数组\n        for (int i = 0; i &lt; k; i++) &#123;\n            myQueue.add(nums[i]);\n        &#125;\n        result[num++] = myQueue.peek();\n\n        //遍历后续数组\n        for (int i = k; i &lt; nums.length; i++) &#123;\n            //滑动窗口移除最前面的元素,移除是判断该元素是否放入队列\n            myQueue.poll(nums[i - k]);\n            //滑动窗口加入最后面的元素\n            myQueue.add(nums[i]);\n            //记录对应的最大值\n            result[num++] = myQueue.peek();\n        &#125;\n        return result;\n    &#125;\n&#125;\n前 K 个高频元素347. 前 K 个高频元素 - 力扣（LeetCode）\n题目\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n示例 1:\ntxt输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]示例 2:\ntxt输入: nums = [1], k = 1\n输出: [1]思路\n这道题目主要涉及到如下三块内容：\n\n要统计元素出现频率\n对频率排序\n找出前K个高频元素\n\n首先统计元素出现的频率，这一类的问题可以使用map来进行统计。\n然后是对频率进行排序，这里我们可以使用一种 容器适配器就是优先级队列。\n什么是优先级队列呢？\n其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？\n缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。\n什么是堆呢？\n堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。\n所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。\n本题我们就要使用优先级队列来对部分频率进行排序。\n为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。\n此时要思考一下，是使用小顶堆呢，还是大顶堆？\n问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。\n而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？\n所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。\n寻找前k个最大元素流程如图所示：（图中的频率只有三个，所以正好构成一个大小为3的小顶堆，如果频率更多一些，则用这个小顶堆进行扫描）\n\n代码实现\njavaclass Solution &#123;\n    //使用小顶堆实现\n    public int[] topKFrequent(int[] nums, int k) &#123;\n        //key表示数组元素,val表示出现次数\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        //先将所有nums数组元素添加到map中,再构建小顶堆\n        for (int num : nums) &#123;\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        &#125;\n\n        //在优先队列中存储二元组(num, cnt) cnt表示元素值num在数组中出现次数\n        //出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)\n        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair1[1]-pair2[1]);\n\n        //小顶堆只维护高频的k个元素(遍历map中每个键值对,根据条件添加到小顶堆中)\n        for (Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet()) &#123;\n            //添加至k个元素\n            if(pq.size()&lt;k)&#123;\n                pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);\n            &#125; else &#123;\n                //大于k个元素则需要判断\n                if(entry.getValue() &gt; pq.peek()[1]) &#123;\n                    pq.poll(); //弹出小顶堆的根节点,即堆出现最少的元素\n                    pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);\n                &#125;\n            &#125;\n        &#125;\n        int[] ans = new int[k];\n        //依次弹出小顶堆\n        for (int i = 0; i &lt; k; i++) &#123;\n            ans[i] = pq.poll()[0];\n        &#125;\n        return ans;\n    &#125;\n&#125;\n栈与队列总结篇栈与队列的理论基础首先我们在栈与队列：来看看栈和队列不为人知的一面 (opens new window)中讲解了栈和队列的理论基础。\n里面提到了灵魂四问：\n\nC++中stack，queue 是容器么？\n我们使用的stack，queue是属于那个版本的STL？\n我们使用的STL中stack，queue是如何实现的？\nstack，queue 提供迭代器来遍历空间么？\n\n相信不仅仅是C++中有这些问题，那么大家使用其他编程语言，也可以考虑一下这四个问题，栈和队列是如何实现的。\n栈与队列是我们熟悉的不能再熟悉的数据结构，但它们的底层实现，很多同学都比较模糊，这其实就是基础所在。\n可以出一道面试题：栈里面的元素在内存中是连续分布的么？\n这个问题有两个陷阱：\n\n陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。\n陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。\n\n所以这就是考察候选者基础知识扎不扎实的好问题。\n大家还是要多多重视起来！\n了解了栈与队列基础之后，那么可以用栈与队列：栈实现队列 (opens new window)和 栈与队列：队列实现栈 (opens new window)来练习一下栈与队列的基本操作。\n值得一提的是，用栈与队列：用队列实现栈还有点别扭 (opens new window)中，其实只用一个队列就够了。\n一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。\n#栈经典题目#栈在系统中的应用如果还记得编译原理的话，编译器在词法分析的过程中处理括号、花括号等这个符号的逻辑，就是使用了栈这种数据结构。\n再举个例子，linux系统中，cd这个进入目录的命令我们应该再熟悉不过了。\ntxtcd a/b/c/../../这个命令最后进入a目录，系统是如何知道进入了a目录呢 ，这就是栈的应用。这在leetcode上也是一道题目，编号：71. 简化路径，大家有空可以做一下。\n递归的实现是栈：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n所以栈在计算机领域中应用是非常广泛的。\n有的同学经常会想学的这些数据结构有什么用，也开发不了什么软件，大多数同学说的软件应该都是可视化的软件例如APP、网站之类的，那都是非常上层的应用了，底层很多功能的实现都是基础的数据结构和算法。\n所以数据结构与算法的应用往往隐藏在我们看不到的地方！\n#括号匹配问题在栈与队列：系统中处处都是栈的应用 (opens new window)中我们讲解了括号匹配问题。\n括号匹配是使用栈解决的经典问题。\n建议要写代码之前要分析好有哪几种不匹配的情况，如果不动手之前分析好，写出的代码也会有很多问题。\n先来分析一下 这里有三种不匹配的情况，\n\n第一种情况，字符串里左方向的括号多余了，所以不匹配。\n第二种情况，括号没有多余，但是括号的类型没有匹配上。\n第三种情况，字符串里右方向的括号多余了，所以不匹配。\n\n这里还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！\n#字符串去重问题在栈与队列：匹配问题都是栈的强项 (opens new window)中讲解了字符串去重问题。 1047. 删除字符串中的所有相邻重复项\n思路就是可以把字符串顺序放到一个栈中，然后如果相同的话 栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。\n#逆波兰表达式问题在栈与队列：有没有想过计算机是如何处理表达式的？ (opens new window)中讲解了求逆波兰表达式。\n本题中每一个子表达式要得出一个结果，然后拿这个结果再进行运算，那么这岂不就是一个相邻字符串消除的过程，和栈与队列：匹配问题都是栈的强项 (opens new window)中的对对碰游戏是不是就非常像了。\n#队列的经典题目#滑动窗口最大值问题在栈与队列：滑动窗口里求最大值引出一个重要数据结构 (opens new window)中讲解了一种数据结构：单调队列。\n这道题目还是比较绕的，如果第一次遇到这种题目，需要反复琢磨琢磨\n主要思想是队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。\n那么这个维护元素单调递减的队列就叫做单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来一个单调队列\n而且不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。\n设计单调队列的时候，pop，和push操作要保持如下规则：\n\npop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作\npush(value)：如果push的元素value大于入口元素的数值，那么就将队列出口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止\n\n保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。\n一些同学还会对单调队列都有一些困惑，首先要明确的是，题解中单调队列里的pop和push接口，仅适用于本题。\n单调队列不是一成不变的，而是不同场景不同写法，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。\n不要以为本地中的单调队列实现就是固定的写法。\n我们用deque作为单调队列的底层数据结构，C++中deque是stack和queue默认的底层实现容器（这个我们之前已经讲过），deque是可以两边扩展的，而且deque里元素并不是严格的连续分布的。\n#求前 K 个高频元素在栈与队列：求前 K 个高频元素和队列有啥关系？ (opens new window)中讲解了求前 K 个高频元素。\n通过求前 K 个高频元素，引出另一种队列就是优先级队列。\n什么是优先级队列呢？\n其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。\n而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？\n缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。\n什么是堆呢？\n堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。\n所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。\n本题就要使用优先级队列来对部分频率进行排序。 注意这里是对部分数据进行排序而不需要对所有数据排序！\n所以排序的过程的时间复杂度是$O(\\log k)$，整个算法的时间复杂度是$O(n\\log k)$。\n#总结在栈与队列系列中，我们强调栈与队列的基础，也是很多同学容易忽视的点。\n使用抽象程度越高的语言，越容易忽视其底层实现，而C++相对来说是比较接近底层的语言。\n我们用栈实现队列，用队列实现栈来掌握的栈与队列的基本操作。\n接着，通过括号匹配问题、字符串去重问题、逆波兰表达式问题来系统讲解了栈在系统中的应用，以及使用技巧。\n通过求滑动窗口最大值，以及前K个高频元素介绍了两种队列：单调队列和优先级队列，这是特殊场景解决问题的利器，是一定要掌握的。\n","slug":"算法-栈与队列","date":"2024-03-28T08:32:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"白"},{"id":"0ded6c408c7bac1aa77b69264ee6a81d","title":"Spring6篇","content":"Spring6学习篇章1、概述1.1、Spring是什么？Spring 是一款主流的 Java EE 轻量级开源框架 ，Spring 由“Spring 之父”Rod Johnson 提出并创立，其目的是用于简化 Java 企业级应用的开发难度和开发周期。Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。\nSpring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE 代名词，成为了构建 Java EE 应用的事实标准。\n自 2004 年 4 月，Spring 1.0 版本正式发布以来，Spring 已经步入到了第 6 个大版本，也就是 Spring 6。本课程采用Spring当前最新发布的正式版本6.0.2。\n\n1.2、Spring 的狭义和广义在不同的语境中，Spring 所代表的含义是不同的。下面我们就分别从“广义”和“狭义”两个角度，对 Spring 进行介绍。\n广义的 Spring：Spring 技术栈\n\n广义上的 Spring 泛指以 Spring Framework 为核心的 Spring 技术栈。\n经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。\n这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。\n\n狭义的 Spring：Spring Framework\n\n狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。\nSpring 框架是一个分层的、面向切面的 Java 应用程序的一站式轻量级解决方案，它是 Spring 技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。\n\nSpring 有两个最核心模块： IoC 和 AOP。\nIoC：Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。\nAOP：Aspect Oriented Programming 的简写，译为“面向切面编程”。AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。\n1.3、Spring Framework特点\n非侵入式 ：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。\n控制反转 ：IoC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。\n面向切面编程 ：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。\n容器 ：Spring IoC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。\n组件化 ：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。\n一站式 ：在 IoC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。\n\n1.4、Spring模块组成官网地址：https://spring.io/\n\n\n上图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。\n①Spring Core（核心容器）\nspring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念： Beans、BeanFactory、BeanDefinitions、ApplicationContext。\n\nspring-core ：IOC和DI的基本实现\n\nspring-beans：BeanFactory和Bean的装配管理(BeanFactory)\n\nspring-context：Spring context上下文，即IOC容器(AppliactionContext)\n\nspring-expression：spring表达式语言\n\n\n②Spring AOP\n\nspring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy\nspring-aspects：集成AspectJ，AOP应用框架\nspring-instrument：动态Class Loading模块\n\n③Spring Data Access\n\nspring-jdbc：spring对JDBC的封装，用于简化jdbc操作\nspring-orm：java对象与数据库数据的映射框架\nspring-oxm：对象与xml文件的映射框架\nspring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信\nspring-tx：spring jdbc事务管理\n\n④Spring Web\n\nspring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器\nspring-webmvc：实现web mvc\nspring-websocket：与前端的全双工通信协议\nspring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive Web框架，异步，非阻塞，事件驱动的服务\n\n⑤Spring Message\n\nSpring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务\n\n⑥Spring test\n\nspring-test：集成测试支持，主要是对junit的封装\n\n1.5、Spring6特点1.5.1、版本要求（1）Spring6要求JDK最低版本是JDK17\n\n1.5.2、软件版本（1）IDEA开发工具：2022.1.2\n（2）JDK：Java17（Spring6要求JDK最低版本是Java17）\n（3）Spring：6.0.2\n\n2、入门入门案例开发步骤\n\n\n2.1、环境要求\nJDK：Java17+（Spring6要求JDK最低版本是Java17）\n\nMaven：3.6+\n\nSpring：6.0.2\n\n\n2.2、构建模块（1）构建父模块spring6\n在idea中，依次单击 File -&gt; New -&gt; Project -&gt; New Project\n\n点击“Create”\n\n删除src目录\n（2）构建子模块spring6-first\n\n点击 Create 完成\n\n2.3、程序开发2.3.1、引入依赖https://spring.io/projects/spring-framework#learn\n添加依赖：\nxml&lt;dependencies&gt;\n    &lt;!--spring context依赖--&gt;\n    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;version&gt;6.0.2&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--junit5测试--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n        &lt;version&gt;5.3.1&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;查看依赖：\n\n2.3.2、创建java类javapackage com.atguigu.spring6.bean;\n\npublic class HelloWorld &#123;\n    \n    public void sayHello()&#123;\n        System.out.println(&quot;helloworld&quot;);\n    &#125;\n&#125;2.3.3、创建配置文件在resources目录创建一个 Spring 配置文件 beans.xml（配置文件名称可随意命名，如：springs.xm）\n\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;!--\n    配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理\n    通过bean标签配置IOC容器所管理的bean\n    属性：\n        id：设置bean的唯一标识\n        class：设置bean所对应类型的全类名\n    --&gt;\n    &lt;bean id=&quot;helloWorld&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt;\n    \n&lt;/beans&gt;2.3.4、创建测试类测试javapackage com.atguigu.spring6.bean;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class HelloWorldTest &#123;\n\n    @Test\n    public void testHelloWorld()&#123;\n        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        HelloWorld helloworld = (HelloWorld) ac.getBean(&quot;helloWorld&quot;);\n        helloworld.sayHello();\n    &#125;\n&#125;2.3.5、运行测试程序\n2.4、程序分析1、底层是怎么创建对象的，是通过反射机制调用无参数构造方法吗？\n修改HelloWorld类：\njavapackage com.atguigu.spring6.bean;\n\npublic class HelloWorld &#123;\n\n    public HelloWorld() &#123;\n        System.out.println(&quot;无参数构造方法执行&quot;);\n    &#125;\n\n    public void sayHello()&#123;\n        System.out.println(&quot;helloworld&quot;);\n    &#125;\n&#125;执行结果：\n\n测试得知：创建对象时确实调用了无参数构造方法。\n2、 Spring是如何创建对象的呢？原理是什么？\njava// dom4j解析beans.xml文件，从中获取class属性值，类的全类名\n // 通过反射机制调用无参数构造方法创建对象\n Class clazz = Class.forName(&quot;com.atguigu.spring6.bean.HelloWorld&quot;);\n //Object obj = clazz.newInstance();\n Object object = clazz.getDeclaredConstructor().newInstance();3、 把创建好的对象存储到一个什么样的数据结构当中了呢？\nbean对象最终存储在spring容器中，在spring源码底层就是一个map集合，存储bean的map在DefaultListableBeanFactory类中：\njavaprivate final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);Spring容器加载到Bean类时 , 会把这个类的描述信息, 以包名加类名的方式存到beanDefinitionMap 中,Map&lt;String,BeanDefinition&gt; , 其中 String是Key , 默认是类名首字母小写 , BeanDefinition , 存的是类的定义(描述信息) , 我们通常叫BeanDefinition接口为 : bean的定义对象。\n2.5、启用Log4j2日志框架2.5.1、Log4j2日志概述在项目开发中，日志十分的重要，不管是记录运行情况还是定位线上问题，都离不开对日志的分析。日志记录了系统行为的时间、地点、状态等相关信息，能够帮助我们了解并监控系统状态，在发生错误或者接近某种危险状态时能够及时提醒我们处理，同时在系统产生问题时，能够帮助我们快速的定位、诊断并解决问题。\nApache Log4j2是一个开源的日志记录组件，使用非常的广泛。在工程中以易用方便代替了 System.out 等打印语句，它是JAVA下最流行的日志输入工具。 \nLog4j2主要由几个重要的组件构成：\n（1）日志信息的优先级，日志信息的优先级从高到低有TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL\n\n​                TRACE ：追踪，是最低的日志级别，相当于追踪程序的执行\n​                DEBUG ：调试，一般在开发中，都将其设置为最低的日志级别\n​                INFO ：信息，输出重要的信息，使用较多\n​                WARN ：警告，输出警告的信息\n​                ERROR ：错误，输出错误信息\n​                FATAL ：严重错误\n\n这些级别分别用来指定这条日志信息的重要程度；级别高的会自动屏蔽级别低的日志，也就是说，设置了WARN的日志，则INFO、DEBUG的日志级别的日志不会显示\n（2）日志信息的输出目的地，日志信息的输出目的地指定了日志将打印到控制台还是文件中；\n（3）日志信息的输出格式，而输出格式则控制了日志信息的显示内容。\n2.5.2、引入Log4j2依赖xml&lt;!--log4j2的依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n    &lt;version&gt;2.19.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;\n    &lt;version&gt;2.19.0&lt;/version&gt;\n&lt;/dependency&gt;2.5.3、加入日志配置文件在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，文件必须放到类根路径下。）\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;configuration&gt;\n    &lt;loggers&gt;\n        &lt;!--\n            level指定日志级别，从低到高的优先级：\n                TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL\n                trace：追踪，是最低的日志级别，相当于追踪程序的执行\n                debug：调试，一般在开发中，都将其设置为最低的日志级别\n                info：信息，输出重要的信息，使用较多\n                warn：警告，输出警告的信息\n                error：错误，输出错误信息\n                fatal：严重错误\n        --&gt;\n        &lt;root level=&quot;DEBUG&quot;&gt;\n            &lt;appender-ref ref=&quot;spring6log&quot;/&gt;\n            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;\n            &lt;appender-ref ref=&quot;log&quot;/&gt;\n        &lt;/root&gt;\n    &lt;/loggers&gt;\n\n    &lt;appenders&gt;\n        &lt;!--输出日志信息到控制台--&gt;\n        &lt;console name=&quot;spring6log&quot; target=&quot;SYSTEM_OUT&quot;&gt;\n            &lt;!--控制日志输出的格式--&gt;\n            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t] %-3level %logger&#123;1024&#125; - %msg%n&quot;/&gt;\n        &lt;/console&gt;\n\n        &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;\n        &lt;File name=&quot;log&quot; fileName=&quot;d:/spring6_log/test.log&quot; append=&quot;false&quot;&gt;\n            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;\n        &lt;/File&gt;\n\n        &lt;!-- 这个会打印出所有的信息，\n            每次大小超过size，\n            则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，\n            作为存档--&gt;\n        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;d:/spring6_log/app.log&quot;\n                     filePattern=&quot;log/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;\n            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd &#39;at&#39; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;\n            &lt;SizeBasedTriggeringPolicy size=&quot;50MB&quot;/&gt;\n            &lt;!-- DefaultRolloverStrategy属性如不设置，\n            则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;\n            &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt;\n        &lt;/RollingFile&gt;\n    &lt;/appenders&gt;\n&lt;/configuration&gt;2.5.4、测试运行原测试程序\n\n运行原测试程序，多了spring打印日志\n2.5.5、使用日志javapublic class HelloWorldTest &#123;\n\n    private Logger logger = LoggerFactory.getLogger(HelloWorldTest.class);\n\n    @Test\n    public void testHelloWorld()&#123;\n        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        HelloWorld helloworld = (HelloWorld) ac.getBean(&quot;helloWorld&quot;);\n        helloworld.sayHello();\n        logger.info(&quot;执行成功&quot;);\n    &#125;\n&#125;控制台：\n\n\n3、容器：IoC简要介绍\n\nIoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。\nSpring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。\nIoC 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。\n\n3.1、IoC容器3.1.1、控制反转（IoC）\n控制反转是一种思想。\n\n控制反转是为了降低程序耦合度，提高程序扩展力。\n\n控制反转，反转的是什么？\n\n将对象的创建权利交出去，交给第三方容器负责。\n\n将对象和对象之间关系的维护权交出去，交给第三方容器负责。\n\n\n\n控制反转这种思想如何实现呢？\n\nDI（Dependency Injection）：依赖注入\n\n\n\n3.1.2、依赖注入DI（Dependency Injection）：依赖注入，依赖注入实现了控制反转的思想。\n依赖注入：\n\n指Spring创建对象的过程中，将对象依赖属性通过配置进行注入\n\n依赖注入常见的实现方式包括两种：\n\n第一种：set注入\n第二种：构造注入\n\n所以结论是：IOC 就是一种控制反转的思想， 而 DI 是对IoC的一种具体实现。\nBean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。\n3.1.3、IoC容器在Spring的实现Spring 的 IoC 容器就是 IoC思想的一个落地的产品实现。IoC容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建IoC 容器。Spring 提供了IoC 容器的两种实现方式：\n①BeanFactory\n这是 IoC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。\n②ApplicationContext\nBeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。\n③ApplicationContext的主要实现类\n\n\n\n\n类型名\n简介\n\n\n\nClassPathXmlApplicationContext\n通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象\n\n\nFileSystemXmlApplicationContext\n通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象\n\n\nConfigurableApplicationContext\nApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。\n\n\nWebApplicationContext\n专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。\n\n\n3.2、基于XML管理Bean3.2.1、搭建子模块spring6-ioc-xml①搭建模块\n搭建方式如：spring-first\n②引入配置文件\n引入spring-first模块配置文件：beans.xml、log4j2.xml\n③添加依赖\nxml&lt;dependencies&gt;\n    &lt;!--spring context依赖--&gt;\n    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;version&gt;6.0.3&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--junit5测试--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n        &lt;version&gt;5.3.1&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--log4j2的依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n        &lt;version&gt;2.19.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;\n        &lt;version&gt;2.19.0&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;④引入java类\n引入spring-first模块java及test目录下实体类\njavapackage com.atguigu.spring6.bean;\n\npublic class HelloWorld &#123;\n\n    public HelloWorld() &#123;\n        System.out.println(&quot;无参数构造方法执行&quot;);\n    &#125;\n\n    public void sayHello()&#123;\n        System.out.println(&quot;helloworld&quot;);\n    &#125;\n&#125;\njavapackage com.atguigu.spring6.bean;\n\nimport org.junit.jupiter.api.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class HelloWorldTest &#123;\n\n    private Logger logger = LoggerFactory.getLogger(HelloWorldTest.class);\n\n    @Test\n    public void testHelloWorld()&#123;\n        \n    &#125;\n&#125;3.2.2、实验一：获取bean①方式一：根据id获取\n由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。\n②方式二：根据类型获取\njava@Test\npublic void testHelloWorld1()&#123;\n    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n    HelloWorld bean = ac.getBean(HelloWorld.class);\n    bean.sayHello();\n&#125;③方式三：根据id和类型\njava@Test\npublic void testHelloWorld2()&#123;\n    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n    HelloWorld bean = ac.getBean(&quot;helloworld&quot;, HelloWorld.class);\n    bean.sayHello();\n&#125;④注意的地方\n当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个\n当IOC容器中一共配置了两个：\nxml&lt;bean id=&quot;helloworldOne&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;helloworldTwo&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt;根据类型获取时会抛出异常：\nshellorg.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.atguigu.spring6.bean.HelloWorld&#39; available: expected single matching bean but found 2: helloworldOne,helloworldTwo⑤扩展知识\n如果组件类实现了接口，根据接口类型可以获取 bean 吗？\n\n\n\n\n\n\n\n\n\n可以，前提是bean唯一\n如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？\n\n\n\n\n\n\n\n\n\n不行，因为bean不唯一\n结论\n\n根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。\njava中，instanceof运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回true，否则返回false。也就是说：用instanceof关键字做判断时， instanceof 操作符的左右操作必须有继承或实现关系\n\n3.2.3、实验二：依赖注入之setter注入\nproperty标签 ：通过组件类的setXxx()方法给组件对象设置属性\nname属性 ：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关）\nvalue属性 ：指定属性值\n\n①创建学生类Student\njavapackage com.atguigu.spring6.bean;\n\npublic class Student &#123;\n\n    private Integer id;\n\n    private String name;\n\n    private Integer age;\n\n    private String sex;\n\n    public Student() &#123;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public Integer getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(Integer age) &#123;\n        this.age = age;\n    &#125;\n\n    public String getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Student&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, sex=&#39;&quot; + sex + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n\n&#125;②配置bean时为属性赋值\nspring-di.xml\nxml&lt;bean id=&quot;studentOne&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt;\n    &lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt;\n    &lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关） --&gt;\n    &lt;!-- value属性：指定属性值 --&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;③测试\njava@Test\npublic void testDIBySet()&#123;\n    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;);\n    Student studentOne = ac.getBean(&quot;studentOne&quot;, Student.class);\n    System.out.println(studentOne);\n&#125;3.2.4、实验三：依赖注入之构造器注入①在Student类中添加有参构造\njavapublic Student(Integer id, String name, Integer age, String sex) &#123;\n    this.id = id;\n    this.name = name;\n    this.age = age;\n    this.sex = sex;\n&#125;②配置bean\nspring-di.xml\nxml&lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt;\n    &lt;constructor-arg name=&quot;id&quot; value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg name=&quot;name&quot; value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg name=&quot;age&quot; value=&quot;33&quot;&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n\n\n\n\n\n\n\n\n注意：\nconstructor-arg标签有两个属性可以进一步描述构造器参数 ：\n\nindex属性：指定参数所在位置的索引（从0开始）\nname属性：指定参数名\n\n③测试\njava@Test\npublic void testDIByConstructor()&#123;\n    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;);\n    Student studentOne = ac.getBean(&quot;studentTwo&quot;, Student.class);\n    System.out.println(studentOne);\n&#125;3.2.5、实验四：特殊值处理①字面量赋值\n\n\n\n\n\n\n\n\n\n什么是字面量？\nint a &#x3D; 10;\n声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。\n而如果a是带引号的：’a’，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。\nxml&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;\n&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;②null值\nxml&lt;property name=&quot;name&quot;&gt;\n    &lt;null /&gt;\n&lt;/property&gt;\n\n\n\n\n\n\n\n\n注意：\nxml&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt;以上写法，为name所赋的值是字符串null\n③xml实体\nxml&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;\n&lt;!-- 解决方案一：使用XML实体来代替 --&gt;\n&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt;④CDATA节\nxml&lt;property name=&quot;expression&quot;&gt;\n    &lt;!-- 解决方案二：使用CDATA节 --&gt;\n    &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt;\n    &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt;\n    &lt;!-- 所以CDATA节中写什么符号都随意 --&gt;\n    &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;\n&lt;/property&gt;3.2.6、实验五：为对象类型属性赋值①创建班级类Clazz\njavapackage com.atguigu.spring6.bean\n    \npublic class Clazz &#123;\n\n    private Integer clazzId;\n\n    private String clazzName;\n\n    public Integer getClazzId() &#123;\n        return clazzId;\n    &#125;\n\n    public void setClazzId(Integer clazzId) &#123;\n        this.clazzId = clazzId;\n    &#125;\n\n    public String getClazzName() &#123;\n        return clazzName;\n    &#125;\n\n    public void setClazzName(String clazzName) &#123;\n        this.clazzName = clazzName;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Clazz&#123;&quot; +\n                &quot;clazzId=&quot; + clazzId +\n                &quot;, clazzName=&#39;&quot; + clazzName + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n\n    public Clazz() &#123;\n    &#125;\n\n    public Clazz(Integer clazzId, String clazzName) &#123;\n        this.clazzId = clazzId;\n        this.clazzName = clazzName;\n    &#125;\n&#125;②修改Student类\n在Student类中添加以下代码：\njavaprivate Clazz clazz;\n\npublic Clazz getClazz() &#123;\n    return clazz;\n&#125;\n\npublic void setClazz(Clazz clazz) &#123;\n    this.clazz = clazz;\n&#125;方式一：引用外部bean配置Clazz类型的bean：\nxml&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt;\n    &lt;property name=&quot;clazzId&quot; value=&quot;1111&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;clazzName&quot; value=&quot;财源滚滚班&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;为Student中的clazz属性赋值：\nxml&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;\n    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;\n    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;错误演示：\nxml&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;clazz&quot; value=&quot;clazzOne&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n\n\n\n\n\n\n\n如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.spring6.bean.Clazz’ for property ‘clazz’: no matching editors or conversion strategy found \n意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值\n方式二：内部beanxml&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;clazz&quot;&gt;\n        &lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt;\n        &lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt;\n        &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt;\n            &lt;property name=&quot;clazzId&quot; value=&quot;2222&quot;&gt;&lt;/property&gt;\n            &lt;property name=&quot;clazzName&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt;\n        &lt;/bean&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;方式三：级联属性赋值xml&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;clazz.clazzId&quot; value=&quot;3333&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;clazz.clazzName&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;3.2.7、实验六：为数组类型属性赋值①修改Student类\n在Student类中添加以下代码：\njavaprivate String[] hobbies;\n\npublic String[] getHobbies() &#123;\n    return hobbies;\n&#125;\n\npublic void setHobbies(String[] hobbies) &#123;\n    this.hobbies = hobbies;\n&#125;②配置bean\nxml&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean6.Student&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;\n    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;\n    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;hobbies&quot;&gt;\n        &lt;array&gt;\n            &lt;value&gt;抽烟&lt;/value&gt;\n            &lt;value&gt;喝酒&lt;/value&gt;\n            &lt;value&gt;烫头&lt;/value&gt;\n        &lt;/array&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;3.2.8、实验七：为集合类型属性赋值①为List集合类型属性赋值\n在Clazz类中添加以下代码：\njavaprivate List&lt;Student&gt; students;\n\npublic List&lt;Student&gt; getStudents() &#123;\n    return students;\n&#125;\n\npublic void setStudents(List&lt;Student&gt; students) &#123;\n    this.students = students;\n&#125;配置bean：\nxml&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt;\n    &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;students&quot;&gt;\n        &lt;list&gt;\n            &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt;\n            &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt;\n            &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n\n\n\n\n\n\n\n\n若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可\n②为Map集合类型属性赋值\n创建教师类Teacher：\njavapackage com.atguigu.spring6.bean;\npublic class Teacher &#123;\n\n    private Integer teacherId;\n\n    private String teacherName;\n\n    public Integer getTeacherId() &#123;\n        return teacherId;\n    &#125;\n\n    public void setTeacherId(Integer teacherId) &#123;\n        this.teacherId = teacherId;\n    &#125;\n\n    public String getTeacherName() &#123;\n        return teacherName;\n    &#125;\n\n    public void setTeacherName(String teacherName) &#123;\n        this.teacherName = teacherName;\n    &#125;\n\n    public Teacher(Integer teacherId, String teacherName) &#123;\n        this.teacherId = teacherId;\n        this.teacherName = teacherName;\n    &#125;\n\n    public Teacher() &#123;\n\n    &#125;\n    \n    @Override\n    public String toString() &#123;\n        return &quot;Teacher&#123;&quot; +\n                &quot;teacherId=&quot; + teacherId +\n                &quot;, teacherName=&#39;&quot; + teacherName + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;在Student类中添加以下代码：\njavaprivate Map&lt;String, Teacher&gt; teacherMap;\n\npublic Map&lt;String, Teacher&gt; getTeacherMap() &#123;\n    return teacherMap;\n&#125;\n\npublic void setTeacherMap(Map&lt;String, Teacher&gt; teacherMap) &#123;\n    this.teacherMap = teacherMap;\n&#125;配置bean：\nxml&lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring6.bean.Teacher&quot;&gt;\n    &lt;property name=&quot;teacherId&quot; value=&quot;10010&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;teacherName&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring6.bean.Teacher&quot;&gt;\n    &lt;property name=&quot;teacherId&quot; value=&quot;10086&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;teacherName&quot; value=&quot;二宝&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;\n    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;\n    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;hobbies&quot;&gt;\n        &lt;array&gt;\n            &lt;value&gt;抽烟&lt;/value&gt;\n            &lt;value&gt;喝酒&lt;/value&gt;\n            &lt;value&gt;烫头&lt;/value&gt;\n        &lt;/array&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;teacherMap&quot;&gt;\n        &lt;map&gt;\n            &lt;entry&gt;\n                &lt;key&gt;\n                    &lt;value&gt;10010&lt;/value&gt;\n                &lt;/key&gt;\n                &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt;\n            &lt;/entry&gt;\n            &lt;entry&gt;\n                &lt;key&gt;\n                    &lt;value&gt;10086&lt;/value&gt;\n                &lt;/key&gt;\n                &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt;\n            &lt;/entry&gt;\n        &lt;/map&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;③引用集合类型的bean\nxml&lt;!--list集合类型的bean--&gt;\n&lt;util:list id=&quot;students&quot;&gt;\n    &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt;\n    &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt;\n    &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;\n&lt;/util:list&gt;\n&lt;!--map集合类型的bean--&gt;\n&lt;util:map id=&quot;teacherMap&quot;&gt;\n    &lt;entry&gt;\n        &lt;key&gt;\n            &lt;value&gt;10010&lt;/value&gt;\n        &lt;/key&gt;\n        &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n        &lt;key&gt;\n            &lt;value&gt;10086&lt;/value&gt;\n        &lt;/key&gt;\n        &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt;\n    &lt;/entry&gt;\n&lt;/util:map&gt;\n&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt;\n    &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;students&quot; ref=&quot;students&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt;\n    &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt;\n    &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;hobbies&quot;&gt;\n        &lt;array&gt;\n            &lt;value&gt;抽烟&lt;/value&gt;\n            &lt;value&gt;喝酒&lt;/value&gt;\n            &lt;value&gt;烫头&lt;/value&gt;\n        &lt;/array&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;teacherMap&quot; ref=&quot;teacherMap&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n\n\n\n\n\n\n\n使用util:list、util:map标签必须引入相应的命名空间\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:util=&quot;http://www.springframework.org/schema/util&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/util\n    http://www.springframework.org/schema/util/spring-util.xsd\n    http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n添加新内容如下所示\n\n3.2.9、实验八：p命名空间引入p命名空间\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;\n       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/util\n       http://www.springframework.org/schema/util/spring-util.xsd\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;引入p命名空间后，可以通过以下方式为bean的各个属性赋值\nxml&lt;bean id=&quot;studentSix&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;\n    p:id=&quot;1006&quot; p:name=&quot;小明&quot; p:clazz-ref=&quot;clazzOne&quot; p:teacherMap-ref=&quot;teacherMap&quot;&gt;&lt;/bean&gt;3.2.10、实验九：引入外部属性文件实现步骤\n\n引入数据库相关依赖\n创建外部属性文件，properties格式，定义数据信息：用户名，密码，地址等\n创建spring配置文件，引入context命名空间引入属性文件，使用表达式完成注入\n\n①加入依赖\nxml &lt;!-- MySQL驱动 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;8.0.30&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- 数据源 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;druid&lt;/artifactId&gt;\n    &lt;version&gt;1.2.15&lt;/version&gt;\n&lt;/dependency&gt;②创建外部属性文件\n\npropertiesjdbc.user=root\njdbc.password=atguigu\njdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC\njdbc.driver=com.mysql.cj.jdbc.Driver③引入属性文件\n引入context 名称空间\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n&lt;/beans&gt;xml&lt;!-- 引入外部属性文件 --&gt;\n&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;注意：在使用 context:property-placeholder 元素加载外包配置文件功能前，首先需要在 XML 配置的一级标签 &lt;beans&gt; 中添加 context 相关的约束。\n④配置bean\nxml&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;\n    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;\n    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt;\n    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;\n&lt;/bean&gt;⑤测试\njava@Test\npublic void testDataSource() throws SQLException &#123;\n    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-datasource.xml&quot;);\n    DataSource dataSource = ac.getBean(DataSource.class);\n    Connection connection = dataSource.getConnection();\n    System.out.println(connection);\n&#125;3.2.11、实验十：bean的作用域①概念\n在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：\n\n\n\n取值\n含义\n创建对象的时机\n\n\n\nsingleton（默认）\n在IOC容器中，这个bean的对象始终为单实例\nIOC容器初始化时\n\n\nprototype\n这个bean在IOC容器中有多个实例\n获取bean时\n\n\n如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）：\n\n\n\n取值\n含义\n\n\n\nrequest\n在一个请求范围内有效\n\n\nsession\n在一个会话范围内有效\n\n\n②创建类User\njavapackage com.atguigu.spring6.bean;\npublic class User &#123;\n\n    private Integer id;\n\n    private String username;\n\n    private String password;\n\n    private Integer age;\n\n    public User() &#123;\n    &#125;\n\n    public User(Integer id, String username, String password, Integer age) &#123;\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.age = age;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username = username;\n    &#125;\n\n    public String getPassword() &#123;\n        return password;\n    &#125;\n\n    public void setPassword(String password) &#123;\n        this.password = password;\n    &#125;\n\n    public Integer getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(Integer age) &#123;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, username=&#39;&quot; + username + &#39;\\&#39;&#39; +\n                &quot;, password=&#39;&quot; + password + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;③配置bean\nxml&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;\n&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;\n&lt;bean class=&quot;com.atguigu.spring6.bean.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;④测试\njava@Test\npublic void testBeanScope()&#123;\n    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;);\n    User user1 = ac.getBean(User.class);\n    User user2 = ac.getBean(User.class);\n    System.out.println(user1==user2);\n&#125;3.2.12、实验十一：bean生命周期①具体的生命周期过程\n\nbean对象创建（调用无参构造器）\n\n给bean对象设置属性\n\nbean的后置处理器（初始化之前）\n\nbean对象初始化（需在配置bean时指定初始化方法）\n\nbean的后置处理器（初始化之后）\n\nbean对象就绪可以使用\n\nbean对象销毁（需在配置bean时指定销毁方法）\n\nIOC容器关闭\n\n\n②修改类User\njavapublic class User &#123;\n\n    private Integer id;\n\n    private String username;\n\n    private String password;\n\n    private Integer age;\n\n    public User() &#123;\n        System.out.println(&quot;生命周期：1、创建对象&quot;);\n    &#125;\n\n    public User(Integer id, String username, String password, Integer age) &#123;\n        this.id = id;\n        this.username = username;\n        this.password = password;\n        this.age = age;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        System.out.println(&quot;生命周期：2、依赖注入&quot;);\n        this.id = id;\n    &#125;\n\n    public String getUsername() &#123;\n        return username;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username = username;\n    &#125;\n\n    public String getPassword() &#123;\n        return password;\n    &#125;\n\n    public void setPassword(String password) &#123;\n        this.password = password;\n    &#125;\n\n    public Integer getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(Integer age) &#123;\n        this.age = age;\n    &#125;\n\n    public void initMethod()&#123;\n        System.out.println(&quot;生命周期：3、初始化&quot;);\n    &#125;\n\n    public void destroyMethod()&#123;\n        System.out.println(&quot;生命周期：5、销毁&quot;);\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, username=&#39;&quot; + username + &#39;\\&#39;&#39; +\n                &quot;, password=&#39;&quot; + password + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法\n③配置bean\nxml&lt;!-- 使用init-method属性指定初始化方法 --&gt;\n&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;\n&lt;bean class=&quot;com.atguigu.spring6.bean.User&quot; scope=&quot;prototype&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;④测试\njava@Test\npublic void testLife()&#123;\n    ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;);\n    User bean = ac.getBean(User.class);\n    System.out.println(&quot;生命周期：4、通过IOC容器获取bean并使用&quot;);\n    ac.close();\n&#125;⑤bean的后置处理器\nbean的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口，且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行\n创建bean的后置处理器：\njavapackage com.atguigu.spring6.process;\n    \nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\n\npublic class MyBeanProcessor implements BeanPostProcessor &#123;\n    \n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;☆☆☆&quot; + beanName + &quot; = &quot; + bean);\n        return bean;\n    &#125;\n    \n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;★★★&quot; + beanName + &quot; = &quot; + bean);\n        return bean;\n    &#125;\n&#125;在IOC容器中配置后置处理器：\nxml&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;\n&lt;bean id=&quot;myBeanProcessor&quot; class=&quot;com.atguigu.spring6.process.MyBeanProcessor&quot;/&gt;3.2.13、实验十二：FactoryBean①简介\n\n\n\n\n\n\n\n\n\nFactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。\n将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。\njava/*\n * Copyright 2002-2020 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.beans.factory;\n\nimport org.springframework.lang.Nullable;\n\n/**\n * Interface to be implemented by objects used within a &#123;@link BeanFactory&#125; which\n * are themselves factories for individual objects. If a bean implements this\n * interface, it is used as a factory for an object to expose, not directly as a\n * bean instance that will be exposed itself.\n *\n * &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a normal bean.&lt;/b&gt;\n * A FactoryBean is defined in a bean style, but the object exposed for bean\n * references (&#123;@link #getObject()&#125;) is always the object that it creates.\n *\n * &lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create\n * objects lazily on demand or eagerly on startup. The &#123;@link SmartFactoryBean&#125;\n * interface allows for exposing more fine-grained behavioral metadata.\n *\n * &lt;p&gt;This interface is heavily used within the framework itself, for example for\n * the AOP &#123;@link org.springframework.aop.framework.ProxyFactoryBean&#125; or the\n * &#123;@link org.springframework.jndi.JndiObjectFactoryBean&#125;. It can be used for\n * custom components as well; however, this is only common for infrastructure code.\n *\n * &lt;p&gt;&lt;b&gt;&#123;@code FactoryBean&#125; is a programmatic contract. Implementations are not\n * supposed to rely on annotation-driven injection or other reflective facilities.&lt;/b&gt;\n * &#123;@link #getObjectType()&#125; &#123;@link #getObject()&#125; invocations may arrive early in the\n * bootstrap process, even ahead of any post-processor setup. If you need access to\n * other beans, implement &#123;@link BeanFactoryAware&#125; and obtain them programmatically.\n *\n * &lt;p&gt;&lt;b&gt;The container is only responsible for managing the lifecycle of the FactoryBean\n * instance, not the lifecycle of the objects created by the FactoryBean.&lt;/b&gt; Therefore,\n * a destroy method on an exposed bean object (such as &#123;@link java.io.Closeable#close()&#125;\n * will &lt;i&gt;not&lt;/i&gt; be called automatically. Instead, a FactoryBean should implement\n * &#123;@link DisposableBean&#125; and delegate any such close call to the underlying object.\n *\n * &lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory&#39;s\n * synchronization of bean creation. There is usually no need for internal\n * synchronization other than for purposes of lazy initialization within the\n * FactoryBean itself (or the like).\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @since 08.03.2003\n * @param &lt;T&gt; the bean type\n * @see org.springframework.beans.factory.BeanFactory\n * @see org.springframework.aop.framework.ProxyFactoryBean\n * @see org.springframework.jndi.JndiObjectFactoryBean\n */\npublic interface FactoryBean&lt;T&gt; &#123;\n\n    /**\n     * The name of an attribute that can be\n     * &#123;@link org.springframework.core.AttributeAccessor#setAttribute set&#125; on a\n     * &#123;@link org.springframework.beans.factory.config.BeanDefinition&#125; so that\n     * factory beans can signal their object type when it can&#39;t be deduced from\n     * the factory bean class.\n     * @since 5.2\n     */\n    String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;;\n\n    /**\n     * Return an instance (possibly shared or independent) of the object\n     * managed by this factory.\n     * &lt;p&gt;As with a &#123;@link BeanFactory&#125;, this allows support for both the\n     * Singleton and Prototype design pattern.\n     * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of\n     * the call (for example because it is involved in a circular reference),\n     * throw a corresponding &#123;@link FactoryBeanNotInitializedException&#125;.\n     * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return &#123;@code null&#125;\n     * objects. The factory will consider this as normal value to be used; it\n     * will not throw a FactoryBeanNotInitializedException in this case anymore.\n     * FactoryBean implementations are encouraged to throw\n     * FactoryBeanNotInitializedException themselves now, as appropriate.\n     * @return an instance of the bean (can be &#123;@code null&#125;)\n     * @throws Exception in case of creation errors\n     * @see FactoryBeanNotInitializedException\n     */\n    @Nullable\n    T getObject() throws Exception;\n\n    /**\n     * Return the type of object that this FactoryBean creates,\n     * or &#123;@code null&#125; if not known in advance.\n     * &lt;p&gt;This allows one to check for specific types of beans without\n     * instantiating objects, for example on autowiring.\n     * &lt;p&gt;In the case of implementations that are creating a singleton object,\n     * this method should try to avoid singleton creation as far as possible;\n     * it should rather estimate the type in advance.\n     * For prototypes, returning a meaningful type here is advisable too.\n     * &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has\n     * been fully initialized. It must not rely on state created during\n     * initialization; of course, it can still use such state if available.\n     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return\n     * &#123;@code null&#125; here. Therefore it is highly recommended to implement\n     * this method properly, using the current state of the FactoryBean.\n     * @return the type of object that this FactoryBean creates,\n     * or &#123;@code null&#125; if not known at the time of the call\n     * @see ListableBeanFactory#getBeansOfType\n     */\n    @Nullable\n    Class&lt;?&gt; getObjectType();\n\n    /**\n     * Is the object managed by this factory a singleton? That is,\n     * will &#123;@link #getObject()&#125; always return the same object\n     * (a reference that can be cached)?\n     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; If a FactoryBean indicates to hold a singleton object,\n     * the object returned from &#123;@code getObject()&#125; might get cached\n     * by the owning BeanFactory. Hence, do not return &#123;@code true&#125;\n     * unless the FactoryBean always exposes the same reference.\n     * &lt;p&gt;The singleton status of the FactoryBean itself will generally\n     * be provided by the owning BeanFactory; usually, it has to be\n     * defined as singleton there.\n     * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This method returning &#123;@code false&#125; does not\n     * necessarily indicate that returned objects are independent instances.\n     * An implementation of the extended &#123;@link SmartFactoryBean&#125; interface\n     * may explicitly indicate independent instances through its\n     * &#123;@link SmartFactoryBean#isPrototype()&#125; method. Plain &#123;@link FactoryBean&#125;\n     * implementations which do not implement this extended interface are\n     * simply assumed to always return independent instances if the\n     * &#123;@code isSingleton()&#125; implementation returns &#123;@code false&#125;.\n     * &lt;p&gt;The default implementation returns &#123;@code true&#125;, since a\n     * &#123;@code FactoryBean&#125; typically manages a singleton instance.\n     * @return whether the exposed object is a singleton\n     * @see #getObject()\n     * @see SmartFactoryBean#isPrototype()\n     */\n    default boolean isSingleton() &#123;\n        return true;\n    &#125;\n&#125;②创建类UserFactoryBean\njavapackage com.atguigu.spring6.bean;\npublic class UserFactoryBean implements FactoryBean&lt;User&gt; &#123;\n    @Override\n    public User getObject() throws Exception &#123;\n        return new User();\n    &#125;\n\n    @Override\n    public Class&lt;?&gt; getObjectType() &#123;\n        return User.class;\n    &#125;\n&#125;③配置bean\nxml&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring6.bean.UserFactoryBean&quot;&gt;&lt;/bean&gt;④测试\njava@Test\npublic void testUserFactoryBean()&#123;\n    //获取IOC容器\n    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-factorybean.xml&quot;);\n    User user = (User) ac.getBean(&quot;user&quot;);\n    System.out.println(user);\n&#125;3.2.14、实验十三：基于xml自动装配\n\n\n\n\n\n\n\n\n自动装配 ：根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值\n①场景模拟\n创建类UserController\njavapackage com.atguigu.spring6.autowire.controller\npublic class UserController &#123;\n\n    private UserService userService;\n\n    public void setUserService(UserService userService) &#123;\n        this.userService = userService;\n    &#125;\n\n    public void saveUser()&#123;\n        userService.saveUser();\n    &#125;\n\n&#125;创建接口UserService\njavapackage com.atguigu.spring6.autowire.service\npublic interface UserService &#123;\n\n    void saveUser();\n\n&#125;创建类UserServiceImpl实现接口UserService\njavapackage com.atguigu.spring6.autowire.service.impl\npublic class UserServiceImpl implements UserService &#123;\n\n    private UserDao userDao;\n\n    public void setUserDao(UserDao userDao) &#123;\n        this.userDao = userDao;\n    &#125;\n\n    @Override\n    public void saveUser() &#123;\n        userDao.saveUser();\n    &#125;\n\n&#125;创建接口UserDao\njavapackage com.atguigu.spring6.autowire.dao\npublic interface UserDao &#123;\n\n    void saveUser();\n\n&#125;创建类UserDaoImpl实现接口UserDao\njavapackage com.atguigu.spring6.autowire.dao.impl\npublic class UserDaoImpl implements UserDao &#123;\n\n    @Override\n    public void saveUser() &#123;\n        System.out.println(&quot;保存成功&quot;);\n    &#125;\n\n&#125;②配置bean\n\n\n\n\n\n\n\n\n\n使用bean标签的autowire属性设置自动装配效果\n自动装配方式：byType\nbyType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值\n\n若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null\n\n若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException\n\n\nxml&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring6.autowire.controller.UserController&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;\n\n&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;\n\n&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;\n\n\n\n\n\n\n\n\n自动装配方式 ：byName\nbyName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值\nxml&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring6.autowire.controller.UserController&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;\n\n&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;\n\n&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;③测试\njava@Test\npublic void testAutoWireByXML()&#123;\n    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;autowire-xml.xml&quot;);\n    UserController userController = ac.getBean(UserController.class);\n    userController.saveUser();\n&#125;3.3、基于注解管理Bean（☆）\n\n\n\n\n\n\n\n\n从 Java 5 开始，Java 增加了对注解（Annotation）的支持，它是代码中的一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理。开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。\nSpring 从 2.5 版本开始提供了对注解技术的全面支持，我们可以使用注解来实现自动装配，简化 Spring 的 XML 配置。\nSpring 通过注解实现自动装配的步骤如下 ：\n\n引入依赖\n开启组件扫描\n使用注解定义 Bean\n依赖注入\n\n3.3.1、搭建子模块spring6-ioc-annotation①搭建模块\n搭建方式如：spring6-ioc-xml\n②引入配置文件\n引入spring-ioc-xml模块日志log4j2.xml\n③添加依赖\nxml&lt;dependencies&gt;\n    &lt;!--spring context依赖--&gt;\n    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;version&gt;6.0.3&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--junit5测试--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--log4j2的依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n        &lt;version&gt;2.19.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;\n        &lt;version&gt;2.19.0&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;3.3.2、开启组件扫描Spring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 context:component-scan 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n    http://www.springframework.org/schema/context\n            http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n    &lt;!--开启组件扫描功能--&gt;\n    &lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt;\n&lt;/beans&gt;注意：在使用 context:component-scan 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签  中添加 context 相关的约束。\n情况一：最基本的扫描方式\nxml&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;\n&lt;/context:component-scan&gt;情况二：指定要排除的组件\nxml&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;\n    &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;\n    &lt;!-- \n         type：设置排除或包含的依据\n        type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名\n        type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名\n    --&gt;\n    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;\n        &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;\n&lt;/context:component-scan&gt;情况三：仅扫描指定组件\nxml&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt;\n    &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;\n    &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;\n    &lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt;\n    &lt;!-- \n         type：设置排除或包含的依据\n        type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名\n        type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名\n    --&gt;\n    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;\n    &lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;\n&lt;/context:component-scan&gt;3.3.3、使用注解定义 BeanSpring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。\n\n\n\n注解\n说明\n\n\n\n@Component\n该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。  使用时只需将该注解标注在相应类上即可。\n\n\n@Repository\n该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。\n\n\n@Service\n该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。\n\n\n@Controller\n该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。\n\n\n3.3.4、实验一：@Autowired注入单独使用@Autowired注解，默认根据类型装配。【默认是byType】\n查看源码：\njavapackage org.springframework.beans.factory.annotation;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Autowired &#123;\n    boolean required() default true;\n&#125;源码中有两处需要注意：\n\n第一处 ：该注解可以标注在哪里？\n构造方法上\n方法上\n形参上\n属性上\n注解上\n\n\n第二处 ：该注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。\n\n场景一：属性注入创建UserDao接口\njavapackage com.atguigu.spring6.dao;\n\npublic interface UserDao &#123;\n\n    public void print();\n&#125;创建UserDaoImpl实现\njavapackage com.atguigu.spring6.dao.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic class UserDaoImpl implements UserDao &#123;\n\n    @Override\n    public void print() &#123;\n        System.out.println(&quot;Dao层执行结束&quot;);\n    &#125;\n&#125;创建UserService接口\njavapackage com.atguigu.spring6.service;\n\npublic interface UserService &#123;\n\n    public void out();\n&#125;创建UserServiceImpl实现类\njavapackage com.atguigu.spring6.service.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport com.atguigu.spring6.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n    @Autowired\n    private UserDao userDao;\n\n    @Override\n    public void out() &#123;\n        userDao.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;创建UserController类\njavapackage com.atguigu.spring6.controller;\n\nimport com.atguigu.spring6.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\n\n@Controller\npublic class UserController &#123;\n\n    @Autowired\n    private UserService userService;\n\n    public void out() &#123;\n        userService.out();\n        System.out.println(&quot;Controller层执行结束。&quot;);\n    &#125;\n\n&#125;测试一\njavapackage com.atguigu.spring6.bean;\n\nimport com.atguigu.spring6.controller.UserController;\nimport org.junit.jupiter.api.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class UserTest &#123;\n\n    private Logger logger = LoggerFactory.getLogger(UserTest.class);\n\n    @Test\n    public void testAnnotation()&#123;\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);\n        UserController userController = context.getBean(&quot;userController&quot;, UserController.class);\n        userController.out();\n        logger.info(&quot;执行成功&quot;);\n    &#125;\n\n\n&#125;测试结果：\n\n以上构造方法和setter方法都没有提供，经过测试，仍然可以注入成功。\n场景二：set注入修改UserServiceImpl类\njavapackage com.atguigu.spring6.service.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport com.atguigu.spring6.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n    private UserDao userDao;\n\n    @Autowired\n    public void setUserDao(UserDao userDao) &#123;\n        this.userDao = userDao;\n    &#125;\n\n    @Override\n    public void out() &#123;\n        userDao.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;修改UserController类\njavapackage com.atguigu.spring6.controller;\n\nimport com.atguigu.spring6.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\n\n@Controller\npublic class UserController &#123;\n\n    private UserService userService;\n\n    @Autowired\n    public void setUserService(UserService userService) &#123;\n        this.userService = userService;\n    &#125;\n\n    public void out() &#123;\n        userService.out();\n        System.out.println(&quot;Controller层执行结束。&quot;);\n    &#125;\n\n&#125;测试：成功调用\n场景三：构造方法注入修改UserServiceImpl类\njavapackage com.atguigu.spring6.service.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport com.atguigu.spring6.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n    private UserDao userDao;\n\n    @Autowired\n    public UserServiceImpl(UserDao userDao) &#123;\n        this.userDao = userDao;\n    &#125;\n\n    @Override\n    public void out() &#123;\n        userDao.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;修改UserController类\njavapackage com.atguigu.spring6.controller;\n\nimport com.atguigu.spring6.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\n\n@Controller\npublic class UserController &#123;\n\n    private UserService userService;\n\n    @Autowired\n    public UserController(UserService userService) &#123;\n        this.userService = userService;\n    &#125;\n\n    public void out() &#123;\n        userService.out();\n        System.out.println(&quot;Controller层执行结束。&quot;);\n    &#125;\n\n&#125;测试：成功调用\n场景四：形参上注入修改UserServiceImpl类\njavapackage com.atguigu.spring6.service.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport com.atguigu.spring6.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n    private UserDao userDao;\n\n    public UserServiceImpl(@Autowired UserDao userDao) &#123;\n        this.userDao = userDao;\n    &#125;\n\n    @Override\n    public void out() &#123;\n        userDao.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;修改UserController类\njavapackage com.atguigu.spring6.controller;\n\nimport com.atguigu.spring6.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\n\n@Controller\npublic class UserController &#123;\n\n    private UserService userService;\n\n    public UserController(@Autowired UserService userService) &#123;\n        this.userService = userService;\n    &#125;\n\n    public void out() &#123;\n        userService.out();\n        System.out.println(&quot;Controller层执行结束。&quot;);\n    &#125;\n\n&#125;测试：成功调用\n场景五：只有一个构造函数，无注解修改UserServiceImpl类\njavapackage com.atguigu.spring6.service.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport com.atguigu.spring6.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n    @Autowired\n    private UserDao userDao;\n\n    public UserServiceImpl(UserDao userDao) &#123;\n        this.userDao = userDao;\n    &#125;\n\n    @Override\n    public void out() &#123;\n        userDao.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;测试通过\n当有参数的构造方法只有一个时，@Autowired注解可以省略。\n说明：有多个构造方法时呢？\n答：再添加一个无参构造函数，测试报错\n场景六：@Autowired注解和@Qualifier注解联合添加dao层实现\njavapackage com.atguigu.spring6.dao.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic class UserDaoRedisImpl implements UserDao &#123;\n\n    @Override\n    public void print() &#123;\n        System.out.println(&quot;Redis Dao层执行结束&quot;);\n    &#125;\n&#125;测试：测试异常\n错误信息中说：不能装配，UserDao这个Bean的数量等于2\n怎么解决这个问题呢？当然要byName，根据名称进行装配了。\n修改UserServiceImpl类\njavapackage com.atguigu.spring6.service.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport com.atguigu.spring6.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n    @Autowired\n    @Qualifier(&quot;userDaoImpl&quot;) // 指定bean的名字\n    private UserDao userDao;\n\n    @Override\n    public void out() &#123;\n        userDao.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;总结\n\n@Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上。\n当带参数的构造方法只有一个，@Autowired注解可以省略。\n@Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用。\n\n3.3.5、实验二：@Resource注入@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？\n\n@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)\n@Autowired注解是Spring框架自己的。\n@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。\n@Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。\n@Resource注解用在属性上、setter方法上。\n@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。\n\n@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。】\nxml&lt;dependency&gt;\n    &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;\n    &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;\n    &lt;version&gt;2.1.1&lt;/version&gt;\n&lt;/dependency&gt;源码：\njavapackage jakarta.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(Resources.class)\npublic @interface Resource &#123;\n    String name() default &quot;&quot;;\n\n    String lookup() default &quot;&quot;;\n\n    Class&lt;?&gt; type() default Object.class;\n\n    Resource.AuthenticationType authenticationType() default Resource.AuthenticationType.CONTAINER;\n\n    boolean shareable() default true;\n\n    String mappedName() default &quot;&quot;;\n\n    String description() default &quot;&quot;;\n\n    public static enum AuthenticationType &#123;\n        CONTAINER,\n        APPLICATION;\n\n        private AuthenticationType() &#123;\n        &#125;\n    &#125;\n&#125;场景一：根据name注入修改UserDaoImpl类\njavapackage com.atguigu.spring6.dao.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport org.springframework.stereotype.Repository;\n\n@Repository(&quot;myUserDao&quot;)\npublic class UserDaoImpl implements UserDao &#123;\n\n    @Override\n    public void print() &#123;\n        System.out.println(&quot;Dao层执行结束&quot;);\n    &#125;\n&#125;修改UserServiceImpl类\njavapackage com.atguigu.spring6.service.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport com.atguigu.spring6.service.UserService;\nimport jakarta.annotation.Resource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n    @Resource(name = &quot;myUserDao&quot;)\n    private UserDao myUserDao;\n\n    @Override\n    public void out() &#123;\n        myUserDao.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;测试通过\n场景二：name未知注入修改UserDaoImpl类\njavapackage com.atguigu.spring6.dao.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport org.springframework.stereotype.Repository;\n\n@Repository(&quot;myUserDao&quot;)\npublic class UserDaoImpl implements UserDao &#123;\n\n    @Override\n    public void print() &#123;\n        System.out.println(&quot;Dao层执行结束&quot;);\n    &#125;\n&#125;修改UserServiceImpl类\njavapackage com.atguigu.spring6.service.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport com.atguigu.spring6.service.UserService;\nimport jakarta.annotation.Resource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n    @Resource\n    private UserDao myUserDao;\n\n    @Override\n    public void out() &#123;\n        myUserDao.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;测试通过\n当@Resource注解使用时没有指定name的时候，还是根据name进行查找，这个name是属性名。\n场景三 其他情况修改UserServiceImpl类，userDao1属性名不存在\njavapackage com.atguigu.spring6.service.impl;\n\nimport com.atguigu.spring6.dao.UserDao;\nimport com.atguigu.spring6.service.UserService;\nimport jakarta.annotation.Resource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService &#123;\n\n    @Resource\n    private UserDao userDao1;\n\n    @Override\n    public void out() &#123;\n        userDao1.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;测试异常\n根据异常信息得知：显然当通过name找不到的时候，自然会启动byType进行注入，以上的错误是因为UserDao接口下有两个实现类导致的。所以根据类型注入就会报错。@Resource的set注入可以自行测试。\n总结：\n@Resource注解：默认byName注入，没有指定name时把属性名当做name，根据name找不到时，才会byType注入。byType注入时，某种类型的Bean只能有一个。\n3.3.6、Spring全注解开发全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。\njavapackage com.atguigu.spring6.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n//@ComponentScan(&#123;&quot;com.atguigu.spring6.controller&quot;, &quot;com.atguigu.spring6.service&quot;,&quot;com.atguigu.spring6.dao&quot;&#125;)\n@ComponentScan(&quot;com.atguigu.spring6&quot;)\npublic class Spring6Config &#123;\n&#125;测试类\n此处和配置xml文件调用的方法不一样，需要注意。\njava@Test\npublic void testAllAnnotation()&#123;\n    ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class);\n    UserController userController = context.getBean(&quot;userController&quot;, UserController.class);\n    userController.out();\n    logger.info(&quot;执行成功&quot;);\n&#125;\n4、原理-手写IoC我们都知道，Spring框架的IOC是基于Java反射机制实现的，下面我们先回顾一下java反射。\n4.1、回顾Java反射\nJava反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。\n要想解剖一个类，必须先要获取到该类的Class对象。而剖析一个类或用反射解决具体的问题就是使用相关API（1）java.lang.Class（2）java.lang.reflect，所以，Class对象是反射的根源。\n\n自定义类\njavapackage com.atguigu.reflect;\n\npublic class Car &#123;\n\n    //属性\n    private String name;\n    private int age;\n    private String color;\n\n    //无参数构造\n    public Car() &#123;\n    &#125;\n\n    //有参数构造\n    public Car(String name, int age, String color) &#123;\n        this.name = name;\n        this.age = age;\n        this.color = color;\n    &#125;\n\n    //普通方法\n    private void run() &#123;\n        System.out.println(&quot;私有方法-run.....&quot;);\n    &#125;\n\n    //get和set方法\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public String getColor() &#123;\n        return color;\n    &#125;\n    public void setColor(String color) &#123;\n        this.color = color;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Car&#123;&quot; +\n                &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, color=&#39;&quot; + color + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;编写测试类\njavapackage com.atguigu.reflect;\n\nimport org.junit.jupiter.api.Test;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class TestCar &#123;\n\n    //1、获取Class对象多种方式\n    @Test\n    public void test01() throws Exception &#123;\n        //1 类名.class\n        Class clazz1 = Car.class;\n\n        //2 对象.getClass()\n        Class clazz2 = new Car().getClass();\n\n        //3 Class.forName(&quot;全路径&quot;)\n        Class clazz3 = Class.forName(&quot;com.atguigu.reflect.Car&quot;);\n\n        //实例化\n        Car car = (Car)clazz3.getConstructor().newInstance();\n        System.out.println(car);\n    &#125;\n\n    //2、获取构造方法\n    @Test\n    public void test02() throws Exception &#123;\n        Class clazz = Car.class;\n        //获取所有构造\n        // getConstructors()获取所有public的构造方法\n//        Constructor[] constructors = clazz.getConstructors();\n        // getDeclaredConstructors()获取所有的构造方法public  private\n        Constructor[] constructors = clazz.getDeclaredConstructors();\n        for (Constructor c:constructors) &#123;\n            System.out.println(&quot;方法名称：&quot;+c.getName()+&quot; 参数个数：&quot;+c.getParameterCount());\n        &#125;\n\n        //指定有参数构造创建对象\n        //1 构造public\n//        Constructor c1 = clazz.getConstructor(String.class, int.class, String.class);\n//        Car car1 = (Car)c1.newInstance(&quot;夏利&quot;, 10, &quot;红色&quot;);\n//        System.out.println(car1);\n        \n        //2 构造private\n        Constructor c2 = clazz.getDeclaredConstructor(String.class, int.class, String.class);\n        c2.setAccessible(true);\n        Car car2 = (Car)c2.newInstance(&quot;捷达&quot;, 15, &quot;白色&quot;);\n        System.out.println(car2);\n    &#125;\n\n    //3、获取属性\n    @Test\n    public void test03() throws Exception &#123;\n        Class clazz = Car.class;\n        Car car = (Car)clazz.getDeclaredConstructor().newInstance();\n        //获取所有public属性\n        //Field[] fields = clazz.getFields();\n        //获取所有属性（包含私有属性）\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field:fields) &#123;\n            if(field.getName().equals(&quot;name&quot;)) &#123;\n                //设置允许访问\n                field.setAccessible(true);\n                field.set(car,&quot;五菱宏光&quot;);\n                System.out.println(car);\n            &#125;\n            System.out.println(field.getName());\n        &#125;\n    &#125;\n\n    //4、获取方法\n    @Test\n    public void test04() throws Exception &#123;\n        Car car = new Car(&quot;奔驰&quot;,10,&quot;黑色&quot;);\n        Class clazz = car.getClass();\n        //1 public方法\n        Method[] methods = clazz.getMethods();\n        for (Method m1:methods) &#123;\n            //System.out.println(m1.getName());\n            //执行方法 toString\n            if(m1.getName().equals(&quot;toString&quot;)) &#123;\n                String invoke = (String)m1.invoke(car);\n                //System.out.println(&quot;toString执行了：&quot;+invoke);\n            &#125;\n        &#125;\n\n        //2 private方法\n        Method[] methodsAll = clazz.getDeclaredMethods();\n        for (Method m:methodsAll) &#123;\n            //执行方法 run\n            if(m.getName().equals(&quot;run&quot;)) &#123;\n                m.setAccessible(true);\n                m.invoke(car);\n            &#125;\n        &#125;\n    &#125;\n&#125;4.2、实现Spring的IoC\nIoC（控制反转）和DI（依赖注入）是Spring里面核心的东西，那么，我们如何自己手写出这样的代码呢？下面我们就一步一步写出Spring框架最核心的部分。\n①搭建子模块\n搭建模块：guigu-spring，搭建方式如其他spring子模块\n②准备测试需要的bean\n添加依赖\nxml&lt;dependencies&gt;\n    &lt;!--junit5测试--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n        &lt;version&gt;5.3.1&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;创建UserDao接口\njavapackage com.atguigu.spring6.test.dao;\n\npublic interface UserDao &#123;\n\n    public void print();\n&#125;创建UserDaoImpl实现\njavapackage com.atguigu.spring6.test.dao.impl;\n\nimport com.atguigu.spring.dao.UserDao;\n\npublic class UserDaoImpl implements UserDao &#123;\n\n    @Override\n    public void print() &#123;\n        System.out.println(&quot;Dao层执行结束&quot;);\n    &#125;\n&#125;\n创建UserService接口\njavapackage com.atguigu.spring6.test.service;\n\npublic interface UserService &#123;\n\n    public void out();\n&#125;创建UserServiceImpl实现类\njavapackage com.atguigu.spring.test.service.impl;\n\nimport com.atguigu.spring.core.annotation.Bean;\nimport com.atguigu.spring.service.UserService;\n\n@Bean\npublic class UserServiceImpl implements UserService &#123;\n\n//    private UserDao userDao;\n\n    @Override\n    public void out() &#123;\n        //userDao.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;\n③定义注解\n我们通过注解的形式加载bean与实现依赖注入\nbean注解\njavapackage com.atguigu.spring.core.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Bean &#123;\n&#125;依赖注入注解\njavapackage com.atguigu.spring.core.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(&#123;ElementType.FIELD&#125;)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Di &#123;\n&#125;说明：上面两个注解可以随意取名\n④定义bean容器接口\njavapackage com.atguigu.spring.core;\n\npublic interface ApplicationContext &#123;\n\n    Object getBean(Class clazz);\n&#125;⑤编写注解bean容器接口实现\nAnnotationApplicationContext基于注解扫描bean\njavapackage com.atguigu.spring.core;\n\nimport java.util.HashMap;\n\npublic class AnnotationApplicationContext implements ApplicationContext &#123;\n\n    //存储bean的容器\n    private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;();\n\n    @Override\n    public Object getBean(Class clazz) &#123;\n        return beanFactory.get(clazz);\n    &#125;\n\n    /**\n     * 根据包扫描加载bean\n     * @param basePackage\n     */\n    public AnnotationApplicationContext(String basePackage) &#123;\n        \n    &#125;\n&#125;⑥编写扫描bean逻辑\n思路在代码注释中，通过构造方法传入包的base路径，扫描被@Bean注解的java对象，完整代码如下：\njavapackage com.atguigu.spring.core;\n\nimport com.atguigu.spring.core.annotation.Bean;\n\nimport java.io.File;\nimport java.util.HashMap;\n\npublic class AnnotationApplicationContext implements ApplicationContext &#123;\n\n    //存储bean的容器\n    private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;();\n    private static String rootPath;\n\n    //返回对象\n    @Override\n    public Object getBean(Class clazz) &#123;\n        return beanFactory.get(clazz);\n    &#125;\n\n    /**\n     * 根据包扫描加载bean\n     * @param basePackage\n     */\n    //设置包扫描规则\n    //当前包及其子包，哪个类有@Bean注解，把这个类通过反射实例化\n    public AnnotationApplicationContext(String basePackage) &#123;\n       try &#123;\n            //1、把.替换成\\\n            String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;);\n            //2、获取包绝对路径\n            Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName);\n            while (dirs.hasMoreElements()) &#123;\n                URL url = dirs.nextElement();\n                String filePath = URLDecoder.decode(url.getFile(),&quot;utf-8&quot;);\n                //获取包前面路径部分，字符串截取\n                rootPath = filePath.substring(0, filePath.length()-packageDirName.length());\n                //进行包的扫描\n                loadBean(new File(filePath));\n            &#125;\n\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n\n    //包扫描过程，实例化\n    private  void loadBean(File fileParent) &#123;\n        //1、判断当前是否是文件夹\n        if (fileParent.isDirectory()) &#123;\n            //2、获取文件夹里面所有内容\n            File[] childrenFiles = fileParent.listFiles();\n            //3、判断文件夹里面为空，直接返回\n            if(childrenFiles == null || childrenFiles.length == 0)&#123;\n                return;\n            &#125;\n            //4、如果文件夹里面不为空，遍历文件夹所有内容\n            for (File child : childrenFiles) &#123;\n                //4.1、遍历得到每个File对象，继续判断，如果还是文件夹，递归\n                if (child.isDirectory()) &#123;\n                    //如果是个文件夹就继续调用该方法,使用了递归\n                    loadBean(child);\n                &#125; else &#123;\n                    //4.2、遍历得到File对象不是文件夹，是文件\n                    //4.3、得到包路径+类名称部分-字符串截取\n                    //通过文件路径转变成全类名,第一步把绝对路径部分去掉\n                    String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1);\n                    //4.4、判断当前文件类型是否.class\n                    //选中class文件\n                    if (pathWithClass.contains(&quot;.class&quot;)) &#123;\n                        //举例:com.xinzhi.dao.UserDao\n                        //4.5、如果是.class类型，去掉.class后缀，并且把路径 \\ 替换成 .\n                        String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;);\n                        //4.6、判断类上面是否有注解@Bean，如果有实例化过程\n                        try &#123;\n                            //4.6.1、获取类的Class\n                            Class&lt;?&gt; aClass = Class.forName(fullName);\n                            //4.6.2、判断不是接口\n                            //把非接口的类实例化放在map中\n                            if(!aClass.isInterface())&#123;\n                                //4.6.3、判断类上面是否有注解@Bean\n                                Bean annotation = aClass.getAnnotation(Bean.class);\n                                if(annotation != null)&#123;\n                                    //4.6.4、实例化\n                                    Object instance = aClass.newInstance();\n                                    //4.7、把对象实例化之后，放到map集合beanFactory\n                                    //4.7.1、判断当前类如果有接口，让接口class作为map的key\n                                    //判断一下有没有接口\n                                    if(aClass.getInterfaces().length &gt; 0) &#123;\n                                        //如果有接口把接口的class当成key，实例对象当成value\n                                        System.out.println(&quot;正在加载【&quot;+ aClass.getInterfaces()[0] +&quot;】,实例对象是：&quot; + instance.getClass().getName());\n                                        beanFactory.put(aClass.getInterfaces()[0], instance);\n                                    &#125;else&#123;\n                                        //如果有接口把自己的class当成key，实例对象当成value\n                                        System.out.println(&quot;正在加载【&quot;+ aClass.getName() +&quot;】,实例对象是：&quot; + instance.getClass().getName());\n                                        beanFactory.put(aClass, instance);\n                                    &#125;\n                                &#125;\n                            &#125;\n                        &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;\n                            e.printStackTrace();\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n&#125;⑦java类标识Bean注解\njava@Bean\npublic class UserServiceImpl implements UserServicejava@Bean\npublic class UserDaoImpl implements UserDao ⑧测试Bean加载\njavapackage com.atguigu.spring;\n\nimport com.atguigu.spring.core.AnnotationApplicationContext;\nimport com.atguigu.spring.core.ApplicationContext;\nimport com.atguigu.spring.test.service.UserService;\nimport org.junit.jupiter.api.Test;\n\npublic class SpringIocTest &#123;\n\n    @Test\n    public void testIoc() &#123;\n        ApplicationContext applicationContext = new AnnotationApplicationContext(&quot;com.atguigu.spring.test&quot;);\n        UserService userService = (UserService)applicationContext.getBean(UserService.class);\n        userService.out();\n        System.out.println(&quot;run success&quot;);\n    &#125;\n&#125;控制台打印测试\n⑨依赖注入\n只要userDao.print();调用成功，说明就注入成功\njavapackage com.atguigu.spring.test.service.impl;\n\nimport com.atguigu.spring.core.annotation.Bean;\nimport com.atguigu.spring.core.annotation.Di;\nimport com.atguigu.spring.dao.UserDao;\nimport com.atguigu.spring.service.UserService;\n\n@Bean\npublic class UserServiceImpl implements UserService &#123;\n\n    @Di\n    private UserDao userDao;\n\n    @Override\n    public void out() &#123;\n        userDao.print();\n        System.out.println(&quot;Service层执行结束&quot;);\n    &#125;\n&#125;执行第八步：报错了，说明当前userDao是个空对象\n⑩Di依赖注入实现\njavapackage com.atguigu.spring.core;\n\nimport com.atguigu.spring.core.annotation.Bean;\nimport com.atguigu.spring.core.annotation.Di;\n\nimport java.io.File;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class AnnotationApplicationContext implements ApplicationContext &#123;\n\n    //存储bean的容器\n    private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;();\n    private static String rootPath;\n\n    @Override\n    public Object getBean(Class clazz) &#123;\n        return beanFactory.get(clazz);\n    &#125;\n\n    /**\n     * 根据包扫描加载bean\n     * @param basePackage\n     */\n    public AnnotationApplicationContext(String basePackage) &#123;\n        try &#123;\n            String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;);\n            Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName);\n            while (dirs.hasMoreElements()) &#123;\n                URL url = dirs.nextElement();\n                String filePath = URLDecoder.decode(url.getFile(),&quot;utf-8&quot;);\n                rootPath = filePath.substring(0, filePath.length()-packageDirName.length());\n                loadBean(new File(filePath));\n            &#125;\n\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n        \n        //依赖注入\n        loadDi();\n    &#125;\n    \n     //包扫描过程，实例化\n    private  void loadBean(File fileParent) &#123;\n        //1、判断当前是否是文件夹\n        if (fileParent.isDirectory()) &#123;\n            //2、获取文件夹里面所有内容\n            File[] childrenFiles = fileParent.listFiles();\n            //3、判断文件夹里面为空，直接返回\n            if(childrenFiles == null || childrenFiles.length == 0)&#123;\n                return;\n            &#125;\n            //4、如果文件夹里面不为空，遍历文件夹所有内容\n            for (File child : childrenFiles) &#123;\n                //4.1、遍历得到每个File对象，继续判断，如果还是文件夹，递归\n                if (child.isDirectory()) &#123;\n                    //如果是个文件夹就继续调用该方法,使用了递归\n                    loadBean(child);\n                &#125; else &#123;\n                    //4.2、遍历得到File对象不是文件夹，是文件\n                    //4.3、得到包路径+类名称部分-字符串截取\n                    //通过文件路径转变成全类名,第一步把绝对路径部分去掉\n                    String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1);\n                    //4.4、判断当前文件类型是否.class\n                    //选中class文件\n                    if (pathWithClass.contains(&quot;.class&quot;)) &#123;\n                        //举例:com.xinzhi.dao.UserDao\n                        //4.5、如果是.class类型，去掉.class后缀，并且把路径 \\ 替换成 .\n                        String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;);\n                        //4.6、判断类上面是否有注解@Bean，如果有实例化过程\n                        try &#123;\n                            //4.6.1、获取类的Class\n                            Class&lt;?&gt; aClass = Class.forName(fullName);\n                            //4.6.2、判断不是接口\n                            //把非接口的类实例化放在map中\n                            if(!aClass.isInterface())&#123;\n                                //4.6.3、判断类上面是否有注解@Bean\n                                Bean annotation = aClass.getAnnotation(Bean.class);\n                                if(annotation != null)&#123;\n                                    //4.6.4、实例化\n                                    Object instance = aClass.newInstance();\n                                    //4.7、把对象实例化之后，放到map集合beanFactory\n                                    //4.7.1、判断当前类如果有接口，让接口class作为map的key\n                                    //判断一下有没有接口\n                                    if(aClass.getInterfaces().length &gt; 0) &#123;\n                                        //如果有接口把接口的class当成key，实例对象当成value\n                                        System.out.println(&quot;正在加载【&quot;+ aClass.getInterfaces()[0] +&quot;】,实例对象是：&quot; + instance.getClass().getName());\n                                        beanFactory.put(aClass.getInterfaces()[0], instance);\n                                    &#125;else&#123;\n                                        //如果有接口把自己的class当成key，实例对象当成value\n                                        System.out.println(&quot;正在加载【&quot;+ aClass.getName() +&quot;】,实例对象是：&quot; + instance.getClass().getName());\n                                        beanFactory.put(aClass, instance);\n                                    &#125;\n                                &#125;\n                            &#125;\n                        &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;\n                            e.printStackTrace();\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    //属性注入\n    private void loadDi() &#123;\n        //实例化对象在beanFactory的map集合里面\n        //1、遍历beanFactory的map集合\n        for(Map.Entry&lt;Class,Object&gt; entry : beanFactory.entrySet())&#123;\n            //2、获取map集合每个对象(value)，每个对象属性获取到\n            Object obj = entry.getValue();\n            //获取对象class\n            Class&lt;?&gt; aClass = obj.getClass();\n            //获取每个对象属性获取到\n            Field[] declaredFields = aClass.getDeclaredFields();\n            //3、遍历得到每个对象属性数组，得到每个属性\n            for (Field field : declaredFields)&#123;\n                //4、判断属性上面是否有@Di注解\n                Di annotation = field.getAnnotation(Di.class);\n                if( annotation != null )&#123;\n                    //如果私有属性，设置可以设置值\n                    field.setAccessible(true);\n                    //5、如果有@Di注解，把对象进行设置(注入)\n                    try &#123;\n                        System.out.println(&quot;正在给【&quot;+obj.getClass().getName()+&quot;】属性【&quot; + field.getName() + &quot;】注入值【&quot;+ beanFactory.get(field.getType()).getClass().getName() +&quot;】&quot;);\n                        field.set(obj,beanFactory.get(field.getType()));\n                    &#125; catch (IllegalAccessException e) &#123;\n                        e.printStackTrace();\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n&#125;执行第八步：执行成功，依赖注入成功\n\n5、面向切面：AOP5.1、场景模拟搭建子模块：spring6-aop\n5.1.1、声明接口声明计算器接口Calculator，包含加减乘除的抽象方法\njavapublic interface Calculator &#123;\n    \n    int add(int i, int j);\n    \n    int sub(int i, int j);\n    \n    int mul(int i, int j);\n    \n    int div(int i, int j);\n    \n&#125;5.1.2、创建实现类\njavapublic class CalculatorImpl implements Calculator &#123;\n    \n    @Override\n    public int add(int i, int j) &#123;\n    \n        int result = i + j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        return result;\n    &#125;\n    \n    @Override\n    public int sub(int i, int j) &#123;\n    \n        int result = i - j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        return result;\n    &#125;\n    \n    @Override\n    public int mul(int i, int j) &#123;\n    \n        int result = i * j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        return result;\n    &#125;\n    \n    @Override\n    public int div(int i, int j) &#123;\n    \n        int result = i / j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        return result;\n    &#125;\n&#125;5.1.3、创建带日志功能的实现类\njavapublic class CalculatorLogImpl implements Calculator &#123;\n    \n    @Override\n    public int add(int i, int j) &#123;\n    \n        System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);\n    \n        int result = i + j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + result);\n    \n        return result;\n    &#125;\n    \n    @Override\n    public int sub(int i, int j) &#123;\n    \n        System.out.println(&quot;[日志] sub 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);\n    \n        int result = i - j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        System.out.println(&quot;[日志] sub 方法结束了，结果是：&quot; + result);\n    \n        return result;\n    &#125;\n    \n    @Override\n    public int mul(int i, int j) &#123;\n    \n        System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);\n    \n        int result = i * j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result);\n    \n        return result;\n    &#125;\n    \n    @Override\n    public int div(int i, int j) &#123;\n    \n        System.out.println(&quot;[日志] div 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);\n    \n        int result = i / j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        System.out.println(&quot;[日志] div 方法结束了，结果是：&quot; + result);\n    \n        return result;\n    &#125;\n&#125;5.1.4、提出问题①现有代码缺陷\n针对带日志功能的实现类，我们发现有如下缺陷：\n\n对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力\n附加功能分散在各个业务功能方法中，不利于统一维护\n\n②解决思路\n解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。\n③困难\n解决问题的困难：要抽取的代码在方法内部，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。\n5.2、代理模式5.2.1、概念①介绍\n二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。\n\n使用代理后：\n\n②生活中的代理\n\n广告商找大明星拍广告需要经过经纪人\n合作伙伴找大老板谈合作要约见面时间需要经过秘书\n房产中介是买卖双方的代理\n\n③相关术语\n\n代理 ：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。\n目标 ：被代理“套用”了非核心逻辑代码的类、对象、方法。\n\n5.2.2、静态代理创建静态代理类：\njavapublic class CalculatorStaticProxy implements Calculator &#123;\n    \n    // 将被代理的目标对象声明为成员变量\n    private Calculator target;\n    \n    public CalculatorStaticProxy(Calculator target) &#123;\n        this.target = target;\n    &#125;\n    \n    @Override\n    public int add(int i, int j) &#123;\n    \n        // 附加功能由代理类中的代理方法来实现\n        System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j);\n    \n        // 通过目标对象来实现核心业务逻辑\n        int addResult = target.add(i, j);\n    \n        System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + addResult);\n    \n        return addResult;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。\n提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。\n5.2.3、动态代理\n生产代理对象的工厂类：\njavapublic class ProxyFactory &#123;\n\n    private Object target;\n\n    public ProxyFactory(Object target) &#123;\n        this.target = target;\n    &#125;\n\n    public Object getProxy()&#123;\n\n        /**\n         * newProxyInstance()：创建一个代理实例\n         * 其中有三个参数：\n         * 1、classLoader：加载动态生成的代理类的类加载器\n         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组\n         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法\n         */\n        //1、classLoader：加载动态生成的代理类的类加载器\n        ClassLoader classLoader = target.getClass().getClassLoader();\n        //2、interfaces：目标对象实现的所有接口的class对象所组成的数组\n        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();\n        //3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法\n        InvocationHandler invocationHandler = new InvocationHandler() &#123;\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                /**\n                 * proxy：代理对象\n                 * method：代理对象需要实现的方法，即其中需要重写的方法\n                 * args：method所对应方法的参数\n                 */\n                Object result = null;\n                try &#123;\n                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args));\n                    result = method.invoke(target, args);\n                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result);\n                &#125; catch (Exception e) &#123;\n                    e.printStackTrace();\n                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage());\n                &#125; finally &#123;\n                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;);\n                &#125;\n                return result;\n            &#125;\n        &#125;;\n\n        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);\n    &#125;\n&#125;5.2.4、测试java@Test\npublic void testDynamicProxy()&#123;\n    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());\n    Calculator proxy = (Calculator) factory.getProxy();\n    proxy.div(1,0);\n    //proxy.div(1,1);\n&#125;5.3、AOP概念及相关术语5.3.1、概述\n\n\n\n\n\n\n\n\nAOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现，在不修改源代码的情况下，给程序动态统一添加额外功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n5.3.2、相关术语①横切关注点\n\n分散在每个各个模块中解决同一样的问题，如用户验证、日志管理、事务处理、数据缓存都属于横切关注点。\n\n从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。\n\n这个概念不是语法层面的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。\n\n\n\n②通知（增强）\n增强，通俗说，就是你想要增强的功能，比如 安全，事务，日志等。\n每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。\n\n前置通知 ：在被代理的目标方法前执行\n返回通知 ：在被代理的目标方法成功结束后执行（寿终正寝）\n异常通知 ：在被代理的目标方法异常结束后执行（死于非命）\n后置通知 ：在被代理的目标方法最终结束后执行（盖棺定论）\n环绕通知 ：使用try...catch...finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置\n\n\n③切面\n封装通知方法的类。\n\n④目标\n被代理的目标对象。\n⑤代理\n向目标对象应用通知之后创建的代理对象。\n⑥连接点\n这也是一个纯逻辑概念，不是语法定义的。\n把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。通俗说，就是spring允许你使用通知的地方\n\n⑦切入点\n\n定位连接点的方式。\n\n每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。\n\n如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。\n\nSpring 的 AOP 技术可以通过切入点定位到特定的连接点。通俗说，要实际去增强的方法\n\n切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。\n\n\n5.3.3、作用\n简化代码 ：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。\n\n代码增强 ：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就被切面给增强了。\n\n\n5.4、基于注解的AOP5.4.1、技术说明\n\n\n动态代理分为JDK动态代理和cglib动态代理\n当目标类有接口的情况使用JDK动态代理和cglib动态代理，没有接口时只能使用cglib动态代理\nJDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1，和目标类实现相同的接口\ncglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类\n动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。\ncglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。\nAspectJ：是AOP思想的一种实现。本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。\n\naop代理介绍\n\n5.4.2、准备工作基本步骤\n\n①添加依赖\n在IOC所需依赖基础上再加入下面依赖即可：\nxml&lt;dependencies&gt;\n    &lt;!--spring context依赖--&gt;\n    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;version&gt;6.0.2&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--spring aop依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;\n        &lt;version&gt;6.0.2&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!--spring aspects依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;\n        &lt;version&gt;6.0.2&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--junit5测试--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n        &lt;version&gt;5.3.1&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--log4j2的依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n        &lt;version&gt;2.19.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;\n        &lt;version&gt;2.19.0&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;②准备被代理的目标资源\n接口：\njavapublic interface Calculator &#123;\n    \n    int add(int i, int j);\n    \n    int sub(int i, int j);\n    \n    int mul(int i, int j);\n    \n    int div(int i, int j);\n    \n&#125;实现类：\njava@Component\npublic class CalculatorImpl implements Calculator &#123;\n    \n    @Override\n    public int add(int i, int j) &#123;\n    \n        int result = i + j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        return result;\n    &#125;\n    \n    @Override\n    public int sub(int i, int j) &#123;\n    \n        int result = i - j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        return result;\n    &#125;\n    \n    @Override\n    public int mul(int i, int j) &#123;\n    \n        int result = i * j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        return result;\n    &#125;\n    \n    @Override\n    public int div(int i, int j) &#123;\n    \n        int result = i / j;\n    \n        System.out.println(&quot;方法内部 result = &quot; + result);\n    \n        return result;\n    &#125;\n&#125;5.4.3、创建切面类并配置java// @Aspect表示这个类是一个切面类\n@Aspect\n// @Component注解保证这个切面类能够放入IOC容器\n@Component\npublic class LogAspect &#123;\n    \n    @Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)\n    public void beforeMethod(JoinPoint joinPoint)&#123;\n        String methodName = joinPoint.getSignature().getName();\n        String args = Arrays.toString(joinPoint.getArgs());\n        System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);\n    &#125;\n\n    @After(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)\n    public void afterMethod(JoinPoint joinPoint)&#123;\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName);\n    &#125;\n\n    @AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)\n    public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123;\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);\n    &#125;\n\n    @AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)\n    public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123;\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);\n    &#125;\n    \n    @Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)\n    public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123;\n        String methodName = joinPoint.getSignature().getName();\n        String args = Arrays.toString(joinPoint.getArgs());\n        Object result = null;\n        try &#123;\n            System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);\n            //目标对象（连接点）方法的执行\n            result = joinPoint.proceed();\n            System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);\n        &#125; catch (Throwable throwable) &#123;\n            throwable.printStackTrace();\n            System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);\n        &#125; finally &#123;\n            System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);\n        &#125;\n        return result;\n    &#125;\n    \n&#125;在Spring的配置文件中配置：\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n    &lt;!--\n        基于注解的AOP的实现：\n        1、将目标对象和切面交给IOC容器管理（注解+扫描）\n        2、开启AspectJ的自动代理，为目标对象自动生成代理\n        3、将切面类通过注解@Aspect标识\n    --&gt;\n    &lt;context:component-scan base-package=&quot;com.atguigu.aop.annotation&quot;&gt;&lt;/context:component-scan&gt;\n\n    &lt;aop:aspectj-autoproxy /&gt;\n&lt;/beans&gt;执行测试：\njavapublic class CalculatorTest &#123;\n\n    private Logger logger = LoggerFactory.getLogger(CalculatorTest.class);\n\n    @Test\n    public void testAdd()&#123;\n        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        Calculator calculator = ac.getBean( Calculator.class);\n        int add = calculator.add(1, 1);\n        logger.info(&quot;执行成功:&quot;+add);\n    &#125;\n\n&#125;执行结果：\n\n5.4.4、各种通知\n前置通知 ：使用@Before注解标识，在被代理的目标方法前执行\n返回通知 ：使用@AfterReturning注解标识，在被代理的目标方法成功结束后执行（寿终正寝）\n异常通知 ：使用@AfterThrowing注解标识，在被代理的目标方法异常结束后执行（死于非命）\n后置通知 ：使用@After注解标识，在被代理的目标方法最终结束后执行（盖棺定论）\n环绕通知 ：使用@Around注解标识，使用try...catch...finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置\n\n\n\n\n\n\n\n\n\n\n各种通知的执行顺序：\nSpring版本5.3.x以前：\n\n前置通知\n目标操作\n后置通知\n返回通知或异常通知\n\nSpring版本5.3.x以后：\n\n前置通知\n目标操作\n返回通知或异常通知\n后置通知\n\n各种通知代码举例\njava//切面类\n@Aspect //切面类\n@Component //ioc容器\npublic class LogAspect &#123;\n    //前置通知@Before\n    @Before(&quot;execution(public int com.annoaop.CalculatorImpl.*(..))&quot;)\n    public void beforeMethod(JoinPoint joinPoint)&#123;\n        //获取连接点的签名信息\n        String methodName = joinPoint.getSignature().getName();\n        //获取目标方法到的实参信息\n        String args = Arrays.toString(joinPoint.getArgs());\n        System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);\n    &#125;\n    //后置通知@After()\n    @After(value = &quot;execution(* com.annoaop.CalculatorImpl.*(..))&quot;)\n    public void afterMethod(JoinPoint joinPoint)&#123;\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName);\n    &#125;\n    //返回通知@AfterReturning\n    @AfterReturning(value = &quot;execution(* com.annoaop.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)\n    public void returnMethod(JoinPoint joinPoint, Object result) &#123;\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName + &quot;返回结果：&quot; +result);\n    &#125;\n    //异常通知@AfterThrowing\n    @AfterThrowing(value = &quot;execution(* com.annoaop.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)\n    public void throwMethod(JoinPoint joinPoint, Throwable ex) &#123;\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName + &quot;异常信息：&quot; +ex);\n    &#125;\n    //环绕通知@Around\n    @Around(value = &quot;execution(* com.annoaop.CalculatorImpl.*(..))&quot;)\n    public Object aroundMethod(ProceedingJoinPoint joinPoint) &#123;\n        String methodName = joinPoint.getSignature().getName();\n        Object[] args = joinPoint.getArgs();\n        String argString = Arrays.toString(args);\n        Object result = null;\n        try &#123;\n            System.out.println(&quot;环绕通知==目标方法之前执行&quot;);\n            //调用目标方法\n            result = joinPoint.proceed();\n            System.out.println(&quot;环绕通知==目标方法返回值之后执行&quot;);\n        &#125;catch (Throwable throwable) &#123;\n            throwable.printStackTrace();\n            System.out.println(&quot;环绕通知==目标方法出现异常执行&quot;);\n        &#125; finally &#123;\n            System.out.println(&quot;环绕通知==目标方法执行完毕执行&quot;);\n        &#125;\n        return result;\n    &#125;\n\n&#125;5.4.5、切入点表达式语法①作用\n\n②语法细节\n\n用*号代替 “权限修饰符” 和 “返回值” 部分表示 “权限修饰符” 和 “返回值” 不限\n在包名的部分，一个*号只能代表包的层次结构中的一层，表示这一层是任意的。\n例如：.Hello匹配com.Hello，不匹配com.atguigu.Hello\n\n\n在包名的部分，使用*..表示包名任意、包的层次深度任意\n在类名的部分，类名部分整体用*号代替，表示类名任意\n在类名的部分，可以使用*号代替类名的一部分\n例如：*Service匹配所有名称以Service结尾的类或接口\n\n\n在方法名部分，可以使用*号表示方法名任意\n在方法名部分，可以使用*号代替方法名的一部分\n例如：*Operation匹配所有方法名以Operation结尾的方法\n\n\n在方法参数列表部分，使用(..)表示参数列表任意\n在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头\n在方法参数列表部分，基本数据类型和对应的包装类型是不一样的\n切入点表达式中使用int和实际方法中 Integer 是不匹配的\n\n\n在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符\n例如：execution(public int *..*Service.*(.., int))\t正确\n例如：execution(* int *..*Service.*(.., int))\t错误\n\n\n\n\n5.4.6、重用切入点表达式①声明\njava@Pointcut(&quot;execution(* com.atguigu.aop.annotation.*.*(..))&quot;)\npublic void pointCut()&#123;&#125;②在同一个切面中使用\njava@Before(&quot;pointCut()&quot;)\npublic void beforeMethod(JoinPoint joinPoint)&#123;\n    String methodName = joinPoint.getSignature().getName();\n    String args = Arrays.toString(joinPoint.getArgs());\n    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);\n&#125;③在不同切面中使用\njava@Before(&quot;com.atguigu.aop.CommonPointCut.pointCut()&quot;)\npublic void beforeMethod(JoinPoint joinPoint)&#123;\n    String methodName = joinPoint.getSignature().getName();\n    String args = Arrays.toString(joinPoint.getArgs());\n    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);\n&#125;5.4.7、获取通知的相关信息①获取连接点信息\n获取连接点信息可以在通知方法的参数位置设置JoinPoint类型的形参\njava@Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)\npublic void beforeMethod(JoinPoint joinPoint)&#123;\n    //获取连接点的签名信息\n    String methodName = joinPoint.getSignature().getName();\n    //获取目标方法到的实参信息\n    String args = Arrays.toString(joinPoint.getArgs());\n    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);\n&#125;②获取目标方法的返回值\n@AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值\njava@AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)\npublic void afterReturningMethod(JoinPoint joinPoint, Object result)&#123;\n    String methodName = joinPoint.getSignature().getName();\n    System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);\n&#125;③获取目标方法的异常\n@AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常\njava@AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)\npublic void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123;\n    String methodName = joinPoint.getSignature().getName();\n    System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);\n&#125;5.4.8、环绕通知java@Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)\npublic Object aroundMethod(ProceedingJoinPoint joinPoint)&#123;\n    String methodName = joinPoint.getSignature().getName();\n    String args = Arrays.toString(joinPoint.getArgs());\n    Object result = null;\n    try &#123;\n        System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);\n        //目标方法的执行，目标方法的返回值一定要返回给外界调用者\n        result = joinPoint.proceed();\n        System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);\n    &#125; catch (Throwable throwable) &#123;\n        throwable.printStackTrace();\n        System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);\n    &#125; finally &#123;\n        System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);\n    &#125;\n    return result;\n&#125;5.4.9、切面的优先级相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。\n\n优先级高的切面：外面\n优先级低的切面：里面\n\n使用@Order注解可以控制切面的优先级：\n\n@Order(较小的数)：优先级高\n@Order(较大的数)：优先级低\n\n\n5.5、基于XML的AOP5.5.1、准备工作参考基于注解的AOP环境\n5.5.2、实现xml&lt;!--开启组件扫描--&gt;\n    &lt;context:component-scan base-package=&quot;com.xmlaop&quot;&gt;&lt;/context:component-scan&gt;\n\n    &lt;!--配置aop五种通知类型--&gt;\n    &lt;aop:config&gt;\n        &lt;!--配置切面类--&gt;\n        &lt;aop:aspect ref=&quot;logAspect&quot;&gt;\n            &lt;!--配置切入点--&gt;\n            &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.xmlaop.CalculatorImpl.*(..))&quot;/&gt;\n            &lt;!--配置五种通知--&gt;\n            &lt;!--前置通知--&gt;\n            &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:before&gt;\n            &lt;!--后置通知--&gt;\n            &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after&gt;\n            &lt;!--返回通知--&gt;\n            &lt;aop:after-returning method=&quot;returnMethod&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after-returning&gt;\n            &lt;!--异常通知--&gt;\n            &lt;aop:after-throwing method=&quot;throwMethod&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:after-throwing&gt;\n            &lt;!--环绕通知--&gt;\n            &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:around&gt;\n        &lt;/aop:aspect&gt;\n    &lt;/aop:config&gt;\n6、单元测试：JUnit在之前的测试方法中，几乎都能看到以下的两行代码：\njavaApplicationContext context = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);\nXxxx xxx = context.getBean(Xxxx.class);这两行代码的作用是创建Spring容器，最终获取到对象，但是每次测试都需要重复编写。针对上述问题，我们需要的是程序能自动帮我们创建容器。我们都知道JUnit无法知晓我们是否使用了 Spring 框架，更不用说帮我们创建 Spring 容器了。Spring提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件位置就可以了。这样一来，我们通过Spring整合JUnit可以使程序创建spring容器了\n6.1、整合JUnit56.1.1、搭建子模块搭建spring-junit模块\n6.1.2、引入依赖xml&lt;dependencies&gt;\n    &lt;!--spring context依赖--&gt;\n    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;version&gt;6.0.2&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--spring对junit的支持相关依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n        &lt;version&gt;6.0.2&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--junit5测试--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n        &lt;version&gt;5.9.0&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--log4j2的依赖--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n        &lt;version&gt;2.19.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt;\n        &lt;version&gt;2.19.0&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;6.1.3、添加配置文件beans.xml\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n    &lt;context:component-scan base-package=&quot;com.atguigu.spring6.bean&quot;/&gt;\n&lt;/beans&gt;copy日志文件：log4j2.xml\n6.1.4、添加java类javapackage com.atguigu.spring6.bean;\n\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class User &#123;\n\n    public User() &#123;\n        System.out.println(&quot;run user&quot;);\n    &#125;\n&#125;6.1.5、测试javaimport com.atguigu.spring6.bean.User;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\nimport org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n\n//两种方式均可\n//方式一\n//@ExtendWith(SpringExtension.class)\n//@ContextConfiguration(&quot;classpath:beans.xml&quot;)\n//方式二\n@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)\npublic class SpringJUnit5Test &#123;\n\n    @Autowired\n    private User user;\n\n    @Test\n    public void testUser()&#123;\n        System.out.println(user);\n    &#125;\n&#125;6.2、整合JUnit4JUnit4在公司也会经常用到，在此也学习一下\n6.2.1、添加依赖xml&lt;!-- junit测试 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;version&gt;4.12&lt;/version&gt;\n&lt;/dependency&gt;6.2.2、测试javaimport com.atguigu.spring6.bean.User;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(&quot;classpath:beans.xml&quot;)\npublic class SpringJUnit4Test &#123;\n\n    @Autowired\n    private User user;\n\n    @Test\n    public void testUser()&#123;\n        System.out.println(user);\n    &#125;\n&#125;\n7、事务7.1、JdbcTemplate7.1.1、简介\nSpring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作\n7.1.2、准备工作①搭建子模块\n搭建子模块：spring-jdbc-tx\n②加入依赖\nxml&lt;dependencies&gt;\n    &lt;!--spring jdbc  Spring 持久化层支持jar包--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n        &lt;version&gt;6.0.2&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- MySQL驱动 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;version&gt;8.0.30&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- 数据源 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n        &lt;artifactId&gt;druid&lt;/artifactId&gt;\n        &lt;version&gt;1.2.15&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;③创建jdbc.properties\npropertiesjdbc.user=root\njdbc.password=root\njdbc.url=jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false\njdbc.driver=com.mysql.cj.jdbc.Driver④配置Spring的配置文件\nbeans.xml\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;!-- 导入外部属性文件 --&gt;\n    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;&lt;/context:property-placeholder&gt;\n\n    &lt;!-- 配置数据源 --&gt;\n    &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 配置 JdbcTemplate --&gt;\n    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;!-- 装配数据源 --&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;⑤准备数据库与测试表\nsqlCREATE DATABASE `spring`;\n\nuse `spring`;\n\nCREATE TABLE `t_emp` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) DEFAULT NULL COMMENT &#39;姓名&#39;,\n  `age` int(11) DEFAULT NULL COMMENT &#39;年龄&#39;,\n  `sex` varchar(2) DEFAULT NULL COMMENT &#39;性别&#39;,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;7.1.3、实现CURD①装配 JdbcTemplate创建测试类，整合JUnit，注入JdbcTemplate\njavapackage com.atguigu.spring6;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n\n@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)\npublic class JDBCTemplateTest &#123;\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    \n&#125;②测试增删改功能java@Test\n//测试增删改功能\npublic void testUpdate()&#123;\n    //添加功能\n    String sql = &quot;insert into t_emp values(null,?,?,?)&quot;;\n    int result = jdbcTemplate.update(sql, &quot;张三&quot;, 23, &quot;男&quot;);\n    \n    //修改功能\n    //String sql = &quot;update t_emp set name=? where id=?&quot;;\n    //int result = jdbcTemplate.update(sql, &quot;张三atguigu&quot;, 1);\n\n    //删除功能\n    //String sql = &quot;delete from t_emp where id=?&quot;;\n    //int result = jdbcTemplate.update(sql, 1);\n&#125;③查询数据返回对象javapublic class Emp &#123;\n\n    private Integer id;\n    private String name;\n    private Integer age;\n    private String sex;\n\n    //生成get和set方法\n    //......\n\n    @Override\n    public String toString() &#123;\n        return &quot;Emp&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age=&quot; + age +\n                &quot;, sex=&#39;&quot; + sex + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;java//查询：返回对象\n@Test\npublic void testSelectObject() &#123;\n    //写法一\n//        String sql = &quot;select * from t_emp where id=?&quot;;\n//        Emp empResult = jdbcTemplate.queryForObject(sql,\n//                (rs, rowNum) -&gt; &#123;\n//                    Emp emp = new Emp();\n//                    emp.setId(rs.getInt(&quot;id&quot;));\n//                    emp.setName(rs.getString(&quot;name&quot;));\n//                    emp.setAge(rs.getInt(&quot;age&quot;));\n//                    emp.setSex(rs.getString(&quot;sex&quot;));\n//                    return emp;\n//                &#125;, 1);\n//        System.out.println(empResult);\n\n    //写法二\n    String sql = &quot;select * from t_emp where id=?&quot;;\n    Emp emp = jdbcTemplate.queryForObject(sql,\n                  new BeanPropertyRowMapper&lt;&gt;(Emp.class),1);\n    System.out.println(emp);\n&#125;④查询数据返回list集合java@Test\n//查询多条数据为一个list集合\npublic void testSelectList()&#123;\n    String sql = &quot;select * from t_emp&quot;;\n    List&lt;Emp&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class));\n    System.out.println(list);\n&#125;⑤查询返回单个的值java@Test\n//查询单行单列的值\npublic void selectCount()&#123;\n    String sql = &quot;select count(id) from t_emp&quot;;\n    Integer count = jdbcTemplate.queryForObject(sql, Integer.class);\n    System.out.println(count);\n&#125;7.2、声明式事务概念7.2.1、事务基本概念①什么是事务数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。\n②事务的特性A：原子性(Atomicity)\n一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\nC：一致性(Consistency)\n事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。\n如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。\n如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。\nI：隔离性(Isolation)\n指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。\nD：持久性(Durability)\n指的是只要事务成功结束，它对数据库所做的更新就必须保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。\n7.2.2、编程式事务事务功能的相关操作全部通过自己编写代码来实现：\njavaConnection conn = ...;\n    \ntry &#123;\n    \n    // 开启事务：关闭事务的自动提交\n    conn.setAutoCommit(false);\n    \n    // 核心操作\n    \n    // 提交事务\n    conn.commit();\n    \n&#125;catch(Exception e)&#123;\n    \n    // 回滚事务\n    conn.rollBack();\n    \n&#125;finally&#123;\n    \n    // 释放数据库连接\n    conn.close();\n    \n&#125;编程式的实现方式存在缺陷：\n\n细节没有被屏蔽 ：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。\n代码复用性不高 ：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。\n\n7.2.3、声明式事务既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。\n封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。\n\n好处1：提高开发效率\n好处2：消除了冗余的代码\n好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化\n\n所以，我们可以总结下面两个概念：\n\n编程式：自己写代码实现功能\n声明式：通过配置让框架实现功能\n\n7.3、基于注解的声明式事务7.3.1、准备工作①添加配置\n在beans.xml添加配置\nxml&lt;!--扫描组件--&gt;\n&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt;②创建表\nsqlCREATE TABLE `t_book` (\n  `book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  `book_name` varchar(20) DEFAULT NULL COMMENT &#39;图书名称&#39;,\n  `price` int(11) DEFAULT NULL COMMENT &#39;价格&#39;,\n  `stock` int(10) unsigned DEFAULT NULL COMMENT &#39;库存（无符号）&#39;,\n  PRIMARY KEY (`book_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;\ninsert  into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,&#39;斗破苍穹&#39;,80,100),(2,&#39;斗罗大陆&#39;,50,100);\nCREATE TABLE `t_user` (\n  `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  `username` varchar(20) DEFAULT NULL COMMENT &#39;用户名&#39;,\n  `balance` int(10) unsigned DEFAULT NULL COMMENT &#39;余额（无符号）&#39;,\n  PRIMARY KEY (`user_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\ninsert  into `t_user`(`user_id`,`username`,`balance`) values (1,&#39;admin&#39;,50);③创建组件\n创建BookController：\njavapackage com.atguigu.spring6.controller;\n\n@Controller\npublic class BookController &#123;\n\n    @Autowired\n    private BookService bookService;\n\n    public void buyBook(Integer bookId, Integer userId)&#123;\n        bookService.buyBook(bookId, userId);\n    &#125;\n&#125;创建接口BookService：\njavapackage com.atguigu.spring6.service;\npublic interface BookService &#123;\n    void buyBook(Integer bookId, Integer userId);\n&#125;创建实现类BookServiceImpl：\njavapackage com.atguigu.spring6.service.impl;\n@Service\npublic class BookServiceImpl implements BookService &#123;\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Override\n    public void buyBook(Integer bookId, Integer userId) &#123;\n        //查询图书的价格\n        Integer price = bookDao.getPriceByBookId(bookId);\n        //更新图书的库存\n        bookDao.updateStock(bookId);\n        //更新用户的余额\n        bookDao.updateBalance(userId, price);\n    &#125;\n&#125;创建接口BookDao：\njavapackage com.atguigu.spring6.dao;\npublic interface BookDao &#123;\n    Integer getPriceByBookId(Integer bookId);\n\n    void updateStock(Integer bookId);\n\n    void updateBalance(Integer userId, Integer price);\n&#125;创建实现类BookDaoImpl：\njavapackage com.atguigu.spring6.dao.impl;\n@Repository\npublic class BookDaoImpl implements BookDao &#123;\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Override\n    public Integer getPriceByBookId(Integer bookId) &#123;\n        String sql = &quot;select price from t_book where book_id = ?&quot;;\n        return jdbcTemplate.queryForObject(sql, Integer.class, bookId);\n    &#125;\n\n    @Override\n    public void updateStock(Integer bookId) &#123;\n        String sql = &quot;update t_book set stock = stock - 1 where book_id = ?&quot;;\n        jdbcTemplate.update(sql, bookId);\n    &#125;\n\n    @Override\n    public void updateBalance(Integer userId, Integer price) &#123;\n        String sql = &quot;update t_user set balance = balance - ? where user_id = ?&quot;;\n        jdbcTemplate.update(sql, price, userId);\n    &#125;\n&#125;7.3.2、测试无事务情况①创建测试类\njavaimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n\n@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)\npublic class TxByAnnotationTest &#123;\n\n    @Autowired\n    private BookController bookController;\n\n    @Test\n    public void testBuyBook()&#123;\n        bookController.buyBook(1, 1);\n    &#125;\n\n&#125;②模拟场景\n\n用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额\n假设用户id为1的用户，购买id为1的图书\n用户余额为50，而图书价格为80\n购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段\n此时执行sql语句会抛出SQLException\n\n③观察结果\n\n因为没有添加事务，图书的库存更新了，但是用户的余额没有更新\n显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败\n\n7.3.3、加入事务①添加事务配置在spring配置文件中引入tx命名空间\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;在Spring的配置文件中添加配置：\nxml&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n    &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;!--\n    开启事务的注解驱动\n    通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务\n--&gt;\n&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;\n&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;②添加事务注解因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理\n在BookServiceImpl的buybook()添加注解@Transactional\n③观察结果由于使用了Spring的声明式事务，更新库存和更新余额都没有执行\n添加完基于注解的声明式事务代码如下\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;\n\n    &lt;!--扫描组件--&gt;\n    &lt;context:component-scan base-package=&quot;com.spring6.tx&quot;&gt;&lt;/context:component-scan&gt;\n    &lt;!--引入外部属性文件，创建数据源对象--&gt;\n    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;\n\n    &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;&gt;&lt;/property&gt;\n        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    \n    &lt;!--创建jdbcTemplate对象，注入数据源--&gt;\n    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!--\n        开启事务的注解驱动\n        通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务\n    --&gt;\n    &lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;\n    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;\n&lt;/beans&gt;7.3.4、@Transactional注解标识的位置@Transactional标识在方法上，则只会影响该方法\n@Transactional标识的类上，则会影响类中所有的方法\n7.3.5、事务属性：只读①介绍\n对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。\n②使用方式\njava@Transactional(readOnly = true)\npublic void buyBook(Integer bookId, Integer userId) &#123;\n    //查询图书的价格\n    Integer price = bookDao.getPriceByBookId(bookId);\n    //更新图书的库存\n    bookDao.updateStock(bookId);\n    //更新用户的余额\n    bookDao.updateBalance(userId, price);\n    //System.out.println(1/0);\n&#125;③注意\n对增删改操作设置只读会抛出下面异常：\nCaused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed\n7.3.6、事务属性：超时①介绍\n事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。\n概括来说就是一句话：超时回滚，释放资源。\n②使用方式\njava//超时时间单位秒\n@Transactional(timeout = 3)\npublic void buyBook(Integer bookId, Integer userId) &#123;\n    try &#123;\n        TimeUnit.SECONDS.sleep(5);\n    &#125; catch (InterruptedException e) &#123;\n        e.printStackTrace();\n    &#125;\n    //查询图书的价格\n    Integer price = bookDao.getPriceByBookId(bookId);\n    //更新图书的库存\n    bookDao.updateStock(bookId);\n    //更新用户的余额\n    bookDao.updateBalance(userId, price);\n    //System.out.println(1/0);\n&#125;③观察结果\n执行过程中抛出异常：\norg.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2022\n7.3.7、事务属性：回滚策略①介绍\n声明式事务默认只针对运行时异常回滚，编译时异常不回滚。\n可以通过@Transactional中相关属性设置回滚策略\n\nrollbackFor属性：需要设置一个Class类型的对象\n\nrollbackForClassName属性：需要设置一个字符串类型的全类名\n\nnoRollbackFor属性：需要设置一个Class类型的对象\n\nrollbackFor属性：需要设置一个字符串类型的全类名\n\n\n②使用方式\njava@Transactional(noRollbackFor = ArithmeticException.class)\n//@Transactional(noRollbackForClassName = &quot;java.lang.ArithmeticException&quot;)\npublic void buyBook(Integer bookId, Integer userId) &#123;\n    //查询图书的价格\n    Integer price = bookDao.getPriceByBookId(bookId);\n    //更新图书的库存\n    bookDao.updateStock(bookId);\n    //更新用户的余额\n    bookDao.updateBalance(userId, price);\n    System.out.println(1/0);\n&#125;③观察结果\n虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当出现ArithmeticException不发生回滚，因此购买图书的操作正常执行\n7.3.8、事务属性：隔离级别①介绍\n数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。\n隔离级别一共有四种：\n\n读未提交：READ UNCOMMITTED\n允许Transaction01读取Transaction02未提交的修改。\n\n读已提交：READ COMMITTED、\n要求Transaction01只能读取Transaction02已提交的修改。\n\n可重复读：REPEATABLE READ\n确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。\n\n串行化：SERIALIZABLE\n确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。\n\n\n各个隔离级别解决并发问题的能力见下表：\n\n\n\n隔离级别\n脏读\n不可重复读\n幻读\n\n\n\nREAD UNCOMMITTED\n有\n有\n有\n\n\nREAD COMMITTED\n无\n有\n有\n\n\nREPEATABLE READ\n无\n无\n有\n\n\nSERIALIZABLE\n无\n无\n无\n\n\n各种数据库产品对事务隔离级别的支持程度：\n\n\n\n隔离级别\nOracle\nMySQL\n\n\n\nREAD UNCOMMITTED\n×\n√\n\n\nREAD COMMITTED\n√(默认)\n√\n\n\nREPEATABLE READ\n×\n√(默认)\n\n\nSERIALIZABLE\n√\n√\n\n\n②使用方式\njava@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别\n@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交\n@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交\n@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读\n@Transactional(isolation = Isolation.SERIALIZABLE)//串行化7.3.9、事务属性：传播行为①介绍\n什么是事务的传播行为？\n在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。\n一共有七种传播行为：\n\nREQUIRED ：支持当前事务，如果不存在就新建一个(默认)【没有就新建，有就加入】\nSUPPORTS ：支持当前事务，如果当前没有事务，就以非事务方式执行【有就加入，没有就不管了】\nMANDATORY ：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常【有就加入，没有就抛异常】\nREQUIRES_NEW ：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】\nNOT_SUPPORTED ：以非事务方式运行，如果有事务存在，挂起当前事务【不支持事务，存在就挂起】\nNEVER ：以非事务方式运行，如果有事务存在，抛出异常【不支持事务，存在就抛异常】\nNESTED ：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】\n\n②测试\n创建接口CheckoutService：\njavapackage com.atguigu.spring6.service;\n\npublic interface CheckoutService &#123;\n    void checkout(Integer[] bookIds, Integer userId);\n&#125;创建实现类CheckoutServiceImpl：\njavapackage com.atguigu.spring6.service.impl;\n\n@Service\npublic class CheckoutServiceImpl implements CheckoutService &#123;\n\n    @Autowired\n    private BookService bookService;\n\n    @Override\n    @Transactional\n    //一次购买多本图书\n    public void checkout(Integer[] bookIds, Integer userId) &#123;\n        for (Integer bookId : bookIds) &#123;\n            bookService.buyBook(bookId, userId);\n        &#125;\n    &#125;\n&#125;在BookController中添加方法：\njava@Autowired\nprivate CheckoutService checkoutService;\n\npublic void checkout(Integer[] bookIds, Integer userId)&#123;\n    checkoutService.checkout(bookIds, userId);\n&#125;在数据库中将用户的余额修改为100元\n③观察结果\n\n可以通过@Transactional中的propagation属性设置事务传播行为\n修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性。BookServiceImpl添加@Transactional(propagation = Propagation.REQUIRED)\n@Transactional(propagation = Propagation.REQUIRED)，默认情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，即只要有一本书买不了，就都买不了\n@Transactional(propagation = Propagation.REQUIRES_NEW)，表示不管当前线程上是否有已经开启的事务，都要开启新事务。同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不受影响，即能买几本就买几本。\n\n7.3.10、全注解配置事务①添加配置类\njavapackage com.atguigu.spring6.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport javax.sql.DataSource;\n\n@Configuration //配置类\n@ComponentScan(&quot;com.atguigu.spring6&quot;)\n@EnableTransactionManagement //开启事务管理\npublic class SpringConfig &#123;\n\n    //配置数据库连接对象\n    @Bean\n    public DataSource getDataSource()&#123;\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false&quot;);\n        dataSource.setUsername(&quot;root&quot;);\n        dataSource.setPassword(&quot;root&quot;);\n        return dataSource;\n    &#125;\n\n    //配置jdbcTemplate对象，注入数据源\n    @Bean(name = &quot;jdbcTemplate&quot;)\n    public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123;\n        JdbcTemplate jdbcTemplate = new JdbcTemplate();\n        jdbcTemplate.setDataSource(dataSource);\n        return jdbcTemplate;\n    &#125;\n\n    //开启事务的注解驱动,因为是基于注解的声明式事务\n    @Bean\n    public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource)&#123;\n        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();\n        dataSourceTransactionManager.setDataSource(dataSource);\n        return dataSourceTransactionManager;\n    &#125;\n&#125;②测试\njavaimport com.atguigu.spring6.config.SpringConfig;\nimport com.atguigu.spring6.controller.BookController;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\n\npublic class TxByAllAnnotationTest &#123;\n\n    @Test\n    public void testTxAllAnnotation()&#123;\n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class);\n        BookController accountService = applicationContext.getBean(&quot;bookController&quot;, BookController.class);\n        accountService.buyBook(1, 1);\n    &#125;\n&#125;7.4、基于XML的声明式事务7.3.1、场景模拟参考基于注解的声明式事务\n7.3.2、修改Spring配置文件将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置：\nxml&lt;aop:config&gt;\n    &lt;!-- 配置事务通知和切入点表达式 --&gt; \n    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.atguigu.spring.tx.xml.service.impl.*.*(..))&quot;&gt;&lt;/aop:advisor&gt;\n&lt;/aop:config&gt;\n&lt;!-- tx:advice标签：配置事务通知 --&gt;\n&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;\n&lt;!-- transaction-manager属性：关联事务管理器 --&gt;\n&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;\n    &lt;tx:attributes&gt;\n        &lt;!-- tx:method标签：配置具体的事务方法 --&gt;\n        &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt;\n        &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;\n        &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;\n        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;\n    \n        &lt;!-- read-only属性：设置只读属性 --&gt;\n        &lt;!-- rollback-for属性：设置回滚的异常 --&gt;\n        &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt;\n        &lt;!-- isolation属性：设置事务的隔离级别 --&gt;\n        &lt;!-- timeout属性：设置事务的超时属性 --&gt;\n        &lt;!-- propagation属性：设置事务的传播行为 --&gt;\n        &lt;tx:method name=&quot;save*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;\n        &lt;tx:method name=&quot;update*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;\n        &lt;tx:method name=&quot;delete*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt;\n    &lt;/tx:attributes&gt;\n&lt;/tx:advice&gt;\n\n\n\n\n\n\n\n\n注意：基于xml实现的声明式事务，必须引入aspectJ的依赖\nxml&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;\n  &lt;version&gt;6.0.2&lt;/version&gt;\n&lt;/dependency&gt;\n\n8、资源操作：Resources8.1、Spring Resources概述\n\nJava的标准java.net.URL类和各种URL前缀的标准处理程序无法满足所有对low-level资源的访问，比如：没有标准化的 URL 实现可用于访问需要从类路径或相对于 ServletContext 获取的资源。并且缺少某些Spring所需要的功能，例如检测某资源是否存在等。而Spring的Resource声明了访问low-level资源的能力。\n8.2、Resource接口Spring 的 Resource 接口位于 org.springframework.core.io 中。 旨在成为一个更强大的接口，用于抽象对低级资源的访问。以下显示了Resource接口定义的方法\njavapublic interface Resource extends InputStreamSource &#123;\n\n    boolean exists();\n\n    boolean isReadable();\n\n    boolean isOpen();\n\n    boolean isFile();\n\n    URL getURL() throws IOException;\n\n    URI getURI() throws IOException;\n\n    File getFile() throws IOException;\n\n    ReadableByteChannel readableChannel() throws IOException;\n\n    long contentLength() throws IOException;\n\n    long lastModified() throws IOException;\n\n    Resource createRelative(String relativePath) throws IOException;\n\n    String getFilename();\n\n    String getDescription();\n&#125;Resource接口继承了InputStreamSource接口，提供了很多InputStreamSource所没有的方法。InputStreamSource接口，只有一个方法：\njavapublic interface InputStreamSource &#123;\n\n    InputStream getInputStream() throws IOException;\n\n&#125;其中一些重要的方法：\n\ngetInputStream() ： 找到并打开资源，返回一个InputStream以从资源中读取。预计每次调用都会返回一个新的InputStream()，调用者有责任关闭每个流\nexists() ： 返回一个布尔值，表明某个资源是否以物理形式存在\nisOpen ：返回一个布尔值，指示此资源是否具有开放流的句柄。如果为true，InputStream就不能够多次读取，只能够读取一次并且及时关闭以避免内存泄漏。对于所有常规资源实现，返回false，但是InputStreamResource除外。\ngetDescription() ： 返回资源的描述，用来输出错误的日志。这通常是完全限定的文件名或资源的实际URL。\n\n其他方法：\n\nisReadable() ： 表明资源的目录读取是否通过getInputStream()进行读取。\nisFile() ：表明这个资源是否代表了一个文件系统的文件。\ngetURL() ：返回一个URL句柄，如果资源不能够被解析为URL，将抛出IOException\ngetURI() ： 返回一个资源的URI句柄\ngetFile() ： 返回某个文件，如果资源不能够被解析称为绝对路径，将会抛出FileNotFoundException\nlastModified() ：资源最后一次修改的时间戳\ncreateRelative() ：创建此资源的相关资源\ngetFilename() ：资源的文件名是什么 例如：最后一部分的文件名 myfile.txt\n\n8.3、Resource的实现类Resource 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略。Resource一般包括这些实现类：UrlResource、ClassPathResource、FileSystemResource、ServletContextResource、InputStreamResource、ByteArrayResource\n8.3.1、UrlResource访问网络资源Resource的一个实现类，用来访问网络资源，它支持URL的绝对路径。\nhttp:——该前缀用于访问基于HTTP协议的网络资源。\nftp:——该前缀用于访问基于FTP协议的网络资源\nfile: ——该前缀用于从文件系统中读取资源\n实验：访问基于HTTP协议的网络资源\n创建一个maven子模块spring6-resources，配置Spring依赖（参考前面）\n\njavapackage com.atguigu.spring6.resources;\n\nimport org.springframework.core.io.UrlResource;\n\npublic class UrlResourceDemo &#123;\n\n    public static void loadAndReadUrlResource(String path)&#123;\n        // 创建一个 Resource 对象\n        UrlResource url = null;\n        try &#123;\n            url = new UrlResource(path);\n            // 获取资源名\n            System.out.println(url.getFilename());\n            System.out.println(url.getURI());\n            // 获取资源描述\n            System.out.println(url.getDescription());\n            //获取资源内容\n            System.out.println(url.getInputStream().read());\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    \n    public static void main(String[] args) &#123;\n        //访问网络资源\n        loadAndReadUrlResource(&quot;http://www.baidu.com&quot;);\n    &#125;\n&#125;实验二：在项目根路径下创建文件，从文件系统中读取资源\n方法不变，修改调用传递路径\njavapublic static void main(String[] args) &#123;\n    //1 访问网络资源\n    //loadAndReadUrlResource(&quot;http://www.atguigu.com&quot;);\n    \n    //2 访问文件系统资源\n    loadAndReadUrlResource(&quot;file:atguigu.txt&quot;);\n&#125;8.3.2、ClassPathResource 访问类路径下资源ClassPathResource 用来访问类加载路径下的资源，相对于其他的 Resource 实现类，其主要优势是方便访问类加载路径里的资源，尤其对于 Web 应用，ClassPathResource 可自动搜索位于 classes 下的资源文件，无须使用绝对路径访问。\n实验：在类路径下创建文件atguigu.txt，使用ClassPathResource 访问\n\njavapackage com.atguigu.spring6.resources;\n\nimport org.springframework.core.io.ClassPathResource;\nimport java.io.InputStream;\n\npublic class ClassPathResourceDemo &#123;\n\n    public static void loadAndReadUrlResource(String path) throws Exception&#123;\n        // 创建一个 Resource 对象\n        ClassPathResource resource = new ClassPathResource(path);\n        // 获取文件名\n        System.out.println(&quot;resource.getFileName = &quot; + resource.getFilename());\n        // 获取文件描述\n        System.out.println(&quot;resource.getDescription = &quot;+ resource.getDescription());\n        //获取文件内容\n        InputStream in = resource.getInputStream();\n        byte[] b = new byte[1024];\n        while(in.read(b)!=-1) &#123;\n            System.out.println(new String(b));\n        &#125;\n    &#125;\n\n    public static void main(String[] args) throws Exception &#123;\n        loadAndReadUrlResource(&quot;atguigu.txt&quot;);\n    &#125;\n&#125;ClassPathResource实例可使用ClassPathResource构造器显式地创建，但更多的时候它都是隐式地创建的。当执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含classpath:前缀后，系统会自动创建ClassPathResource对象。\n8.3.3、FileSystemResource 访问文件系统资源Spring 提供的 FileSystemResource 类用于访问文件系统资源，使用 FileSystemResource 来访问文件系统资源并没有太大的优势，因为 Java 提供的 File 类也可用于访问文件系统资源。\n实验：使用FileSystemResource 访问文件系统资源\njavapackage com.atguigu.spring6.resources;\n\nimport org.springframework.core.io.FileSystemResource;\n\nimport java.io.InputStream;\n\npublic class FileSystemResourceDemo &#123;\n\n    public static void loadAndReadUrlResource(String path) throws Exception&#123;\n        //相对路径\n        FileSystemResource resource = new FileSystemResource(&quot;atguigu.txt&quot;);\n        //绝对路径\n        //FileSystemResource resource = new FileSystemResource(&quot;C:\\\\atguigu.txt&quot;);\n        // 获取文件名\n        System.out.println(&quot;resource.getFileName = &quot; + resource.getFilename());\n        // 获取文件描述\n        System.out.println(&quot;resource.getDescription = &quot;+ resource.getDescription());\n        //获取文件内容\n        InputStream in = resource.getInputStream();\n        byte[] b = new byte[1024];\n        while(in.read(b)!=-1) &#123;\n            System.out.println(new String(b));\n        &#125;\n    &#125;\n\n    public static void main(String[] args) throws Exception &#123;\n        loadAndReadUrlResource(&quot;atguigu.txt&quot;);\n    &#125;\n&#125;FileSystemResource实例可使用FileSystemResource构造器显示地创建，但更多的时候它都是隐式创建。执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含file:前缀后，系统将会自动创建FileSystemResource对象。\n8.3.4、ServletContextResource这是ServletContext资源的Resource实现，它解释相关Web应用程序根目录中的相对路径。它始终支持流(stream)访问和URL访问，但只有在扩展Web应用程序存档且资源实际位于文件系统上时才允许java.io.File访问。无论它是在文件系统上扩展还是直接从JAR或其他地方（如数据库）访问，实际上都依赖于Servlet容器。\n8.3.5、InputStreamResourceInputStreamResource 是给定的输入流(InputStream)的Resource实现。它的使用场景在没有特定的资源实现的时候使用(感觉和@Component 的适用场景很相似)。与其他Resource实现相比，这是已打开资源的描述符。 因此，它的isOpen()方法返回true。如果需要将资源描述符保留在某处或者需要多次读取流，请不要使用它。\n8.3.6、ByteArrayResource字节数组的Resource实现类。通过给定的数组创建了一个ByteArrayInputStream。它对于从任何给定的字节数组加载内容非常有用，而无需求助于单次使用的InputStreamResource。\n8.4、Resource类图上述Resource实现类与Resource顶级接口之间的关系可以用下面的UML关系模型来表示\n\n8.5、ResourceLoader 接口8.5.1、ResourceLoader 概述Spring 提供如下两个标志性接口：\n（1）ResourceLoader ： 该接口实现类的实例可以获得一个Resource实例。\n（2） ResourceLoaderAware ： 该接口实现类的实例将获得一个ResourceLoader的引用。\n在ResourceLoader接口里有如下方法：\n（1）Resource getResource（String location） ： 该接口仅有这个方法，用于返回一个Resource实例。ApplicationContext实现类都实现ResourceLoader接口，因此ApplicationContext可直接获取Resource实例。\n8.5.2、使用演示实验一：ClassPathXmlApplicationContext获取Resource实例\njavapackage com.atguigu.spring6.resouceloader;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.core.io.Resource;\n\npublic class Demo1 &#123;\n\n    public static void main(String[] args) &#123;\n        ApplicationContext ctx = new ClassPathXmlApplicationContext();\n//        通过ApplicationContext访问资源\n//        ApplicationContext实例获取Resource实例时，\n//        默认采用与ApplicationContext相同的资源访问策略\n        Resource res = ctx.getResource(&quot;atguigu.txt&quot;);\n        System.out.println(res.getFilename());\n    &#125;\n&#125;实验二：FileSystemApplicationContext获取Resource实例\njavapackage com.atguigu.spring6.resouceloader;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.FileSystemXmlApplicationContext;\nimport org.springframework.core.io.Resource;\n\npublic class Demo2 &#123;\n\n    public static void main(String[] args) &#123;\n        ApplicationContext ctx = new FileSystemXmlApplicationContext();\n        Resource res = ctx.getResource(&quot;atguigu.txt&quot;);\n        System.out.println(res.getFilename());\n    &#125;\n&#125;8.5.3、ResourceLoader 总结Spring将采用和ApplicationContext相同的策略来访问资源。也就是说\n\n如果ApplicationContext是FileSystemXmlApplicationContext，res就是FileSystemResource实例；\n如果ApplicationContext是ClassPathXmlApplicationContext，res就是ClassPathResource实例\n\n当Spring应用需要进行资源访问时，实际上并不需要直接使用Resource实现类，而是调用ResourceLoader实例的getResource()方法来获得资源，ReosurceLoader将会负责选择Reosurce实现类，也就是确定具体的资源访问策略，从而将应用程序和具体的资源访问策略分离开来\n另外，使用ApplicationContext访问资源时，可通过不同前缀指定强制使用指定的ClassPathResource、FileSystemResource等实现类\njavaResource res = ctx.getResource(&quot;calsspath:bean.xml&quot;);\nResrouce res = ctx.getResource(&quot;file:bean.xml&quot;);\nResource res = ctx.getResource(&quot;http://localhost:8080/beans.xml&quot;);8.6、ResourceLoaderAware 接口\nResourceLoaderAware接口实现类的实例将获得一个ResourceLoader的引用，ResourceLoaderAware接口也提供了一个setResourceLoader()方法，该方法将由Spring容器负责调用，Spring容器会将一个ResourceLoader对象作为该方法的参数传入。\n如果把实现ResourceLoaderAware接口的Bean类部署在Spring容器中，Spring容器会将自身当成ResourceLoader作为setResourceLoader()方法的参数传入。由于ApplicationContext的实现类都实现了ResourceLoader接口，Spring容器自身完全可作为ResorceLoader使用。\n实验：演示ResourceLoaderAware使用\n第一步 创建类，实现ResourceLoaderAware接口\njavapackage com.atguigu.spring6.resouceloader;\n\nimport org.springframework.context.ResourceLoaderAware;\nimport org.springframework.core.io.ResourceLoader;\n\npublic class TestBean implements ResourceLoaderAware &#123;\n\n    private ResourceLoader resourceLoader;\n\n    //实现ResourceLoaderAware接口必须实现的方法\n    //如果把该Bean部署在Spring容器中，该方法将会有Spring容器负责调用。\n    //Spring容器调用该方法时，Spring会将自身作为参数传给该方法。\n    public void setResourceLoader(ResourceLoader resourceLoader) &#123;\n        this.resourceLoader = resourceLoader;\n    &#125;\n\n    //返回ResourceLoader对象的应用\n    public ResourceLoader getResourceLoader()&#123;\n        return this.resourceLoader;\n    &#125;\n\n&#125;第二步 创建bean.xml文件，配置TestBean\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;testBean&quot; class=&quot;com.atguigu.spring6.resouceloader.TestBean&quot;&gt;&lt;/bean&gt;\n&lt;/beans&gt;第三步 测试\njavapackage com.atguigu.spring6.resouceloader;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.ResourceLoader;\n\npublic class Demo3 &#123;\n\n    public static void main(String[] args) &#123;\n        //Spring容器会将一个ResourceLoader对象作为该方法的参数传入\n        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);\n        TestBean testBean = ctx.getBean(&quot;testBean&quot;,TestBean.class);\n        //获取ResourceLoader对象\n        ResourceLoader resourceLoader = testBean.getResourceLoader();\n        System.out.println(&quot;Spring容器将自身注入到ResourceLoaderAware Bean 中 ？ ：&quot; + (resourceLoader == ctx)); //true\n        //加载其他资源\n        Resource resource = resourceLoader.getResource(&quot;atguigu.txt&quot;);\n        System.out.println(resource.getFilename());\n        System.out.println(resource.getDescription());\n    &#125;\n&#125;8.7、使用Resource 作为属性前面介绍了 Spring 提供的资源访问策略，但这些依赖访问策略要么需要使用 Resource 实现类，要么需要使用 ApplicationContext 来获取资源。实际上，当应用程序中的 Bean 实例需要访问资源时，Spring 有更好的解决方法：直接利用依赖注入。从这个意义上来看，Spring 框架不仅充分利用了策略模式来简化资源访问，而且还将策略模式和 IoC 进行充分地结合，最大程度地简化了 Spring 资源访问。\n归纳起来，如果 Bean 实例需要访问资源，有如下两种解决方案：\n\n代码中获取 Resource 实例。\n使用依赖注入。\n\n对于第一种方式，当程序获取 Resource 实例时，总需要提供 Resource 所在的位置，不管通过 FileSystemResource 创建实例，还是通过 ClassPathResource 创建实例，或者通过 ApplicationContext 的 getResource() 方法获取实例，都需要提供资源位置。这意味着：资源所在的物理位置将被耦合到代码中，如果资源位置发生改变，则必须改写程序。因此，通常建议采用第二种方法，让 Spring 为 Bean 实例依赖注入资源。\n实验：让Spring为Bean实例依赖注入资源\n第一步 创建依赖注入类，定义属性和方法\njavapackage com.atguigu.spring6.resouceloader;\n\nimport org.springframework.core.io.Resource;\n\npublic class ResourceBean &#123;\n    \n    private Resource res;\n    \n    public void setRes(Resource res) &#123;\n        this.res = res;\n    &#125;\n    public Resource getRes() &#123;\n        return res;\n    &#125;\n    \n    public void parse()&#123;\n        System.out.println(res.getFilename());\n        System.out.println(res.getDescription());\n    &#125;\n&#125;第二步 创建spring配置文件，配置依赖注入\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;resourceBean&quot; class=&quot;com.atguigu.spring6.resouceloader.ResourceBean&quot; &gt;\n      &lt;!-- 可以使用file:、http:、ftp:等前缀强制Spring采用对应的资源访问策略 --&gt;\n      &lt;!-- 如果不采用任何前缀，则Spring将采用与该ApplicationContext相同的资源访问策略来访问资源 --&gt;\n        &lt;property name=&quot;res&quot; value=&quot;classpath:atguigu.txt&quot;/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;第三步 测试\njavapackage com.atguigu.spring6.resouceloader;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Demo4 &#123;\n\n    public static void main(String[] args) &#123;\n        ApplicationContext ctx =\n                new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);\n        ResourceBean resourceBean = ctx.getBean(&quot;resourceBean&quot;,ResourceBean.class);\n        resourceBean.parse();\n    &#125;\n&#125;8.8、应用程序上下文和资源路径8.8.1、概述\n\n\n\n\n\n\n\n\n不管以怎样的方式创建ApplicationContext实例，都需要为ApplicationContext指定配置文件，Spring允许使用一份或多分XML配置文件。当程序创建ApplicationContext实例时，通常也是以Resource的方式来访问配置文件的，所以ApplicationContext完全支持ClassPathResource、FileSystemResource、ServletContextResource等资源访问方式。\nApplicationContext确定资源访问策略通常有两种方法：\n（1）使用ApplicationContext实现类指定访问策略。\n（2）使用前缀指定访问策略。\n8.8.2、ApplicationContext实现类指定访问策略创建ApplicationContext对象时，通常可以使用如下实现类：\n（1）ClassPathXMLApplicationContext : 对应使用ClassPathResource进行资源访问。\n（2）FileSystemXmlApplicationContext ： 对应使用FileSystemResource进行资源访问。\n（3）XmlWebApplicationContext ： 对应使用ServletContextResource进行资源访问。\n当使用ApplicationContext的不同实现类时，就意味着Spring使用响应的资源访问策略。\n效果前面已经演示\n8.8.3、使用前缀指定访问策略实验一：classpath前缀使用\njavapackage com.atguigu.spring6.context;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.FileSystemXmlApplicationContext;\nimport org.springframework.core.io.Resource;\n\npublic class Demo1 &#123;\n\n    public static void main(String[] args) &#123;\n        /*\n         * 通过搜索文件系统路径下的xml文件创建ApplicationContext，\n         * 但通过指定classpath:前缀强制搜索类加载路径\n         * classpath:bean.xml\n         * */\n        ApplicationContext ctx =\n                new ClassPathXmlApplicationContext(&quot;classpath:bean.xml&quot;);\n        System.out.println(ctx);\n        Resource resource = ctx.getResource(&quot;atguigu.txt&quot;);\n        System.out.println(resource.getFilename());\n        System.out.println(resource.getDescription());\n    &#125;\n&#125;实验二：classpath通配符使用\nclasspath * :前缀提供了加载多个XML配置文件的能力，当使用classpath*:前缀来指定XML配置文件时，系统将搜索类加载路径，找到所有与文件名匹配的文件，分别加载文件中的配置定义，最后合并成一个ApplicationContext。\njavaApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:bean.xml&quot;);\nSystem.out.println(ctx);当使用classpath *: 前缀时，Spring将会搜索类加载路径下所有满足该规则的配置文件。\n如果不是采用classpath *:前缀，而是改为使用classpath:前缀，Spring则只加载第一个符合条件的XML文件\n注意 ： \nclasspath * : 前缀仅对ApplicationContext有效。实际情况是，创建ApplicationContext时，分别访问多个配置文件(通过ClassLoader的getResource方法实现)。因此，classpath * :前缀不可用于Resource。\n使用三：通配符其他使用\n一次性加载多个配置文件的方式：指定配置文件时使用通配符\njavaApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:bean*.xml&quot;);Spring允许将classpath*:前缀和通配符结合使用：\njavaApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:bean*.xml&quot;);\n9、国际化：i18n\n9.1、i18n概述国际化也称作i18n，其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数。由于软件发行可能面向多个国家，对于不同国家的用户，软件显示不同语言的过程就是国际化。通常来讲，软件中的国际化是通过配置文件来实现的，假设要支撑两种语言，那么就需要两个版本的配置文件。\n9.2、Java国际化（1）Java自身是支持国际化的，java.util.Locale用于指定当前用户所属的语言环境等信息，java.util.ResourceBundle用于查找绑定对应的资源文件。Locale包含了language信息和country信息，Locale创建默认locale对象时使用的静态方法：\njava    /**\n     * This method must be called only for creating the Locale.*\n     * constants due to making shortcuts.\n     */\n    private static Locale createConstant(String lang, String country) &#123;\n        BaseLocale base = BaseLocale.createInstance(lang, country);\n        return getInstance(base, null);\n    &#125;（2）配置文件命名规则： basename_language_country.properties 必须遵循以上的命名规则，java才会识别。其中，basename是必须的，语言和国家是可选的。这里存在一个优先级概念，如果同时提供了messages.properties和messages_zh_CN.propertes两个配置文件，如果提供的locale符合en_CN，那么优先查找messages_en_CN.propertes配置文件，如果没查找到，再查找messages.properties配置文件。最后，提示下，所有的配置文件必须放在classpath中，一般放在resources目录下\n（3）实验：演示Java国际化\n第一步 创建子模块spring6-i18n，引入spring依赖\n\n第二步 在resource目录下创建两个配置文件：messages_zh_CN.propertes和messages_en_GB.propertes\n\n第三步 测试\n此处两个properties文件都有写test=...(内容)以便能够测试获取。\njavapackage com.atguigu.spring6.javai18n;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\n\npublic class Demo1 &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(ResourceBundle.getBundle(&quot;messages&quot;,\n                new Locale(&quot;en&quot;,&quot;GB&quot;)).getString(&quot;test&quot;));\n\n        System.out.println(ResourceBundle.getBundle(&quot;messages&quot;,\n                new Locale(&quot;zh&quot;,&quot;CN&quot;)).getString(&quot;test&quot;));\n    &#125;\n&#125;9.3、Spring6国际化9.3.1、MessageSource接口spring中国际化是通过MessageSource这个接口来支持的\n常见实现类\nResourceBundleMessageSource\n这个是基于Java的ResourceBundle基础类实现，允许仅通过资源名加载国际化资源\nReloadableResourceBundleMessageSource\n这个功能和第一个类的功能类似，多了定时刷新功能，允许在不重启系统的情况下，更新资源的信息\nStaticMessageSource\n它允许通过编程的方式提供国际化信息，一会我们可以通过这个来实现db中存储国际化信息的功能。\n9.3.2、使用Spring6国际化第一步 创建资源文件\n国际化文件命名格式：基本名称 _ 语言 _ 国家.properties\n{0},{1}这样内容，就是动态参数\n\n（1）创建atguigu_en_US.properties\npropertieswww.atguigu.com=welcome &#123;0&#125;,时间:&#123;1&#125;（2）创建atguigu_zh_CN.properties\npropertieswww.atguigu.com=欢迎 &#123;0&#125;,时间:&#123;1&#125;第二步 创建spring配置文件，配置MessageSource\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n\n    &lt;bean id=&quot;messageSource&quot;\n          class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt;\n        &lt;property name=&quot;basenames&quot;&gt;\n            &lt;list&gt;\n                &lt;value&gt;atguigu&lt;/value&gt;\n            &lt;/list&gt;\n        &lt;/property&gt;\n        &lt;property name=&quot;defaultEncoding&quot;&gt;\n            &lt;value&gt;utf-8&lt;/value&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;第三步 创建测试类\njavapackage com.atguigu.spring6.javai18n;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\nimport java.util.Date;\nimport java.util.Locale;\n\npublic class Demo2 &#123;\n\n    public static void main(String[] args) &#123;\n        \n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        \n        //传递动态参数，使用数组形式对应&#123;0&#125; &#123;1&#125;顺序\n        Object[] objs = new Object[]&#123;&quot;atguigu&quot;,new Date().toString()&#125;;\n\n        //www.atguigu.com为资源文件的key值,\n        //objs为资源文件value值所需要的参数,Local.CHINA为国际化为语言\n        String str=context.getMessage(&quot;www.atguigu.com&quot;, objs, Locale.CHINA);\n        System.out.println(str);\n    &#125;\n&#125;\n10、数据校验：Validation\n10.1、Spring Validation概述\n在开发中，我们经常遇到参数校验的需求，比如用户注册的时候，要校验用户名不能为空、用户名长度不超过20个字符、手机号是合法的手机号格式等等。如果使用普通方式，我们会把校验的代码和真正的业务处理逻辑耦合在一起，而且如果未来要新增一种校验逻辑也需要在修改多个地方。而spring validation允许通过注解的方式来定义对象校验规则，把校验和业务逻辑分离开，让代码编写更加方便。Spring Validation其实就是对Hibernate Validator进一步的封装，方便在Spring中使用。\n在Spring中有多种校验的方式\n第一种是通过实现org.springframework.validation.Validator接口，然后在代码中调用这个类\n第二种是按照Bean Validation方式来进行校验，即通过注解的方式。\n第三种是基于方法实现校验\n除此之外，还可以实现自定义校验\n10.2、实验一：通过Validator接口实现通过Validator接口实现步骤分析\n\n第一步 创建子模块 spring6-validator\n\n第二步 引入相关依赖\nxml&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;\n        &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n        &lt;version&gt;7.0.5.Final&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.glassfish&lt;/groupId&gt;\n        &lt;artifactId&gt;jakarta.el&lt;/artifactId&gt;\n        &lt;version&gt;4.0.1&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;第三步 创建实体类，定义属性和方法\njavapackage com.atguigu.spring6.validation.method1;\n\npublic class Person &#123;\n    private String name;\n    private int age;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;第四步 创建类实现Validator接口，实现接口方法指定校验规则\njavapackage com.atguigu.spring6.validation.method1;\n\nimport org.springframework.validation.Errors;\nimport org.springframework.validation.ValidationUtils;\nimport org.springframework.validation.Validator;\n\npublic class PersonValidator implements Validator &#123;\n\n    @Override\n    public boolean supports(Class&lt;?&gt; clazz) &#123;\n        return Person.class.equals(clazz);\n    &#125;\n\n    //校验规则\n    @Override\n    public void validate(Object object, Errors errors) &#123;\n        ValidationUtils.rejectIfEmpty(errors, &quot;name&quot;, &quot;name.empty&quot;, &quot;name is null&quot;);\n        Person p = (Person) object;\n        if (p.getAge() &lt; 0) &#123;\n            errors.rejectValue(&quot;age&quot;, &quot;error value &lt; 0&quot;, &quot;age &lt; 0&quot;);\n        &#125; else if (p.getAge() &gt; 110) &#123;\n            errors.rejectValue(&quot;age&quot;, &quot;error value too old&quot;, &quot;age &gt; 110&quot;);\n        &#125;\n    &#125;\n&#125;上面定义的类，其实就是实现接口中对应的方法，\nsupports方法用来表示此校验用在哪个类型上，\nvalidate是设置校验逻辑的地点，其中ValidationUtils，是Spring封装的校验工具类，帮助快速实现校验。\n第五步 使用上述Validator进行测试\njavapackage com.atguigu.spring6.validation.method1;\n\nimport org.springframework.validation.BindingResult;\nimport org.springframework.validation.DataBinder;\n\npublic class TestMethod1 &#123;\n\n    public static void main(String[] args) &#123;\n        //创建person对象\n        Person person = new Person();\n        person.setName(&quot;lucy&quot;);\n        person.setAge(-1);\n        \n        // 创建Person对应的DataBinder\n        DataBinder binder = new DataBinder(person);\n\n        // 设置校验\n        binder.setValidator(new PersonValidator());\n\n        // 由于Person对象中的属性为空，所以校验不通过\n        binder.validate();\n\n        //输出结果\n        BindingResult results = binder.getBindingResult();\n        System.out.println(results.getAllErrors());\n    &#125;\n&#125;10.3、实验二：Bean Validation注解实现 Bean Validation注解实现步骤分析\n\n使用Bean Validation校验方式，就是如何将Bean Validation需要使用的javax.validation.ValidatorFactory 和javax.validation.Validator注入到容器中。spring默认有一个实现类LocalValidatorFactoryBean，它实现了上面Bean Validation中的接口，并且也实现了org.springframework.validation.Validator接口。\n第一步 创建配置类，配置LocalValidatorFactoryBean\njava@Configuration\n@ComponentScan(&quot;com.atguigu.spring6.validation.method2&quot;)\npublic class ValidationConfig &#123;\n\n    @Bean\n    public LocalValidatorFactoryBean validator() &#123;\n        return new LocalValidatorFactoryBean();\n    &#125;\n&#125;第二步 创建实体类，使用注解定义校验规则\njavapackage com.atguigu.spring6.validation.method2;\n\nimport jakarta.validation.constraints.Max;\nimport jakarta.validation.constraints.Min;\nimport jakarta.validation.constraints.NotNull;\n\npublic class User &#123;\n\n    @NotNull\n    private String name;\n\n    @Min(0)\n    @Max(120)\n    private int age;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;常用注解说明\n\n@NotNull\t：限制必须不为null\n@NotEmpty\t：只作用于字符串类型，字符串不为空，并且长度不为0\n@NotBlank\t：只作用于字符串类型，字符串不为空，并且trim()后不为空串\n@DecimalMax(value)\t：限制必须为一个不大于指定值的数字\n@DecimalMin(value)\t：限制必须为一个不小于指定值的数字\n@Max(value)\t：限制必须为一个不大于指定值的数字\n@Min(value)\t：限制必须为一个不小于指定值的数字\n@Pattern(value)\t：限制必须符合指定的正则表达式\n@Size(max,min)\t：限制字符长度必须在min到max之间\n@Email\t：验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式\n\n第三步 使用两种不同的校验器实现\n（1）使用jakarta.validation.Validator校验\njavapackage com.atguigu.spring6.validation.method2;\n\nimport jakarta.validation.ConstraintViolation;\nimport jakarta.validation.Validator;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport java.util.Set;\n\n@Service\npublic class MyService1 &#123;\n\n    @Autowired\n    private Validator validator;\n\n    public  boolean validator(User user)&#123;\n        Set&lt;ConstraintViolation&lt;User&gt;&gt; sets =  validator.validate(user);\n        return sets.isEmpty();\n    &#125;\n\n&#125;（2）使用org.springframework.validation.Validator校验\njavapackage com.atguigu.spring6.validation.method2;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.validation.BindException;\nimport org.springframework.validation.Validator;\n\n@Service\npublic class MyService2 &#123;\n\n    @Autowired\n    private Validator validator;\n\n    public boolean validaPersonByValidator(User user) &#123;\n        BindException bindException = new BindException(user, user.getName());\n        validator.validate(user, bindException);\n        return bindException.hasErrors();\n    &#125;\n&#125;第四步 测试\njavapackage com.atguigu.spring6.validation.method2;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class TestMethod2 &#123;\n\n    @Test\n    public void testMyService1() &#123;\n        ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class);\n        MyService1 myService = context.getBean(MyService1.class);\n        User user = new User();\n        user.setAge(-1);\n        boolean validator = myService.validator(user);\n        System.out.println(validator);\n    &#125;\n\n    @Test\n    public void testMyService2() &#123;\n        ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class);\n        MyService2 myService = context.getBean(MyService2.class);\n        User user = new User();\n        user.setName(&quot;lucy&quot;);\n        user.setAge(130);\n        user.setAge(-1);\n        boolean validator = myService.validaPersonByValidator(user);\n        System.out.println(validator);\n    &#125;\n&#125;10.4、实验三：基于方法实现校验第一步 创建配置类，配置MethodValidationPostProcessor\njavapackage com.atguigu.spring6.validation.method3;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;\nimport org.springframework.validation.beanvalidation.MethodValidationPostProcessor;\n\n@Configuration\n@ComponentScan(&quot;com.atguigu.spring6.validation.method3&quot;)\npublic class ValidationConfig &#123;\n\n    @Bean\n    public MethodValidationPostProcessor validationPostProcessor() &#123;\n        return new MethodValidationPostProcessor();\n    &#125;\n&#125;第二步 创建实体类，使用注解设置校验规则\njavapackage com.atguigu.spring6.validation.method3;\n\nimport jakarta.validation.constraints.*;\n\npublic class User &#123;\n\n    @NotNull\n    private String name;\n\n    @Min(0)\n    @Max(120)\n    private int age;\n\n    @Pattern(regexp = &quot;^1(3|4|5|7|8)\\\\d&#123;9&#125;$&quot;,message = &quot;手机号码格式错误&quot;)\n    @NotBlank(message = &quot;手机号码不能为空&quot;)\n    private String phone;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n    public String getPhone() &#123;\n        return phone;\n    &#125;\n    public void setPhone(String phone) &#123;\n        this.phone = phone;\n    &#125;\n&#125;第三步 定义Service类，通过注解操作对象\njavapackage com.atguigu.spring6.validation.method3;\n\nimport jakarta.validation.Valid;\nimport jakarta.validation.constraints.NotNull;\nimport org.springframework.stereotype.Service;\nimport org.springframework.validation.annotation.Validated;\n\n@Service\n@Validated\npublic class MyService &#123;\n    \n    public String testParams(@NotNull @Valid User user) &#123;\n        return user.toString();\n    &#125;\n\n&#125;第四步 测试\njavapackage com.atguigu.spring6.validation.method3;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class TestMethod3 &#123;\n\n    @Test\n    public void testMyService1() &#123;\n        ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class);\n        MyService myService = context.getBean(MyService.class);\n        User user = new User();\n        user.setAge(-1);\n        myService.testParams(user);\n    &#125;\n&#125;10.5、实验四：实现自定义校验第一步 自定义校验注解\njavapackage com.atguigu.spring6.validation.method4;\n\nimport jakarta.validation.Constraint;\nimport jakarta.validation.Payload;\nimport java.lang.annotation.*;\n\n@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Constraint(validatedBy = &#123;CannotBlankValidator.class&#125;)\npublic @interface CannotBlank &#123;\n    //默认错误消息\n    String message() default &quot;不能包含空格&quot;;\n\n    //分组\n    Class&lt;?&gt;[] groups() default &#123;&#125;;\n\n    //负载\n    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;\n\n    //指定多个时使用\n    @Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @interface List &#123;\n        CannotBlank[] value();\n    &#125;\n&#125;第二步 编写真正的校验类\njavapackage com.atguigu.spring6.validation.method4;\n\nimport jakarta.validation.ConstraintValidator;\nimport jakarta.validation.ConstraintValidatorContext;\n\npublic class CannotBlankValidator implements ConstraintValidator&lt;CannotBlank, String&gt; &#123;\n\n        @Override\n        public void initialize(CannotBlank constraintAnnotation) &#123;\n        &#125;\n\n        @Override\n        public boolean isValid(String value, ConstraintValidatorContext context) &#123;\n            //null时不进行校验\n            if (value != null &amp;&amp; value.contains(&quot; &quot;)) &#123;\n                //获取默认提示信息\n                String defaultConstraintMessageTemplate = context.getDefaultConstraintMessageTemplate();\n                System.out.println(&quot;default message :&quot; + defaultConstraintMessageTemplate);\n                //禁用默认提示信息\n                context.disableDefaultConstraintViolation();\n                //设置提示语\n                context.buildConstraintViolationWithTemplate(&quot;can not contains blank&quot;).addConstraintViolation();\n                return false;\n            &#125;\n            return true;\n        &#125;\n&#125;\n11、提前编译：AOT\n11.1、AOT概述11.1.1、JIT与AOT的区别JIT和AOT 这个名词是指两种不同的编译方式，这两种编译方式的主要区别在于是否在“运行时”进行编译\n（1）JIT， Just-in-time,动态(即时)编译，边运行边编译；\n在程序运行时，根据算法计算出热点代码，然后进行 JIT 实时编译，这种方式吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。JIT 缺点就是编译需要占用运行时资源，会导致进程卡顿。\n（2）AOT，Ahead Of Time，指运行前编译，预先编译。\nAOT 编译能直接将源代码转化为机器码，内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化，AOT 缺点就是在程序运行前编译会使程序安装的时间增加。                                                           \n简单来讲：\n\nJIT即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。\n而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。\n\ntxt.java -&gt; .class -&gt; (使用jaotc编译工具) -&gt; .so（程序函数库,即编译好的可以供其他程序使用的代码和数据）\n（3）AOT的优点\n简单来讲，Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验。\n\n在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗\n可以在程序运行初期就达到最高性能，程序启动速度快\n运行产物只有机器码，打包体积小\n\nAOT的缺点\n由于是静态提前编译，不能根据硬件情况或程序运行情况择优选择机器指令序列，理论峰值性能不如JIT没有动态能力，同一份产物不能跨平台运行\n第一种即时编译 (JIT) 是默认模式，Java Hotspot 虚拟机使用它在运行时将字节码转换为机器码。后者提前编译 (AOT)由新颖的 GraalVM 编译器支持，并允许在构建时将字节码直接静态编译为机器码。\n现在正处于云原生，降本增效的时代，Java 相比于 Go、Rust 等其他编程语言非常大的弊端就是启动编译和启动进程非常慢，这对于根据实时计算资源，弹性扩缩容的云原生技术相冲突，Spring6 借助 AOT 技术在运行时内存占用低，启动速度快，逐渐的来满足 Java 在云原生时代的需求，对于大规模使用 Java 应用的商业公司可以考虑尽早调研使用 JDK17，通过云原生技术为公司实现降本增效。\n11.1.2、GraalvmSpring6 支持的 AOT 技术，这个 GraalVM  就是底层的支持，Spring 也对 GraalVM 本机映像提供了一流的支持。GraalVM 是一种高性能 JDK，旨在加速用 Java 和其他 JVM 语言编写的应用程序的执行，同时还为 JavaScript、Python 和许多其他流行语言提供运行时。 GraalVM 提供两种运行 Java 应用程序的方法：在 HotSpot JVM 上使用 Graal 即时 (JIT) 编译器或作为提前 (AOT) 编译的本机可执行文件。 GraalVM 的多语言能力使得在单个应用程序中混合多种编程语言成为可能，同时消除了外语调用成本。GraalVM 向 HotSpot Java 虚拟机添加了一个用 Java 编写的高级即时 (JIT) 优化编译器。\nGraalVM 具有以下特性：\n（1）一种高级优化编译器，它生成更快、更精简的代码，需要更少的计算资源\n（2）AOT 本机图像编译提前将 Java 应用程序编译为本机二进制文件，立即启动，无需预热即可实现最高性能\n（3）Polyglot 编程在单个应用程序中利用流行语言的最佳功能和库，无需额外开销\n（4）高级工具在 Java 和多种语言中调试、监视、分析和优化资源消耗\n总的来说对云原生的要求不算高短期内可以继续使用 2.7.X 的版本和 JDK8，不过 Spring 官方已经对 Spring6 进行了正式版发布。\n11.1.3、Native Image目前业界除了这种在JVM中进行AOT的方案，还有另外一种实现Java AOT的思路，那就是直接摒弃JVM，和C&#x2F;C++一样通过编译器直接将代码编译成机器代码，然后运行。这无疑是一种直接颠覆Java语言设计的思路，那就是GraalVM Native Image。它通过C语言实现了一个超微缩的运行时组件 —— Substrate VM，基本实现了JVM的各种特性，但足够轻量、可以被轻松内嵌，这就让Java语言和工程摆脱JVM的限制，能够真正意义上实现和C&#x2F;C++一样的AOT编译。这一方案在经过长时间的优化和积累后，已经拥有非常不错的效果，基本上成为Oracle官方首推的Java AOT解决方案。Native Image 是一项创新技术，可将 Java 代码编译成独立的本机可执行文件或本机共享库。在构建本机可执行文件期间处理的 Java 字节码包括所有应用程序类、依赖项、第三方依赖库和任何所需的 JDK 类。生成的自包含本机可执行文件特定于不需要 JVM 的每个单独的操作系统和机器体系结构。\n11.2、演示Native Image构建过程11.2.1、GraalVM安装（1）下载GraalVM\n进入官网下载：https://www.graalvm.org/downloads/\n\n\n（2）配置环境变量\n添加GRAALVM_HOME\n\n把JAVA_HOME修改为graalvm的位置\n\n把Path修改位graalvm的bin位置\n\n使用命令查看是否安装成功\n\n（3）安装native-image插件\n使用命令 gu install native-image下载安装\n\n11.2.2、安装C++的编译环境（1）下载Visual Studio安装软件\nhttps://visualstudio.microsoft.com/zh-hans/downloads/\n\n（2）安装Visual Studio\n\n\n（3）添加Visual Studio环境变量\n配置INCLUDE、LIB和Path\n\n\n\n（4）打开工具，在工具中操作\n\n11.2.3、编写代码，构建Native Image（1）编写Java代码javapublic class Hello &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;hello world&quot;);\n    &#125;\n&#125;（2）复制文件到目录，执行编译\n（3）Native Image 进行构建\n\n（4）查看构建的文件\n（5）执行构建的文件\n可以看到这个Hello最终打包产出的二进制文件大小为11M，这是包含了SVM和JDK各种库后的大小，虽然相比C&#x2F;C++的二进制文件来说体积偏大，但是对比完整JVM来说，可以说是已经是非常小了。\n相比于使用JVM运行，Native Image的速度要快上不少，cpu占用也更低一些，从官方提供的各类实验数据也可以看出Native Image对于启动速度和内存占用带来的提升是非常显著的：\n\n\n","slug":"Spring6","date":"2024-03-23T16:00:00.000Z","categories_index":"微服务核心","tags_index":"微服务核心","author_index":"白"},{"id":"e76bf1e077da981b66e157d84fcb8179","title":"Gradle篇","content":"Gradle项目构建工具1、Gradle入门1.1、Gradle 简介Gradle 是一款 Google 推出的基于 JVM、通用灵活的项目构建工具，支持 Maven，JCenter 多种第三方仓库;支持传递性，依赖管理、废弃了繁杂的 xml 文件，转而使用简洁的、支持多种语言(例如：java、groovy 等)的 build 脚本文件。\n官网地址: https://gradle.org/\n\n学习 Gradle 的原因：\n\n目前已经有相当一部分公司在逐渐使用Gradle作为项目构建工具了。\n作为Java开发程序员,如果想下载Spring、SpringBoot等Spring家族的源码，基本上基于Gradle构建的。\n\n总之，虽然目前市面上常见的项目构建工具有 Ant、Maven、Gradle，主流还是 Maven，但是未来趋势 Gradle。\n1.2、常见的项目构建工具Ant: 2000 年 Apache 推出的纯 Java 编写构建工具，通过 xml[build.xml]文件管理项目\n\n优点：使用灵活，速度快(快于 gradle 和 maven)，\n缺点：Ant 没有强加任何编码约定的项目目录结构,开发人员需编写繁杂 XML 文件构建指令,对开发人员是一个挑战。\n\nMaven: 2004 年 Apache 组织推出的再次使用 xml 文件[pom.xml]管理项目的构建工具。\n\n优点: 遵循一套约定大于配置的项目目录结构，使用统一的 GAV 坐标进行依赖管理,侧重于包管理。\n缺点：项目构建过程僵化,配置文件编写不够灵活、不方便自定义组件,构建速度慢于 gradle。\n\nGradle: 2012 年 Google 推出的基于 Groovy 语言的全新项目构建工具，集合了 Ant 和 Maven 各自的优势。\n\n优点：集 Ant 脚本的灵活性+Maven 约定大于配置的项目目录优势,支持多种远程仓库和插件,侧重于大项目构建。\n缺点：学习成本高、资料少、脚本灵活、版本兼容性差等。\n\n\nWhatever:无论哪种项目构建工具，都有自身的优势和劣势，所以选择一款最适合自己的就是最好的。\n1.3、Gradle 安装1.3.1、Gradle 安装说明SpringBoot 官方文档明确指出,目前 SpringBoot 的 Gradle 插件需要 gradle6.8 版本及以上，所以我们这里选择 7.x 版本。\n其中 SpringBoot 与 Gradle 存在版本兼容问题，Gradle 与 Idea 也存在兼容问题，所以考虑到 java 程序员会使用 SpringBoot，\n所以要选择 6.8 版本及高于 6.8 版本的 Gradle,那么相应的 idea 版本也要升级。\n具体参考文档:https://docs.spring.io/spring-boot/docs/2.5.0/gradle-plugin/reference/htmlsingle/#getting-started\n1.3.2、安装 JDK要求 Jdk 为 1.8 或者 1.8 版本以上。\n1.3.3、下载并解压到指定目录下载：\n解压到指定目录：D:\\software\\gradle-7.4.1 \n1.3.4、配置环境变量\n特别注意：这里我们接着再配置一个 GRALE_USER_HOME 环境变量：\n\nGRALE_USER_HOME 相当于配置 Gradle 本地仓库位置和 Gradle Wrapper 缓存目录。\n1.3.5、检测是否安装成功gradle -v 或者 gradle --version: 通过gradle -v或者 gradle --version检测是否安装成功\n1.4、Gradle 项目目录结构Gradle 项目默认目录结构和 Maven 项目的目录结构一致,都是基于约定大于配置【Convention Over Configuration】。\n其完整项目目录结构如下所示：\n\nTips: \n\n只有war工程才有webapp目录，对于普通的jar工程并没有webapp目录\ngradlew与gradlew.bat执行的指定wrapper版本中的gradle指令,不是本地安装的gradle指令。\n\n1.5、Gradle 创建第一个项目借助于 spring 脚手架创建 gradle 第一个项目：https://start.spring.io/\n\n查看生成的 gradle 项目目录结构如下所示:\n\n与上图对比会发现：总体的目录结构与上图说明的是一致的。\n1.5.1、Gradle 中的常用指令Gradle 常用命令说明:\n注意：gradle 的指令要在含有 build.gradle 的目录执行。\n\n1.5.2、修改 maven 下载源Gradle 自带的 Maven 源地址是国外的，该 Maven 源在国内的访问速度是很慢的，除非使用了特别的手段。一般情况下，我们建议使用国内的第三方开放的 Maven 源或企业内部自建 Maven 源。\n认识 init.d 文件夹\n我们可以在 gradle 的 init.d 目录下创建以.gradle 结尾的文件，.gradle 文件可以实现在 build 开始之前执行，所以你可以在这个文件配置一些你想预先加载的操作。\n在 init.d 文件夹创建 init.gradle 文件\ntexallprojects &#123;\n    repositories &#123; \n        mavenLocal() \n        maven &#123; name &quot;Alibaba&quot; ; url &quot;https://maven.aliyun.com/repository/public&quot; &#125; \n        maven &#123; name &quot;Bstek&quot; ; url &quot;https://nexus.bsdn.org/content/groups/public/&quot; &#125; \n        mavenCentral()\n    &#125;\n    buildscript &#123;\n        repositories &#123; \n            maven &#123; name &quot;Alibaba&quot; ; url &#39;https://maven.aliyun.com/repository/public&#39; &#125; \n            maven &#123; name &quot;Bstek&quot; ; url &#39;https://nexus.bsdn.org/content/groups/public/&#39; &#125; \n            maven &#123; name &quot;M2&quot; ; url &#39;https://plugins.gradle.org/m2/&#39; &#125;\n        &#125;\n    &#125;\n&#125;拓展 1：启用 init.gradle 文件的方法有：\n\n在命令行指定文件,例如：gradle --init-script yourdir/init.gradle -q taskName。你可以多次输入此命令来指定多个init文件\n把init.gradle文件放到 USER_HOME/.gradle/ 目录下\n把以.gradle结尾的文件放到 USER_HOME/.gradle/init.d/ 目录下\n把以.gradle结尾的文件放到 GRADLE_HOME/init.d/ 目录下\n\n如果存在上面的4种方式的2种以上，gradle会按上面的1-4序号依次执行这些文件，如果给定目录下存在多个init脚本，会按拼音a-z顺序执行这些脚本，每个init脚本都存在一个对应的gradle实例,你在这个文件中调用的所有方法和属性，都会委托给这个gradle实例，每个init脚本都实现了Script接口。\n拓展 2：仓库地址说明\n\nmavenLocal() ： 指定使用maven本地仓库，而本地仓库在配置maven时settings文件指定的仓库位置。如E:&#x2F;repository，gradle 查找jar包顺序如下：USER_HOME&#x2F;.m2&#x2F;settings.xml &gt;&gt; M2_HOME&#x2F;conf&#x2F;settings.xml &gt;&gt; USER_HOME&#x2F;.m2&#x2F;repository maven { url 地址}，指定maven仓库，一般用私有仓库地址或其它的第三方库【比如阿里镜像仓库地址】。\nmavenCentral() ：这是Maven的中央仓库，无需配置，直接声明就可以使用。\njcenter() ：JCenter中央仓库，实际也是是用的maven搭建的，但相比Maven仓库更友好，通过CDN分发，并且支持https访问,在新版本中已经废弃了，替换为了mavenCentral()。\n\n总之：gradle可以通过指定仓库地址为本地maven仓库地址和远程仓库地址相结合的方式，避免每次都会去远程仓库下载依赖库。这种方式也有一定的问题，如果本地maven仓库有这个依赖，就会从直接加载本地依赖，如果本地仓库没有该依赖，那么还是会从远程下载。但是下载的jar不是存储在本地maven仓库中，而是放在自己的缓存目录中，默认在USER_HOME&#x2F;.gradle&#x2F;caches目录,当然如果我们配置过GRADLE_USER_HOME环境变量，则会放GRADLE_USER_HOME&#x2F;caches目录,那么可不可以将gradle caches指向maven repository。我们说这是不行的，caches下载文件不是按照maven仓库中存放的方式。\n拓展 3：阿里云仓库地址请参考：https://developer.aliyun.com/mvn/guide\n\n在 gradle 中的使用说明：\n\n1.5.3、Wrapper 包装器Gradle Wrapper 实际上就是对 Gradle 的一层包装，用于解决实际开发中可能会遇到的不同的项目需要不同版本的 Gradle 问题。\n例如：把自己的代码共享给其他人使用，可能出现如下情况: \n\n对方电脑没有安装 gradle \n对方电脑安装过 gradle，但是版本太旧了\n\n这时候，我们就可以考虑使用 Gradle Wrapper 了。这也是官方建议使用 Gradle Wrapper 的原因。实际上有了 Gradle Wrapper 之后，我们本地是可以不配置 Gradle 的,下载 Gradle 项目后，使用 gradle 项目自带的 wrapper 操作也是可以的。\n那如何使用 Gradle Wrapper 呢？\n\n项目中的gradlew、gradlew.cmd脚本用的就是wrapper中规定的gradle版本。参见源码\n而我们上面提到的gradle指令用的是本地gradle,所以gradle指令和gradlew指令所使用的gradle版本有可能是不一样的。\ngradlew、gradlew.cmd的使用方式与gradle使用方式完全一致，只不过把gradle指令换成了gradlew指令。\n\n当然,我们也可在终端执行 gradlew 指令时，指定指定一些参数,来控制 Wrapper 的生成，比如依赖的版本等，如下：\n\n具体操作如下所示 ：\n\ngradle wrapper --gradle-version=4.4：升级wrapper版本号,只是修改gradle.properties中wrapper版本，未实际下载\ngradle wrapper --gradle-version 5.2.1 --distribution-type all :关联源码用\n\nGradleWrapper 的执行流程：\n\n当我们第一次执行 ./gradlew build 命令的时候，gradlew 会读取 gradle-wrapper.properties 文件的配置信息\n准确的将指定版本的 gradle 下载并解压到指定的位置(GRADLE_USER_HOME目录下的wrapper&#x2F;dists目录中) \n并构建本地缓存(GRADLE_USER_HOME目录下的caches目录中),下载再使用相同版本的gradle就不用下载了\n之后执行的 ./gradlew 所有命令都是使用指定的 gradle 版本。如下图所示：\n\n\ngradle-wrapper.properties 文件解读：\n\n注意：前面提到的 GRALE_USER_HOME 环境变量用于这里的 Gradle Wrapper 下载的特定版本的 gradle 存储目录。如果我们没有配置过 GRALE_USER_HOME 环境变量,默认在当前用户家目录下的.gradle 文件夹中。\n那什么时候选择使用 gradle wrapper、什么时候选择使用本地 gradle?\n\n下载别人的项目或者使用操作以前自己写的不同版本的gradle项目时：用Gradle wrapper,也即:gradlew \n什么时候使用本地gradle?新建一个项目时： 使用gradle指令即可。\n\n\n2、Gradle 与 Idea 整合2.1、Groovy 简介在某种程度上，Groovy 可以被视为 Java 的一种脚本化改良版,Groovy 也是运行在 JVM 上，它可以很好地与 Java 代码及其相关库进行交互操作。它是一种成熟的面向对象编程语言，既可以面向对象编程，又可以用作纯粹的脚本语言。大多数有效的 Java 代码也可以转换为有效的 Groovy 代码，Groovy 和 Java 语言的主要区别是：完成同样的任务所需的Groovy 代码比 Java 代码更少。其特点为：\n\n功能强大，例如提供了动态类型转换、闭包和元编程（metaprogramming）支持\n支持函数式编程，不需要 main 函数\n默认导入常用的包\n类不支持 default 作用域,且默认作用域为 public。\nGroovy 中基本类型也是对象，可以直接调用对象的方法。\n支持 DSL（Domain Specific Languages 领域特定语言）和其它简洁的语法，让代码变得易于阅读和维护。\nGroovy 是基于 Java 语言的，所以完全兼容 Java 语法,所以对于 java 程序员学习成本较低。\n\n详细了解请参考：http://www.groovy-lang.org/documentation.html\n2.2、Groovy 安装下载地址: https://groovy.apache.org/download.html\n解压配置环境变量：\n\n2.3、创建 Groovy 项目\n2.4、Groovy 基本语法\n类型转换 ：当需要时,类型之间会自动发生类型转换: 字符串（String）、基本类型(如 int) 和类型的包装类 (如 Integer)\n类说明 ：如果在一个 groovy 文件中没有任何类定义，它将被当做 script 来处理，也就意味着这个文件将被透明的转换为一个 Script 类型的类 ，这个自动转换得到的类将使用原始的 groovy 文件名作为类的名字。groovy 文件的内容被打包进run 方法，另外在新产生的类中被加入一个 main 方法以进行外部执行该脚本。\n2.4.1、案例 1:基本注意点\n提示：方法调用时,在不含有歧义的地方可以省略方法调用时的括号。这类似于使用${变量名}时，括号在不引起歧义的地方可以省略是一样的：如下\ngroovydef num1=1;\ndef num2= 2;\nprintln &quot;$num1 + $num2 = $&#123;num1+num2&#125;&quot;2.4.2、案例 2:引号说明groovydef num1=1; def num2=2; def str1=&quot;1d&quot;; //双引号\ndef str2=&#39;dsd&#39;; //单引号\n//双引号运算能力,单引号用于常量字符串,三引号相当于模板字符串，可以支持换行\nprintln &quot;$num1 + $num2 = $&#123;num1 + num2&#125;&quot; //基本数据类型也可以作为对象使用,可以调用对象的方法\nprintln(num1.getClass().toString())\nprintln(str1.getClass().toString())\nprintln(str2.getClass().toString())2.4.3、案例 3:三个语句结构Groovy 支持顺序结构从上向下依次解析、分支结构(if..else、if..else if ..else..、switch..case、for、while、do..while)\n具体参考官网：http://www.groovy-lang.org/semantics.html#_conditional_structures\n2.4.4、案例 4:类型及权限修饰符Groovy 中的类型有: \n\n原生数据类型及包装类\n类、内部类、抽象类、接口\n注解\nTrait: 可以看成是带有方法实现的接口\n\n权限修饰符: public、protected、private\n拓展：Groovy 类与 Java 类之间的主要区别是\n\n没有可见性修饰符的类或方法自动是公共的(可以使用一个特殊的注释来实现包的私有可见性)。\n没有可见性修饰符的字段将自动转换为属性，不需要显式的 getter 和 setter 方法。\n如果属性声明为 final，则不会生成 setter。\n一个源文件可能包含一个或多个类(但是如果一个文件不包含类定义的代码，则将其视为脚本)。脚本只是具有一些特殊约定的类,它们的名称与源文件相同(所以不要在脚本中包含与脚本源文件名相同的类定义)。\n\n提 示 : 有 关 Groovy 中 各 种 各 样 的 数 据 类 型 和 权 限 修 饰 符 及 Goovy 与 Java 区 别 请 参 考 ：http://www.groovy-lang.org/objectorientation.html#_modifiers_on_a_property\n2.4.5、案例 5:集合操作Groovy 支持 List、Map 集合操作，并且拓展了 Java 中的 API,具体参考如下方法：\nList: \n\nadd():添加某个元素\nplus():添加某个 list 集合\nremove():删除指定下标的元素\nremoveElement():删除某个指定的元素\nremoveAll(): 移除某个集合中的元素\npop():弹出 list 集合中最后一个元素\nputAt():修改指定下标的元素\neach():遍历\nsize(): 获取 list 列表中元素的个数\ncontains(): 判断列表中是否包含指定的值，则返回 true\n\nMap: \n\nput():向 map 中添加元素\nremove():根据某个键做移除，或者移除某个键值对\n+、-：支持 map 集合的加减操作\neach():遍历 map 集合\n\n请参考官网:http://www.groovy-lang.org/syntax.html#_number_type_suffixes \n提示:可以把不同的基本类型添加到同一集合中。\n2.4.6、案例 6:类导入Groovy 遵循 Java 允许 import 语句解析类引用的概念。\ngroovyimport groovy.xml.MarkupBuilder \ndef xml = new MarkupBuilder() \nassert xml != nullGroovy 语言默认提供的导入\ngroovyimport java.lang.*\nimport java.util.*\nimport java.io.*\nimport java.net.*\nimport groovy.lang.*\nimport groovy.util.*\nimport java.math.BigInteger\nimport java.math.BigDecimal这样做是因为这些包中的类最常用。通过导入这些样板代码减少了。\n参考官网地址：http://www.groovy-lang.org/structure.html#_imports \n2.4.7、案例 7:异常处理Groovy 中的异常处理和 java 中的异常处理是一样的。\ngroovydef z\ntry &#123;\n    def i = 7, j = 0\n    try &#123;\n        def k = i / j assert false \n    &#125; finally &#123;\n        z = &#39;reached here&#39; \n    &#125;\n&#125; catch ( e ) &#123;\n    assert e in ArithmeticException\n    assert z == &#39;reached here&#39; \n&#125;参考官网地址： http://www.groovy-lang.org/semantics.html#_try_catch_finally\n2.4.8、案例 8:闭包闭包 ：Groovy 中的闭包是一个开放的、匿名的代码块，它可以接受参数、也可以有返回值。闭包可以引用其周围作用域中声明的变量。\n语法 ：&#123; [closureParameters -&gt; ] statements &#125;\n其中[ closureParameters-&gt; ]是一个可选的逗号分隔的参数列表,参数后面是 Groovy 语句。参数类似于方法参数列表，这些参数可以是类型化的,也可以是非类型化的。当指定参数列表时，需要使用-&gt; 字符，用于将参数与闭包体分离。\n参考：http://www.groovy-lang.org/closures.html\ngroovy//闭包体完成变量自增操作\n&#123; item++ &#125;\n//闭包使用 空参数列表 明确规定这是无参的\n&#123; -&gt; item++ &#125;\n//闭包中有一个默认的参数[it]，写不写无所谓\n&#123; println it &#125;\n&#123; it -&gt; println it &#125;\n//如果不想使用默认的闭包参数it,那需要显示自定义参数的名称\n&#123; name -&gt; println name &#125;\n//闭包也可以接受多个参数\n&#123; String x, int y -&gt;\n    println &quot;hey $&#123;x&#125; the value is $&#123;y&#125;&quot; \n&#125;\n//闭包参数也可是一个对象\n&#123; reader -&gt;\n    def line = reader.readLine()\n    line.trim()\n&#125;闭包调用方式： 闭包是 groovy.lang.Closure 的实例。它可以像任何其他变量一样分配给一个变量或字段。\n\n闭包对象(参数)\n闭包对象.call(参数)\n\ngroovydef isOdd = &#123; int i -&gt; i%2 != 0 &#125;\nassert isOdd(3) == true \nassert isOdd.call(2) == false \n\ndef isEven = &#123; it%2 == 0 &#125;\nassert isEven(3) == false \nassert isEven.call(2) == true特殊说明： 可以把闭包当作一个对象，作为参数传递给方法使用\ngroovy//无参闭包\ndef run(Closure closure)&#123;\n    println(&quot;run start....&quot;) closure()\n    println(&quot;run end....&quot;)\n&#125;\nrun &#123;\n    println &quot;running......&quot;\n&#125;\n//有参闭包\ndef caculate(Closure closure)&#123;\n    def num1=1; \n    def num2=3; \n    println(&quot;caculate start....&quot;) \n    closure(num1,num2)\n    println(&quot;caculate end....&quot;)\n&#125;\ncaculate &#123;x,y -&gt; println &quot;计算结果为：$x+$y=$&#123;x+y&#125;&quot;&#125; //在build.gradle文件中我们见到的很多都是闭包格式的。2.5、在 idea 中创建普通 java 工程具体整合：\n第一步：创建由 Gradle 管理的项目\n\n第二步：修改当前项目使用本地安装的 gradle：可以加快下载项目依赖 jar 包的速度【配置了私服地址】\n\n特别提示 1 ：使得在 Terminal 中执行以 gradlew 开头命令和操作图形化的 IDEA 使用 Gradle 版本不一定是同一个版本。\n\nTerminal中以gradlew开头指令用的是Wrapper规定的gradle版本,wrapper中规定版本默认和idea插件中规定的版本一致。\n而图形化的IDEA使用Gradle是本地安装的哦。\n\n特别提示 2 ：目前只能是在创建项目时重新设置本地 gradle,创建新项目需要重新去改。\n特 别 提 示 3 ：当 我 们 在 gradle.build 文 件 添 加 依 赖 之 后 ， 这 些 依 赖 会 在 下 载 到GRADLE_USER_HOME&#x2F;caches&#x2F;modules-2&#x2F;files-2.1 目录下面,所以这里的 GRADLE_USER_HOME 相当于 Gradle 的本地仓库,当然也可以如下方式找到 jar 包位置。\n\n2.6、在 idea 中创建 web 工程在 idea 新版本的创建项目中,无法自己选择创建项目是普通 java 工程还是 web 工程了【IDEA 旧版本是可以的】，所以我们如果想创建 web 工程，只需要自己在 src&#x2F;main&#x2F;目录下添加 webapp&#x2F;WEB-INF&#x2F;web.xml 及页面即可。\n代码演示：参考视频+资料\n2.7、项目部署当我们将一个 java 项目打成 war 包之后，就需要部署到服务器运行，这里有两种方式：\n\n我们将项目打成 war 包，部署到本地 tomcat 运行。参考视频\n使用 Gretty 插件中内置服务器方式部署项目。参考视频\n\n2.7.1、Gretty 部署项目Gretty 是一个功能丰富的 gradle 插件，用于在嵌入的 servlet 容器上运行 web 应用程序,让项目开发和部署更加简单。\n目前 Gretty 插件已经作为 gradle 的核心库使用了,Gretty 其核心功能为：\n\n底层支持 jetty,tomcat 等 Servlet 容器\n支持项目热部署、HTTPS、调试\n\nGretty 官网地址：http://akhikhl.github.io/gretty-doc/index.html\n2.7.2、具体使用第一步：引入 Gretty 插件\ngroovyplugins &#123;\n    id ‘war’ \n    id &#39;org.gretty&#39; version &#39;2.2.0&#39; \n&#125;第二步：指定 maven 仓库\ngroovyrepositories &#123;\n    //指定jcenter仓库，一定要放在前面\n    jcenter() \n    mavenCentral()\n&#125;第三步：针对 Gretty 插件的设置\ngroovygretty &#123;\n    httpPort = 8888\n    contextPath = &quot;/web&quot;\n    debugPort = 5005 // default\n    debugSuspend = true // default\n    httpsEnabled = true managedClassReload=true //修改了类之后重新加载\n    //servletContainer = &#39;tomcat8&#39; //如果不指定默认的servlet容器，支持tomcat7/8，默认是使用的是Jetty服务器\n    httpsPort = 4431\n&#125;第四步：执行 Gretty 插件\ngroovygradle appRun 如 果 大 家 想 进 一 步 了 解 的 属 性 配 置 , 比 如 Gretty 热 部 署 等 设 置 ， 欢 迎 参 考 其 官 方 文 档http://akhikhl.github.io/gretty-doc/Gretty-configuration.html。\n2.8、Gradle 对测试支持测试任务自动检测并执行测试源集中的所有单元测试。测试执行完成后会生成一个报告。支持 JUnit 和 TestNG 测试。\n2.8.1、默认测试目录及标准输出\n2.8.2、Junit 使用Gradle 对于 Junit4.x 支持\ngroovydependencies &#123;\n    testImplementation group: &#39;junit&#39; ,name: &#39;junit&#39;, version: &#39;4.12&#39; \n&#125;\ntest &#123;\n    useJUnit()\n&#125;Gradle 对于 Junit5.x 版本支持\ngroovydependencies &#123;\n    testImplementation &#39;org.junit.jupiter:junit-jupiter-api:5.8.1&#39; \n       testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine:5.8.1&#39; \n&#125;\ntest &#123;\n    useJUnitPlatform()\n&#125;注意：无论是 Junt4.x 版本还是 Junit5.x 版本，我们只需在 build.gradle 目录下执行 gradle test 指令，gradle 就会帮我们执行所有的加了@Test 注解的测试，并生成测试报告。\n2.8.3、包含和排除特定测试gradle 在 junit 中的批量测试,可以设置包含或者排除某些特定测试。\ngroovytest &#123;\n    enabled true \n    useJUnit()\n    include &#39;com/**&#39; \n    exclude &#39;com/abc/**&#39; \n&#125;\n3、Gradle 进阶说明本章将从整体构建脚本的角度介绍:\n\n什么是 setting 文件,它有什么作用;\n说明什么是 build 文件,它又有什么作用\n我们可以创建多少个 build\nproject 和 task,他们有什么作用;又是什么关系,如何配置\n项目的生命周期\n项目发布\n使用 Gradle 创建 SpringBoot 项目等\n\n3.1、项目的生命周期Gradle 项目的生命周期分为三大阶段: Initialization -&gt; Configuration -&gt; Execution. 每个阶段都有自己的职责,具体如下图所示\n\nInitialization 阶段主要目的是初始化构建, 它又分为两个子过程,一个是执行 Init Script,另一个是执行 Setting Script。\ninit.gradle 文件会在每个项目 build 之前被调用，用于做一些初始化的操作，它主要有如下作用：\n\n配置内部的仓库信息（如公司的 maven 仓库信息）；\n配置一些全局属性；\n配置用户名及密码信息（如公司仓库的用户名和密码信息）。\n\nSetting Script 则更重要, 它初始化了一次构建所参与的所有模块。\nConfiguration 阶段：这个阶段开始加载项目中所有模块的 Build Script。所谓 “加载” 就是执行 build.gradle 中的语句, 根据脚本代码创建对应的 task, 最终根据所有 task 生成由 Task 组成的有向无环图(Directed Acyclic Graphs)，如下:\n\n从而构成如下有向无环树：\n\nExecution 阶段：这个阶段会根据上个阶段构建好的有向无环图，按着顺序执行 Task【Action 动作】。\n3.2、settings 文件首先对 settings 文件的几点说明：\n\n作用：主要是在项目初始化阶段确定一下引入哪些工程需要加入到项目构建中,为构建项目工程树做准备。\n工程树：gradle 中有工程树的概念，类似于 maven 中的 project 与 module。\n内容：里面主要定义了当前 gradle 项目及子 project 的项目名称\n位置：必须放在根工程目录下。\n名字：为 settings.gradle 文件，不能发生变化\n对应实例：与 org.gradle.api.initialization.Settings 实例是一一对应的关系。每个项目只有一个 settings 文件。\n关注：作为开发者我们只需要关注该文件中的 include 方法即可。使用相对路径【 : 】引入子工程。\n一个子工程只有在 setting 文件中配置了才会被 gradle 识别,这样在构建的时候才会被包含进去。案例如下所示：\n\ngroovy//根工程项目名\nrootProject.name = &#39;root&#39; \n//包含的子工程名称\ninclude &#39;subject01&#39; \ninclude &#39;subject02&#39; \ninclude &#39;subject03&#39; \n//包含的子工程下的子工程名称\ninclude &#39;subject01:subproject011&#39; \ninclude &#39;subject01:subproject012&#39;项目名称中&quot;:&quot;代表项目的分隔符, 类似路径中的 &quot;/&quot;. 如果以 &quot;:&quot; 开头则表示相对于 root project 。然后 Gradle 会为每个带有 build.gradle 脚本文件的工程构建一个与之对应的 Project 对象。\n3.3、Task项目实质上是 Task 对象的集合。一个 Task 表示一个逻辑上较为独立的执行过程，比如编译 Java 源代码，拷贝文件，打包 Jar 文件，甚至可以是执行一个系统命令。另外，一个 Task 可以读取和设置 Project 的 Property 以完成特定的操作。\n3.3.1、任务入门可参考官方文档：https://docs.gradle.org/current/userguide/tutorial_using_tasks.html\n例子: \ngroovytask A &#123;\n    println &quot;root taskA&quot; \n    doFirst()&#123;\n        println &quot;root taskA doFirst&quot; \n    &#125;\n    doLast()&#123;\n        println &quot;root taskA doLast&quot; \n    &#125;\n&#125;在文件所在的目录执行命令: gradle A。\n提示 1 :task 的配置段是在配置阶段完成。\n提示 2 :task 的 doFirst、doLast 方法是执行阶段完成，并且 doFirst 在 doLast 执行之前执行。\n提示 3:区分任务的配置段和任务的行为,任务的配置段在配置阶段执行,任务的行为在执行阶段执行。\n3.3.2、任务的行为案例如下：doFirst、doLast 两个方法可以在任务内部定义，也可以在任务外部定义\ngroovydef map=new HashMap&lt;String,Object&gt;(); \n//action属性可以设置为闭包，设置task自身的行为\nmap.put(&quot;action&quot;,&#123;println &quot;taskD..&quot;&#125;)\n\ntask(map,&quot;a&quot;)&#123;\n    description &#39;taskA description....&#39; \n    group &quot;atguigu&quot; \n    //在task内部定义doFirst、doLast行为\n    doFirst &#123;\n        def name = &#39;doFirst..&#39; \n        println name \n    &#125;\n    doLast &#123;\n        def name = &#39;doLast..&#39; \n        println name \n    &#125;\n&#125;\n//在task外部定义doFirst、doLast行为\na.doFirst &#123;\n    println it.description\n&#125;\na.doLast &#123;\n    println it.group\n&#125;测试：gradle a , 输出如下所示：\n\n底层原理分析：无论是定义任务自身的 action,还是添加的 doLast、doFirst 方法，其实底层都被放入到一个 Action 的 List中了，最初这个 action List 是空的，当我们设置了 action【任务自身的行为】,它先将 action 添加到列表中，此时列表中只有一个 action,后续执行 doFirst 的时候 doFirst 在 action 前面添加，执行 doLast 的时候 doLast 在 action 后面添加。doFirst永远添加在 actions List 的第一位，保证添加的 Action 在现有的 action List 元素的最前面；doLast 永远都是在 action List末尾添加，保证其添加的 Action 在现有的 action List 元素的最后面。一个往前面添加,一个往后面添加，最后这个 action List 就按顺序形成了 doFirst、doSelf、doLast 三部分的 Actions,就达到 doFirst、doSelf、doLast 三部分的 Actions 顺序执行的目的。\n提示 1:其中&lt;&lt;代表 doLast,在 gradle5.x 版本之后就废弃,不能使用了,如下所示: \ngroovytask hello &lt;&lt; &#123;\n    println &#39;Hello world!&#39; \n&#125;3.3.3、任务的依赖方式Task 之间的依赖关系可以在以下几部分设置：\n\n参数依赖\n内部依赖\n外部依赖\n\n方式一：参数方式依赖\ngroovytask A &#123;\n    doLast &#123;\n        println &quot;TaskA..&quot; \n    &#125;\n&#125;\ntask &#39;B&#39;&#123;\n    doLast &#123;\n        println &quot;TaskB..&quot; \n    &#125;\n&#125;\n//参数方式依赖: dependsOn后面用冒号\ntask &#39;C&#39;(dependsOn: [&#39;A&#39;,&#39;B&#39;])&#123;\n    doLast &#123;\n        println &quot;TaskC..&quot; \n    &#125;\n&#125;方式二：内部依赖\ngroovy//参数方式依赖\ntask &#39;C&#39; &#123;\n    //内部依赖：dependsOn后面用 = 号\n    dependsOn= [A,B]\n    doLast &#123;\n        println &quot;TaskC..&quot; \n    &#125;\n&#125;测试: gradle C\n方式三：外部依赖\ngroovy//外部依赖:可变参数,引号可加可不加\nC.dependsOn(B,&#39;A&#39;)当然：task 也支持跨项目依赖\n在 subproject01 工程的 build.gradle 文件中定义:\ngroovytask A &#123;\n    doLast &#123;\n        println &quot;TaskA..&quot; \n    &#125;\n&#125;在 subproject02 工程的 build.gradle 文件中定义:\ngroovytask B&#123;\n    dependsOn(&quot;:subproject01:A&quot;) //依赖根工程下的subject01中的任务A ：跨项目依赖。\n    doLast &#123;\n        println &quot;TaskB..&quot; \n    &#125;\n&#125;测试：gradle B ,控制台显示如下\n\n拓展 1：当一个 Task 依赖多个 Task 的时候，被依赖的 Task 之间如果没有依赖关系，那么它们的执行顺序是随机的,并无影响。\n拓展 2：重复依赖的任务只会执行一次,比如：\ntxtA-&gt;B、C\nB-&gt;C任务 A 依赖任务 B 和任务 C、任务 B 依赖 C 任务。执行任务 A 的时候，显然任务 C 被重复依赖了，C 只会执行一次。\n3.3.4、任务执行任务执行语法：gradle [taskName...] [--option-name...]。\n常见的任务（*） \n\ngradle build: 构建项目:编译、测试、打包等操作\ngradle run :运行一个服务,需要 application 插件支持，并且指定了主启动类才能运行\ngradle clean: 请求当前项目的 build 目录\ngradle init : 初始化 gradle 项目使用\ngradle wrapper:生成 wrapper 文件夹的。\ngradle wrapper 升级 wrapper 版本号：gradle wrapper --gradle-version=4.4 \ngradle wrapper --gradle-version 5.2.1 --distribution-type all :关联源码用\n\n项目报告相关任务 \n\ngradle projects : 列出所选项目及子项目列表，以层次结构的形式显示\ngradle tasks: 列出所选项目【当前 project,不包含父、子】的已分配给任务组的那些任务。\ngradle tasks --all :列出所选项目的所有任务。\ngradle tasks --group=&quot;build setup&quot;:列出所选项目中指定分组中的任务。\ngradle help --task someTask :显示某个任务的详细信息\ngradle dependencies :查看整个项目的依赖信息，以依赖树的方式显示\ngradle properties 列出所选项目的属性列表\n\n调试相关选项 \n\n-h,--help: 查看帮助信息\n-v, --version:打印 Gradle、 Groovy、 Ant、 JVM 和操作系统版本信息。\n-S, --full-stacktrace:打印出所有异常的完整(非常详细)堆栈跟踪信息。\n-s,--stacktrace: 打印出用户异常的堆栈跟踪(例如编译错误)。\n-Dorg.gradle.daemon.debug=true: 调试 Gradle 守护进程。\n-Dorg.gradle.debug=true:调试 Gradle 客户端(非 daemon)进程。\n-Dorg.gradle.debug.port=(port number):指定启用调试时要侦听的端口号。默认值为 5005。\n\n性能选项:【备注:在gradle.properties 中指定这些选项中的许多选项，因此不需要命令行标志】\n\n--build-cache,--no-build-cache： 尝试重用先前版本的输出。默认关闭(off)。\n--max-workers: 设置 Gradle 可以使用的 woker 数。默认值是处理器数。\n-parallel, --no-parallel: 并行执行项目。有关此选项的限制，请参阅并行项目执行。默认设置为关闭(off)\n\n守护进程选项 \n\n--daemon, --no-daemon: 使用 Gradle 守护进程运行构建。默认是 on\n--foreground:在前台进程中启动 Gradle 守护进程。\n-Dorg.gradle.daemon.idletimeout=(number of milliseconds): \nGradle Daemon 将在这个空闲时间的毫秒数之后停止自己。默认值为 10800000(3 小时)。\n\n日志选项 \n\n-Dorg.gradle.logging.level=(quiet,warn,lifecycle,info,debug): \n通过 Gradle 属性设置日志记录级别。\n-q, --quiet: 只能记录错误信息\n-w, --warn: 设置日志级别为 warn\n-i, --info: 将日志级别设置为 info\n-d, --debug:登录调试模式(包括正常的堆栈跟踪)\n\n其它(*) \n\n-x:-x 等价于: --exclude-task : 常见 gradle -x test clean build\n--rerun-tasks: 强制执行任务，忽略 up-to-date ,常见 gradle build --rerun-tasks\n--continue: 忽略前面失败的任务,继续执行,而不是在遇到第一个失败时立即停止执行。每个遇到的故障都将在构建结束时报告，常见：gradle build --continue。\ngradle init --type pom :将 maven 项目转换为 gradle 项目(根目录执行)\ngradle [taskName]:执行自定义任务\n\n更详细请参考官方文档: \nhttps://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_executing_tasks \n拓展：gradle 任务名是缩写: 任务名支持驼峰式命名风格的任务名缩写，如：connectTask 简写为：cT,执行任务 gradle cT。\n拓展 1:前面提到的 Gradle 指令本质:一个个的 task[任务], Gradle 中所有操作都是基于任务完成的。\n拓展 2：gradle 默认各指令之间相互的依赖关系：\n\n相关解释：\n\n3.3.5、任务定义方式任务定义方式，总体分为两大类：\n\n通过Project中的task()方法\n通过tasks对象的create或者register方法\n\ngroovytask(&#39;A&#39;,&#123;//任务名称,闭包都作为参数\n    println &quot;taskA...&quot;\n&#125;)\ntask(&#39;B&#39;)&#123;//闭包作为最后一个参数可以直接从括号中拿出来\n    println &quot;taskB...&quot;\n&#125;\ntask C&#123;//groovy语法支持省略方法括号:上面三种本质是一种\n    println &quot;taskC...&quot;\n&#125;\ndef map=new HashMap&lt;String,Object&gt;(); map.put(&quot;action&quot;,&#123;println &quot;taskD..&quot;&#125;) //action属性可以设置为闭包\ntask(map,&quot;D&quot;); tasks.create(&#39;E&#39;)&#123;//使用tasks的create方法\n    println &quot;taskE..&quot;\n&#125;\ntasks.register(&#39;f&#39;)&#123; //注：register执行的是延迟创建。也即只有当task被需要使用的时候才会被创建。\n    println &quot;taskF....&quot;\n&#125;当然：我们也可以在定义任务的同时指定任务的属性，具体属性有：\n\n在定义任务时也可以给任务分配属性：定义任务的时候可以直接指定任务属性，也可以给已有的任务动态分配属性：\ngroovy//①.F是任务名，前面通过具名参数给map的属性赋值,以参数方式指定任务的属性信息\ntask(group: &quot;atguigu&quot;,description: &quot;this is task B&quot;,&quot;F&quot;)\n//②.H是任务名，定义任务的同时，在内部直接指定属性信息\ntask(&quot;H&quot;) &#123;\n    group(&quot;atguigu&quot;)\n    description(&quot;this is the task H&quot;)\n&#125;\n//③.Y是任务名，给已有的任务 在外部直接指定属性信息\ntask &quot;y&quot;&#123;&#125;\ny.group=&quot;atguigu&quot;\nclean.group(&quot;atguigu&quot;) //案例：给已有的clean任务重新指定组信息可以在 idea 中看到: 上面自定义的那几个任务和 gradle 自带的 clean 任务已经跑到：atguigu 组了。\n\n3.3.6、任务类型前面我们定义的 task 都是 DefaultTask 类型的,如果要完成某些具体的操作完全需要我们自己去编写 gradle 脚本，势必有些麻烦，那有没有一些现成的任务类型可以使用呢？有的，Gradle 官网给出了一些现成的任务类型帮助我们快速完成想要的任务，我们只需要在创建任务的时候，指定当前任务的类型即可，然后即可使用这种类型中的属性和 API 方法了。\n\n提示 1：如果想看更详细的 gradle 自带 Task 类型，请参考官方文档: https://docs.gradle.org/current/dsl/index.html\n提示 2: 官方文档在给出这些任务类型的时候，同时给出了案例代码，可以点进去上述官网地址中的某个类型中观看\n\n具体使用例如： \ngroovytasks.register(&#39;myClean&#39;, Delete) &#123; \n    delete buildDir \n&#125; 在命令行执行 gradlemyClean 发现就可以将当前project的build目录删除  ，当然除了gradle自带的task类型,我们也可以自定义task类型，如下所示： \n拓展4:自定义Task类型\ngroovydef myTask=task MyDefinitionTask (type: CustomTask)\nmyTask.doFirst()&#123;\n    println &quot;task 执行之前 执行的 doFirst方法&quot;\n&#125;\nmyTask.doLast()&#123;\n    println &quot;task 执行之后 执行的 doLast方法&quot;\n&#125;\nclass CustomTask extends DefaultTask &#123;\n    //@TaskAction表示Task本身要执行的方法\n    @TaskAction\n    def doSelf()&#123;\n        println &quot;Task 自身 在执行的indoSelf&quot;\n    &#125;\n&#125;\t测试：gradleMyDefinitionTask \n控制台输出：\n\n3.3.7、任务的执行顺序在 Gradle 中,有三种方式可以指定 Task 执行顺序： \n\ndependsOn 强依赖方式 \n通过 Task 输入输出 \n通过 API 指定执行顺序\n\n详细请参考官网：https://docs.gradle.org/current/dsl/org.gradle.api.Task.html\n3.3.8、动态分配任务gradle 的强大功能不仅仅用于定义任务的功能。例如，可以使用它在循环中注册同一类型的多个任务\ngroovy4.times &#123; counter-&gt;\n    tasks.register(&quot;task$counter&quot;) &#123;\n        doLast &#123;\n            println &quot;I&#39;m task number $counter&quot;\n        &#125;\n    &#125;\n&#125;一旦注册了任务,就可以通过 API 访问它们。例如，您可以使用它在运行时动态地向任务添加依赖项。Ant不允许这样 的事情发生。\ngroovy4.times &#123; counter-&gt;\n    tasks.register(&quot;task$counter&quot;) &#123;\n        doLast &#123;\n            println &quot;I&#39;m task number $counter&quot;\n        &#125;\n    &#125;\n&#125;构建4个任务,但是任务0必须依赖于任务2和3,那么代表任务2和3需要在任务0之前优先加载。具体测试如下:\n\n3.3.9、任务的关闭与开启每个任务都有一个 enabled 默认为的标志 true。将其设置为 false 阻止执行任何任务动作。禁用的任务将标记为“跳过”。\ngroovytask disableMe &#123;\n    doLast &#123;\n        println &#39;This task is Executing...&#39;\n    &#125;\n    enabled(true)//直接设置任务开启，默认值为true\n&#125;\n//disableMe.enabled = false //设置关闭任务3.3.10、任务的超时每个任务都有一个 timeout 可用于限制其执行时间的属性。当任务达到超时时，其任务执行线程将被中断。该任务将 被标记为失败。终结器任务仍将运行。如果--continue 使用，其他任务可以在此之后继续运行。不响应中断的任务无法 超时。Gradle 的所有内置任务均会及时响应超时。\ngroovytaska()&#123;\n    doLast&#123;\n        Thread.sleep(1000)\n        println&quot;当前任务a执行了&quot;\n    &#125;\n    timeout=Duration.ofMillis(500)\n&#125;\ntaskb()&#123;\n    doLast&#123;\n        println&quot;当前任务b执行了&quot;\n    &#125;\n&#125;在控制台使用:gradle a b测试会发现执行a的时候,由于a执行超时，抛出异常，所以没有继续往下执行【b也没执行】。 然后在控制台使用:gradle a b –continue,测试会发现a虽然执行失败，但是b还是执行了。\n3.3.11、任务的查找常用的任务查找方法有：\ngroovytaskatguigu&#123;\n    doLast&#123;\n        println&quot;让天下没有难学的技术&quot;\n    &#125;\n&#125;\n//根据任务名查找\t\ntasks.findByName(&quot;atguigu&quot;).doFirst(&#123;println&quot;1：北京....&quot;&#125;)\ntasks.getByName(&quot;atguigu&quot;).doFirst(&#123;println&quot;2：深圳....&quot;&#125;)\n//根据任务路径查找【相对路径】\ntasks.findByPath(&quot;:atguigu&quot;).doFirst(&#123;println&quot;3：上海....&quot;&#125;)\ntasks.getByPath(&quot;:atguigu&quot;).doFirst(&#123;println&quot;4：武汉....&quot;&#125;)执行task: gradleatguigu，输出结果如下所示：\ntex4：武汉....\n3：上海....\n2：深圳....\n1：北京....\n让天下没有难学的技术3.3.12、任务的规则当我们执行、依赖一个不存在的任务时，Gradle会执行失败,报错误信息。那我们能否对其进行改进,当执行一个不存在 的任务时，不是报错而是打印提示信息呢？\ngroovytaskhello&#123;\n    doLast&#123;\n        println&#39;hello尚硅谷的粉丝们&#39;\n    &#125;\n&#125;\ntasks.addRule(&quot;对该规则的一个描述，便于调试、查看等&quot;)&#123;\n    StringtaskName-&gt;task(taskName)&#123;\n        doLast&#123;\n            println&quot;该$&#123;taskName&#125;任务不存在，请查证后再执行&quot;\n        &#125;\n    &#125;\n&#125;测试:使用gradle abc hello进行测试,此时当abc任务不存在时，也不会报异常【不中断执行】而是提示自定义的规则信 息，继续执行hello任务。此外，它还可以根据不同的规则动态创建需要的任务等情况。\n3.3.13、任务的onlyIf断言断言就是一个条件表达式。Task有一个onlyIf方法。它接受一个闭包作为参数，如果该闭包返回true则该任务执行， 否则跳过。这有很多用途，比如控制程序哪些情况下打什么包，什么时候执行单元测试，什么情况下执行单元测试的时 候不执行网络测试等。具体案例如下所示：\ngroovytask hello &#123;\n    doLast &#123;\n        println &#39;hello 尚硅谷的粉丝们&#39;\n    &#125;\n&#125;\nhello.onlyIf &#123; !project.hasProperty(&#39;fensi&#39;) &#125;测试：通过-P为Project添加fensi属性\nshellgradle hello -Pfensi3.3.14、默认任务Gradle 允许您定义一个或多个在没有指定其他任务时执行的默认任务。 \n代码如下所示：\ngroovydefaultTasks &#39;myClean&#39;, &#39;myRun&#39;\ntasks.register(&#39;myClean&#39;)&#123;\n    doLast &#123;\n        println &#39;Default Cleaning!&#39;\n    &#125;\n&#125;\ntasks.register(&#39;myRun&#39;) &#123;\n    doLast &#123;\n        println &#39;Default Running!&#39;\n    &#125;\n&#125;\ntasks.register(&#39;other&#39;) &#123;\n    doLast &#123;\n        println &quot;I&#39;m not a default task!&quot;\n    &#125;\n&#125;测试及结果如下：\nshell&gt;gradle-q\nDefault Cleaning!\nDefault Running!3.4、Gradle 中的文件操作几种常见的文件操作方式： \n\n本地文件 \n文件集合 \n文件树 \n文件拷贝 \n归档文件\n\n各种文件操作类型的详细介绍如下所示：\n3.4.1、本地文件使用Project.file(java.lang.Object)方法，通过指定文件的相对路径或绝对路径来对文件的操作,其中相对路径为相对当前 project[根project或者子project]的目录。其实使用Project.file(java.lang.Object)方法创建的File对象就是Java中的File 对象，我们可以使用它就像在Java中使用一样。示例代码如下：\ngroovy//使用相对路径\nFileconfigFile=file(&#39;src/conf.xml&#39;)\nconfigFile.createNewFile();\n//使用绝对路径\nconfigFile=file(&#39;D:\\\\conf.xml&#39;)\nprintln(configFile.createNewFile())\n//使用一个文件对象\nconfigFile=newFile(&#39;src/config.xml&#39;)\nprintln(configFile.exists())3.4.2、文件集合文件集合就是一组文件的列表,在Gradle中,文件集合用FileCollection接口表示。我们可以使用 Project.files(java.lang.Object[])方法来获得一个文件集合对象，如下代码创建一个FileCollection实例：\n对于文件集合我们可以遍历它；也可以把它转换成java类型；同时还能使用+来添加一个集合，或使用-来删除集合。\ngroovydefcollection=files(&#39;src/test1.txt&#39;,newFile(&#39;src/test2.txt&#39;),[&#39;src/test3.txt&#39;,&#39;src/test4.txt&#39;])\ncollection.forEach()&#123;Fileit-&gt;\n    it.createNewFile()//创建该文件\n    printlnit.name//输出文件名\n&#125;\nSetset1=collection.files//把文件集合转换为java中的Set类型\nSetset2=collectionasSet\nListlist=collectionasList//把文件集合转换为java中的List类型\nfor(iteminlist)&#123;\n    printlnitem.name\n&#125;\ndefunion=collection+files(&#39;src/test5.txt&#39;)//添加或者删除一个集合\ndefminus=collection-files(&#39;src/test3.txt&#39;)\nunion.forEach()&#123;Fileit-&gt;\n    printlnit.name\n&#125;3.4.3、文件树文件树是有层级结构的文件集合,一个文件树它可以代表一个目录结构或一ZIP压缩包中的内容结构。文件树是从文件集合继承过来的,所以文件树具有文件集合所有的功能。我们可以使用Project.fileTree(java.util.Map)方法来创建文件树对象， 还可以使用过虑条件来包含或排除相关文件。示例代码如下：\ngroovy tree=fileTree(&#39;src/main&#39;).include(&#39;**/*.java&#39;)//第一种方式:使用路径创建文件树对象，同时指定包含的文件\n//第二种方式:通过闭包创建文件树:\ntree=fileTree(&#39;src/main&#39;)&#123;\n    include&#39;**/*.java&#39;\n&#125;\ntree=fileTree(dir: &#39;src/main&#39;,include:&#39;**/*.java&#39;)//第三种方式:通过路径和闭包创建文件树：具名参数给map传值\n\ntree=fileTree(dir: &#39;src/main&#39;,includes:[&#39;**/*.java&#39;,&#39;**/*.xml&#39;, &#39;**/*.txt&#39;],exclude: &#39;**/*test*/**&#39;)\n\ntree.each&#123;Filefile-&gt;//遍历文件树的所有文件\n    printlnfile\n    printlnfile.name\n&#125;3.4.4、文件拷贝我们可以使用Copy任务来拷贝文件，通过它可以过虑指定拷贝内容，还能对文件进行重命名操作等。Copy任务必须指 定一组需要拷贝的文件和拷贝到的目录，这里使用CopySpec.from(java.lang.Object[])方法指定原文件；使用 CopySpec.into(java.lang.Object)方法指定目标目录。示例代码如下\ngroovytaskcopyTask(type:Copy)&#123;\n    from&#39;src/main/resources&#39;\n    into&#39;build/config&#39;\n&#125;from()方法接受的参数和文件集合时files()一样。当参数为一个目录时，该目录下所有的文件都会被拷贝到指定目录下（目 录自身不会被拷贝）；当参数为一个文件时，该文件会被拷贝到指定目录；如果参数指定的文件不存在，就会被忽略； 当参数为一个Zip压缩文件，该压缩文件的内容会被拷贝到指定目录。\ninto()方法接受的参数与本地文件时file()一样。示例代码如下\ngroovytaskcopyTask(type:Copy)&#123;\n    //拷贝src/main/webapp目录下所有的文件\n    from&#39;src/main/webapp&#39;\n    //拷贝单独的一个文件\n    from&#39;src/staging/index.html&#39;\n    //从Zip压缩文件中拷贝内容\n    fromzipTree(&#39;src/main/assets.zip&#39;)\n    //拷贝到的目标目录\n    into&#39;build/explodedWar&#39;\n&#125;在拷贝文件的时候还可以添加过虑条件来指定包含或排除的文件，示例如下：\ngroovytaskcopyTaskWithPatterns(type:Copy)&#123;\n    from&#39;src/main/webapp&#39;\n    into&#39;build/explodedWar&#39;\n    include&#39;**/*.html&#39;\n    include&#39;**/*.jsp&#39;\n    exclude&#123;details-&gt;details.file.name.endsWith(&#39;.html&#39;)&#125;\n&#125;在拷贝文件的时候还可以对文件进行重命名操作，示例如下：\ngroovytaskrename(type:Copy)&#123;\n    from&#39;src/main/webapp&#39;\n    into&#39;build/explodedWar&#39;\n    //使用一个闭包方式重命名文件\n    rename&#123;StringfileName-&gt;\n        fileName.replace(&#39;-staging-&#39;, &#39;&#39;)\n    &#125;\n&#125;在上面的例子中我们都是使用Copy任务来完成拷贝功能的，那么有没有另外一种方式呢？答案是肯定的，那就是 Project.copy(org.gradle.api.Action)方法。下面示例展示了copy()方法的使用方式：\ngroovy taskcopyMethod&#123;\n     doLast&#123;\n         copy&#123;\n             from&#39;src/main/webapp&#39;\n             into&#39;build/explodedWar&#39;\n             include&#39;**/*.html&#39;\n             include&#39;**/*.jsp&#39;\n         &#125;\n     &#125;\n &#125;或者使用project对象的copy方法\ngroovycopy &#123;\n    //相对路径或者绝对路径\n    from file(&#39;src/main/resources/ddd.txt&#39;) //file也可以换成new File()\n    into this.buildDir.absolutePath\n&#125;执行gradle build 指令即可。去build目录的本地磁盘查看，就能看到。\n3.4.5、归档文件通常一个项目会有很多的 Jar 包，我们希望把项目打包成一个 WAR，ZIP 或 TAR 包进行发布，这时我们就可以使用 Zip，Tar，Jar，War 和Ear任务来实现，不过它们的用法都一样，所以在这里我只介绍Zip任务的示例。 \n首先，创建一个 Zip 压缩文件,并指定压缩文件名称，如下代码所示：\ngroovyapply plugin: &#39;java&#39;\nversion=1.0\ntask myZip(type: Zip) &#123;\n    from &#39;src/main‘\n    into ‘build’ //保存到build目录中\n    baseName = &#39;myGame&#39;\n&#125;\nprintln myZip.archiveName执行命令gradle -q myZip，输出结果为：\nshell&gt;gradle-q myZip\nmyGame-1.0.zip最后，我们可以使用Project.zipTree(java.lang.Object)和 Project.tarTree(java.lang.Object)方法来创建访问 Zip 压缩包的文 件树对象，示例代码如下：\ngroovy// 使用zipTree\nFileTree zip = zipTree(&#39;someFile.zip&#39;)\n// 使用tarTree\nFileTree tar = tarTree(&#39;someFile.tar&#39;)在这里，我们介绍了 Gradle 对本地文件、文件集合、文件树、文件拷贝和归档文件的操作方式。更详细的请参考官方 文档：https://docs.gradle.org/current/userguide/working_with_files.htm\n3.5、Dependencies3.5.1、依赖的方式Gradle 中的依赖分别为直接依赖，项目依赖，本地jar依赖。\n案例如下：\ngroovydependencies &#123;\n    //①.依赖当前项目下的某个模块[子工程]\n    implementation project(&#39;:subject01&#39;)\n    //②.直接依赖本地的某个jar文件\n    implementation files(&#39;libs/foo.jar&#39;, &#39;libs/bar.jar&#39;)\n    //②.配置某文件夹作为依赖项\n    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])\n    //③.直接依赖\n    implementation &#39;org.apache.logging.log4j:log4j:2.17.2&#39;\n&#125;直接依赖 ：在项目中直接导入的依赖，就是直接依赖\ngroovyimplementation &#39;org.apache.logging.log4j:log4j:2.17.2&#39;上面是简写法，完整版写法如下：\ngroovyimplementationgroup: &#39;org.apache.logging.log4j&#39;,name: &#39;log4j&#39;,version: &#39;2.17.2&#39;group/name/version共同定位一个远程仓库,version最好写一个固定的版本号，以防构建出问题，implementation类似 maven中的依赖的scope,对比maven中的依赖:\ngroovy&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;log4j&lt;/groupId&gt;\n&lt;artifactId&gt;log4j&lt;/artifactId&gt;\n&lt;version&gt;1.2.12&lt;/version&gt;\n&lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;项目依赖 ：从项目的某个模块依赖另一个模块\ngroovyimplementationproject(&#39;:subject01&#39;)这种依赖方式是直接依赖本工程中的libary module，这个libary module需要在setting.gradle中配置。\n本地jar依赖 ：本地jar文件依赖，一般包含以下两种方式\ngroovy//直接依赖某文件\nimplementationfiles(&#39;libs/foo.jar&#39;,&#39;libs/bar.jar&#39;)\n//配置某文件夹作为依赖项\nimplementationfileTree(dir:&#39;libs&#39;,include:[&#39;*.jar&#39;])3.5.2、依赖的下载当执行build命令时，gradle就会去配置的依赖仓库中下载对应的Jar，并应用到项目中。\n3.5.3、依赖的类型类似于Maven的scope标签，gradle也提供了依赖的类型,具体如下所示:\n\n官方文档参考：\nhttps://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin: 各个依赖范围的关系和说明\nhttps://docs.gradle.org/current/userguide/upgrading_version_6.html#sec:configuration_removal : 依赖范围升级和移除\nhttps://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin：API 和 implemention 区别\nhttps://docs.gradle.org/current/userguide/java_plugin.html#java_plugin: 执行 java 命令时都使用了哪些依赖范围的依赖。\n提示 1：java 插件提供的功能，java-library 插件都提供。\n3.5.4、api 与 implementation 区别\n如下所示：\n\n编译时:如果 libC 的内容发生变化,由于使用的是 api 依赖,依赖会传递,所以 libC、libA、projectX 都要发生变化,都需要重新编译,速度慢,运行时：libC、libA、projectX 中的 class 都要被加载。\n编译时:如果 libD 的内容发生变化,由于使用的是 implemetation 依赖,依赖不会传递,只有 libD、libB 要变化并重新编译,速度快,运行时：libC、libA、projectX 中的 class 都要被加载。\n拓展 3:api 和 implementation 案例分析\napi 的适用场景是多 module 依赖，moduleA 工程依赖了 module B，同时 module B 又需要依赖了 module C，modelA 工程也需要去依赖 module C,这个时候避免重复依赖 module,可以使用 module B api 依赖的方式去依赖 module C,modelA 工程只需要依赖 moduleB 即可。\n\n总之：除非涉及到多模块依赖，为了避免重复依赖，咱们会使用 api,其它情况我们优先选择 implementation，拥有大量的 api 依赖项会显著增加构建时间。\n3.5.5、依赖冲突及解决方案依赖冲突是指 “在编译过程中, 如果存在某个依赖的多个版本, 构建系统应该选择哪个进行构建的问题”,如下所示:\n\nA、B、C 都是本地子项目 module，log4j 是远程依赖。\n编译时： B 用 1.4.2 版本的 log4j，C 用 2.2.4 版本的 log4j,B 和 C 之间没有冲突\n打包时： 只能有一个版本的代码最终打包进最终的A对应的jar |war包，对于 Gradle 来说这里就有冲突了\n案例演示：我们在 build.gradle 引入依赖库\ngroovydependencies &#123;\n    testImplementation &#39;org.junit.jupiter:junit-jupiter-api:5.8.1&#39; \n    testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine:5.8.1&#39; \n    implementation &#39;org.hibernate:hibernate-core:3.6.3.Final&#39; \n&#125;\n修改 build.gradle\ngroovydependencies &#123;\n    testImplementation &#39;org.junit.jupiter:junit-jupiter-api:5.8.1&#39; \n    testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine:5.8.1&#39; \n    implementation &#39;org.hibernate:hibernate-core:3.6.3.Final&#39; \n    implementation &#39;org.slf4j:slf4j-api:1.4.0&#39; \n&#125;\n如上所示：默认下，Gradle 会使用最新版本的 jar 包【考虑到新版本的 jar 包一般都是向下兼容的】，实际开发中，还是建议使用官方自带的这种解决方案。当然除此之外，Gradle 也为我们提供了一系列的解决依赖冲突的方法: exclude 除一个依赖，不允许依赖传递，强制使用某个版本。\nExclude 排除某个依赖\ngroovydependencies &#123;\n    testImplementation &#39;org.junit.jupiter:junit-jupiter-api:5.8.1&#39; \n    testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine:5.8.1&#39; \n    implementation(&#39;org.hibernate:hibernate-core:3.6.3.Final&#39;)&#123;\n        //排除某一个库(slf4j)依赖:如下三种写法都行\n        exclude group: &#39;org.slf4j&#39; \n        exclude module: &#39;slf4j-api&#39; \n        exclude group: &#39;org.slf4j&#39;,module: &#39;slf4j-api&#39; \n    &#125;\n    //排除之后,使用手动的引入即可。\n    implementation &#39;org.slf4j:slf4j-api:1.4.0&#39; \n&#125;不允许依赖传递\ngroovydependencies &#123;\n    testImplementation &#39;org.junit.jupiter:junit-jupiter-api:5.8.1&#39; \n    testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine:5.8.1&#39; \n    implementation(&#39;org.hibernate:hibernate-core:3.6.3.Final&#39;)&#123;\n        //不允许依赖传递，一般不用\n        transitive(false)\n    &#125;\n    //排除之后,使用手动的引入即可\n    implementation &#39;org.slf4j:slf4j-api:1.4.0&#39; \n&#125;在添加依赖项时,如果设置 transitive 为 false,表示关闭依赖传递。即内部的所有依赖将不会添加到编译和运行时的类路径。\n强制使用某个版本\ngroovydependencies &#123;\n    testImplementation &#39;org.junit.jupiter:junit-jupiter-api:5.8.1&#39; \n    testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine:5.8.1&#39; \n    implementation(&#39;org.hibernate:hibernate-core:3.6.3.Final&#39;)\n    //强制使用某个版本!!【官方建议使用这种方式】\n    implementation(&#39;org.slf4j:slf4j-api:1.4.0!!&#39;)\n    //这种效果和上面那种一样,强制指定某个版本\n    implementation(&#39;org.slf4j:slf4j-api:1.4.0&#39;)&#123; \n        version&#123;\n            strictly(&quot;1.4.0&quot;)\n        &#125;\n    &#125;\n&#125;拓展：我们可以先查看当前项目中到底有哪些依赖冲突：\ngroovy//下面我们配置，当 Gradle 构建遇到依赖冲突时，就立即构建失败\nconfigurations.all() &#123;\n    Configuration configuration -&gt;\n        //当遇到版本冲突时直接构建失败\n        configuration.resolutionStrategy.failOnVersionConflict()\n&#125;3.6、Gradle 插件3.6.1、使用插件的原因简单的说,通过应用插件我们可以:\n\n促进代码重用、减少功能类似代码编写、提升工作效率\n促进项目更高程度的模块化、自动化、便捷化\n可插拔式的的扩展项目的功能\n\n3.6.2、插件的作用在项目构建过程中做很多事情，把插件应用到项目中，通常可以完成: \n\n可以添加任务【task】到项目中，从而帮助完成测试、编译、打包等。\n可以添加依赖配置到项目中。\n可以向项目中拓展新的扩展属性、方法等。\n可以对项目进行一些约定，如应用 Java 插件后，约定 src&#x2F;main&#x2F;java 目录是我们的源代码存在位置，编译时编译这个目录下的 Java 源代码文件。\n\n3.6.3、插件的分类和使用\n第一种：脚本插件\n脚本插件的本质就是一个脚本文件，使用脚本插件时通过 apply from:将脚本加载进来就可以了，后面的脚本文件可以是本地的也可以是网络上的脚本文件，下面定义一段脚本，我们在 build.gradle 文件中使用它，具体如下：\ngroovy//version.gradle文件\next &#123;\n    company= &quot;尚硅谷&quot; cfgs = [\n        compileSdkVersion : JavaVersion.VERSION_1_8\n    ]\n    spring = [\n        version : &#39;5.0.0&#39; \n    ]\n&#125;下面将将在构建文件中使用这个脚本文件，具体如下: \ngroovy//build.gradle文件\n//map作为参数\napply from: &#39;version.gradle&#39; \ntask taskVersion&#123;\n    doLast&#123;\n        println &quot;公司名称为：$&#123;company&#125;,JDK版本是$&#123;cfgs.compileSdkVersion&#125;,版本号是$&#123;spring.version&#125;&quot; \n    &#125;\n&#125;上述代码的执行结果如下：\nshellPS D:\\repos\\idearepos\\root&gt; gradle -q taskVersion \n版本是2.0,版本号是1意义：脚本文件模块化的基础，可按功能把我们的脚本进行拆分一个个公用、职责分明的文件，然后在主脚本文件引用。比如：将很多共有的库版本号一起管理、应用构建版本一起管理等。\n第二种：对象插件之内部插件[核心插件]\n二进制插件[对象插件]就是实现了 org.gradle.api.Plugin 接口的插件，每个 Java Gradle 插件都有一个 plugin id。\n\n可通过如下方式使用一个 Java 插件：\ngroovyapply plugin : &#39;java&#39; //map具名参数方式或者：\ngroovy//也可以使用闭包作为project.apply方法的一个参数\napply&#123;\n    plugin &#39;java&#39; \n&#125;通过上述代码就将 Java 插件应用到我们的项目中了，对于 Gradle 自带的核心插件都有唯一的 plugin id，其中 java 是Java 插件的 plugin id,这个 plugin id 必须是唯一的，可使用应用包名来保证 plugin id 的唯一性。这里的 java 对应的具体类型是 org.gradle.api.plugins.JavaPlugin，所以可以使用如下方式使用 Java 插件：\n使用方式1 ：Map具名参数,全类名\ngroovy//使用方式1：Map具名参数,全类名\napply plugin:org.gradle.api.plugins.JavaPlugin使用方式2 ：org.gradle.api.plugins默认导入\ngroovy//使用方式2：org.gradle.api.plugins默认导入\napply plugin:JavaPlugin使用方式3 ：插件的id。核心插件，无需事先引入\ngroovy//使用方式3:插件的id。核心插件，无需事先引入\napply plugin: &#39;java&#39; Gradle 中提供的二进制插件【核心插件】,可参考: https://docs.gradle.org/current/userguide/plugin_reference.html\n第二种：对象插件之第三方插件\n如果是使用第三方发布的二进制插件，一般需要配置对应的仓库和类路径\ngroovy//使用传统的应用方式\nbuildscript &#123; \n    ext &#123;\n        springBootVersion = &quot;2.3.3.RELEASE&quot;\n    &#125;\n    repositories &#123; \n        mavenLocal() \n        maven &#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public&#39; &#125;\n        jcenter()\n    &#125;\n    // 此处先引入插件\n    dependencies &#123; \n        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;)\n    &#125;\n&#125;\n//再应用插件\napply plugin: &#39;org.springframework.boot&#39; //社区插件,需要事先引入，不必写版本号但是如果是第三方插件已经被托管在 https://plugins.gradle.org/ 网站上，就可以不用在 buildscript 里配置 classpath依赖了，直接使用新出的 plugins DSL 的方式引用，案例如下：\n使用 plugins DSL 方式\ngroovyplugins &#123;\n    id &#39;org.springframework.boot&#39; version &#39;2.4.1&#39; \n&#125;注意：\n\n如果使用老式插件方式 buildscript&#123;&#125;要放在 build.gradle 文件的最前面,而新式 plugins&#123;&#125;没有该限制。\n托管在网站 gradle 插件官网的第三方插件有两种使用方式，一是传统的 buildscript 方式，一种是 plugins DSL 方式 。\n\n第二种：对象插件之用户自定义插件\ngroovyinterface GreetingPluginExtension &#123;\n    Property&lt;String&gt; getMessage()\n    Property&lt;String&gt; getGreeter()\n&#125;\nclass GreetingPlugin implements Plugin&lt;Project&gt; &#123; \n    void apply(Project project) &#123;\n        def extension = project.extensions.create(&#39;greeting&#39;, GreetingPluginExtension)\n        project.task(&#39;hello&#39;) &#123;\n            doLast &#123;\n                println &quot;$&#123;extension.message.get()&#125; from $&#123;extension.greeter.get()&#125;&quot;\n            &#125;\n        &#125;\n    &#125;\n&#125;\napply plugin: GreetingPlugin\n// Configure the extension using a DSL block\ngreeting &#123; \n    message = &#39;Hi&#39; \n    greeter = &#39;Gradle&#39; \n&#125;参考地址：https://docs.gradle.org/current/userguide/custom_plugins.html\n我们直接执行 hello 任务./gradle hello 即可,这种方式实现的插件我们一般不使用，因为这种方式局限性太强，只能本Project，而其他的 Project 不能使用。\n3.6.4、buildSrc 项目buildSrc 是 Gradle 默认的插件目录，编译 Gradle 的时候会自动识别这个目录，将其中的代码编译为插件。\n1、首先先建立一个名为 buildSrc 的 java Module,将 buildSrc 从 included modules 移除,重新构建,然后只保留 build.gradle 和 src/main 目录，其他全部删掉,注意名字一定是 buildSrc,不然会找不到插件。\n2、然后修改 Gradle 中的内容\ngroovyapply plugin: &#39;groovy&#39; //必须\napply plugin: &#39;maven-publish&#39; \n\ndependencies &#123;\n    implementation gradleApi() //必须\n    implementation localGroovy() //必须\n&#125;\nrepositories &#123;\n    google()\n    jcenter() \n    mavenCentral() //必须\n&#125;\n\n//把项目入口设置为src/main/groovy\nsourceSets &#123; \n    main &#123;\n        groovy &#123;\n            srcDir &#39;src/main/groovy&#39; \n        &#125;\n    &#125;\n&#125;3、创建入口目录，在 src&#x2F;main 下创建代码入口目录，如下：\n\n4、然后实现插件代码 Text.groovy，注意文件后缀为 groovy,文件要引入 package com.atguigu\ngroovypackage com.atguigu\nimport org.gradle.api.Plugin\nimport org.gradle.api.Project class Text implements Plugin&lt;Project&gt;&#123;\n    @Override \n    void apply(Project project) &#123;\n        project.task(&quot;atguigu&quot;)&#123;\n            doLast&#123;\n                println(&quot;自定义atguigu插件&quot;)\n            &#125;\n        &#125;\n    &#125;\n&#125;5、接下来在 main 目录下创建 resources 目录,在 resources 目录下创建 META-INF 目录，在 META-INF 目录下创建gradle-plugins 目录，在 gradle-plugins 目录下创建 properties 文件\n6、properties 文件可以自己命名，但是要以.properties 结尾，比如 com.atguigu.plugin.properties,其 com.atguigu.plugin 就是定义的包名路径.\n\n7、最后需要在 properties 文件中指明我们实现插件的全类名 implementation-class = com.atguigu.Text\n\n到目前为止我们的插件项目已经写完了，在 module 引入我们写的插件 apply plugin:&#39;com.atguigu.plugin&#39;,然后执行插件的Task，./gradle atguigu \n输出:\n这种形式的写法，在我们整个工程的 module 都可以使用，但也只是限制在本工程，其他工程不能使用。\n改进：\n第二种写插件的方式他只能在本工程中使用，而其他的项目工程不能使用，有时候我们需要一个插件在多个工程中使用，这时候我们就需要把插件上传 maven 中。\n第一步 ：首先将上述 buildSrc 目录复制一份，修改文件夹名，然后在 settings.gradle 文件中使用 include 引入\n第二步 ：修改 build.gradle 文件，发布到 maven 仓库中\ngroovyapply plugin: &#39;groovy&#39; //必须\napply plugin: &#39;maven-publish&#39; \ndependencies &#123;\n    implementation gradleApi() //必须\n    implementation localGroovy() //必须\n&#125;\nrepositories &#123;\n    google()\n    jcenter() \n    mavenCentral() //必须\n&#125;\nsourceSets &#123; //把项目入口设置为src/main/groovy \n    main &#123;\n        groovy &#123;\n            srcDir &#39;src/main/groovy&#39; \n        &#125;\n    &#125;\n&#125;\npublishing &#123;\n    publications &#123; \n        myLibrary(MavenPublication) &#123;\n            groupId = &#39;com.atguigu.plugin&#39; //指定GAV坐标信息\n            artifactId = &#39;library&#39; \n            version = &#39;1.1&#39; \n            from components.java//发布jar包\n            //from components.web///引入war插件，发布war包\n        &#125;\n    &#125;\t\t\n    repositories &#123; \n        maven &#123; url &quot;$rootDir/lib/release&quot; &#125;\n        //发布项目到私服中\n        // maven &#123;\n        // name = &#39;myRepo&#39; //name属性可选,表示仓库名称，url必填\n        // //发布地址:可以是本地仓库或者maven私服\n        // //url = layout.buildDirectory.dir(&quot;repo&quot;)\n        // //url=&#39;http://my.org/repo&#39; // // change URLs to point to your repos, e.g. http://my.org/repo // //认证信息:用户名和密码\n        // credentials &#123;\n        // username = &#39;joe&#39; // password = &#39;secret&#39; // &#125;\n        // &#125;\n    &#125;\n&#125;第三步 ：执行 publish 指令,发布到根 project 或者 maven 私服仓库。\n第四步 ：使用插件,在项目级 build.gradle 文件中将插件添加到 classpath：\ngroovybuildscript &#123;\n    repositories &#123; \n        maven &#123; url &quot;$rootDir/lib/release&quot; &#125;\n    &#125;\n    dependencies &#123;\n        classpath &quot;com.atguigu.plugin:library:1.1&quot; \n    &#125;\n&#125;\napply plugin: &#39;java&#39; \n//是在 atguiguplugin 中定义的插件 ID\napply plugin: &#39;com.atguigu.plugin&#39;第五步 ：执行 gradle build 指令就会在控制台看到自定义插件的输出，说明自定义插件就已经生效了。\n最后，至于如何写一个插件，能帮助项目更加自动化或者便捷化，是值得大家未来需要长期思考、关注、努力的点。\n3.6.5、插件的关注点第一点: 插件的引用\ngroovyapply plugin: &#39;插件名&#39;第二点:主要的功能[任务]\n当我们在工程中引入插件后，插件会自动的为我们的工程添加一些额外的任务来完成相应的功能。以 Java 插件为例，当我们加入 java 插件之后，就加入了如下功能：\n\n具体大家可通过 gradle tasks 查看加入某个插件前后的区别。\n说明：Gradle 中的任务依赖关系是很重要的，它们之间的依赖关系就形成了构建的基本流程。\n第三点:工程目录结构\n一些插件对工程目结构有约定，所以我们一般遵循它的约定结构来创建工程，这也是 Gradle 的“约定优于配置”原则。\n例如 java 插件规定的项目源集目录结构如下所示：\n\n如果要使用某个插件就应该按照它约定的目录结构设置，这样能大大提高我们的效率，当然各目录结构也可以自己定义。\n第四点：依赖管理\n比如前面我们提到的 依赖的类型[依赖管理]部分，不同的插件提供了不同的依赖管理。\n第五点：常用的属性\n例如：Java 插件会为工程添加一些常用的属性,我们可以直接在编译脚本中直接使用。\n\n当然，这里还有一些其它属性\n\n3.6.6、Java 插件分析参考官网：https://docs.gradle.org/current/userguide/plugin_reference.html,以 Java 插件为例，讲解需要关注的几点：\n第一点：我们要关注插件使用\ngroovyplugins &#123;\n    id &#39;java&#39; \n&#125;第二点：我们要关注插件的功能\n我们可通过官方文档介绍了解某个插件功能或者百度、再或者大家可以通过 gradle tasks 查看加入 java 插件前后的区别。\n第三点：项目布局\n一般加入一个插件之后，插件也会提供相应的目录结构，例如：java 插件的目录结构\n\n当然这个默认的目录结构也是可以改动的例如：\ngroovysourceSets &#123; \n    main &#123;\n        java &#123;\n            srcDirs = [&#39;src/java&#39;]\n        &#125;\n        resources &#123;\n            srcDirs = [&#39;src/resources&#39;]\n        &#125;\n    &#125;\n&#125;也可设置源集的属性等信息。\n第四点：依赖管理：以 java 插件为例，提供了很多依赖管理项\n\n\n\n\n\n\n\n\n\n源集依赖关系配置\n\n\n\n\n\n\n\n\n\n\n测试源集依赖关系配置\n\n第五点：额外的属性和方法：\n可参考官方文档： sourceCompatibility(JavaVersion.*VERSION_1_8*)\n3.7、build.gradle 文件\nbuild.gradle 是一个 gradle 的构建脚本文件,支持 java、groovy 等语言。\n每个 project 都会有一个 build.gradle 文件,该文件是项目构建的入口,可配置版本、插件、依赖库等信息。\n每个 build 文件都有一个对应的 Project 实例,对 build.gradle 文件配置，本质就是设置 Project 实例的属性和方法。\n由于每个 project 都会有一个 build 文件,那么 Root Project 也不列外.Root Project 可以获取到所有 Child Project,所以在Root Project 的 build 文件中我们可以对 Child Project 统一配置,比如应用的插件、依赖的 maven 中心仓库等。\n\nbuild 文件中常见的属性和方法如下所示：\n\n3.7.1、常见属性代码代码参考：\ngroovy//指定使用什么版本的JDK语法编译源代码,跟编译环境有关,在有java插件时才能用\nsourceCompatibility = 1.8\n//指定生成特定于某个JDK版本的class文件:跟运行环境有关,在有java插件时才能用\ntargetCompatibility = 1.8\n//业务编码字符集,注意这是指定源码解码的字符集[编译器]\ncompileJava.options.encoding &quot;UTF-8&quot;\n//测试编码字符集,注意这是指定源码解码的字符集[编译器]\ncompileTestJava.options.encoding &quot;UTF-8&quot;\n//编译JAVA文件时采用UTF-8:注意这是指定源码编码的字符集【源文件】\ntasks.withType(JavaCompile) &#123; \n    options.encoding = &quot;UTF-8&quot;\n&#125;\n//编译JAVA文件时采用UTF-8:注意这是指定文档编码的字符集【源文件】\ntasks.withType(Javadoc) &#123; \n    options.encoding = &quot;UTF-8&quot;\n&#125;提示 1 ：group+name+version 类似于 maven 的 group+artifactId+version \n提示 2 ：encoding 解决业务代码与测试代码中文乱码问题\n3.7.2、Repositories因为 Gradle 没有自己的远程仓库，而是使用 Maven、jcenter、jvy、google 这些远程仓库。\ngroovyrepositories &#123;\n    //gradle中会按着仓库配置的顺序，从上往下依次去对应的仓库中找所需要的jar包: \n    //如果找到，则停止向下搜索，如果找不到，继续在下面的仓库中查找\n    //指定去本地某个磁盘目录中查找:使用本地file文件协议:一般不用这种方式\n    maven &#123; url &#39;file:///D:/repos/mavenrepos3.5.4&#39;&#125; \n    maven &#123; url &quot;$rootDir/lib/release&quot; &#125;\n    //指定去maven的本地仓库查找\n    mavenLocal()\n    //指定去maven的私服或者第三方镜像仓库查找\n    maven &#123; name &quot;Alibaba&quot; ; url &quot;https://maven.aliyun.com/repository/public&quot; &#125; \n    maven &#123; name &quot;Bstek&quot; ; url &quot;https://nexus.bsdn.org/content/groups/public/&quot; &#125;\n    //指定去maven的远程仓库查找:即 https://repo.maven.apache.org/maven2/ mavenCentral()\n    //去google仓库查找\n    google()\n&#125;3.7.3、Subprojects 与 Allprojectsallprojects 是对所有 project(包括 Root Project+ child Project[当前工程和所有子工程])的进行统一配置，而 subprojects 是对所有 Child Project 的进行统一配置。\n测试如下：\ngroovyallprojects &#123;\n    tasks.create(&#39;hello&#39;) &#123;\n        doLast &#123;\n            task -&gt;\n            println &quot;project name is $task.project.name&quot; \n        &#125;\n    &#125;\n&#125;\nsubprojects &#123;\n    hello.doLast&#123;\n        task-&gt;\n        println &quot;here is subprojects $task.project.name&quot; \n    &#125;\n&#125;通常在 subprojects 和 allprojects 中\ngroovyallprojects()&#123; //本质Project中的allprojects方法，传递一个闭包作为参数。\n    apply plugin: &#39;java&#39; \n    ext &#123;\n        junitVersion = &#39;4.10&#39;\n        .. \n    &#125;\n    task allTask&#123;\n        ... \n    &#125;\n    repositories &#123;\n        ... \n    &#125;\n    dependencies &#123;\n        ... \n    &#125;\n&#125;\nsubprojects()&#123; \n    …//同上面allprojects中的方法。\n&#125;拓展 1: 如果是直接在根 project 配置 repositories 和 dependencies 则只针对根工程有效。\n拓展:我们也可以在对单个 Project 进行单独配置：\ngroovyproject(&#39;subject01&#39;) &#123;\n    task subject01 &#123;\n        doLast &#123;\n            println &#39;for subject01&#39; \n        &#125;\n    &#125;\n&#125;执行 gradle build 指令即可查看测试效果。\n3.7.4、ext 用户自定义属性Project 和 Task 都允许用户添加额外的自定义属性，要添加额外的属性，通过应用所属对象的 ext 属性即可实现。添加之后可以通过 ext 属性对自定义属性读取和设置，如果要同时添加多个自定义属性,可以通过 ext 代码块\ngroovy//自定义一个Project的属性\next.age = 18\n//通过代码块同时自定义多个属性\next &#123;\n    phone = 19292883833\n    address=&quot;北京&quot;\n&#125;\ntask extCustomProperty &#123;\n    //在task中自定义属性\n    ext &#123;\n        desc = &quot;奥利给&quot;\n    &#125;\n    doLast &#123;\n        println &quot;年龄是：$&#123;age&#125;&quot;\n        println &quot;电话是：$&#123;phone&#125;&quot;\n        println &quot;地址是：$&#123;address&#125;&quot;\n        println &quot;尚硅谷：$&#123;desc&#125;&quot;\n    &#125;\n&#125;测试：通过 gradle extCustomProperty\n输出结果为：\nshell年龄是：18\n电话是：19292883833 \n地址是：北京\n尚硅谷：奥利给拓展 1: ext 配置的是用户自定义属性，而 gradle.properties 中一般定义 系统属性、环境变量、项目属性、JVM 相关配置信息。\n例如 gradle.properties 文件案例：加快构建速度的，gradle.properties 文件中的属性会自动在项目运行时加载。\nproperties## 设置此参数主要是编译下载包会占用大量的内存，可能会内存溢出\norg.gradle.jvmargs=-Xms4096m -Xmx8192m\n## 开启gradle缓存\norg.gradle.caching=true \n#开启并行编译\norg.gradle.parallel=true \n#启用新的孵化模式\norg.gradle.configureondemand=true \n#开启守护进程\norg.gradle.daemon=true详细请参考：https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties\n3.7.5、Buildscriptbuildscript 里是 gradle 脚本执行所需依赖，分别是对应的 maven 库和插件。\n案例如下：\ngroovyimport org.apache.commons.codec.binary.Base64\nbuildscript &#123;\n    repositories &#123; \n        mavenCentral()\n    &#125;\n    dependencies &#123;\n        classpath group: &#39;commons-codec&#39;, name: &#39;commons-codec&#39;, version: &#39;1.2&#39; \n    &#125;\n&#125;\ntasks.register(&#39;encode&#39;) &#123;\n    doLast &#123;\n        def byte[] encodedString = new Base64().encode(&#39;hello world\\n&#39;.getBytes())\n        println new String(encodedString)\n    &#125;\n&#125;需要注意的是：\n\nbuildscript&#123;&#125;必须在 build.gradle 文件的最前端。\n对于多项目构建，项目的 buildscript ()方法声明的依赖关系可用于其所有子项目的构建脚本。\n构建脚本依赖可能是 Gradle 插件。\n\n案例如下所示：\ngroovy//老式apply插件的引用方式,使用apply+buildscript\nbuildscript &#123;\n    ext &#123;\n        springBootVersion = &quot;2.3.3.RELEASE&quot; \n    &#125;\n    repositories &#123; \n        mavenLocal() \n        maven &#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public&#39; &#125;\n        jcenter()\n    &#125;\n    //此处引入插件\n    dependencies &#123;\n        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;)\n    &#125;\n&#125;\napply plugin: &#39;java&#39; //核心插件，无需事先引入\napply plugin: &#39;org.springframework.boot&#39; //社区插件，需要事先引入,才能应用，不必写版本号3.8、publishing 项目发布接下来,将咱们写好的模块发布发布到公司的私服以供别人使用,如下所示：\n\n3.8.1、引入 maven 发布的插件groovyplugins &#123;\n    id &#39;java-library&#39; //如果发布war包，需要war插件,java-library支持带源码、文档发布\n    id &#39;maven-publish&#39; \n&#125;3.8.2、设置发布代码groovy//带源码和javadoc的发布:需要&#39;java-library&#39;插件支持:它是java的升级版，java插件的功能java-library都有\n//javadoc.options.encoding=&quot;UTF-8&quot; \n//java &#123;\n// withJavadocJar()\n// withSourcesJar()\n//&#125;\npublishing &#123;\n    publications &#123; \n        myLibrary(MavenPublication) &#123;\n            groupId = &#39;org.gradle.sample&#39; //指定GAV坐标信息\n            artifactId = &#39;library&#39; version = &#39;1.1&#39;\n            from components.java//发布jar包\n            //from components.web///引入war插件，发布war包\n        &#125;\n    &#125;\n    repositories &#123;\n        //本地仓库位于USER_HOME/.m2/repository \n        mavenLocal()\n        //发布项目到私服中\n        maven &#123; \n            name = &#39;myRepo&#39; //name属性可选,表示仓库名称，url必填\n            //发布地址:可以是本地仓库或者maven私服\n            //url = layout.buildDirectory.dir(&quot;repo&quot;)\n            // change URLs to point to your repos, e.g. http://my.org/repo \n            def releasesRepoUrl = layout.buildDirectory.dir(&#39;repos/releases&#39;)\n            def snapshotsRepoUrl = layout.buildDirectory.dir(&#39;repos/snapshots&#39;) \n            url = version.endsWith(&#39;SNAPSHOT&#39;) ? snapshotsRepoUrl : releasesRepoUrl\n            //认证信息:用户名和密码\n            // credentials &#123;\n            // \tusername = &#39;joe&#39; \n            // \tpassword = &#39;secret&#39; \n            // &#125;\n        &#125;\n    &#125;\n&#125;3.8.3、执行发布指令执行发布命令，将项目发布到本地仓库或者远程仓库。常见的发布指令有：\n\ngeneratePomFileForPubNamePublication: 生成 pom 文件\npublishPubNamePublicationToRepoNameRepository:发布项目到指定仓库,如果没有仓库名，默认为 maven\npublishPubNamePublicationToMavenLocal: 将 PubName 发布复制到本地 Maven 仓库中包括 POM 文件和其他元数据。\npublish: 发布到 repositories 中指定的仓库(为比如 Maven 私服)\npublishToMavenLocal: 执行所有发布任务中的操作发布到本地 maven 仓库【默认在用户家目录下的.m2/repository】。\n\n3.9、生命周期中 Hook生命周期中的这些钩子函数都是由 gradle 自动回调完成的,利用这些钩子函数可以帮助我们实现一些我们想要的功能。\n\nGradle 在生命周期各个阶段都提供了用于回调的钩子函数:\nGradle 初始化阶段: \n\n在 settings.gradle 执行完后,会回调 Gradle 对象的 settingsEvaluated 方法\n在构建所有工程 build.gradle 对应的 Project 对象后,也既初始化阶段完毕,会回调 Gradle 对象的 projectsLoaded 方法\n\nGradle 配置阶段:\n\nGradle 会循环执行每个工程的 build.gradle 脚本文件\n在执行当前工程 build.gradle 前,会回调 Gradle 对象的 beforeProject 方法和当前 Project 对象的 beforeEvaluate 方法,\n虽然 beforeEvalute 属于 project 的生命周期, 但是此时 build script 尚未被加载, 所以 beforeEvaluate 的设置依然要在 init script 或 setting script 中进行,不要在 build script 中使用 project.beforeEvaluate 方法。\n\n\n在执行当前工程 build.gradle 后,会回调 Gradle 对象的 afterProject 方法和当前 Project 对象的 afterEvaluate 方法\n在所有工程的 build.gradle 执行完毕后，会回调 Gradle 对象的 projectsEvaluated 方法\n在构建 Task 依赖有向无环图后,也就是配置阶段完毕,会回调 TaskExecutionGraph 对象的 whenReady 方法\n\nGradle 执行阶段:\n\nGradle 会循环执行 Task 及其依赖的 Task\n在当前 Task 执行之前,会回调 TaskExecutionGraph 对象的 beforeTask 方法\n在当前 Task 执行之后,会回调 TaskExecutionGraph 对象的 afterTask 方法\n\n当所有的 Task 执行完毕后，会回调 Gradle 对象的 buildFinish 方法。\n提示：Gradle 执行脚本文件的时候会生成对应的实例，主要有如下几种对象：\n\nGradle 对象 ：在项目初始化时构建，全局单例存在，只有这一个对象\nProject 对象 ：每一个build.gradle文件 都会转换成一个 Project 对象,类似于maven中的pom.xml文件\nSettings 对象 ：settings.gradle 会转变成一个 settings 对象,和整个项目是一对一的关系,一般只用到include方法\nTask对象 ： 从前面的有向无环图中，我们也可以看出，gradle最终是基于Task的,一个项目可以有一个或者多个Task\n\n钩子函数代码演示：项目目录结构如下：\n\n在 root project 的 settings.gradle 文件中添加：\ngroovygradle.settingsEvaluated &#123; //1.settingsEvaluated钩子函数,在初始化阶段完成\n    println &quot;settingsEvaluated&quot;\n&#125;\ngradle.projectsLoaded &#123; //2.projectsLoaded钩子函数,在初始化阶段完成\n    println &quot;projectsLoaded&quot;\n&#125;\n//声明一个变量：表示当前项目名,在每次执行某个项目的beforeEvaluate方法时先给projectName变量赋值\n//这样方便在：gradle.beforeProject和afterProject两个钩子函数使用。\ndef projectName=&quot;&quot;\ngradle.addProjectEvaluationListener( new ProjectEvaluationListener()&#123;\n    //3.执行各个project的beforeEvaluate：在配置阶段完成\n    @Override \n    void beforeEvaluate(Project project) &#123;\n        projectName=project.name \n        println &quot;$&#123;project.name&#125; Project beforeEvaluate&quot;\n&#125;\n    //5.执行各个project的afterEvaluate：在配置阶段完成\n    @Override \n    void afterEvaluate(Project project, ProjectState projectState) &#123;\n        println &quot;$&#123;project.name&#125; Project afterEvaluate&quot;\n    &#125;\n&#125;); \ngradle.beforeProject &#123;//4.执行各个project的beforeProject：在配置阶段完成\n    println &quot;$&#123;projectName&#125; beforeProject...&quot;\n&#125;\ngradle.afterProject &#123;//6.执行各个project的afterProject：在配置阶段完成\n    println &quot;$&#123;projectName&#125; afterProject...&quot;\n&#125;\n//7.所有工程的 build.gradle 执行完毕后，回调 Gradle 对象的 projectsEvaluated 方法：在配置阶段完成\ndef rootProjectName=rootProject.getName()\ngradle.projectsEvaluated &#123;\n    println &quot;$&#123;rootProjectName&#125; projectsEvaluated...&quot;\n&#125;\n//8.配置阶段完毕后，回调 TaskExecutionGraph 对象的 whenReady 方法：在配置阶段完成\ngradle.taskGraph.whenReady &#123;\n    println &quot;$&#123;rootProjectName&#125; taskGraph whenReady...&quot;\n&#125;\n//9.在当前Task执行之前,会回调 TaskExecutionGraph 对象的 beforeTask方法：在执行阶段完成\ngradle.taskGraph.beforeTask &#123;task -&gt;\n    println &quot;this is the task $&#123;task.name&#125; of the project $&#123;task.getProject().name&#125; beforeTask..&quot;\n&#125;\n//10.在当前Task执行之后,会回调 TaskExecutionGraph 对象的 afterTask方法：在执行阶段完成\ngradle.taskGraph.afterTask &#123;task -&gt;\n    println &quot;this is the task $&#123;task.name&#125; of the project $&#123;task.getProject().name&#125; afterTask..&quot;\n&#125;\n//11.当所有的 Task 执行完毕后，会回调 Gradle 对象的 buildFinish 方法：在执行阶段完成\ngradle.buildFinished &#123;\n    println &quot;$&#123;rootProjectName&#125; buildFinished...&quot;\n&#125;在 root 的 build.gradle 文件中添加:\ngroovytask A &#123;\n    println &quot;root taskA&quot; \n    doFirst()&#123;\n        println &quot;root taskA doFirst&quot; \n    &#125;\n    doLast()&#123;\n        println &quot;root taskA doLast&quot; \n    &#125;\n&#125;在 subject01 的 build.gradle 文件中添加:\ngroovytask B &#123;\n    println &quot;SubProject01 taskB&quot; \n    doFirst()&#123;\n        println &quot;SubProject01 taskB doFirst&quot; \n    &#125;\n    doLast()&#123;\n        println &quot;SubProject01 taskB doLast&quot; \n    &#125;\n&#125;在 subject02 的 build.gradle 文件中添加:\ngroovy//task C在上面\ntask C&#123;\n    //依赖task D\n    dependsOn &#39;D&#39; \n    println &quot;SubProject02 taskC&quot; \n    doFirst()&#123;\n        println &quot;SubProject02 taskC doFirst&quot; \n    &#125;\n    doLast()&#123;\n        println &quot;SubProject02 taskC doLast&quot; \n    &#125;\n&#125;\n//task D在下面\ntask D &#123;\n    println &quot;SubProject02 taskD&quot; \n    doFirst()&#123;\n        println &quot;SubProject02 taskD doFirst&quot; \n    &#125;\n    doLast()&#123;\n        println &quot;SubProject02 taskD doLast&quot; \n    &#125;\n&#125;测试：在 root 工程的根目录执行：gradle C .就能看到 gradle 生命周期的三个阶段，及每个阶段执行的钩子函数、还有在执行阶段有依赖关系的任务的执行顺序问题。\n拓展 1：在 settings.gradle 中添加监听器，查看 task 有向无环图: \ngroovygradle.taskGraph.addTaskExecutionGraphListener(new TaskExecutionGraphListener() &#123;\n    @Override //生成有向无环图\n    void graphPopulated(TaskExecutionGraph taskExecutionGraph) &#123;\n        taskExecutionGraph.allTasks.forEach(task-&gt;&#123;//核心逻辑:通过taskExecutionGraph获得所有的task\n            taskExecutionGraph.allTasks.forEach(releaseTask-&gt;&#123;\n        println &quot;尚硅谷:&quot; + releaseTask.getProject().name + &quot;:&quot; + releaseTask.name \n            &#125;)\n        &#125;)\n    &#125;\n&#125;)测试：在 root 工程根目录下执行：gradle C。查看测试结果：\n\n拓展 2: 计算 Gradle 构建过程中各个阶段的耗时:需要注意，这里只是计算了初始化阶段的 settings 文件，并没有计算init.gradle 初始化的时间。\ngroovydef projectName=rootProject.getName() //定义项目名\nlong beginOfSetting = System.currentTimeMillis() //初始化阶段开始时间\ndef beginOfConfig //配置阶段开始时间\ndef configHasBegin = false //配置阶段是否开始了，只执行一次\ndef beginOfProjectConfig = new HashMap() //存放每个 build.gradle 执行之前的时间\ndef beginOfTaskExecute //执行阶段开始时间\ngradle.projectsLoaded &#123; //初始化阶段执行完毕\n    println &quot;$&#123;projectName&#125;工程 初始化总耗时 $&#123;System.currentTimeMillis() - beginOfSetting&#125; ms&quot;\n&#125;\n//build.gradle 执行前\ngradle.beforeProject &#123;Project project -&gt;\n    if(!configHasBegin)&#123;\n        configHasBegin = true \n        beginOfConfig = System.currentTimeMillis()\n    &#125;\n    beginOfProjectConfig.put(project,System.currentTimeMillis())\n&#125;\n//build.gradle 执行后\ngradle.afterProject &#123;Project project -&gt;\n    def begin = beginOfProjectConfig.get(project)\n    if(project.name == projectName) &#123;\n        println &quot;根工程$&#123;projectName&#125; 配置阶段耗时：$&#123;System.currentTimeMillis() - begin&#125; ms&quot;\n    &#125;else&#123;\n        println &quot;子工程$&#123;project.name&#125; 配置阶段耗时：$&#123;System.currentTimeMillis() - begin&#125; ms&quot;\n    &#125;\n&#125;\ngradle.taskGraph.whenReady &#123;//配置阶段完毕\n    println &quot;整个$&#123;projectName&#125;项目在配置阶段总耗时：$&#123;System.currentTimeMillis() - beginOfConfig&#125; ms&quot;\n    beginOfTaskExecute = System.currentTimeMillis()\n&#125;\n//执行阶段开始\ngradle.taskGraph.beforeTask &#123;Task task -&gt;\n    task.doFirst &#123;\n        task.ext.beginOfTask = System.currentTimeMillis()\n    &#125;\n    task.doLast &#123;\n        println &quot;$&#123;task.name&#125;在执行阶段耗时：$&#123;System.currentTimeMillis() - task.ext.beginOfTask&#125; ms&quot;\n    &#125;\n&#125;\ngradle.buildFinished &#123;//执行阶段完毕\n    println &quot; 执行阶段总耗时：$&#123;System.currentTimeMillis() - beginOfTaskExecute&#125; ms&quot;\n    println &quot; 整个构建过程耗时：$&#123;System.currentTimeMillis() - beginOfSetting&#125; ms&quot;\n&#125;3.10、创建 Springboot 项目Spring Boot Gradle 插件在 Gradle 提供 Spring Boot 支持。它允许您打包可执行 jar 或 war 归档文件，运行 SpringBoot 应用程序，并使用 Spring-Boot-dependencies 提供的依赖管理。相关文档请参考：https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#running-your-application\n3.10.1、引入 springboot 插件该插件发布在 Gradle 的插件门户网站上，可以使用插件块来应用:\ngroovyplugins &#123;\n    id &#39;org.springframework.boot&#39; version &#39;2.3.7.RELEASE&#39; //维护springboot版本号,不单独使用,和下面两个插件一起用\n    id &#39;io.spring.dependency-management&#39; version &#39;1.0.10.RELEASE&#39; \n    //进行依赖管理,在引入其它boot依赖时省略版本号、解决jar包冲突问题\n    id &#39;java&#39; \n&#125;3.10.2、引入所需要的依赖groovydependencies &#123;\n    implementation &#39;org.springframework.boot:spring-boot-starter&#39; \n    implementation &#39;org.springframework.boot:spring-boot-starter-web&#39; //省略版本,原生bom支持,插件management提供\n    testImplementation(&#39;org.springframework.boot:spring-boot-starter-test&#39;) &#123;\n        exclude group: &#39;org.junit.vintage&#39;, module: &#39;junit-vintage-engine&#39; \n    &#125;\n&#125;\ntest &#123;\n    useJUnitPlatform()\n&#125;3.10.3、执行 gradle bootRun 指令\n要想运行当前 Springboot 项目，直接执行 gradle bootRun 指令或者 idea 右侧按钮即可。\n当然如果想让当前项目打成可执行 jar 包，只需执行： gradle bootJar 指令即可。\nCloud 项目创建也可以借助于脚手架创建，与 Boot 项目类似。\n\n3.10.4、拓展 spring-boot-gradle-plugin 插件groovybuildscript &#123;\n    repositories &#123; \n        maven &#123; url &#39;https://maven.aliyun.com/repository/public&#39; &#125;\n    &#125;\n    dependencies &#123;\n        classpath &#39;org.springframework.boot:spring-boot-gradle-plugin:2.4.1&#39; \n    &#125;\n&#125;apply plugin: &#39;org.springframework.boot&#39; \napply plugin: &#39;io.spring.dependency-management&#39;\n3.11、基于 ssm 多模块项目案例3.11.1、多项目模块划分\nmeinian-mobile-web: 美年旅游项目的用户系统\nmeinian-web: 美年旅游项目的管理员系统\nmeinian-service: 美年旅游项目的业务逻辑层\nmeinian-dao : 美年旅游项目的持久化层\nmeinian-bean : 美年旅游项目的 Model 封装\n3.11.2、项目搭建前配置分析\n3.11.3、代码演示代码和配置文件同单体 ssm 一样。只不过做了拆分。\n3.11.4、settings.gradle 文件中groovyrootProject.name = &#39;meinian-parent&#39; \ninclude &#39;meinian-bean&#39; \ninclude &#39;meinian-dao&#39; \ninclude &#39;meinian-service&#39; \ninclude &#39;meinian-web&#39; \ninclude &#39;meinian-mobile-web3.11.5、在根工程 build.gradle 文件中抽取子模块的公共配置groovygroup &#39;com.atguigu&#39; \nversion &#39;1.0-SNAPSHOT&#39; \n\nsubprojects &#123;\n    //添加插件\n    apply plugin: &#39;java&#39; \n    //基本JDK配置\n    sourceCompatibility = 1.8\n    targetCompatibility = 1.8\n    \n    compileJava.options.encoding &quot;UTF-8&quot; \n    compileTestJava.options.encoding &quot;UTF-8&quot;\n    \n    tasks.withType(JavaCompile) &#123; \n        options.encoding = &quot;UTF-8&quot; \n    &#125;\n    \n    group &#39;com.atguigu&#39; \n    version &#39;1.0-SNAPSHOT&#39; \n    \n    repositories &#123; \n        mavenLocal() \n        maven &#123;url &quot;https://maven.aliyun.com/repository/public&quot;&#125; \n        maven &#123;url &quot;https://maven.aliyun.com/repository/central&quot;&#125; \n        maven &#123;url &quot;https://maven.aliyun.com/repository/google&quot;&#125; \n        maven &#123;url &quot;https://maven.aliyun.com/repository/spring&quot;&#125; \n        mavenCentral()\n    &#125;\n    //依赖的配置:设置通用的依赖\n    dependencies &#123;\n        testImplementation &#39;org.junit.jupiter:junit-jupiter-api&#39; \n        testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine&#39; \n        implementation &#39;log4j:log4j:1.2.17&#39; \n    &#125;\n    test &#123;\n        useJUnitPlatform()\n    &#125;\n&#125;3.11.6、在根工程的 build.gradle 文件中配置各个模块的依赖信息groovyproject(&quot;meinian-bean&quot;)&#123;\n    dependencies &#123;\n        compileOnly &#39;org.projectlombok:lombok:1.18.24&#39; \n    &#125;\n&#125;\nproject(&quot;meinian-dao&quot;)&#123;\n    apply plugin: &#39;java-library&#39;//支持api\n    dependencies &#123;\n        api project(&#39;:meinian-bean&#39;)\n        implementation &#39;org.mybatis:mybatis-spring:1.2.3&#39; \n        implementation &#39;com.alibaba:druid:1.0.15&#39; \n        implementation &#39;org.mybatis:mybatis:3.3.0&#39; \n        implementation &#39;mysql:mysql-connector-java:5.1.36&#39; \n    &#125;\n&#125;\nproject(&quot;meinian-service&quot;)&#123;\n    apply plugin: &#39;java-library&#39;//支持api\n    dependencies &#123;\n        api project(&#39;:meinian-dao&#39;)\n        implementation &#39;org.springframework:spring-web:4.1.7.RELEASE&#39; \n        implementation &#39;org.springframework:spring-test:4.0.5.RELEASE&#39; \n        implementation &#39;org.springframework:spring-jdbc:4.1.7.RELEASE&#39; \n        implementation &#39;org.aspectj:aspectjweaver:1.8.6&#39; \n    &#125;\n&#125;\nproject(&quot;meinian-web&quot;)&#123;\n    apply plugin: &#39;war&#39; \n    dependencies &#123;\n        implementation project(&#39;:meinian-service&#39;)\n        implementation &#39;org.springframework:spring-webmvc:4.1.7.RELEASE&#39; \n        implementation &quot;com.fasterxml.jackson.core:jackson-databind:2.2.3&quot;\n        implementation &quot;com.fasterxml.jackson.core:jackson-annotations:2.2.3&quot;\n        implementation &quot;com.fasterxml.jackson.core:jackson-core:2.2.3&quot; \n        compileOnly &#39;javax.servlet:servlet-api:2.5&#39; \n        implementation &#39;jstl:jstl:1.2&#39; \n    &#125;\n&#125;\nproject(&quot;meinian-mobile-web&quot;)&#123;\n    apply plugin: &#39;war&#39; dependencies &#123;\n        //implementation project(&#39;:meinian-bean&#39;)\n        implementation project(&#39;:meinian-service&#39;)\n        implementation &#39;org.springframework:spring-webmvc:4.1.7.RELEASE&#39; \n        implementation &quot;com.fasterxml.jackson.core:jackson-databind:2.2.3&quot;\n        implementation &quot;com.fasterxml.jackson.core:jackson-annotations:2.2.3&quot;\n        implementation &quot;com.fasterxml.jackson.core:jackson-core:2.2.3&quot; \n        compileOnly &#39;javax.servlet:servlet-api:2.5&#39; \n        implementation &#39;jstl:jstl:1.2&#39; \n    &#125;\n&#125;抽取之后，各子模块的 build.gradle 文件就不用配置了。\n3.12、微服务实战3.12.1、创建数据库及表创建对应的数据库：CREATEDATABASE micro_user\nsqlCREATETABLEUSER(\n    id INT UNSIGNEDPRIMARYKEYAUTO_INCREMENT,\n    username VARCHAR(30) NOT NULLCOMMENT&#39;用户名&#39;,\n    email VARCHAR(30) NOT NULLCOMMENT&#39;邮箱&#39;,\n    gender TINYINT DEFAULT0COMMENT&#39;性别&#39;\n)创建对应的数据库：CREATEDATABASEmicro_order\nsql USEmicro_order;\n \n CREATETABLE`orderinfo` (\n     `oid` INT(10) UNSIGNED NOTNULL AUTO_INCREMENT,\n     `uid` INT(11) DEFAULT NULLCOMMENT&#39;用户id&#39;,\n     `product_name` VARCHAR(30) NOT NULL COMMENT&#39;省份&#39;,\n     PRIMARYKEY(`oid`)\n ) ENGINE=INNODBAUTO_INCREMENT=5DEFAULTCHARSET=utf83.12.2、搭建项目架构\nmicroservice-parent ： 统一管理所有模块的jar包版本信息 \nmicroservice-bean ： 统一管理所有模块的用到的pojo类 \nmicroservice-common ：统一管理所有模块的用到的工具类、枚举类、异常处理、日志文件、统一返回结果信息 \nmicroservice-service ： 统一封装所有的微服务 \nmicroservice-gateway ： 封装网关信息\n3.12.3、具体演示创建项目结构，记得将gradle改成本地自己安装的gradle。详情请参考视频【尚硅谷】Gradle教程入门到进阶-从gradle安装到项目实战\n","slug":"Gradle","date":"2024-03-20T12:51:00.000Z","categories_index":"微服务核心","tags_index":"微服务核心","author_index":"白"},{"id":"08a5f0c088798b8e49d191a85cd599c2","title":"Maven篇","content":"Maven依赖管理项目构建工具一、Maven简介1. 为什么学习Maven1.1 Maven是一个依赖管理工具①jar 包的规模\n随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。\n比如下面的例子，我们只用到 SpringBoot、SpringCloud 框架中的三个功能：\n\nNacos 服务注册发现\nWeb 框架环境\n视图模板技术 Thymeleaf\n\n最终却导入了 106 个 jar 包：\n\n\n\n\n\n\n\n\n\norg.springframework.security:spring-security-rsa:jar:1.0.9.RELEASE:compilecom.netflix.ribbon: ribbon:jar:2.3.0:compileorg.springframework.boot:spring-boot-starter-thymeleaf:jar:2.3.6.RELEASE:compilecommons-configuration:commons-configuration:jar:1.8:compileorg.apache.logging.log4j:log4j-api:jar:2.13.3:compileorg.springframework:spring-beans:jar:5.2.11.RELEASE:compileorg.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.2.6.RELEASE:compileorg.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.39:compilecom.alibaba.cloud:spring-cloud-alibaba-commons:jar:2.2.6.RELEASE:compileorg.bouncycastle:bcprov-jdk15on:jar:1.64:compileorg.springframework.security:spring-security-crypto:jar:5.3.5.RELEASE:compileorg.apache.httpcomponents:httpasyncclient:jar:4.1.4:compilecom.google.j2objc:j2objc-annotations:jar:1.3:compilecom.fasterxml.jackson.core:jackson-databind:jar:2.11.3:compileio.reactivex:rxjava:jar:1.3.8:compilech.qos.logback:logback-classic:jar:1.2.3:compileorg.springframework:spring-web:jar:5.2.11.RELEASE:compileio.reactivex:rxnetty-servo:jar:0.4.9:runtimeorg.springframework:spring-core:jar:5.2.11.RELEASE:compileio.github.openfeign.form:feign-form-spring:jar:3.8.0:compileio.github.openfeign.form:feign-form:jar:3.8.0:compilecom.netflix.ribbon:ribbon-loadbalancer:jar:2.3.0:compileorg.apache.httpcomponents:httpcore:jar:4.4.13:compileorg.thymeleaf.extras:thymeleaf-extras-java8time:jar:3.0.4.RELEASE:compileorg.slf4j:jul-to-slf4j:jar:1.7.30:compilecom.atguigu.demo:demo09-base-entity:jar:1.0-SNAPSHOT:compileorg.yaml:snakeyaml:jar:1.26:compileorg.springframework.boot:spring-boot-starter-logging:jar:2.3.6.RELEASE:compileio.reactivex:rxnetty-contexts:jar:0.4.9:runtimeorg.apache.httpcomponents:httpclient:jar:4.5.13:compileio.github.openfeign:feign-core:jar:10.10.1:compileorg.springframework.boot:spring-boot-starter-aop:jar:2.3.6.RELEASE:compileorg.hdrhistogram:HdrHistogram:jar:2.1.9:compileorg.springframework:spring-context:jar:5.2.11.RELEASE:compilecommons-lang:commons-lang:jar:2.6:compileio.prometheus:simpleclient:jar:0.5.0:compilech.qos.logback:logback-core:jar:1.2.3:compileorg.springframework:spring-webmvc:jar:5.2.11.RELEASE:compilecom.sun.jersey:jersey-core:jar:1.19.1:runtimejavax.ws.rs:jsr311-api:jar:1.1.1:runtimejavax.inject:javax.inject:jar:1:runtimeorg.springframework.cloud:spring-cloud-openfeign-core:jar:2.2.6.RELEASE:compilecom.netflix.ribbon:ribbon-core:jar:2.3.0:compilecom.netflix.hystrix:hystrix-core:jar:1.5.18:compilecom.netflix.ribbon:ribbon-transport:jar:2.3.0:runtimeorg.springframework.boot:spring-boot-starter-json:jar:2.3.6.RELEASE:compileorg.springframework.cloud:spring-cloud-starter-openfeign:jar:2.2.6.RELEASE:compilecom.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.11.3:compilecom.sun.jersey.contribs:jersey-apache-client4:jar:1.19.1:runtimeio.github.openfeign:feign-hystrix:jar:10.10.1:compileio.github.openfeign:feign-slf4j:jar:10.10.1:compilecom.alibaba.nacos:nacos-client:jar:1.4.2:compileorg.apache.httpcomponents:httpcore-nio:jar:4.4.13:compilecom.sun.jersey:jersey-client:jar:1.19.1:runtimeorg.springframework.cloud:spring-cloud-context:jar:2.2.6.RELEASE:compileorg.glassfish:jakarta.el:jar:3.0.3:compileorg.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compilecom.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.11.3:compileorg.springframework.cloud:spring-cloud-commons:jar:2.2.6.RELEASE:compileorg.aspectj:aspectjweaver:jar:1.9.6:compilecom.alibaba.cloud:spring-cloud-starter-alibaba-nacos-discovery:jar:2.2.6.RELEASE:compilecom.google.guava:listenablefuture:jar:9999.0-empty-to-avoid-conflict-with-guava:compilecom.alibaba.spring:spring-context-support:jar:1.0.10:compilejakarta.annotation:jakarta.annotation-api:jar:1.3.5:compileorg.bouncycastle:bcpkix-jdk15on:jar:1.64:compilecom.netflix.netflix-commons:netflix-commons-util:jar:0.3.0:runtimecom.fasterxml.jackson.core:jackson-annotations:jar:2.11.3:compilecom.google.guava:guava:jar:29.0-jre:compilecom.google.guava:failureaccess:jar:1.0.1:compileorg.springframework.boot:spring-boot:jar:2.3.6.RELEASE:compilecom.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.11.3:compilecom.atguigu.demo:demo08-base-api:jar:1.0-SNAPSHOT:compileorg.springframework.cloud:spring-cloud-starter-netflix-archaius:jar:2.2.6.RELEASE:compileorg.springframework.boot:spring-boot-autoconfigure:jar:2.3.6.RELEASE:compileorg.slf4j:slf4j-api:jar:1.7.30:compilecommons-io:commons-io:jar:2.7:compileorg.springframework.cloud:spring-cloud-starter:jar:2.2.6.RELEASE:compileorg.apache.tomcat.embed:tomcat-embed-core:jar:9.0.39:compileio.reactivex:rxnetty:jar:0.4.9:runtimecom.fasterxml.jackson.core:jackson-core:jar:2.11.3:compilecom.google.code.findbugs:jsr305:jar:3.0.2:compilecom.netflix.archaius:archaius-core:jar:0.7.6:compileorg.springframework.boot:spring-boot-starter-web:jar:2.3.6.RELEASE:compilecommons-codec:commons-codec:jar:1.14:compilecom.netflix.servo:servo-core:jar:0.12.21:runtimecom.google.errorprone:error_prone_annotations:jar:2.3.4:compileorg.attoparser:attoparser:jar:2.0.5.RELEASE:compilecom.atguigu.demo:demo10-base-util:jar:1.0-SNAPSHOT:compileorg.checkerframework:checker-qual:jar:2.11.1:compileorg.thymeleaf:thymeleaf-spring5:jar:3.0.11.RELEASE:compilecommons-fileupload:commons-fileupload:jar:1.4:compilecom.netflix.ribbon:ribbon-httpclient:jar:2.3.0:compilecom.netflix.netflix-commons:netflix-statistics:jar:0.1.1:runtimeorg.unbescape:unbescape:jar:1.1.6.RELEASE:compileorg.springframework:spring-jcl:jar:5.2.11.RELEASE:compilecom.alibaba.nacos:nacos-common:jar:1.4.2:compilecommons-collections:commons-collections:jar:3.2.2:runtimejavax.persistence:persistence-api:jar:1.0:compilecom.alibaba.nacos:nacos-api:jar:1.4.2:compileorg.thymeleaf:thymeleaf:jar:3.0.11.RELEASE:compileorg.springframework:spring-aop:jar:5.2.11.RELEASE:compileorg.springframework.boot:spring-boot-starter:jar:2.3.6.RELEASE:compileorg.springframework.boot:spring-boot-starter-tomcat:jar:2.3.6.RELEASE:compileorg.springframework.cloud:spring-cloud-netflix-ribbon:jar:2.2.6.RELEASE:compileorg.springframework:spring-expression:jar:5.2.11.RELEASE:compileorg.springframework.cloud:spring-cloud-netflix-archaius:jar:2.2.6.RELEASE:compile\n而如果使用 Maven 来引入这些 jar 包只需要配置三个『依赖』：\nxml&lt;!-- Nacos 服务注册发现启动器 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n&lt;!-- web启动器依赖 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n&lt;!-- 视图模板技术 thymeleaf --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;②jar包的来源问题\n\n这个jar包所属技术的官网。官网通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载。\n第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。\njar包的名称\njar包的版本\njar包内的具体细节\n\n\n而使用 Maven 后，依赖对应的 jar 包能够自动下载，方便、快捷又规范。\n\n③jar包的导入问题\n在web工程中，jar包必须存放在指定位置：\n\n在使用Maven之后，通过配置依赖(jar包)的坐标，查找本地仓库中相应jar包，若本地仓库没有，则统一从镜像网站或中央仓库中下载：\n\n④jar包之间的依赖\n框架中使用的 jar 包，不仅数量庞大，而且彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度。另外，jar 包之间有可能产生冲突。进一步增加了我们在 jar 包使用过程中的难度。\n下面是前面例子中 jar 包之间的依赖关系：\n\n而实际上 jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本，而这些工作又对实现业务功能毫无帮助。\n而使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量。\n1.2 Maven是一个构建工具①你没有注意过的构建\n你可以不使用 Maven，但是构建必须要做。当我们使用 IDEA 进行开发时，构建是 IDEA 替我们做的。\n\n②脱离 IDE 环境仍需构建\n\n1.3 结论\n管理规模庞大的 jar 包，需要专门工具。\n脱离 IDE 环境执行构建操作，需要专门工具。\n\n2. Maven介绍https://maven.apache.org/what-is-maven.html\nMaven 是一款为 Java 项目管理构建、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。\nMaven就是一个软件，掌握安装、配置、以及基本功能 （项目构建、依赖管理） 的理解和使用即可！\n\n依赖管理：Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，避免版本冲突和转换错误等，而我们仅仅需要编写配置即可。\n构建管理：项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程。Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。\n\n\n场景1： 例如我们项目需要第三方依赖如：Druid连接池、MySQL数据库驱动和Jackson JSON等处理。那么我们可以将想要的依赖项的信息编写到Maven工程的配置文件，Maven就会自动下载并复制这些依赖项到项目中，无需自己导入jar包，管理jar!\n场景2： 项目完成开发，我们想要打成war部署到服务器中，使用maven的构建命令可以快速打包！节省大量时间！\n3. Maven软件工作原理模型图（了解）\n\n二、Maven安装和配置1. Maven安装https://maven.apache.org/docs/history.html\n各个工具选用版本：\n\n\n\n工具\n版本\n\n\n\nMaven\n3.8.8\n\n\nJDK\n17\n\n\nIDEA\n2022.2\n\n\n安装条件： maven需要本机安装java环境、必需包含java_home环境变量！\n软件安装： 右键解压即可（绿色免安装）\n软件结构：\n\nbin：含有Maven的运行脚本\nboot：含有plexus-classworlds类加载器框架\nconf：含有Maven的核心配置文件\nlib：含有Maven运行时所需要的Java类库\nLICENSE、NOTICE、README.txt：针对Maven版本，第三方软件等简要介绍\n2. Maven环境配置\n\n\n\n\n\n\n\n\n1、配置MAVEN_HOME\n\n\n\n\n\n\n\n\n\n\n2、配置Path\n\n\n\n\n\n\n\n\n\n\n3、命令测试（cmd窗口)\nbashmvn -v \n# 输出版本信息即可，如果错误，请仔细检查环境变量即可！3. Maven功能配置\n\n\n\n\n\n\n\n\n我们需要需改maven&#x2F;conf&#x2F;settings.xml配置文件，来修改maven的一些默认配置。我们主要休要修改的有三个配置：\n1.依赖本地缓存位置（本地仓库位置）\n2.maven下载镜像\n3.maven选用编译项目的jdk版本\n\n配置本地仓库地址\nxml  &lt;!-- localRepository\n   | The path to the local repository maven will use to store artifacts.\n   |\n   | Default: $&#123;user.home&#125;/.m2/repository\n  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;\n  --&gt;\n &lt;!-- conf/settings.xml 55行 --&gt;\n &lt;localRepository&gt;D:\\maven-repository&lt;/localRepository&gt;\n配置国内阿里镜像\nxml&lt;!--在mirrors节点(标签)下添加中央仓库镜像 160行附近--&gt;\n&lt;mirror&gt;\n    &lt;id&gt;alimaven&lt;/id&gt;\n    &lt;name&gt;aliyun maven&lt;/name&gt;\n    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n&lt;/mirror&gt;\n配置jdk17版本项目构建\nxml&lt;!--在profiles节点(标签)下添加jdk编译版本 268行附近--&gt;\n&lt;profile&gt;\n    &lt;id&gt;jdk-17&lt;/id&gt;\n    &lt;activation&gt;\n      &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\n      &lt;jdk&gt;17&lt;/jdk&gt;\n    &lt;/activation&gt;\n    &lt;properties&gt;\n      &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n      &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n      &lt;maven.compiler.compilerVersion&gt;17&lt;/maven.compiler.compilerVersion&gt;\n    &lt;/properties&gt;\n&lt;/profile&gt;\n\n4. IDEA配置本地Maven软件\n\n\n\n\n\n\n\n\n我们需要将配置好的maven软件，配置到idea开发工具中即可！ 注意：idea工具默认自带maven配置软件，但是因为没有修改配置，建议替换成本地配置好的maven！\n选择本地maven软件\n\n注意：\n\n如果本地仓库地址不变化，只有一个原因，就是maven&#x2F;conf&#x2F;settings.xml配置文件编写错误！仔细检查即可！\n\n一定保证User settings file对应之前修改的settings.xml的路径，若 不一致，选中Override复选框，手动选择配置文件\n\n\n\n三、基于IDEA创建Maven工程1. 概念梳理Maven工程的GAVPMaven工程相对之前的项目，多出一组gavp属性，gav需要我们在创建项目的时候指定，p有默认值，我们先行了解下这组属性的含义：\nMaven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。这四个属性主要为每个项目在maven仓库中做一个标识，类似人的姓-名！有了具体标识，方便后期项目之间相互引用依赖等！\nGAV遵循一下规则：\n​\t1） GroupID 格式：com.{公司&#x2F;BU }.业务线.[子业务线]，最多 4 级。\n​\t\t说明：{公司&#x2F;BU} 例如：alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliexpress 等 BU 一级；子业务线可选。\n​\t\t正例：com.taobao.tddl 或 com.alibaba.sourcing.multilang\n​\t2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。\n​\t\t正例：tc-client &#x2F; uic-api &#x2F; tair-tool &#x2F; bookstore\n​\t3） Version版本号格式推荐：主版本号.次版本号.修订号\n\n主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。\n\n次版本号：当做了向下兼容的功能性新增（新增类、接口等）。\n\n修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。\n\n\n​\t\t例如： 初始→1.0.0  修改bug → 1.0.1  功能调整 → 1.1.1等\nPackaging定义规则：\n\n指示将项目打包为什么类型的文件，idea根据packaging值，识别maven项目类型！\n\npackaging 属性为 jar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。\n\npackaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。\n\npackaging 属性为 pom，代表不会打包，用来做继承的父工程。\n\n\n2. Idea构建Maven Java SE工程注意：此处省略了version，直接给了一个默认值：1.0-SNAPSHOT\n自己后期可以在项目中随意修改！\n\n创建工程之后，若第一次使用maven，或者使用的是新的本地仓库，idea右下角会出现以下进度条，表示maven正在下载相关插件，等待下载完毕，进度条消失即可\n\n验证maven工程是否创建成功，当创建完毕maven工程之后，idea中会自动打开Maven视图，如下图：\n\n3. Idea构建Maven Java Web工程\n手动创建\n\n创建一个maven的javase工程\n\n\n修改pom.xml文件打包方式\n修改位置：项目下&#x2F;pom.xml\nxml&lt;groupId&gt;com.atguigu&lt;/groupId&gt;\n&lt;artifactId&gt;maven_web&lt;/artifactId&gt;\n&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;!-- 新增一列打包方式packaging --&gt;\n&lt;packaging&gt;war&lt;/packaging&gt;\n设置web资源路径和web.xml路径\n点击File–&gt;Project Structure\n\n\n\n\n刷新和校验\n\n\n\n\n\n\n\n插件创建\n\n安装插件JBLJavaToWeb\nfile / settings / plugins / marketplace\n\n\n创建一个javasemaven工程\n\n右键、使用插件快速补全web项目\n\n\n\n\n\n4. Maven工程项目结构说明Maven 是一个强大的构建工具，它提供一种标准化的项目结构，可以帮助开发者更容易地管理项目的依赖、构建、测试和发布等任务。以下是 Maven Web 程序的文件结构及每个文件的作用：\nxml|-- pom.xml                               # Maven 项目管理文件 \n|-- src\n    |-- main                              # 项目主要代码\n    |   |-- java                          # Java 源代码目录\n    |   |   `-- com/example/myapp         # 开发者代码主目录\n    |   |       |-- controller            # 存放 Controller 层代码的目录\n    |   |       |-- service               # 存放 Service 层代码的目录\n    |   |       |-- dao                   # 存放 DAO 层代码的目录\n    |   |       `-- model                 # 存放数据模型的目录\n    |   |-- resources                     # 资源目录，存放配置文件、静态资源等\n    |   |   |-- log4j.properties          # 日志配置文件\n    |   |   |-- spring-mybatis.xml        # Spring Mybatis 配置文件\n    |   |   `-- static                    # 存放静态资源的目录\n    |   |       |-- css                   # 存放 CSS 文件的目录\n    |   |       |-- js                    # 存放 JavaScript 文件的目录\n    |   |       `-- images                # 存放图片资源的目录\n    |   `-- webapp                        # 存放 WEB 相关配置和资源\n    |       |-- WEB-INF                   # 存放 WEB 应用配置文件\n    |       |   |-- web.xml               # Web 应用的部署描述文件\n    |       |   `-- classes               # 存放编译后的 class 文件\n    |       `-- index.html                # Web 应用入口页面\n    `-- test                              # 项目测试代码\n        |-- java                          # 单元测试目录\n        `-- resources                     # 测试资源目录\npom.xml：Maven 项目管理文件，用于描述项目的依赖和构建配置等信息。\nsrc&#x2F;main&#x2F;java：存放项目的 Java 源代码。\nsrc&#x2F;main&#x2F;resources：存放项目的资源文件，如配置文件、静态资源等。\nsrc&#x2F;main&#x2F;webapp&#x2F;WEB-INF：存放 Web 应用的配置文件。\nsrc&#x2F;main&#x2F;webapp&#x2F;index.jsp：Web 应用的入口页面。\nsrc&#x2F;test&#x2F;java：存放项目的测试代码。\nsrc&#x2F;test&#x2F;resources：存放测试相关的资源文件，如测试配置文件等。\n\n\n四、基于IDEA进行Maven工程构建1. 构建概念和构建过程项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。\n项目构建是软件开发过程中至关重要的一部分，它能够大大提高软件开发效率，使得开发人员能够更加专注于应用程序的开发和维护，而不必关心应用程序的构建细节。\n同时，项目构建还能够将多个开发人员的代码汇合到一起，并能够自动化项目的构建和部署，大大降低了项目的出错风险和提高开发效率。常见的构建工具包括 Maven、Gradle、Ant 等。\n\n2. 命令方式项目构建\n\n\n命令\n描述\n\n\n\nmvn (test-)compile\n编译项目，生成target文件(不加test-无法打包test源码)\n\n\nmvn package\n打包项目，生成jar或war文件\n\n\nmvn clean\n清理编译或打包后的项目结构\n\n\nmvn install\n打包后上传到maven本地仓库\n\n\nmvn deploy\n只打包，上传到maven私服仓库\n\n\nmvn site\n生成站点\n\n\nmvn test\n执行测试源码\n\n\nwar包打包插件和jdk版本不匹配：pom.xml 添加以下代码即可\nxml&lt;build&gt;\n    &lt;!-- jdk17 和 war包版本插件不匹配 --&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n            &lt;version&gt;3.2.2&lt;/version&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;命令触发练习：\nbashmvn 命令 命令\n\n#清理\nmvn clean\n#清理，并重新打包\nmvn clean package\n#执行测试代码\nmvn test3. 可视化方式项目构建\n注意：打包（package）和安装（install）的区别是什么\n打包是将工程打成jar或war文件，保存在target目录下\n安装是将当前工程所生成的jar或war文件，安装到本地仓库，会按照坐标保存到指定位置\n4. 构建插件、命令、生命周期命令之间关系\n构建生命周期\n我们发现一个情况！当我们执行package命令也会自动执行compile命令！\nshell[INFO] --------------------------------[ jar ]---------------------------------\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ mybatis-base-curd ---\n[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ mybatis-base-curd ---\n[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ mybatis-base-curd ---\n[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ mybatis-base-curd ---\n[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ mybatis-base-curd ---\n[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ mybatis-base-curd ---\n[INFO] Building jar: D:\\javaprojects\\backend-engineering\\part03-mybatis\\mybatis-base-curd\\target\\mybatis-base-curd-1.0-SNAPSHOT.jar\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  5.013 s\n[INFO] Finished at: 2023-06-05T10:03:47+08:00\n[INFO] ------------------------------------------------------------------------这种行为就是因为构建生命周期产生的！构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！！！\n\n\n构建周期作用：会简化构建过程\n例如：项目打包   mvn clean package即可。&#x20;\n主要两个构建生命周期：\n\n清理周期：主要是对项目编译生成文件进行清理。包含命令：clean&#x20;\n\n默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分\ntxt包含命令：compile -  test - package - install - deploy\n插件、命令、周期三者关系（了解）\n\n周期→包含若干命令→包含若干插件\n\n使用周期命令构建，简化构建过程！\n\n最终进行构建的是插件！\n\n\n\n\n\n五、基于IDEA 进行Maven依赖管理1. 依赖管理概念Maven 依赖管理是 Maven 软件中最重要的功能之一。Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。\n我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven 仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。\n总之，Maven 的依赖管理是 Maven 软件的一个核心功能之一，使得软件包依赖的管理和使用更加智能和方便，简化了开发过程中的工作，并提高了软件质量和可维护性。\n2. Maven工程核心信息配置和解读（GAVP）位置：pom.xml\nxml&lt;!-- 模型版本 --&gt;\n&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;\n&lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt;\n&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;\n&lt;artifactId&gt;project&lt;/artifactId&gt;\n&lt;!-- 版本号 --&gt;\n&lt;version&gt;1.0.0&lt;/version&gt;\n\n&lt;!--打包方式\n    默认：jar\n    jar指的是普通的java项目打包方式！ 项目打成jar包！\n    war指的是web项目打包方式！项目打成war包！\n    pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念\n--&gt;\n&lt;packaging&gt;jar/pom/war&lt;/packaging&gt;3. Maven工程依赖管理配置位置：pom.xml\n依赖管理和依赖添加\nxml&lt;!-- \n   通过编写依赖jar包的gav必要属性，引入第三方依赖！\n   scope属性是可选的，可以指定依赖生效范围！\n   依赖信息查询方式：\n      1. maven仓库信息官网 https://mvnrepository.com/\n      2. mavensearch插件搜索\n --&gt;\n&lt;dependencies&gt;\n    &lt;!-- 引入具体的依赖包 --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n        &lt;version&gt;1.2.17&lt;/version&gt;\n        &lt;!-- 依赖范围 --&gt;\n        &lt;scope&gt;runtime&lt;/scope&gt;\n    &lt;/dependency&gt;\n\n&lt;/dependencies&gt;依赖版本统一提取和维护\nxml&lt;!--声明版本--&gt;\n&lt;properties&gt;\n  &lt;!--命名随便,内部制定版本号即可！--&gt;\n  &lt;junit.version&gt;4.12&lt;/junit.version&gt;\n  &lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt;\n  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n  &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;!--引用properties声明版本 --&gt;\n    &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;4. 依赖范围通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境\n\n\n\n依赖范围\n描述\n\n\n\ncompile\n编译依赖范围，scope 元素的缺省值。使用此依赖范围的 Maven 依赖，对于三种 classpath 均有效，即该 Maven 依赖在上述三种 classpath 均会被引入。例如，log4j 在编译、测试、运行过程都是必须的。\n\n\ntest\n测试依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath 有效。例如，Junit 依赖只有在测试阶段才需要。\n\n\nprovided\n已提供依赖范围。使用此依赖范围的 Maven 依赖，只对编译 classpath 和测试 classpath 有效。例如，servlet-api 依赖对于编译、测试阶段而言是需要的，但是运行阶段，由于外部容器已经提供，故不需要 Maven 重复引入该依赖。\n\n\nruntime\n运行时依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath、运行 classpath 有效。例如，JDBC 驱动实现依赖，其在编译时只需 JDK 提供的 JDBC 接口即可，只有测试、运行阶段才需要实现了 JDBC 接口的驱动。\n\n\nsystem\n系统依赖范围，其效果与 provided 的依赖范围一致。其用于添加非 Maven 仓库的本地依赖，通过依赖元素 dependency 中的 systemPath 元素指定本地依赖的路径。鉴于使用其会导致项目的可移植性降低，一般不推荐使用。\n\n\nimport\n导入依赖范围，该依赖范围只能与 dependencyManagement 元素配合使用，其功能是将目标 pom.xml 文件中 dependencyManagement 的配置导入合并到当前 pom.xml 的 dependencyManagement 中。\n\n\n5. Maven工程依赖下载失败错误解决（重点）在使用 Maven 构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种：\n\n下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。\n依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。\n本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项。\n\n解决方案：\n\n检查网络连接和 Maven 仓库服务器状态。\n\n确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。\n\n清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！\n例如： pom.xml依赖\nxml&lt;dependency&gt;\n  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n  &lt;artifactId&gt;druid&lt;/artifactId&gt;\n  &lt;version&gt;1.2.8&lt;/version&gt;\n&lt;/dependency&gt;文件：\n\n\n或者可以将清除lastUpdated文件的操作写在一个脚本文件中，手动创建文件”clearLastUpdated.bat”，名字任意，但是后缀必须是bat，将以下内容复制到文件中\nbatcls \n@ECHO OFF \nSET CLEAR_PATH=D: \nSET CLEAR_DIR=D:\\maven-repository(本地仓库路径)\ncolor 0a \nTITLE ClearLastUpdated For Windows \nGOTO MENU \n:MENU \nCLS\nECHO. \nECHO. * * * *  ClearLastUpdated For Windows  * * * * \nECHO. * * \nECHO. * 1 清理*.lastUpdated * \nECHO. * * \nECHO. * 2 查看*.lastUpdated * \nECHO. * * \nECHO. * 3 退 出 * \nECHO. * * \nECHO. * * * * * * * * * * * * * * * * * * * * * * * * \nECHO. \nECHO.请输入选择项目的序号： \nset /p ID= \nIF &quot;%id%&quot;==&quot;1&quot; GOTO cmd1 \nIF &quot;%id%&quot;==&quot;2&quot; GOTO cmd2 \nIF &quot;%id%&quot;==&quot;3&quot; EXIT \nPAUSE \n:cmd1 \nECHO. 开始清理\n%CLEAR_PATH%\ncd %CLEAR_DIR%\nfor /r %%i in (*.lastUpdated) do del %%i\nECHO.OK \nPAUSE \nGOTO MENU \n:cmd2 \nECHO. 查看*.lastUpdated文件\n%CLEAR_PATH%\ncd %CLEAR_DIR%\nfor /r %%i in (*.lastUpdated) do echo %%i\nECHO.OK \nPAUSE \nGOTO MENU \n\n\n6. Maven工程Build构建配置项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。\n默认情况下，构建不需要额外配置，都有对应的缺省配置。当然了，我们也可以在pom.xml定制一些配置，来修改默认构建的行为和产物！\n例如：\n\n指定构建打包文件的名称，非默认名称\n制定构建打包时，指定包含文件格式和排除文件\n打包插件版本过低，配置更高版本插件\n\n构建配置是在pom.xml &#x2F; build标签中指定！\n指定打包命名\nxml&lt;!-- 默认的打包名称：artifactid+verson.打包方式 --&gt;\n&lt;build&gt;\n  &lt;finalName&gt;定义打包名称&lt;/finalName&gt;\n&lt;/build&gt;  指定打包文件\n\n如果在java文件夹中添加java类，会自动打包编译到classes文件夹下！\n\n但是在java文件夹中添加xml文件，默认不会被打包！\n\n默认情况下，按照maven工程结构放置的文件会默认被编译和打包！\n\n除此之外、我们可以使用resources标签，指定要打包资源的文件夹要把哪些静态资源打包到 classes根目录下！\n\n\n应用场景：mybatis中有时会将用于编写SQL语句的映射文件和mapper接口都写在src&#x2F;main&#x2F;java下的某个包中，此时映射文件就不会被打包，如何解决\nxml&lt;build&gt;\n    &lt;!--设置要打包的资源位置--&gt;\n    &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;!--设置资源所在目录--&gt;\n            &lt;directory&gt;src/main/java&lt;/directory&gt;\n            &lt;includes&gt;\n                &lt;!--设置包含的资源类型--&gt;\n                &lt;include&gt;**/*.xml&lt;/include&gt;\n            &lt;/includes&gt;\n        &lt;/resource&gt;\n    &lt;/resources&gt;\n&lt;/build&gt;配置依赖插件\ndependencies标签下引入开发需要的jar包！我们可以在build&#x2F;plugins&#x2F;plugin标签引入插件！\n常用的插件：修改jdk版本、tomcat插件、mybatis分页插件、mybatis逆向工程插件等等！\nxml&lt;build&gt;\n  &lt;plugins&gt;\n      &lt;!-- java编译插件，配jdk的编译版本 --&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n        &lt;configuration&gt;\n          &lt;source&gt;1.8&lt;/source&gt;\n          &lt;target&gt;1.8&lt;/target&gt;\n          &lt;encoding&gt;UTF-8&lt;/encoding&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n      &lt;!-- tomcat插件 --&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;\n        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;\n         &lt;version&gt;2.2&lt;/version&gt;\n          &lt;configuration&gt;\n          &lt;port&gt;8090&lt;/port&gt;\n          &lt;path&gt;/&lt;/path&gt;\n          &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;\n          &lt;server&gt;tomcat7&lt;/server&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n六、Maven依赖传递和依赖冲突1. Maven依赖传递特性概念\n假如有Maven项目A，项目B依赖A，项目C依赖B。那么我们可以说 C依赖A。也就是说，依赖的关系为：C—&gt;B—&gt;A， 那么我们执行项目C时，会自动把B、A都下载导入到C项目的jar包文件夹中，这就是依赖的传递性。\n作用\n\n简化依赖导入过程\n确保依赖版本正确\n\n传递的原则\n在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围以及配置\n\nB 依赖 C 时使用 compile 范围：可以传递\nB 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。\nB 依赖 C 时，若配置了以下标签，则不能传递\n\nxml&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;druid&lt;/artifactId&gt;\n    &lt;version&gt;1.2.15&lt;/version&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;依赖传递终止\n\n非compile范围进行依赖传递\n使用optional配置终止传递\n依赖冲突（传递的依赖已经存在）\n\n案例：导入jackson依赖\n分析：jackson需要三个依赖\n\n依赖传递关系：data-bind中，依赖其他两个依赖\n\n最佳导入：直接可以导入data-bind，自动依赖传递需要的依赖\nxml&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.10.0&lt;/version&gt;\n&lt;/dependency&gt;\n2. Maven依赖冲突特性当直接引用或者间接引用出现了相同的jar包! 这时呢，一个项目就会出现相同的重复jar包，这就算作冲突！依赖冲突避免出现重复依赖，并且终止依赖传递！\n\nmaven自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择。同时也提供了手动解决的冲突的方式，不过不推荐！\n解决依赖冲突（如何选择重复依赖）方式：\n\n自动选择原则\n\n短路优先原则（第一原则）\ntxtA—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1)\nA—&gt;F—&gt;X(version 0.0.2)则A依赖于X(version 0.0.2)。\n\n依赖路径长度相同情况下，则“先声明优先”（第二原则）\ntxtA—&gt;E—&gt;X(version 0.0.1)\nA—&gt;F—&gt;X(version 0.0.2)在&lt;depencies&gt;&lt;&#x2F;depencies&gt;中，先声明的，路径相同，会优先选择！\n\n\n\n手动排除\nxml&lt;dependency&gt;\n  &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;\n  &lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;scope&gt;compile&lt;/scope&gt;\n  &lt;!-- 使用excludes标签配置依赖的排除  --&gt;\n  &lt;exclusions&gt;\n    &lt;!-- 在exclude标签中配置一个具体的排除 --&gt;\n    &lt;exclusion&gt;\n      &lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;\n      &lt;groupId&gt;commons-logging&lt;/groupId&gt;\n      &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;\n    &lt;/exclusion&gt;\n  &lt;/exclusions&gt;\n&lt;/dependency&gt;\n小案例\n伪代码如下：\nxml前提：\n   A 1.1 -&gt; B 1.1 -&gt; C 1.1 \n   F 2.2 -&gt; B 2.2 \n   \npom声明：\n   F 2.2\n   A 1.1 请问最终会导入哪些依赖和对应版本？\n\n\n\n七、Maven工程继承和聚合关系1. Maven工程继承关系\n继承概念\nMaven 继承是指在 Maven 的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。&lt;scope&gt;&lt;/scope&gt;中test，provided依然会继承到子工程中。\n\n继承作用\n在父工程中统一管理项目中的依赖信息。\n它的背景是：\n\n对一个比较大型的项目进行了模块拆分。\n一个 project 下面，创建了很多个 module。\n每一个 module 都需要配置自己的依赖信息。\n\n它背后的需求是：\n\n在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。\n使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。\n使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。\n通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。\n\n\n继承语法\n\n父工程\nxml  &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;\n  &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;\n  &lt;packaging&gt;pom&lt;/packaging&gt;\n子工程\nxml&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;\n&lt;parent&gt;\n  &lt;!-- 父工程的坐标 --&gt;\n  &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;\n  &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/parent&gt;\n\n&lt;!-- 子工程的坐标 --&gt;\n&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;\n&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;\n&lt;artifactId&gt;pro04-maven-module&lt;/artifactId&gt;\n&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;\n\n\n父工程依赖统一管理\n\n父工程声明版本\nxml&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;\n&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;\n&lt;dependencyManagement&gt;\n  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n      &lt;version&gt;6.0.10&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;\n      &lt;version&gt;6.0.10&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n      &lt;version&gt;6.0.10&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;\n      &lt;version&gt;6.0.10&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;\n      &lt;version&gt;6.0.10&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n子工程引用版本\nxml&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。  --&gt;\n&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;\n&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;\n&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n\n\n2. Maven工程聚合关系\n聚合概念\nMaven 聚合是指将多个项目组织到一个父级项目中，以便一起构建和管理的机制。聚合可以帮助我们更好地管理一组相关的子项目，同时简化它们的构建和部署过程。\n\n聚合作用\n\n管理多个子项目：通过聚合，可以将多个子项目组织在一起，方便管理和维护。\n构建和发布一组相关的项目：通过聚合，可以在一个命令中构建和发布多个相关的项目，简化了部署和维护工作。\n优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。\n统一管理依赖项：通过聚合，可以在父项目中管理公共依赖项和插件，避免重复定义。\n\n\n聚合语法\n父项目中包含的子项目列表。&lt;module&gt;&lt;/module&gt;中放的是路径，不是工程名字。\nxml&lt;project&gt;\n  &lt;groupId&gt;com.example&lt;/groupId&gt;\n  &lt;artifactId&gt;parent-project&lt;/artifactId&gt;\n  &lt;packaging&gt;pom&lt;/packaging&gt;\n  &lt;version&gt;1.0.0&lt;/version&gt;\n  &lt;modules&gt;\n    &lt;module&gt;child-project1&lt;/module&gt;\n    &lt;module&gt;child-project2&lt;/module&gt;\n  &lt;/modules&gt;\n&lt;/project&gt;\n聚合演示\n通过触发父工程构建命令、引发所有子模块构建！产生反应堆！\n\n\n\n八、Maven私服1. Maven私服简介①私服简介\nMaven 私服是一种特殊的Maven远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的远程仓库（中央仓库、其他远程公共仓库）。\n\n\n\n\n\n\n\n\n\n当然也并不是说私服只能建立在局域网，也有很多公司会直接把私服部署到公网，具体还是得看公司业务的性质是否是保密的等等，因为局域网的话只能在公司用，部署到公网的话员工在家里也可以办公使用。\n建立了 Maven 私服后，当局域网内的用户需要某个构件时，会按照如下顺序进行请求和下载。\n\n请求本地仓库，若本地仓库不存在所需构件，则跳转到第 2 步；\n请求 Maven 私服，将所需构件下载到本地仓库，若私服中不存在所需构件，则跳转到第 3 步。\n请求外部的远程仓库，将所需构件下载并缓存到 Maven 私服，若外部远程仓库不存在所需构件，则 Maven 直接报错。\n\n此外，一些无法从外部仓库下载到的构件，也能从本地上传到私服供其他人使用。\n\n②Maven私服的优势\n\n节省外网带宽：消除对外部远程仓库的大量重复请求（会消耗很大量的带宽），降低外网带宽压力。\n下载速度更快：Maven私服位于局域网内，从私服下载构建更快更稳定。\n便于部署第三方构件：有些构件无法从任何一个远程仓库中获得（如：公司或组织内部的私有构件、Oracle的JDBC驱动等），建立私服之后，就可以将这些构件部署到私服中，供内部Maven项目使用。\n提高项目的稳定性，增强对项目的控制：如果不建立私服，那么Maven项目的构件就高度依赖外部的远程仓库，若外部网络不稳定，则项目的构建过程也会变得不稳定。建立私服后，即使外部网络状况不佳甚至中断，只要私服中已经缓存了所需的构件，Maven也能够正常运行。私服软件（如：Nexus）提供了很多控制功能（如：权限管理、RELEASE&#x2F;SNAPSHOT版本控制等），可以对仓库进行一些更加高级的控制。\n降低中央仓库得负荷压力：由于私服会缓存中央仓库的构件，避免了很多对中央仓库的重复下载，降低了中央仓库的负荷。\n\n③常见的Maven私服产品\n\nApache的Archiva\nJFrog的Artifactory\nSonatype的Nexus（[ˈneksəs]）（当前最流行、使用最广泛）\n\n2. Nexus下载安装下载地址：https://help.sonatype.com/repomanager3/product-information/download\n解压，以管理员身份打开CMD，进入bin目录下，执行.&#x2F;nexus &#x2F;run命令启动\n访问 Nexus 首页\n首页地址：http://localhost:8081/，8081为默认端口号\n\n3. 初始设置\n\n这里参考提示：\n\n用户名：admin\n密码：查看 E:\\Server\\nexus-3.61.0-02-win64\\sonatype-work\\nexus3\\admin.password 文件\n\n\n继续执行初始化：\n\n\n匿名登录，启用还是禁用？由于启用匿名登录后，后续操作比较简单，这里我们演示禁用匿名登录的操作：\n\n初始化完毕：\n\n4. Nexus上的各种仓库\n\n\n\n仓库类型\n说明\n\n\n\nproxy\n某个远程仓库的代理\n\n\ngroup\n存放：通过 Nexus 获取的第三方 jar 包\n\n\nhosted\n存放：本团队其他开发人员部署到 Nexus 的 jar 包\n\n\n\n\n\n仓库名称\n说明\n\n\n\nmaven-central\nNexus 对 Maven 中央仓库的代理\n\n\nmaven-public\nNexus 默认创建，供开发人员下载使用的组仓库\n\n\nmaven-releases\nNexus 默认创建，供开发人员部署自己 jar 包的宿主仓库 要求 releases 版本\n\n\nmaven-snapshots\nNexus 默认创建，供开发人员部署自己 jar 包的宿主仓库 要求 snapshots 版本\n\n\n初始状态下，这几个仓库都没有内容：\n\n5. 通过 Nexus 下载 jar 包修改本地maven的核心配置文件settings.xml，设置新的本地仓库地址\nxml&lt;!-- 配置一个新的 Maven 本地仓库 --&gt;\n&lt;localRepository&gt;D:/maven-repository-new&lt;/localRepository&gt;把我们原来配置阿里云仓库地址的 mirror 标签改成下面这样：id可随便取，但一定要和下面内容对应。mirrorOf此处表示中央仓库。name是别名。\nxml&lt;mirror&gt;\n    &lt;id&gt;nexus-mine&lt;/id&gt;\n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n    &lt;name&gt;Nexus mine&lt;/name&gt;\n    &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;\n&lt;/mirror&gt;这里的 url 标签是这么来的：\n\n\n把上图中看到的地址复制出来即可。如果我们在前面允许了匿名访问，到这里就够了。但如果我们禁用了匿名访问，那么接下来我们还要继续配置 settings.xml：\nxml&lt;server&gt;\n  &lt;id&gt;nexus-mine&lt;/id&gt;\n  &lt;username&gt;admin&lt;/username&gt;\n  &lt;password&gt;atguigu&lt;/password&gt;\n&lt;/server&gt;这里需要格外注意：server 标签内的 id 标签值必须和 mirror 标签中的 id 值一样。\n找一个用到框架的 Maven 工程，执行命令：（如果使用VScode记得检查Maven配置的本地仓库）\nshmvn clean compile下载过程日志：\n\n\n\n\n\n\n\n\n\nDownloading from nexus-mine: http://localhost:8081/repository/maven-public/com/jayway/jsonpath/json-path/2.4.0/json-path-2.4.0.pomDownloaded from nexus-mine: http://localhost:8081/repository/maven-public/com/jayway/jsonpath/json-path/2.4.0/json-path-2.4.0.pom (2.6 kB at 110 kB&#x2F;s)Downloading from nexus-mine: http://localhost:8081/repository/maven-public/net/minidev/json-smart/2.3/json-smart-2.3.pomDownloaded from nexus-mine: http://localhost:8081/repository/maven-public/net/minidev/json-smart/2.3/json-smart-2.3.pom (9.0 kB at 376 kB&#x2F;s)Downloading from nexus-mine: http://localhost:8081/repository/maven-public/net/minidev/minidev-parent/2.3/minidev-parent-2.3.pomDownloaded from nexus-mine: http://localhost:8081/repository/maven-public/net/minidev/minidev-parent/2.3/minidev-parent-2.3.pom (8.5 kB at 404 kB&#x2F;s)Downloading from nexus-mine: http://localhost:8081/repository/maven-public/net/minidev/accessors-smart/1.2/accessors-smart-1.2.pomDownloaded from nexus-mine: http://localhost:8081/repository/maven-public/net/minidev/accessors-smart/1.2/accessors-smart-1.2.pom (12 kB at 463 kB&#x2F;s)\n下载后，Nexus 服务器上就有了 jar 包：\n\n若下载速度太慢，可以设置私服中中央仓库的地址为阿里云仓库地址\n\n修改为：http://maven.aliyun.com/nexus/content/groups/public/\n\n6. 将 jar 包部署到 Nexusmaven工程中pom.xml配置：\nxml&lt;distributionManagement&gt;\n    &lt;snapshotRepository&gt;\n        &lt;id&gt;nexus-mine&lt;/id&gt;\n        &lt;name&gt;Nexus Snapshot&lt;/name&gt;\n        &lt;url&gt;http://localhost:8081/repository/maven-snapshots/&lt;/url&gt;\n    &lt;/snapshotRepository&gt;\n&lt;/distributionManagement&gt;注意：这里 snapshotRepository 的 id 标签必须和 settings.xml 中指定的 mirror 标签的 id 属性一致。\n执行部署命令：\nshmvn deploy\n\n\n\n\n\n\n\n\nUploading to nexus-mine: http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/1.0-SNAPSHOT/maven-metadata.xmlUploaded to nexus-mine: http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/1.0-SNAPSHOT/maven-metadata.xml (786 B at 19 kB&#x2F;s)Uploading to nexus-mine: http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/maven-metadata.xmlUploaded to nexus-mine: http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/maven-metadata.xml (300 B at 6.5 kB&#x2F;s)[INFO] ————————————————————————[INFO] Reactor Summary:[INFO][INFO] demo-imperial-court-ms-show 1.0-SNAPSHOT ……….. SUCCESS [ 1.875 s][INFO] demo09-base-entity …………………………… SUCCESS [ 21.883 s][INFO] demo10-base-util …………………………….. SUCCESS [ 0.324 s][INFO] demo08-base-api ……………………………… SUCCESS [ 1.171 s][INFO] demo01-imperial-court-gateway …………………. SUCCESS [ 0.403 s][INFO] demo02-user-auth-center ………………………. SUCCESS [ 2.932 s][INFO] demo03-emp-manager-center …………………….. SUCCESS [ 0.312 s][INFO] demo04-memorials-manager-center ……………….. SUCCESS [ 0.362 s][INFO] demo05-working-manager-center …………………. SUCCESS [ 0.371 s][INFO] demo06-mysql-data-provider ……………………. SUCCESS [ 6.779 s][INFO] demo07-redis-data-provider 1.0-SNAPSHOT ………… SUCCESS [ 0.273 s]\n\n7. 引用别人部署的 jar 包maven工程中配置：\nxml&lt;repositories&gt;\n    &lt;repository&gt;\n        &lt;id&gt;nexus-mine&lt;/id&gt;\n        &lt;name&gt;nexus-mine&lt;/name&gt;\n        &lt;url&gt;http://localhost:8081/repository/maven-snapshots/&lt;/url&gt;\n        &lt;snapshots&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/snapshots&gt;\n        &lt;releases&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/releases&gt;\n    &lt;/repository&gt;\n&lt;/repositories&gt;\n九、Maven综合案例1. 项目需求和结构分析\n需求案例：搭建一个电商平台项目，该平台包括用户服务、订单服务、通用工具模块等。\n项目架构：\n\n用户服务：负责处理用户相关的逻辑，例如用户信息的管理、用户注册、登录等。\nspring-context 6.0.6 \nspring-core 6.0.6\nspring-beans 6.0.6\ncommon-service\n\n\n订单服务：负责处理订单相关的逻辑，例如订单的创建、订单支付、退货、订单查看等。\nspring-context 6.0.6 \nspring-core 6.0.6\nspring-beans 6.0.6\nspring-security 6.0.6\ncommon-service\n\n\n通用模块：负责存储其他服务需要通用工具类，其他服务依赖此模块。\ncommons-io 2.11.0\njunit 5.9.2\n\n\n\n2. 项目搭建和统一构建①父模块 (micro-shop)创建工程：\n\npom.xml配置：\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.atguigu&lt;/groupId&gt;\n    &lt;artifactId&gt;micro-shop&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;!--知识点：父工程的打包方式为pom--&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;properties&gt;\n        &lt;spring.version&gt;6.0.6&lt;/spring.version&gt;\n        &lt;jackson.version&gt;2.15.0&lt;/jackson.version&gt;\n        &lt;commons.version&gt;2.11.0&lt;/commons.version&gt;\n        &lt;junit.version&gt;5.9.2&lt;/junit.version&gt;\n        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n\n    &lt;!-- 依赖管理 --&gt;\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;!-- spring-context会依赖传递core/beans --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n                &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;\n            &lt;/dependency&gt;\n\n            &lt;!-- jackson-databind会依赖传递core/annotations --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n                &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n                &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;\n            &lt;/dependency&gt;\n\n            &lt;!-- commons-io --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;commons-io&lt;/groupId&gt;\n                &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n                &lt;version&gt;$&#123;commons.version&#125;&lt;/version&gt;\n            &lt;/dependency&gt;\n\n            &lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n                &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n                &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;\n                &lt;scope&gt;test&lt;/scope&gt;\n            &lt;/dependency&gt;\n\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n\n    &lt;!-- 统一更新子工程打包插件--&gt;\n    &lt;build&gt;\n        &lt;!-- jdk17 和 war包版本插件不匹配 --&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.2.2&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;可选操作：删除src目录\n②通用模块 (common-service)创建工程：\n\n\npom.xml配置：\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;micro-shop&lt;/artifactId&gt;\n        &lt;groupId&gt;com.atguigu&lt;/groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;artifactId&gt;common-service&lt;/artifactId&gt;\n    &lt;!--知识点：打包方式默认就是jar，因此可以省略--&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- 配置spring-context，继承父工程版本，自动传递 core / beans --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 配置jackson-databind，继承父工程版本，自动传递 core / annotations --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 配置commons-io，继承父工程版本 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;commons-io&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 配置junit，继承父工程版本 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;③用户模块 (user-service)创建工程：\n\n\npom.xml配置：\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;micro-shop&lt;/artifactId&gt;\n        &lt;groupId&gt;com.atguigu&lt;/groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;artifactId&gt;user-service&lt;/artifactId&gt;\n    &lt;!-- web工程打包方式为war --&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- 配置common-service，所需依赖会传递到当前工程（仅限compile范围） --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu&lt;/groupId&gt;\n            &lt;artifactId&gt;common-service&lt;/artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;依赖传递结果：\n\n④订单模块 (order-service)创建工程，并使用插件转为web工程：\n\npom.xml配置：\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;micro-shop&lt;/artifactId&gt;\n        &lt;groupId&gt;com.atguigu&lt;/groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;artifactId&gt;order-service&lt;/artifactId&gt;\n    &lt;!-- web工程打包方式为war --&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- 配置common-service，所需依赖会传递到当前工程（仅限compile范围） --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.atguigu&lt;/groupId&gt;\n            &lt;artifactId&gt;common-service&lt;/artifactId&gt;\n            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;此时，查看父工程的pom.xml，会发现其中已经自动聚合了子工程：\nxml&lt;modules&gt;\n    &lt;module&gt;common-service&lt;/module&gt;\n    &lt;module&gt;user-service&lt;/module&gt;\n    &lt;module&gt;order-service&lt;/module&gt;\n&lt;/modules&gt;","slug":"Maven","date":"2024-03-20T09:50:00.000Z","categories_index":"微服务核心","tags_index":"微服务核心","author_index":"白"},{"id":"2f1e0f645f95e2a39638b276516d9ceb","title":"微头条项目开发","content":"微头条项目开发一 项目简介1.1 微头条业务简介\n\n\n\n\n\n\n\n\n微头条新闻发布和浏览平台,主要包含业务如下\n\n用户功能\n注册功能\n登录功能\n\n\n头条新闻\n新闻的分页浏览\n通过标题关键字搜索新闻\n查看新闻详情\n新闻的修改和删除\n\n\n权限控制\n用户只能修改和自己发布的头条新闻\n\n\n\n1.2 技术栈介绍\n\n\n\n\n\n\n\n\n前端技术栈\n\nES6作为基础JS语法\nnodejs用于运行环境\nnpm用于项目依赖管理工具\nvite用于项目的构建架工具\nVue3用于项目数据的渲染框架\nAxios用于前后端数据的交互\nRouter用于页面的跳转\nPinia用于存储用户的数据\nLocalStorage作为用户校验token的存储手段\nElement-Plus提供组件\n\n\n\n\n\n\n\n\n\n\n后端技术栈\n\nJAVA作为开发语言,版本为JDK17\nTomcat作为服务容器,版本为10.1.7\nMysql8用于项目存储数据\nServlet用于控制层实现前后端数据交互\nJDBC用于实现数据的CURD\nDruid用于提供数据源的连接池\nMD5用于用户密码的加密\nJwt用于token的生成和校验\nJackson用于转换JSON\nFilter用于用户登录校验和跨域处理\nLombok用于处理实体类\n\n1.3 功能展示\n\n\n\n\n\n\n\n\n头条首页信息搜索\n\n\n\n\n\n\n\n\n\n\n登录功能\n\n\n\n\n\n\n\n\n\n\n注册功能\n\n\n\n\n\n\n\n\n\n\n权限控制功能\n\n\n\n\n\n\n\n\n\n\n发布头条功能\n\n\n\n\n\n\n\n\n\n\n修改头条功能\n\n\n\n\n\n\n\n\n\n\n删除头条功能\n\n\n二 前端项目环境搭建\n解压前端项目代码并存放到磁盘的合适位置\n\n\n\n使用vscode打开工程\n\n\n\n进入项目后打开集成终端或者在src上右击选择在集成终端中打开\n\n\n\n通过 npm run dev启动前端项目\n\n\n\n\n三 后端项目环境搭建3.1  数据库准备\n\n\n\n\n\n\n\n\nnews_users 用户表\n\n\n\n\n\n\n\n\n\n\nnews_type 新闻类型表\n\n\n\n\n\n\n\n\n\n\nnews_headline 新闻信息表\n\n\n\n\n\n\n\n\n\n\n数据库创建SQL\n\n导入资料中的top_news.sql文件即可\n\n3.2 MVC项目架构模式\n\n\n\n\n\n\n\n\n MVC（Model View Controller）是软件工程中的一种**软件架构模式，它把软件系统分为模型、视图和控制器**三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。\n\nM：Model 模型层,具体功能如下\n\n存放和数据库对象的实体类以及一些用于存储非数据库表完整相关的VO对象\n存放一些对数据进行逻辑运算操作的的一些业务处理代码\n\n\nV：View 视图层,具体功能如下\n\n存放一些视图文件相关的代码 html css js等\n在前后端分离的项目中,后端已经没有视图文件,该层次已经衍化成独立的前端项目\n\n\nC：Controller 控制层,具体功能如下1. 接收客户端请求,获得请求数据2. 将准备好的数据响应给客户端\n\n\n\n\n\n\n\n\n\n\n\nMVC模式下,项目中的常见包\n\nM:\n\n实体类包(pojo &#x2F;entity &#x2F;bean) 专门存放和数据库对应的实体类和一些VO对象\n数据库访问包(dao&#x2F;mapper)  专门存放对数据库不同表格CURD方法封装的一些类\n服务包(service)                       专门存放对数据进行业务逻辑预算的一些类\n\n\nC:\n\n控制层包(controller)\n\n\nV:\n\nweb目录下的视图资源 html css js img 等\n前端工程化后,在后端项目中已经不存在了\n\n\n\n\n3.3 搭建项目3.3.1 创建WEB项目\n3.3.2 导入依赖\n3.3.3 准备包结构\n\ncontroller： 控制层代码,主要由Servlet组成\nservice：     服务层代码,主要用于处理业务逻辑\ndao：          数据访问层,主要用户定义对于各个表格的CURD的方法\npojo：         实体类层,主要用于存放和数据库对应的实体类以及一些VO对象\nutil：           工具类包,主要用存放一些工具类\ncommon：  公共包,主要用户存放一些其他公共代码\nfilters：       过滤器包,专门用于存放一些过滤器\ntest：          测试代码包,专门用于定义一些测试的功能代码,上线前应该删掉,后期用maven可以自动处理掉\n\n3.5 准备工具类3.5.1 异步响应规范格式类\nResult类\n\njavapackage com.atguigu.headline.common;\n\n/**\n * 全局统一返回结果类\n *\n */\npublic class Result&lt;T&gt; &#123;\n    // 返回码\n    private Integer code;\n    // 返回消息\n    private String message;\n    // 返回数据\n    private T data;\n    public Result()&#123;&#125;\n    // 返回数据\n    protected static &lt;T&gt; Result&lt;T&gt; build(T data) &#123;\n        Result&lt;T&gt; result = new Result&lt;T&gt;();\n        if (data != null)\n            result.setData(data);\n        return result;\n    &#125;\n    public static &lt;T&gt; Result&lt;T&gt; build(T body, Integer code, String message) &#123;\n        Result&lt;T&gt; result = build(body);\n        result.setCode(code);\n        result.setMessage(message);\n        return result;\n    &#125;\n    public static &lt;T&gt; Result&lt;T&gt; build(T body, ResultCodeEnum resultCodeEnum) &#123;\n        Result&lt;T&gt; result = build(body);\n        result.setCode(resultCodeEnum.getCode());\n        result.setMessage(resultCodeEnum.getMessage());\n        return result;\n    &#125;\n    /**\n     * 操作成功\n     * @param data  baseCategory1List\n     * @param &lt;T&gt;\n     * @return\n     */\n    public static&lt;T&gt; Result&lt;T&gt; ok(T data)&#123;\n        Result&lt;T&gt; result = build(data);\n        return build(data, ResultCodeEnum.SUCCESS);\n    &#125;\n    public Result&lt;T&gt; message(String msg)&#123;\n        this.setMessage(msg);\n        return this;\n    &#125;\n    public Result&lt;T&gt; code(Integer code)&#123;\n        this.setCode(code);\n        return this;\n    &#125;\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n    public void setCode(Integer code) &#123;\n        this.code = code;\n    &#125;\n    public String getMessage() &#123;\n        return message;\n    &#125;\n    public void setMessage(String message) &#123;\n        this.message = message;\n    &#125;\n    public T getData() &#123;\n        return data;\n    &#125;\n    public void setData(T data) &#123;\n        this.data = data;\n    &#125;\n&#125;\nResultCodeEnum 枚举类\n\njavapackage com.atguigu.headline.common;\n/**\n * 统一返回结果状态信息类\n *\n */\npublic enum ResultCodeEnum &#123;\n\n    SUCCESS(200,&quot;success&quot;),\n    USERNAME_ERROR(501,&quot;usernameError&quot;),\n    PASSWORD_ERROR(503,&quot;passwordError&quot;),\n    NOTLOGIN(504,&quot;notLogin&quot;),\n    USERNAME_USED(505,&quot;userNameUsed&quot;)\n    ;\n\n    private Integer code;\n    private String message;\n    private ResultCodeEnum(Integer code, String message) &#123;\n        this.code = code;\n        this.message = message;\n    &#125;\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n    public String getMessage() &#123;\n        return message;\n    &#125;\n&#125;\n3.5.2 MD5加密工具类javapackage com.atguigu.headline.util;\n\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic final class MD5Util &#123;\n    public static String encrypt(String strSrc) &#123;\n        try &#123;\n            char hexChars[] = &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,\n                    &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; &#125;;\n            byte[] bytes = strSrc.getBytes();\n            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);\n            md.update(bytes);\n            bytes = md.digest();\n            int j = bytes.length;\n            char[] chars = new char[j * 2];\n            int k = 0;\n            for (int i = 0; i &lt; bytes.length; i++) &#123;\n                byte b = bytes[i];\n                chars[k++] = hexChars[b &gt;&gt;&gt; 4 &amp; 0xf];\n                chars[k++] = hexChars[b &amp; 0xf];\n            &#125;\n            return new String(chars);\n        &#125; catch (NoSuchAlgorithmException e) &#123;\n            e.printStackTrace();\n            throw new RuntimeException(&quot;MD5加密出错！！+&quot; + e);\n        &#125;\n    &#125;\n&#125;\n3.5.3 JDBCUtil连接池工具类javapackage com.atguigu.headline.util;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\npublic class JDBCUtil &#123;\n    private static ThreadLocal&lt;Connection&gt; threadLocal =new ThreadLocal&lt;&gt;();\n\n    private static DataSource dataSource;\n    // 初始化连接池\n    static&#123;\n        // 可以帮助我们读取.properties配置文件\n        Properties properties =new Properties();\n        InputStream resourceAsStream = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);\n        try &#123;\n            properties.load(resourceAsStream);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n\n        try &#123;\n            dataSource = DruidDataSourceFactory.createDataSource(properties);\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n\n\n    &#125;\n    /*1 向外提供连接池的方法*/\n    public static DataSource getDataSource()&#123;\n        return dataSource;\n    &#125;\n\n    /*2 向外提供连接的方法*/\n    public static Connection getConnection()&#123;\n        Connection connection = threadLocal.get();\n        if (null == connection) &#123;\n            try &#123;\n                connection = dataSource.getConnection();\n            &#125; catch (SQLException e) &#123;\n                throw new RuntimeException(e);\n            &#125;\n            threadLocal.set(connection);\n        &#125;\n\n        return connection;\n    &#125;\n\n\n    /*定义一个归还连接的方法 (解除和ThreadLocal之间的关联关系) */\n    public static void releaseConnection()&#123;\n        Connection connection = threadLocal.get();\n        if (null != connection) &#123;\n            threadLocal.remove();\n            // 把连接设置回自动提交的连接\n            try &#123;\n                connection.setAutoCommit(true);\n                // 自动归还到连接池\n                connection.close();\n            &#125; catch (SQLException e) &#123;\n                throw new RuntimeException(e);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n添加jdbc.properties配置文件\n\npropertiesdriverClassName=com.mysql.cj.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/top_news\nusername=root\npassword=root\ninitialSize=5\nmaxActive=10\nmaxWait=10003.5.4  JwtHelper工具类javapackage com.atguigu.headline.util;\n\nimport com.alibaba.druid.util.StringUtils;\nimport io.jsonwebtoken.*;\n\nimport java.util.Date;\n\npublic class JwtHelper &#123;\n    private static long tokenExpiration = 24*60*60*1000;\n    private static String tokenSignKey = &quot;123456&quot;;\n\n    //生成token字符串\n    public static String createToken(Long userId) &#123;\n        String token = Jwts.builder()\n\n                .setSubject(&quot;YYGH-USER&quot;)\n                .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration))\n                .claim(&quot;userId&quot;, userId)\n                .signWith(SignatureAlgorithm.HS512, tokenSignKey)\n                .compressWith(CompressionCodecs.GZIP)\n                .compact();\n        return token;\n    &#125;\n\n    //从token字符串获取userid\n    public static Long getUserId(String token) &#123;\n        if(StringUtils.isEmpty(token)) return null;\n        Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token);\n        Claims claims = claimsJws.getBody();\n        Integer userId = (Integer)claims.get(&quot;userId&quot;);\n        return userId.longValue();\n    &#125;\n\n\n\n    //判断token是否有效\n    public static boolean isExpiration(String token)&#123;\n        try &#123;\n            boolean isExpire = Jwts.parser()\n                    .setSigningKey(tokenSignKey)\n                    .parseClaimsJws(token)\n                    .getBody()\n                    .getExpiration().before(new Date());\n            //没有过期，有效，返回false\n            return isExpire;\n        &#125;catch(Exception e) &#123;\n            //过期出现异常，返回true\n            return true;\n        &#125;\n    &#125;\n&#125;\n3.5.5 JSON转换的WEBUtil工具类javapackage com.atguigu.headline.util;\n\nimport com.atguigu.headline.common.Result;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\n\npublic class WebUtil &#123;\n    private static ObjectMapper objectMapper;\n    // 初始化objectMapper\n    static&#123;\n        objectMapper=new ObjectMapper();\n        // 设置JSON和Object转换时的时间日期格式\n        objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));\n    &#125;\n    // 从请求中获取JSON串并转换为Object\n    public static &lt;T&gt; T readJson(HttpServletRequest request,Class&lt;T&gt; clazz)&#123;\n        T t =null;\n        BufferedReader reader = null;\n        try &#123;\n            reader = request.getReader();\n            StringBuffer buffer =new StringBuffer();\n            String line =null;\n            while((line = reader.readLine())!= null)&#123;\n                buffer.append(line);\n            &#125;\n\n            t= objectMapper.readValue(buffer.toString(),clazz);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n        return t;\n    &#125;\n    // 将Result对象转换成JSON串并放入响应对象\n    public static void writeJson(HttpServletResponse response, Result result)&#123;\n        response.setContentType(&quot;application/json;charset=UTF-8&quot;);\n        try &#123;\n            String json = objectMapper.writeValueAsString(result);\n            response.getWriter().write(json);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;3.6 准备各层的接口和实现类注意这里要在idea的设置 &#x3D;&gt; 构建、执行、部署 &#x3D;&gt; 注解处理器 &#x3D;&gt; 启用注解处理，就无法对@AllArgsConstructor，@NoArgsConstructor，@Data进行解析。\n3.6.1 准备实体类和VO对象\n\n\n\n\n\n\n\n\nNewsUser\njavapackage com.atguigu.headline.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class NewsUser implements Serializable &#123;\n    private Integer uid;\n    private String username;\n    private String userPwd;\n    private String nickName;\n&#125;\n\n\n\n\n\n\n\n\nNewsType\njavapackage com.atguigu.headline.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class NewsType implements Serializable &#123;\n    private Integer tid;\n    private String tname;\n&#125;\n\n\n\n\n\n\n\n\nNewsHeadline\njavapackage com.atguigu.headline.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\nimport java.util.Date;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class NewsHeadline implements Serializable &#123;\n    private Integer hid;\n    private String title;\n    private String article;\n    private Integer type;\n    private Integer publisher;\n    private Integer pageViews;\n    private Date createTime;\n    private Date updateTime;\n    private Integer isDeleted;\n\n&#125;\n\n\n\n\n\n\n\n\nHeadlineQueryVo\njavapackage com.atguigu.headline.pojo.vo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class HeadlineQueryVo implements Serializable &#123;\n    private String keyWords;\n    private Integer type ;\n    private Integer pageNum;\n    private Integer pageSize;\n&#125;\n\n\n\n\n\n\n\n\n\nHeadlinePageVo\njavapackage com.atguigu.headline.pojo.vo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class HeadlinePageVo implements Serializable &#123;\n    private Integer hid;\n    private String title;\n    private Integer type;\n    private Integer pageViews;\n    private Long pastHours;\n    private Integer publisher;\n&#125;\n\n\n\n\n\n\n\n\nHeadlineDetailVo\njavapackage com.atguigu.headline.pojo.vo;\n\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class HeadlineDetailVo implements Serializable &#123;\n    private Integer hid;\n    private String title;\n    private String article;\n    private Integer type;\n    private String typeName;\n    private Integer pageViews;\n    private Long pastHours;\n    private Integer publisher;\n    private String author;\n&#125;\n3.6.2 DAO层接口和实现类\n\n\n\n\n\n\n\n\n\nBaseDao基础类,封装了公共的查询方法和公共的增删改方法\n\n注意,所有的Dao接口的实现类都要继承BaseDao\n\njavapackage com.atguigu.headline.dao;\n\n\nimport com.atguigu.headline.util.JDBCUtil;\nimport java.lang.reflect.Field;\nimport java.sql.*;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class BaseDao &#123;\n    // 公共的查询方法  返回的是单个对象\n    public &lt;T&gt; T baseQueryObject(Class&lt;T&gt; clazz, String sql, Object ... args) &#123;\n        T t = null;\n        Connection connection = JDBCUtil.getConnection();\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        int rows = 0;\n        try &#123;\n            // 准备语句对象\n            preparedStatement = connection.prepareStatement(sql);\n            // 设置语句上的参数\n            for (int i = 0; i &lt; args.length; i++) &#123;\n                preparedStatement.setObject(i + 1, args[i]);\n            &#125;\n\n            // 执行 查询\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) &#123;\n                t = (T) resultSet.getObject(1);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            if (null != resultSet) &#123;\n                try &#123;\n                    resultSet.close();\n                &#125; catch (SQLException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n            &#125;\n            if (null != preparedStatement) &#123;\n                try &#123;\n                    preparedStatement.close();\n                &#125; catch (SQLException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n\n            &#125;\n            JDBCUtil.releaseConnection();\n        &#125;\n        return t;\n    &#125;\n    // 公共的查询方法  返回的是对象的集合\n\n    public &lt;T&gt; List&lt;T&gt; baseQuery(Class clazz, String sql, Object ... args)&#123;\n        List&lt;T&gt; list =new ArrayList&lt;&gt;();\n        Connection connection = JDBCUtil.getConnection();\n        PreparedStatement preparedStatement=null;\n        ResultSet resultSet =null;\n        int rows = 0;\n        try &#123;\n            // 准备语句对象\n            preparedStatement = connection.prepareStatement(sql);\n            // 设置语句上的参数\n            for (int i = 0; i &lt; args.length; i++) &#123;\n                preparedStatement.setObject(i+1,args[i]);\n            &#125;\n\n            // 执行 查询\n            resultSet = preparedStatement.executeQuery();\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // 将结果集通过反射封装成实体类对象\n            while (resultSet.next()) &#123;\n                // 使用反射实例化对象\n                Object obj =clazz.getDeclaredConstructor().newInstance();\n\n                for (int i = 1; i &lt;= columnCount; i++) &#123;\n                    String columnName = metaData.getColumnLabel(i);\n                    Object value = resultSet.getObject(columnName);\n                    // 处理datetime类型字段和java.util.Data转换问题\n                    if(value.getClass().equals(LocalDateTime.class))&#123;\n                        value= Timestamp.valueOf((LocalDateTime) value);\n                    &#125;\n                    Field field = clazz.getDeclaredField(columnName);\n                    field.setAccessible(true);\n                    field.set(obj,value);\n                &#125;\n\n                list.add((T)obj);\n            &#125;\n\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            if (null !=resultSet) &#123;\n                try &#123;\n                    resultSet.close();\n                &#125; catch (SQLException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n            &#125;\n            if (null != preparedStatement) &#123;\n                try &#123;\n                    preparedStatement.close();\n                &#125; catch (SQLException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n            &#125;\n            JDBCUtil.releaseConnection();\n        &#125;\n        return list;\n    &#125;\n    \n    // 通用的增删改方法\n    public int baseUpdate(String sql,Object ... args) &#123;\n        // 获取连接\n        Connection connection = JDBCUtil.getConnection();\n        PreparedStatement preparedStatement=null;\n        int rows = 0;\n        try &#123;\n            // 准备语句对象\n            preparedStatement = connection.prepareStatement(sql);\n            // 设置语句上的参数\n            for (int i = 0; i &lt; args.length; i++) &#123;\n                preparedStatement.setObject(i+1,args[i]);\n            &#125;\n\n            // 执行 增删改 executeUpdate\n            rows = preparedStatement.executeUpdate();\n            // 释放资源(可选)\n\n\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            if (null != preparedStatement) &#123;\n                try &#123;\n                    preparedStatement.close();\n                &#125; catch (SQLException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n\n            &#125;\n            JDBCUtil.releaseConnection();\n        &#125;\n        // 返回的是影响数据库记录数\n        return rows;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\ndao层的所有接口\njavapackage com.atguigu.headline.dao;\npublic interface NewsHeadLineDao &#123;\n    \n&#125;\n\npackage com.atguigu.headline.dao;\npublic interface NewsTypeDao &#123;\n    \n&#125;\n\n\npackage com.atguigu.headline.dao;\npublic interface NewsUserDao &#123;\n\n&#125;\n\n\n\n\n\n\n\n\n\ndao层所有实现类\njavapackage com.atguigu.headline.dao.impl;\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsHeadLineDao;\npublic class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123;\n    \n&#125;\n\npackage com.atguigu.headline.dao.impl;\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsTypeDao;\npublic class NewsTypeDaoImpl extends BaseDao implements NewsTypeDao&#123;\n    \n&#125;\n\npackage com.atguigu.headline.dao.impl;\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsUserDao;\npublic class NewsUserDaoImpl extends BaseDao implements NewsUserDao&#123;\n    \n&#125;3.6.3 Service层接口和实现类\n\n\n\n\n\n\n\n\n\nservice层所有接口\njavapackage com.atguigu.headline.service;\npublic interface NewsHeadlineService &#123;\n    \n&#125;\n\npackage com.atguigu.headline.service;\npublic interface NewsTypeService &#123;\n    List&lt;NewsType&gt; findAll();\n&#125;\n\npackage com.atguigu.headline.service;\npublic interface NewsUserService &#123;\n    \n&#125;\n\n\n\n\n\n\n\n\nservice层所有实现类\njavapackage com.atguigu.headline.service.impl;\nimport com.atguigu.headline.service.NewsHeadlineService;\npublic class NewsHeadlineServiceImpl  implements NewsHeadlineService &#123;\n&#125;\n\n\npackage com.atguigu.headline.service.impl;\nimport com.atguigu.headline.service.NewsTypeService;\npublic class NewsTypeServiceImpl implements NewsTypeService &#123;\n  \n&#125;\n\npackage com.atguigu.headline.service.impl;\nimport com.atguigu.headline.service.NewsUserService;\npublic class NewsUserServiceImpl implements NewsUserService &#123;\n   \n&#125;\n3.6.4 Controller层接口和实现类\n\n\n\n\n\n\n\n\nBaseController 用于将路径关联到处理方法的基础控制器\n\n所有的Controller都要继承该类\n\njavapackage com.atguigu.headline.controller;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class BaseController extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 响应的MIME类型和乱码问题\n        resp.setContentType(&quot;application/json;charset=UTF-8&quot;);\n\n        String requestURI = req.getRequestURI();\n        String[] split = requestURI.split(&quot;/&quot;);\n        String methodName =split[split.length-1];\n        // 通过反射获取要执行的方法\n        Class clazz = this.getClass();\n        try &#123;\n            Method method=clazz.getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class);\n            // 设置方法可以访问\n            method.setAccessible(true);\n            // 通过反射执行代码\n            method.invoke(this,req,resp);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            throw new RuntimeException(e.getMessage());\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n所有的Controller类\njavapackage com.atguigu.headline.controller;\nimport jakarta.servlet.annotation.WebServlet;\n@WebServlet(&quot;/headline/*&quot;)\npublic class NewsHeadlineController extends BaseController &#123;\n    \n&#125;\n\npackage com.atguigu.headline.controller;\nimport jakarta.servlet.annotation.WebServlet;\n@WebServlet(&quot;/type/*&quot;)\npublic class NewsTypeController &#123;\n    \n&#125;\n\npackage com.atguigu.headline.controller;\nimport jakarta.servlet.annotation.WebServlet;\n@WebServlet(&quot;/user/*&quot;)\npublic class NewsUserController extends BaseController&#123;\n    \n&#125;\n\npackage com.atguigu.headline.controller;\nimport jakarta.servlet.annotation.WebServlet;\n@WebServlet(&quot;/portal/*&quot;)\npublic class PortalController extends BaseController&#123;\n    \n&#125;\n3.7 开发跨域CORS过滤器3.7.1 什么是跨域\n\n\n\n\n\n\n\n\n同源策略（Sameoriginpolicy）是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。**同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号**\n3.7.2 为什么会产生跨域\n\n\n\n\n\n\n\n\n前后端分离模式下,客户端请求前端服务器获取视图资源,然后客户端自行向后端服务器获取数据资源,前端服务器的 协议,IP和端口和后端服务器很可能是不一样的,这样就产生了跨域\n\n3.7.3 如何解决跨域\n\n\n\n\n\n\n\n\n前端项目代理模式处理\n\n\n\n\n\n\n\n\n\n\n后端跨域过滤器方式处理\n\n\nCrosFilter过滤器\n\njavapackage com.atguigu.headline.filters;\n\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebFilter;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\n\n@WebFilter(&quot;/*&quot;)\npublic class CrosFilter implements Filter &#123;\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n        HttpServletRequest request =(HttpServletRequest) servletRequest;\n        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE, HEAD&quot;);\n        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);\n        response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;access-control-allow-origin, authority, content-type, version-info, X-Requested-With&quot;);\n        // 非预检请求,放行即可,预检请求,则到此结束,不需要放行\n        if(!request.getMethod().equalsIgnoreCase(&quot;OPTIONS&quot;))&#123;\n            filterChain.doFilter(servletRequest, servletResponse);\n        &#125;\n    &#125;\n&#125;\n未来我们使用框架,直接用一个@CrossOrigin 就可以解决跨域问题了\n\n\n四 PostMan测试工具4.1 什么是PostMan\nPostman是一个**接口测试工具**,在做接口测试的时候,Postman相当于一个客户端,它可以模拟用户发起的各类HTTP请求,将请求数据发送至服务端,获取对应的响应结果, 从而验证响应中的结果数据是否和预期值相匹配;并确保开发人员能够及时处理接口中的bug,进而保证产品上线之后的稳定性和安全性。 它主要是用来模拟各种HTTP请求的(如:get&#x2F;post&#x2F;delete&#x2F;put..等等),Postman与浏览器的区别在于有的浏览器不能输出Json格式,而Postman更直观接口返回的结果。\n\n4.2 怎么安装PostMan\n官网下载地址: https://www.getpostman.com ,或者使用资料中提供的安装包\n安装过程简单,一路next即可\n第一次启动postman 会要求输入用户名和密码，如果没有的话，关闭，再次启动就可以直接进入了\n\n4.3 怎么使用PostMan\n\n\n\n\n\n\n\n\n启动PostMan后,创建一个collection,在该collection下专门存放和微头条项目相关的测试\n\n\n\n\n\n\n\n\n\n\n创建完毕后,增加新的接口测试\n\n\n\n\n\n\n\n\n\n\n填写要测试的接口相关的路径,参数,请求体内容等信息\n\n\n\n\n\n\n\n\n\n\n测试完毕后,可以选择将该接口的测试进行保存,方便后续随时再次测试\n\n\n五 登录注册功能5.1 登录表单提交\n\n\n\n\n\n\n\n\n\n需求描述\n\n用户在客户端输入用户名密码并向后端提交,后端根据用户名和密码判断登录是否成功,用户有误或者密码有误响应不同的提示信息\n\n\n\n\n\n\n\n\n\n\nuri: \nhttpuser/login\n\n\n\n\n\n\n\n\n请求方式:\nhttpPOST\n\n\n\n\n\n\n\n\n请求参数\njson&#123;\n    &quot;username&quot;:&quot;zhangsan&quot;, //用户名\n    &quot;userPwd&quot;:&quot;123456&quot;     //明文密码\n&#125;\n\n\n\n\n\n\n\n\n响应示例\n\n登录成功\n\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,         // 成功状态码 \n     &quot;message&quot;:&quot;success&quot;   // 成功状态描述\n     &quot;data&quot;:&#123;\n        &quot;token&quot;:&quot;... ...&quot; // 用户id的token\n    &#125;\n&#125;\n用户名有误\n\njson&#123;\n    &quot;code&quot;:&quot;501&quot;,\n     &quot;message&quot;:&quot;用户名有误&quot;\n     &quot;data&quot;:&#123;&#125;\n&#125;\n密码有误\n\njson&#123;\n    &quot;code&quot;:&quot;503&quot;,\n     &quot;message&quot;:&quot;密码有误&quot;\n     &quot;data&quot;:&#123;&#125;\n&#125;\n\n\n\n\n\n\n\n\n后端代码\n\nNewsUserController\n\njavapackage com.atguigu.headline.controller;\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.common.ResultCodeEnum;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.NewsUser;\nimport com.atguigu.headline.service.NewsUserService;\nimport com.atguigu.headline.service.impl.NewsUserServiceImpl;\nimport com.atguigu.headline.util.JwtHelper;\nimport com.atguigu.headline.util.MD5Util;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n@WebServlet(&quot;/user/*&quot;)\npublic class NewsUserController extends BaseController&#123;\n\n    private NewsUserService newsUserService =new NewsUserServiceImpl();\n     /**\n     * 登录验证\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        NewsUser newsUser = WebUtil.readJson(req, NewsUser.class);\n\n        Result result =null;\n        NewsUser loginNewsUser =newsUserService.findByUserName(newsUser.getUsername());\n        // 判断用户名\n        if (null != loginNewsUser) &#123;\n            // 判断密码\n            if(loginNewsUser.getUserPwd().equals(MD5Util.encrypt(newsUser.getUserPwd())))&#123;\n                // 密码正确\n                Map&lt;String,Object&gt; data =new HashMap&lt;&gt;();\n                // 生成token口令\n                String token = JwtHelper.createToken(loginNewsUser.getUid().longValue());\n                // 封装数据map\n                data.put(&quot;token&quot;,token);\n                // 封装结果\n                result=Result.ok(data);\n            &#125;else&#123;\n                // 封装密码错误结果\n                result=Result.build(null, ResultCodeEnum.PASSWORD_ERROR);\n            &#125;\n        &#125;else&#123;\n            // 封装用户名错误结果\n            result=Result.build(null, ResultCodeEnum.USERNAME_ERROR);\n        &#125;\n        // 响应结果\n        WebUtil.writeJson(resp,result);\n    &#125;\n&#125;\nNewsUserService\n\njavapackage com.atguigu.headline.service;\n\nimport com.atguigu.headline.pojo.NewsUser;\n\npublic interface NewsUserService &#123;\n    /**\n     * 根据用户名,获得查询用户的方法\n     * @param username 要查询的用户名\n     * @return 如果找到返回NewsUser对象,找不到返回null\n     */\n    NewsUser findByUserName(String username);\n&#125;\nNewsUserServiceImpl\n\njavapackage com.atguigu.headline.service.impl;\n\nimport com.atguigu.headline.dao.NewsUserDao;\nimport com.atguigu.headline.dao.impl.NewsUserDaoImpl;\nimport com.atguigu.headline.pojo.NewsUser;\nimport com.atguigu.headline.service.NewsTypeService;\nimport com.atguigu.headline.service.NewsUserService;\nimport com.atguigu.headline.util.MD5Util;\n\npublic class NewsUserServiceImpl implements NewsUserService &#123;\n    private NewsUserDao newsUserDao =new NewsUserDaoImpl();\n    @Override\n    public NewsUser findByUserName(String username) &#123;\n        return newsUserDao.findByUserName(username);\n    &#125;\n&#125;\nNewUserDao\n\njavapackage com.atguigu.headline.dao;\nimport com.atguigu.headline.pojo.NewsUser;\n\npublic interface NewsUserDao &#123;\n    /**\n     * 根据用户名查询用户信息\n     * @param username 要查询的用户名\n     * @return 找到返回NewsUser对象,找不到返回null\n     */\n    NewsUser findByUserName(String username);\n&#125;\nNewsUserDaoImpl\n\njavapackage com.atguigu.headline.dao.impl;\n\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsUserDao;\nimport com.atguigu.headline.pojo.NewsUser;\nimport java.util.List;\n\npublic class NewsUserDaoImpl extends BaseDao implements NewsUserDao &#123;\n\n    @Override\n    public NewsUser findByUserName(String username) &#123;\n        // 准备SQL\n        String sql =&quot;select uid,username,user_pwd userPwd ,nick_name nickName from news_user where username = ?&quot;;\n        // 调用BaseDao公共查询方法\n        List&lt;NewsUser&gt; newsUserList = baseQuery(NewsUser.class, sql, username);\n        // 如果找到,返回集合中的第一个数据(其实就一个)\n        if (null != newsUserList &amp;&amp; newsUserList.size()&gt;0)&#123;\n            return  newsUserList.get(0);\n        &#125;\n        return null;\n    &#125;\n&#125;5.2 根据token获取完整用户信息token图解\n\n\n\n\n\n\n\n\n\n\n\n需求描述\n\n客户端发送请求,提交token请求头,后端根据token请求头获取登录用户的详细信息并响应给客户端进行存储\n\n\n\n\n\n\n\n\n\n\nuri\nhttpuser/getUserInfo\n\n\n\n\n\n\n\n\n请求方式\nhttpGET\n\n\n\n\n\n\n\n\n请求头\njsontoken: ... ...\n\n\n\n\n\n\n\n\n响应示例\n\n成功获取\n\njson&#123;\n    &quot;code&quot;: 200,\n    &quot;message&quot;: &quot;success&quot;,\n    &quot;data&quot;: &#123;\n        &quot;loginUser&quot;: &#123;\n            &quot;uid&quot;: 1,\n            &quot;username&quot;: &quot;zhangsan&quot;,\n            &quot;userPwd&quot;: &quot;&quot;,\n            &quot;nickName&quot;: &quot;张三&quot;\n        &#125;\n    &#125;\n&#125;\n获取失败\n\njson&#123;\n    &quot;code&quot;: 504,\n    &quot;message&quot;: &quot;notLogin&quot;,\n    &quot;data&quot;: null\n&#125;\n\n\n\n\n\n\n\n\n后端代码\n\nNewsUserController\n\njavapackage com.atguigu.headline.controller;\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.common.ResultCodeEnum;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.NewsUser;\nimport com.atguigu.headline.service.NewsUserService;\nimport com.atguigu.headline.service.impl.NewsUserServiceImpl;\nimport com.atguigu.headline.util.JwtHelper;\nimport com.atguigu.headline.util.MD5Util;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n@WebServlet(&quot;/user/*&quot;)\npublic class NewsUserController extends BaseController&#123;\n\n    private NewsUserService newsUserService =new NewsUserServiceImpl();\n\n    /**\n     * 接收token,根据token查询完整用户信息\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void getUserInfo(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        String token = req.getHeader(&quot;token&quot;);\n        Result  result =Result.build(null,ResultCodeEnum.NOTLOGIN);\n        if(null!= token)&#123;\n            if (!JwtHelper.isExpiration(token)) &#123;\n                Integer uid = JwtHelper.getUserId(token).intValue();\n                NewsUser newsUser =newsUserService.findByUid(uid);\n                newsUser.setUserPwd(&quot;&quot;);\n                Map&lt;String,Object&gt; data =new HashMap&lt;&gt;();\n                data.put(&quot;loginUser&quot;,newsUser);\n                result=Result.ok(data);\n\n            &#125;\n        &#125;\n        WebUtil.writeJson(resp,result);\n    &#125;\n&#125;\nNewsUserService\n\njavapackage com.atguigu.headline.service;\n\nimport com.atguigu.headline.pojo.NewsUser;\n\npublic interface NewsUserService &#123;\n    /**\n     * 根据用户id查询用户信息\n     * @param uid 要查询的用户id\n     * @return 找到返回NewsUser对象,找不到返回null\n     */\n    NewsUser findByUid(Integer uid);\n&#125;\nNewsUserServiceImpl\n\njavapackage com.atguigu.headline.service.impl;\n\nimport com.atguigu.headline.dao.NewsUserDao;\nimport com.atguigu.headline.dao.impl.NewsUserDaoImpl;\nimport com.atguigu.headline.pojo.NewsUser;\nimport com.atguigu.headline.service.NewsTypeService;\nimport com.atguigu.headline.service.NewsUserService;\nimport com.atguigu.headline.util.MD5Util;\n\npublic class NewsUserServiceImpl implements NewsUserService &#123;\n    private NewsUserDao newsUserDao =new NewsUserDaoImpl();\n\n    @Override\n    public NewsUser findByUid(Integer uid) &#123;\n        return newsUserDao.findByUid(uid);\n    &#125;\n&#125;\nNewUserDao\n\njavapackage com.atguigu.headline.dao;\n\nimport com.atguigu.headline.pojo.NewsUser;\n\n\npublic interface NewsUserDao &#123;\n    /**\n     * 根据用户id连接数据库查询用户信息\n     * @param uid  要查询的用户id\n     * @return 找到返回NewsUser对象,找不到返回null\n     */\n    NewsUser findByUid(Integer uid);\n&#125;\nNewUserDaoImpl\n\njavapackage com.atguigu.headline.dao.impl;\n\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsUserDao;\nimport com.atguigu.headline.pojo.NewsUser;\nimport java.util.List;\n\npublic class NewsUserDaoImpl extends BaseDao implements NewsUserDao &#123;\n    @Override\n    public NewsUser findByUid(Integer uid) &#123;\n        String sql =&quot;select uid,username,user_pwd userPwd ,nick_name nickName from news_user where uid = ?&quot;;\n        List&lt;NewsUser&gt; newsUserList = baseQuery(NewsUser.class, sql, uid);\n        if (null != newsUserList &amp;&amp; newsUserList.size()&gt;0)&#123;\n            return  newsUserList.get(0);\n        &#125;\n        return null;\n    &#125;\n&#125;5.3 注册时用户名占用校验\n\n\n\n\n\n\n\n\n\n需求说明\n\n用户在注册时输入用户名时,立刻将用户名发送给后端,后端根据用户名查询用户名是否可用并做出响应\n\n\n\n\n\n\n\n\n\n\nuri:\nhttpuser/checkUserName\n\n\n\n\n\n\n\n\n请求方式:\nhttpPOST\n\n\n\n\n\n\n\n\n请求参数\njsonusername=zhangsan\n\n\n\n\n\n\n\n\n响应示例\n\n用户名校验通过\n\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,\n     &quot;message&quot;:&quot;success&quot;\n     &quot;data&quot;:&#123;&#125;\n&#125;\n用户名占用\n\njson&#123;\n    &quot;code&quot;:&quot;505&quot;,\n     &quot;message&quot;:&quot;用户名占用&quot;\n     &quot;data&quot;:&#123;&#125;\n&#125;\n\n\n\n\n\n\n\n\n后端代码\n\nNewsUserController\n\njavapackage com.atguigu.headline.controller;\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.common.ResultCodeEnum;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.NewsUser;\nimport com.atguigu.headline.service.NewsUserService;\nimport com.atguigu.headline.service.impl.NewsUserServiceImpl;\nimport com.atguigu.headline.util.JwtHelper;\nimport com.atguigu.headline.util.MD5Util;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n@WebServlet(&quot;/user/*&quot;)\npublic class NewsUserController extends BaseController&#123;\n\n    private NewsUserService newsUserService =new NewsUserServiceImpl();\n    /**\n     * 注册时校验用户名是否被占用\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void checkUserName(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        String username = req.getParameter(&quot;username&quot;);\n        NewsUser newsUser = newsUserService.findByUserName(username);\n        Result result=null;\n        if (null == newsUser)&#123;\n            result=Result.ok(null);\n        &#125;else&#123;\n            result=Result.build(null,ResultCodeEnum.USERNAME_USED);\n        &#125;\n        WebUtil.writeJson(resp,result);\n    &#125;\n&#125;5.4 注册表单提交\n\n\n\n\n\n\n\n\n\n需求说明\n\n客户端将新用户信息发送给服务端,服务端将新用户存入数据库,存入之前做用户名是否被占用校验,校验通过响应成功提示,否则响应失败提示\n\n\n\n\n\n\n\n\n\n\nuri:\nhttpuser/regist\n\n\n\n\n\n\n\n\n请求方式:\nhttpPOST\n\n\n\n\n\n\n\n\n请求参数\njson&#123;\n    &quot;username&quot;:&quot;zhangsan&quot;,\n    &quot;userPwd&quot;:&quot;123456&quot;,\n    &quot;nickName&quot;:&quot;张三&quot;\n&#125;\n\n\n\n\n\n\n\n\n响应示例\n\n注册成功\n\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,\n     &quot;message&quot;:&quot;success&quot;\n     &quot;data&quot;:&#123;&#125;\n&#125;\n用户名占用\n\njson&#123;\n    &quot;code&quot;:&quot;505&quot;,\n     &quot;message&quot;:&quot;用户名占用&quot;\n     &quot;data&quot;:&#123;&#125;\n&#125;\n\n\n\n\n\n\n\n\n后端代码\n\nNewsUserController\n\njavapackage com.atguigu.headline.controller;\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.common.ResultCodeEnum;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.NewsUser;\nimport com.atguigu.headline.service.NewsUserService;\nimport com.atguigu.headline.service.impl.NewsUserServiceImpl;\nimport com.atguigu.headline.util.JwtHelper;\nimport com.atguigu.headline.util.MD5Util;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n@WebServlet(&quot;/user/*&quot;)\npublic class NewsUserController extends BaseController&#123;\n\n    private NewsUserService newsUserService =new NewsUserServiceImpl();\n\n    /**\n     * 注册功能接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        NewsUser newsUser = WebUtil.readJson(req, NewsUser.class);\n        NewsUser usedUser = newsUserService.findByUserName(newsUser.getUsername());\n        Result result=null;\n        if (null == usedUser)&#123;\n            newsUserService.registUser(newsUser);\n            result=Result.ok(null);\n        &#125;else&#123;\n            result=Result.build(null,ResultCodeEnum.USERNAME_USED);\n        &#125;\n        WebUtil.writeJson(resp,result);\n    &#125;\n&#125;\nNewsUserService\n\njavapackage com.atguigu.headline.service;\n\nimport com.atguigu.headline.pojo.NewsUser;\n\npublic interface NewsUserService &#123;\n\n    /**\n     * 注册用户信息,注册成功返回大于0的整数,失败返回0\n     * @param newsUser\n     * @return\n     */\n    int registUser(NewsUser newsUser);\n&#125;\nNewsUserServiceImpl\n\njavapackage com.atguigu.headline.service.impl;\n\nimport com.atguigu.headline.dao.NewsUserDao;\nimport com.atguigu.headline.dao.impl.NewsUserDaoImpl;\nimport com.atguigu.headline.pojo.NewsUser;\nimport com.atguigu.headline.service.NewsTypeService;\nimport com.atguigu.headline.service.NewsUserService;\nimport com.atguigu.headline.util.MD5Util;\n\npublic class NewsUserServiceImpl implements NewsUserService &#123;\n    @Override\n    public int registUser(NewsUser newsUser) &#123;\n        // 密码明文转密文\n        newsUser.setUserPwd(MD5Util.encrypt(newsUser.getUserPwd()));\n        // 存入数据库\n        return newsUserDao.insertNewsUser(newsUser);\n    &#125;\n&#125;\nNewUserDao\n\njavapackage com.atguigu.headline.dao;\n\nimport com.atguigu.headline.pojo.NewsUser;\n\n\npublic interface NewsUserDao &#123;\n    /**\n     * 将用户信息存入数据库\n     * @param newsUser \n     * @return\n     */\n    int insertNewsUser(NewsUser newsUser);\n&#125;\nNewUserDaoImpl\n\njavapackage com.atguigu.headline.dao.impl;\n\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsUserDao;\nimport com.atguigu.headline.pojo.NewsUser;\nimport java.util.List;\n\npublic class NewsUserDaoImpl extends BaseDao implements NewsUserDao &#123;\n    @Override\n    public int insertNewsUser(NewsUser newsUser) &#123;\n        String sql =&quot;insert into news_user values(DEFAULT,?,?,?)&quot;;\n        return baseUpdate(sql,newsUser.getUsername(),newsUser.getUserPwd(),newsUser.getNickName());\n    &#125;\n&#125;\n六 头条首页功能6.1 查询所有头条分类\n\n\n\n\n\n\n\n\n\n需求说明\n\n进入新闻首页,查询所有分类并动态展示新闻类别栏位\n\n\n\n\n\n\n\n\n\n\nuri:\nhttpportal/findAllTypes\n\n\n\n\n\n\n\n\n请求方式\nhttpGET\n\n\n\n\n\n\n\n\n请求参数\njson无\n\n\n\n\n\n\n\n\n响应示例\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,\n     &quot;message&quot;:&quot;OK&quot;\n     &quot;data&quot;:\n            [\n                &#123;\n                    &quot;tid&quot;:&quot;1&quot;,\n                    &quot;tname&quot;:&quot;新闻&quot;\n                &#125;,\n                &#123;\n                    &quot;tid&quot;:&quot;2&quot;,\n                    &quot;tname&quot;:&quot;体育&quot;\n                &#125;,\n                &#123;\n                    &quot;tid&quot;:&quot;3&quot;,\n                    &quot;tname&quot;:&quot;娱乐&quot;\n                &#125;,\n                &#123;\n                    &quot;tid&quot;:&quot;4&quot;,\n                    &quot;tname&quot;:&quot;科技&quot;\n                &#125;,\n                &#123;\n                    &quot;tid&quot;:&quot;5&quot;,\n                    &quot;tname&quot;:&quot;其他&quot;\n                &#125;\n            ]\n    \n&#125;\n\n\n\n\n\n\n\n\n\n后端代码\n\nPortalController\n\njavapackage com.atguigu.headline.controller;\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.pojo.NewsType;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\nimport com.atguigu.headline.service.NewsHeadlineService;\nimport com.atguigu.headline.service.NewsTypeService;\nimport com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;\nimport com.atguigu.headline.service.impl.NewsTypeServiceImpl;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@WebServlet(&quot;/portal/*&quot;)\npublic class PortalController extends BaseController&#123;\n\n    private NewsHeadlineService headlineService=new NewsHeadlineServiceImpl();\n    private NewsTypeService newsTypeService=new NewsTypeServiceImpl();\n    /**\n     * 查询所有新闻类型\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void findAllTypes(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        List&lt;NewsType&gt; newsTypeList =newsTypeService.findAll();\n        WebUtil.writeJson(resp,Result.ok(newsTypeList));\n    &#125;\n&#125;\nNewsTypeService\n\njavapackage com.atguigu.headline.service;\n\nimport com.atguigu.headline.pojo.NewsType;\n\nimport java.util.List;\n\npublic interface NewsTypeService &#123;\n    /**\n     * 查询全部新闻类型\n     * @return\n     */\n    List&lt;NewsType&gt; findAll();\n&#125;\n\nNewsTypeServiceImpl\n\njavapackage com.atguigu.headline.service.impl;\n\nimport com.atguigu.headline.dao.NewsTypeDao;\nimport com.atguigu.headline.dao.impl.NewsTypeDaoImpl;\nimport com.atguigu.headline.pojo.NewsType;\nimport com.atguigu.headline.service.NewsTypeService;\n\nimport java.util.List;\n\npublic class NewsTypeServiceImpl implements NewsTypeService &#123;\n    private NewsTypeDao  newsTypeDao =new NewsTypeDaoImpl();\n    @Override\n    public List&lt;NewsType&gt; findAll() &#123;\n        return newsTypeDao.findAll();\n    &#125;\n&#125;\nNewUserDao\n\njavapackage com.atguigu.headline.dao;\n\nimport com.atguigu.headline.pojo.NewsType;\n\nimport java.util.List;\n\npublic interface NewsTypeDao &#123;\n    /**\n     * 从数据库中查询全部新闻类型\n     * @return\n     */\n    List&lt;NewsType&gt; findAll();\n&#125;\n\nNewsTypeDaoImpl\n\njavapackage com.atguigu.headline.dao.impl;\n\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsTypeDao;\nimport com.atguigu.headline.pojo.NewsType;\n\nimport java.util.List;\n\npublic class NewsTypeDaoImpl extends BaseDao implements NewsTypeDao &#123;\n    @Override\n    public List&lt;NewsType&gt; findAll() &#123;\n        String sql =&quot;select tid,tname from news_type&quot;;\n        return  baseQuery(NewsType.class, sql);\n    &#125;\n&#125;6.2 分页带条件查询所有头条\n\n\n\n\n\n\n\n\n\n需求说明\n\n客户端向服务端发送查询关键字,新闻类别,页码数,页大小\n服务端根据条件搜索分页信息,返回含页码数,页大小,总页数,总记录数,当前页数据等信息,并根据时间降序,浏览量降序排序\n\n\n\n\n\n\n\n\n\n\nuri:\nhttpportal/findNewsPage\n\n\n\n\n\n\n\n\n请求方式:\nhttpPOST\n\n\n\n\n\n\n\n\n请求参数:\njson&#123;\n    &quot;keyWords&quot;:&quot;马斯克&quot;, // 搜索标题关键字\n    &quot;type&quot;:0,           // 新闻类型\n    &quot;pageNum&quot;:1,        // 页码数\n    &quot;pageSize&quot;:&quot;10&quot;     // 页大小\n&#125;\n\n\n\n\n\n\n\n\n响应示例:\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,\n     &quot;message&quot;:&quot;success&quot;\n     &quot;data&quot;:&#123;\n        &quot;pageInfo&quot;:&#123;\n            &quot;pageData&quot;:[                           // 本页的数据\n                &#123;\n                    &quot;hid&quot;:&quot;1&quot;,                     // 新闻id \n                    &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;,   // 新闻标题\n                    &quot;type&quot;:&quot;1&quot;,                    // 新闻所属类别编号\n                    &quot;pageViews&quot;:&quot;40&quot;,              // 新闻浏览量\n                    &quot;pastHours&quot;:&quot;3&quot; ,              // 发布时间已过小时数\n                    &quot;publisher&quot;:&quot;1&quot;                // 发布用户ID\n                &#125;,\n                &#123;\n                    &quot;hid&quot;:&quot;1&quot;,                     // 新闻id \n                    &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;,   // 新闻标题\n                    &quot;type&quot;:&quot;1&quot;,                    // 新闻所属类别编号\n                    &quot;pageViews&quot;:&quot;40&quot;,              // 新闻浏览量\n                    &quot;pastHours&quot;:&quot;3&quot;,              // 发布时间已过小时数\n                    &quot;publisher&quot;:&quot;1&quot;                // 发布用户ID\n                &#125;,\n                &#123;\n                    &quot;hid&quot;:&quot;1&quot;,                     // 新闻id \n                    &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;,   // 新闻标题\n                    &quot;type&quot;:&quot;1&quot;,                    // 新闻所属类别编号\n                    &quot;pageViews&quot;:&quot;40&quot;,              // 新闻浏览量\n                    &quot;pastHours&quot;:&quot;3&quot;,               // 发布时间已过小时数\n                    &quot;publisher&quot;:&quot;1&quot;                // 发布用户ID\n                &#125;\n            ],\n            &quot;pageNum&quot;:1,    //页码数\n            &quot;pageSize&quot;:10,  // 页大小\n            &quot;totalPage&quot;:20, // 总页数\n            &quot;totalSize&quot;:200 // 总记录数\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n 后端代码\n\nPortalController\n\njavapackage com.atguigu.headline.controller;\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.pojo.NewsType;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\nimport com.atguigu.headline.service.NewsHeadlineService;\nimport com.atguigu.headline.service.NewsTypeService;\nimport com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;\nimport com.atguigu.headline.service.impl.NewsTypeServiceImpl;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@WebServlet(&quot;/portal/*&quot;)\npublic class PortalController extends BaseController&#123;\n\n    private NewsHeadlineService headlineService=new NewsHeadlineServiceImpl();\n    private NewsTypeService newsTypeService=new NewsTypeServiceImpl();\n    /**\n     * 分页带条件查询新闻\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void findNewsPage(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        HeadlineQueryVo headLineQueryVo = WebUtil.readJson(req, HeadlineQueryVo.class);\n        // 查询分页五项数据\n        Map&lt;String,Object&gt; pageInfo =headlineService.findPage(headLineQueryVo);\n        // 将分页五项数据放入PageInfoMap\n        Map&lt;String,Object&gt; pageInfoMap=new HashMap&lt;&gt;();\n        pageInfoMap.put(&quot;pageInfo&quot;,pageInfo);\n        // 响应JSON\n        WebUtil.writeJson(resp, Result.ok(pageInfoMap));\n    &#125;\n&#125;\nNewsHeadlineService\n\njavapackage com.atguigu.headline.service;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic interface NewsHeadlineService &#123;\n    /**\n     * 分页查询头条新闻方法\n     * @param headLineQueryVo\n     * @return\n     */\n    Map&lt;String, Object&gt; findPage(HeadlineQueryVo headLineQueryVo);\n&#125;\nNewsHeadlineServiceImpl\n\njavapackage com.atguigu.headline.service.impl;\n\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\nimport com.atguigu.headline.service.NewsHeadlineService;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NewsHeadlineServiceImpl  implements NewsHeadlineService &#123;\n    private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl();\n\n    @Override\n    public Map&lt;String, Object&gt; findPage(HeadlineQueryVo headLineQueryVo) &#123;\n        // 准备一个map,用于装分页的五项数据\n        Map&lt;String,Object&gt; pageInfo =new HashMap&lt;&gt;();\n        // 分页查询本页数据\n        List&lt;HeadlinePageVo&gt;  pageData =newsHeadLineDao.findPageList(headLineQueryVo);\n        // 分页查询满足记录的总数据量\n        int totalSize = newsHeadLineDao.findPageCount(headLineQueryVo);\n        // 页大小\n        int pageSize =headLineQueryVo.getPageSize();\n        // 总页码数\n        int totalPage=totalSize%pageSize == 0 ?  totalSize/pageSize  : totalSize/pageSize+1;\n        // 当前页码数\n        int pageNum= headLineQueryVo.getPageNum();\n        pageInfo.put(&quot;pageData&quot;,pageData);\n        pageInfo.put(&quot;pageNum&quot;,pageNum);\n        pageInfo.put(&quot;pageSize&quot;,pageSize);\n        pageInfo.put(&quot;totalPage&quot;,totalPage);\n        pageInfo.put(&quot;totalSize&quot;,totalSize);\n\n\n        return pageInfo;\n    &#125;\n&#125;\nNewsHeadLineDao\n\njavapackage com.atguigu.headline.dao;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\n\npublic interface NewsHeadLineDao &#123;\n    /**\n     * 根据查询条件,查询满足条件的记录数\n     * @param headLineQueryVo\n     * @return\n     */\n    int findPageCount(HeadlineQueryVo headLineQueryVo);\n\n    /**\n     * 根据查询条件,查询当前页数据\n     * @param headLineQueryVo\n     * @return\n     */\n    List&lt;HeadlinePageVo&gt; findPageList(HeadlineQueryVo headLineQueryVo);\n&#125;\nNewsHeadlineDaoImpl\n\njavapackage com.headline.dao.impl;\nimport com.headline.dao.BaseDao;\nimport com.headline.dao.NewsHeadLineDao;\nimport com.headline.pojo.vo.HeadlineDetailVo;\nimport com.headline.pojo.vo.HeadlinePageVo;\nimport com.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123;\n    /*\n    HeadlineDetailVo类\n    private Integer hid;\n    private String title;\n    private Integer type;\n    private Integer pageViews;\n    private Long pastHours;\n    private Integer publisher;\n\n    HeadlineQueryVo类\n    private String keyWords;\n    private Integer type ;\n    private Integer pageNum;\n    private Integer pageSize;\n     */\n    @Override\n    public List&lt;HeadlinePageVo&gt; findPageList(HeadlineQueryVo headlineQueryVo) &#123;\n        //设置集合用来填充sql语句中的?\n        List params = new ArrayList();\n        String sql = &quot;&quot;&quot;\n                select\n                    hid,\n                    title,\n                    type,\n                    page_views pageViews,\n                    TIMESTAMPDIFF(HOUR,create_time,now()) pastHours,\n                    publisher\n                from \n                    news_headline\n                where\n                    is_deleted = 0\n                &quot;&quot;&quot;;\n        if(headlineQueryVo.getType() != 0)&#123; //type不为空说明有类型，应该添加到where后\n            sql = sql.concat(&quot; and type = ? &quot;);\n            params.add(headlineQueryVo.getType());\n        &#125;\n        //设置模糊查询,关键词是传入参数中的keywords\n        if(headlineQueryVo.getKeyWords() != null &amp;&amp; !headlineQueryVo.getKeyWords().equals(&quot;&quot;))&#123;\n            sql = sql.concat(&quot; and title like ? &quot;);\n            params.add(&quot;%&quot;+ headlineQueryVo.getKeyWords() + &quot;%&quot;);\n        &#125;\n        //对信息进行排序，先按着时间，再按着浏览量排序\n        sql = sql.concat(&quot; order by pastHours ASC, page_views DESC &quot;);\n        //对信息进行分页处理\n        sql = sql.concat(&quot; limit ? , ? &quot;);\n        params.add((headlineQueryVo.getPageNum()-1)*headlineQueryVo.getPageSize());\n        params.add(headlineQueryVo.getPageSize());\n        //需要将params转换成数组\n        return baseQuery(HeadlineDetailVo.class, sql, params.toArray());\n    &#125;\n\n    @Override\n    public int findPageCount(HeadlineQueryVo headlineQueryVo) &#123;\n        //设置集合用来填充sql语句中的?\n        List params = new ArrayList();\n        String sql = &quot;&quot;&quot;\n                select\n                    count(1)\n                from \n                    news_headline\n                where\n                    is_deleted = 0\n                &quot;&quot;&quot;;\n        if(headlineQueryVo.getType() != 0)&#123; //type不为空说明有类型，应该添加到where后\n            sql = sql.concat(&quot; and type = ? &quot;);\n            params.add(headlineQueryVo.getType());\n        &#125;\n        //设置模糊查询,关键词是传入参数中的key\n        if(headlineQueryVo.getKeyWords() != null &amp;&amp; !headlineQueryVo.getKeyWords().equals(&quot;&quot;))&#123;\n            sql = sql.concat(&quot; and title like ? &quot;);\n            params.add(&quot;%&quot;+ headlineQueryVo.getKeyWords() + &quot;%&quot;);\n        &#125;\n\n        Long count = baseQueryObject(Long.class, sql, params.toArray());\n        return count.intValue();\n    &#125;\n&#125;6.3 查看头条详情\n\n\n\n\n\n\n\n\n\n\n需求说明\n\n用户点击”查看全文”时,向服务端发送新闻id\n后端根据新闻id查询完整新闻文章信息并返回\n后端要同时让新闻的浏览量+1\n\n\n\n\n\n\n\n\n\n\nuri\nhttpportal/showHeadlineDetail\n\n\n\n\n\n\n\n\n请求方式\nhttpPOST\n\n\n\n\n\n\n\n\n请求参数\njsonhid=1\n\n\n\n\n\n\n\n\n响应示例\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,\n    &quot;message&quot;:&quot;success&quot;,\n    &quot;data&quot;:&#123;\n        &quot;headline&quot;:&#123;\n            &quot;hid&quot;:&quot;1&quot;,                     // 新闻id \n            &quot;title&quot;:&quot;马斯克宣布 ... ...&quot;,   // 新闻标题\n            &quot;article&quot;:&quot;... ...&quot;            // 新闻正文\n            &quot;type&quot;:&quot;1&quot;,                    // 新闻所属类别编号\n            &quot;typeName&quot;:&quot;科技&quot;,             // 新闻所属类别\n            &quot;pageViews&quot;:&quot;40&quot;,              // 新闻浏览量\n            &quot;pastHours&quot;:&quot;3&quot; ,              // 发布时间已过小时数\n            &quot;publisher&quot;:&quot;1&quot; ,               // 发布用户ID\n            &quot;author&quot;:&quot;张三&quot;                 // 新闻作者\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n后端代码\n\nPortalController\n\njavapackage com.atguigu.headline.controller;\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.pojo.NewsType;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\nimport com.atguigu.headline.service.NewsHeadlineService;\nimport com.atguigu.headline.service.NewsTypeService;\nimport com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;\nimport com.atguigu.headline.service.impl.NewsTypeServiceImpl;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@WebServlet(&quot;/portal/*&quot;)\npublic class PortalController extends BaseController&#123;\n\n    private NewsHeadlineService headlineService=new NewsHeadlineServiceImpl();\n    private NewsTypeService newsTypeService=new NewsTypeServiceImpl();\n    /**\n     * 查询单个新闻详情\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void showHeadlineDetail(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 获取要查询的详情新闻id\n        Integer hid =Integer.parseInt(req.getParameter(&quot;hid&quot;));\n        \n        // 查询新闻详情vo\n        HeadlineDetailVo headlineDetailVo =headlineService.findHeadlineDetail(hid);\n        // 封装data内容\n        Map&lt;String ,Object&gt; data =new HashMap&lt;&gt;();\n        data.put(&quot;headline&quot;,headlineDetailVo);\n        // 响应JSON\n        WebUtil.writeJson(resp,Result.ok(data));\n    &#125;\n&#125;\nNewsHeadlineService\n\njavapackage com.atguigu.headline.service;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic interface NewsHeadlineService &#123;\n    /**\n     * 根据头条id,显示头条详情\n     * @param hid\n     * @return\n     */\n    HeadlineDetailVo findHeadlineDetail(Integer hid);\n&#125;\nNewsHeadlineServiceImpl\n\njavapackage com.atguigu.headline.service.impl;\n\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\nimport com.atguigu.headline.service.NewsHeadlineService;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NewsHeadlineServiceImpl  implements NewsHeadlineService &#123;\n    private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl();\n    @Override\n    public HeadlineDetailVo findHeadlineDetail(Integer hid) &#123;\n        // 修改新闻信息浏览量+1\n        newsHeadLineDao.increasePageViews(hid);\n        // 查询新闻详情\n        return newsHeadLineDao.findHeadlineDetail(hid);\n    &#125;\n&#125;\nNewsHeadLineDao\n\njavapackage com.atguigu.headline.dao;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\n\npublic interface NewsHeadLineDao &#123;\n    /**\n     * 多表查询新闻详情\n     * @param hid\n     * @return\n     */\n    HeadlineDetailVo findHeadlineDetail(Integer hid);\n    \n    int increasePageViews(Integer hid);\n&#125;\nNewsHeadlineDaoImpl\n\njavapackage com.atguigu.headline.dao.impl;\n\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123;\n    @Override\n    public HeadlineDetailVo findHeadlineDetail(Integer hid) &#123;\n        String sql =&quot;select hid,title,article,type, tname typeName ,page_views pageViews,TIMESTAMPDIFF(HOUR,create_time,NOW()) pastHours,publisher,nick_name author from news_headline h left join  news_type t on h.type = t.tid left join news_user u  on h.publisher = u.uid where hid = ?&quot;;\n        List&lt;HeadlineDetailVo&gt; headlineDetailVoList = baseQuery(HeadlineDetailVo.class, sql, hid);\n        if(null != headlineDetailVoList &amp;&amp; headlineDetailVoList.size()&gt;0)\n            return headlineDetailVoList.get(0);\n        return null;\n    &#125;\n    \n    @Override\n    public int increasePageViews(Integer hid) &#123;\n        String sql =&quot;update news_headline set page_views = page_views +1 where hid =?&quot;;\n        return baseUpdate(sql,hid);\n    &#125;\n&#125;\n七 头条发布修改和删除7.1 登录校验\n\n\n\n\n\n\n\n\n需求说明\n\n客户端在进入发布页前、发布新闻前、进入修改页前、修改前、删除新闻前先向服务端发送请求携带token请求头\n后端接收token请求头后,校验用户登录是否过期并做响应\n前端根据响应信息提示用户进入登录页还是进入正常业务页面\n\n\n\n\n\n\n\n\n\n\nuri\nhttpuser/checkLogin\n\n\n\n\n\n\n\n\n请求方式\nhttpGET\n\n\n\n\n\n\n\n\n请求参数\njson无\n\n\n\n\n\n\n\n\n请求头\njsontoken: ... ...\n\n\n\n\n\n\n\n\n响应示例\n\n登录未过期\n\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,\n    &quot;message&quot;:&quot;success&quot;,\n    &quot;data&quot;:&#123;&#125;\n&#125;\n登录已过期\n\njson&#123;\n    &quot;code&quot;:&quot;504&quot;,\n    &quot;message&quot;:&quot;loginExpired&quot;,\n    &quot;data&quot;:&#123;&#125;\n&#125;\n\n\n\n\n\n\n\n\n后端代码\n\nNewsUserController\n\njavapackage com.atguigu.headline.controller;\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.common.ResultCodeEnum;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.NewsUser;\nimport com.atguigu.headline.service.NewsUserService;\nimport com.atguigu.headline.service.impl.NewsUserServiceImpl;\nimport com.atguigu.headline.util.JwtHelper;\nimport com.atguigu.headline.util.MD5Util;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n@WebServlet(&quot;/user/*&quot;)\npublic class NewsUserController extends BaseController&#123;\n\n    private NewsUserService newsUserService =new NewsUserServiceImpl();\n    /**\n     * 通过token检验用户登录是否过期\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void checkLogin(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        String token = req.getHeader(&quot;token&quot;);\n        Result  result =Result.build(null,ResultCodeEnum.NOTLOGIN);\n        if(null!= token)&#123;\n            if (!JwtHelper.isExpiration(token)) &#123;\n                result=Result.ok(null);\n            &#125;\n        &#125;\n        WebUtil.writeJson(resp,result);\n    &#125;\n&#125;\n登录校验过滤器\n\njavapackage com.atguigu.headline.filters;\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.common.ResultCodeEnum;\nimport com.atguigu.headline.util.JwtHelper;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.*;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\n\npublic class LoginFilter implements Filter &#123;\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        HttpServletRequest request =(HttpServletRequest)  servletRequest;\n        String token = request.getHeader(&quot;token&quot;);\n        boolean flag =false;\n        // token不为空并且没过期\n        if (null  != token )&#123;\n            boolean expiration = JwtHelper.isExpiration(token);\n            if (!expiration )&#123;\n               flag=true;\n            &#125;\n        &#125;\n        if (flag)&#123;\n            filterChain.doFilter(servletRequest,servletResponse);\n        &#125;else&#123;\n            WebUtil.writeJson((HttpServletResponse) servletResponse, Result.build(null, ResultCodeEnum.NOTLOGIN));\n        &#125;\n    &#125;\n&#125;\nweb.xml中配置登录校验过滤器\n\nxml    &lt;!--登录校验过滤器--&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;loginFilter&lt;/filter-name&gt;\n        &lt;filter-class&gt;com.atguigu.headline.filters.LoginFilter&lt;/filter-class&gt;\n    &lt;/filter&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;loginFilter&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/headline/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;7.2 提交发布头条\n\n\n\n\n\n\n\n\n\n需求说明\n\n用户在客户端输入发布的新闻信息完毕后\n发布前先请求后端的登录校验接口验证登录\n登录通过则提交新闻信息\n后端将新闻信息存入数据库\n\n\n\n\n\n\n\n\n\n\nuri\nhttpheadline/publish\n\n\n\n\n\n\n\n\n请求方式\nhttpPOST\n\n\n\n\n\n\n\n\n请求头\njsontoken: ... ...\n\n\n\n\n\n\n\n\n请求参数\njson&#123;\n    &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;,   // 文章标题\n    &quot;article&quot;:&quot;... ...&quot;,          // 文章内容\n    &quot;type&quot;:&quot;1&quot;                    // 文章类别\n&#125;\n\n\n\n\n\n\n\n\n响应示例\n\n发布成功\n\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,\n    &quot;message&quot;:&quot;success&quot;,\n    &quot;data&quot;:&#123;&#125;\n&#125;\n失去登录状态发布失败\n\njson&#123;\n    &quot;code&quot;:&quot;504&quot;,\n    &quot;message&quot;:&quot;loginExpired&quot;,\n    &quot;data&quot;:&#123;&#125;\n&#125;\n\n\n\n\n\n\n\n\n后端代码\n\nNewsHeadlineController\n\njavapackage com.atguigu.headline.controller;\n\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.service.NewsHeadlineService;\nimport com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;\nimport com.atguigu.headline.util.JwtHelper;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@WebServlet(&quot;/headline/*&quot;)\npublic class NewsHeadlineController extends BaseController &#123;\n\n    private NewsHeadlineService newsHeadlineService =new NewsHeadlineServiceImpl();\n    /**\n     * 发布新闻\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void publish(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 读取新闻信息\n        NewsHeadline newsHeadline = WebUtil.readJson(req, NewsHeadline.class);\n        // 通过token获取发布者ID\n        String token = req.getHeader(&quot;token&quot;);\n        Long userId = JwtHelper.getUserId(token);\n        newsHeadline.setPublisher(userId.intValue());\n        // 将新闻存入数据库\n        newsHeadlineService.addNewsHeadline(newsHeadline);\n        WebUtil.writeJson(resp,Result.ok(null));\n    &#125;\n&#125;\nNewsHeadlineService\n\njavapackage com.atguigu.headline.service;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic interface NewsHeadlineService &#123;\n    /**\n     * 新增头条\n     * @param newsHeadline\n     * @return\n     */\n    int addNewsHeadline(NewsHeadline newsHeadline);\n&#125;\nNewsHeadlineServiceImpl\n\njavapackage com.atguigu.headline.service.impl;\n\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\nimport com.atguigu.headline.service.NewsHeadlineService;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NewsHeadlineServiceImpl  implements NewsHeadlineService &#123;\n    private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl();\n    public int addNewsHeadline(NewsHeadline newsHeadline) &#123;\n        return newsHeadLineDao.addNewsHeadline(newsHeadline);\n    &#125;\n&#125;\nNewsHeadLineDao\n\njavapackage com.atguigu.headline.dao;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\n\npublic interface NewsHeadLineDao &#123;\n    /**\n     * 头条存入数据库\n     * @param newsHeadline\n     * @return\n     */\n    int addNewsHeadline(NewsHeadline newsHeadline);\n&#125;\nNewsHeadlineDaoImpl\n\njavapackage com.atguigu.headline.dao.impl;\n\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123;\n    @Override\n    public int addNewsHeadline(NewsHeadline newsHeadline) &#123;\n        String sql = &quot;insert into news_headline values(DEFAULT,?,?,?,?,0,NOW(),NOW(),0)&quot;;\n\n        return baseUpdate(\n                sql,\n                newsHeadline.getTitle(),\n                newsHeadline.getArticle(),\n                newsHeadline.getType(),\n                newsHeadline.getPublisher()\n        );\n    &#125;\n&#125;7.3 修改头条回显\n\n\n\n\n\n\n\n\n\n需求说明\n\n前端先调用登录校验接口,校验登录是否过期\n登录校验通过后 ,则根据新闻id查询新闻的完整信息并响应给前端\n\n\n\n\n\n\n\n\n\n\nuri\nhttpheadline/findHeadlineByHid\n\n\n\n\n\n\n\n\n请求方式\nhttpPOST\n\n\n\n\n\n\n\n\n请求参数\njsonhid=1\n\n\n\n\n\n\n\n\n响应示例\n\n查询成功\n\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,\n    &quot;message&quot;:&quot;success&quot;,\n    &quot;data&quot;:&#123;\n        &quot;headline&quot;:&#123;\n            &quot;hid&quot;:&quot;1&quot;,\n            &quot;title&quot;:&quot;马斯克宣布&quot;,\n            &quot;article&quot;:&quot;... ... &quot;,\n            &quot;type&quot;:&quot;2&quot;\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n后端代码\n\nNewsHeadlineController\n\njavapackage com.atguigu.headline.controller;\n\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.service.NewsHeadlineService;\nimport com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;\nimport com.atguigu.headline.util.JwtHelper;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@WebServlet(&quot;/headline/*&quot;)\npublic class NewsHeadlineController extends BaseController &#123;\n    private NewsHeadlineService newsHeadlineService =new NewsHeadlineServiceImpl();\n    /**\n     * 修改新闻回显\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void findHeadlineByHid(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        Integer hid = Integer.parseInt(req.getParameter(&quot;hid&quot;));\n        NewsHeadline newsHeadline =newsHeadlineService.findHeadlineByHid(hid);\n        Map&lt;String ,Object&gt; data =new HashMap&lt;&gt;();\n        data.put(&quot;headline&quot;,newsHeadline);\n        WebUtil.writeJson(resp,Result.ok(data));\n\n    &#125;\n&#125;\nNewsHeadlineService\n\njavapackage com.atguigu.headline.service;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic interface NewsHeadlineService &#123;\n    /**\n     * 根据新闻id查询单个新闻\n     * @param hid\n     * @return\n     */\n    NewsHeadline findHeadlineByHid(Integer hid);\n&#125;\nNewsHeadlineServiceImpl\n\njavapackage com.atguigu.headline.service.impl;\n\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\nimport com.atguigu.headline.service.NewsHeadlineService;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NewsHeadlineServiceImpl  implements NewsHeadlineService &#123;\n    private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl();\n    @Override\n    public NewsHeadline findHeadlineByHid(Integer hid) &#123;\n        return newsHeadLineDao.findHeadlineByHid(hid);\n    &#125;\n&#125;\nNewsHeadLineDao\n\njavapackage com.atguigu.headline.dao;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\n\npublic interface NewsHeadLineDao &#123;\n    NewsHeadline findHeadlineByHid(Integer hid);\n&#125;\nNewUserDaoImpl\n\njavapackage com.atguigu.headline.dao.impl;\n\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123;\n    \n    @Override\n    public NewsHeadline findHeadlineByHid(Integer hid) &#123;\n        String sql =&quot;select hid,title,article,type,publisher,page_views pageViews from news_headline where hid =?&quot;;\n        List&lt;NewsHeadline&gt; newsHeadlineList = baseQuery(NewsHeadline.class, sql, hid);\n        if(null != newsHeadlineList &amp;&amp; newsHeadlineList.size()&gt;0)\n            return newsHeadlineList.get(0);\n        return null;\n    &#125;\n&#125;7.4 保存修改\n\n\n\n\n\n\n\n\n需求描述\n\n客户端将新闻信息修改后,提交前先请求登录校验接口校验登录状态\n登录校验通过则提交修改后的新闻信息,后端接收并更新进入数据库\n\n\n\n\n\n\n\n\n\n\nuri\nhttpheadline/update\n\n\n\n\n\n\n\n\n请求方式 \nhttpPOST\n\n\n\n\n\n\n\n\n请求参数\njson&#123;\n    &quot;hid&quot;:&quot;1&quot;,\n    &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;,\n    &quot;article&quot;:&quot;... ...&quot;,\n    &quot;type&quot;:&quot;2&quot;\n&#125;\n\n\n\n\n\n\n\n\n响应示例\n\n修改成功\n\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,\n    &quot;message&quot;:&quot;success&quot;,\n    &quot;data&quot;:&#123;&#125;\n&#125;\n修改失败\n\njson&#123;\n    &quot;code&quot;:&quot;504&quot;,\n    &quot;message&quot;:&quot;loginExpired&quot;,\n    &quot;data&quot;:&#123;&#125;\n&#125;\n\n\n\n\n\n\n\n\n后端代码\n\nNewsHeadlineController\n\njavapackage com.atguigu.headline.controller;\n\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.service.NewsHeadlineService;\nimport com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;\nimport com.atguigu.headline.util.JwtHelper;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@WebServlet(&quot;/headline/*&quot;)\npublic class NewsHeadlineController extends BaseController &#123;\n    private NewsHeadlineService newsHeadlineService =new NewsHeadlineServiceImpl();\n    /**\n     * 更新新闻信息\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void update(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        NewsHeadline newsHeadline = WebUtil.readJson(req, NewsHeadline.class);\n        newsHeadlineService.updateNewsHeadline(newsHeadline);\n        WebUtil.writeJson(resp,Result.ok(null));\n    &#125;\n&#125;\nNewsHeadlineService\n\njavapackage com.atguigu.headline.service;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic interface NewsHeadlineService &#123;\n    int updateNewsHeadline(NewsHeadline newsHeadline);\n&#125;\nNewsHeadlineServiceImpl\n\njavapackage com.atguigu.headline.service.impl;\n\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\nimport com.atguigu.headline.service.NewsHeadlineService;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NewsHeadlineServiceImpl  implements NewsHeadlineService &#123;\n    private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl();\n    @Override\n    public int updateNewsHeadline(NewsHeadline newsHeadline) &#123;\n        return newsHeadLineDao.updateNewsHeadline(newsHeadline);\n    &#125;\n&#125;\nNewsHeadLineDao\n\njavapackage com.atguigu.headline.dao;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\n\npublic interface NewsHeadLineDao &#123;\n    int updateNewsHeadline(NewsHeadline newsHeadline);\n&#125;\nNewUserDaoImpl\n\njavapackage com.atguigu.headline.dao.impl;\n\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123;\n    @Override\n    public int updateNewsHeadline(NewsHeadline newsHeadline) &#123;\n        String sql =&quot;update news_headline set title = ?, article= ? , type =? , update_time = NOW() where hid = ? &quot;;\n        return baseUpdate(\n                sql,\n                newsHeadline.getTitle(),\n                newsHeadline.getArticle(),\n                newsHeadline.getType(),\n                newsHeadline.getHid()\n        );\n    &#125;\n&#125;7.5 删除头条\n\n\n\n\n\n\n\n\n\n需求说明\n\n将要删除的新闻id发送给服务端\n服务端校验登录是否过期,未过期则直接删除,过期则响应登录过期信息\n\n\n\n\n\n\n\n\n\n\nuri\nhttpheadline/removeByHid\n\n\n\n\n\n\n\n\n请求方式\nhttpPOST\n\n\n\n\n\n\n\n\n请求参数\njsonhid=1\n\n\n\n\n\n\n\n\n响应示例\n\n删除成功\n\njson&#123;\n    &quot;code&quot;:&quot;200&quot;,\n    &quot;message&quot;:&quot;success&quot;,\n    &quot;data&quot;:&#123;&#125;\n&#125;\n删除失败\n\njson&#123;\n    &quot;code&quot;:&quot;504&quot;,\n    &quot;message&quot;:&quot;loginExpired&quot;,\n    &quot;data&quot;:&#123;&#125;\n    \n&#125;\n\n\n\n\n\n\n\n\n后端代码\n\nNewsHeadlineController\n\njavapackage com.atguigu.headline.controller;\n\n\nimport com.atguigu.headline.common.Result;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.service.NewsHeadlineService;\nimport com.atguigu.headline.service.impl.NewsHeadlineServiceImpl;\nimport com.atguigu.headline.util.JwtHelper;\nimport com.atguigu.headline.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@WebServlet(&quot;/headline/*&quot;)\npublic class NewsHeadlineController extends BaseController &#123;\n    private NewsHeadlineService newsHeadlineService =new NewsHeadlineServiceImpl();\n    /**\n     * 删除新闻\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void removeByHid(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        Integer hid = Integer.parseInt(req.getParameter(&quot;hid&quot;));\n        newsHeadlineService.removeByHid(hid);\n        WebUtil.writeJson(resp,Result.ok(null));\n    &#125;\n&#125;\nNewsHeadlineService\n\njavapackage com.atguigu.headline.service;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic interface NewsHeadlineService &#123;\n    int removeByHid(Integer hid);\n&#125;\nNewsHeadlineServiceImpl\n\njavapackage com.atguigu.headline.service.impl;\n\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.dao.impl.NewsHeadlineDaoImpl;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\nimport com.atguigu.headline.service.NewsHeadlineService;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NewsHeadlineServiceImpl  implements NewsHeadlineService &#123;\n    private NewsHeadLineDao newsHeadLineDao =new NewsHeadlineDaoImpl();\n    @Override\n    public int removeByHid(Integer hid) &#123;\n        return newsHeadLineDao.removeByHid(hid);\n    &#125;\n&#125;\nNewsHeadLineDao\n\njavapackage com.atguigu.headline.dao;\n\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.List;\n\npublic interface NewsHeadLineDao &#123;\n    int removeByHid(Integer hid);\n&#125;\nNewsHeadlineDaoImpl\n\njavapackage com.atguigu.headline.dao.impl;\n\nimport com.atguigu.headline.dao.BaseDao;\nimport com.atguigu.headline.dao.NewsHeadLineDao;\nimport com.atguigu.headline.pojo.NewsHeadline;\nimport com.atguigu.headline.pojo.vo.HeadlineDetailVo;\nimport com.atguigu.headline.pojo.vo.HeadlinePageVo;\nimport com.atguigu.headline.pojo.vo.HeadlineQueryVo;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class NewsHeadlineDaoImpl extends BaseDao implements NewsHeadLineDao&#123;\n    @Override\n    public int removeByHid(Integer hid) &#123;\n        String sql =&quot;update news_headline set is_deleted =1 ,  update_time =NOW() where hid = ? &quot;;\n        return baseUpdate(sql,hid);\n    &#125;","slug":"Javaweb_微头条项目开发","date":"2024-03-19T08:32:00.000Z","categories_index":"Javaweb","tags_index":"Javaweb","author_index":"白"},{"id":"afb07748d86065b72d707abf6c00312f","title":"案例开发-日程管理","content":"案例开发-日程管理第一期简要概述\n\n\n\n\n\n\n\n\n\n运用html，CSS，JavaScript来构建页面。\n\nhtml：构建页面，设置表格，设置标题…..\n\nCSS：通过style美化页面，对表格进行美化，修改字体颜色\n\nJavaScript：对规则做出响应，校验账号格式是否正确，密码格式是否正确，当登陆时，表单是否提交\n\n\n1.1 登录页及校验效果演示\n\n代码实现\n\n\n\n\n\n\n\n\n\n\nstyle：设置 字体(颜色，居中，样式)，表格(边界，颜色) 。\nscript：checkUsername()：检验用户名格式是否合法。checkUserPwd()：检验密码格式是否合法的函数。checkForm()：表单在提交时,校验用户名和密码格式,格式OK才会提交。\nhtml：基本页面设计\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n\n        .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 500px;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:60px;\n            background-color: antiquewhite;\n\n        &#125;\n        #usernameMsg , #userPwdMsg &#123;\n            color: rgb(230, 87, 51);\n        &#125;\n\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n    &lt;/style&gt;\n    &lt;script&gt;\n        // 检验用户名格式是否合法的函数\n        function checkUsername()&#123;\n            // 定义正则表示字符串的规则\n            var  usernameReg= /^[a-zA-Z0-9]&#123;5,10&#125;$/\n            // 获得用户在页面上输入的信息\n            var usernameInput =document.getElementById(&quot;usernameInput&quot;)\n            var username = usernameInput.value\n            // 获得格式提示的框\n            var usernameMsg =document.getElementById(&quot;usernameMsg&quot;)\n            // 格式有误时,返回false,在页面上提示\n            if(!usernameReg.test(username))&#123; \n                usernameMsg.innerText=&quot;用户名格式有误&quot;\n                return false\n            &#125;\n            // 格式OK,返回true 在页面上提示OK\n            usernameMsg.innerText=&quot;OK&quot;\n            return true\n\n        &#125;\n\n        // 检验密码格式是否合法的函数\n        function checkUserPwd()&#123;\n            // 定义正则表示字符串的规则\n            var  userPwdReg= /^[0-9]&#123;6&#125;$/\n            // 获得用户在页面上输入的信息\n            var userPwdInput =document.getElementById(&quot;userPwdInput&quot;)\n            var userPwd = userPwdInput.value\n            // 获得格式提示的框\n            var userPwdMsg =document.getElementById(&quot;userPwdMsg&quot;)\n            // 格式有误时,返回false,在页面上提示\n            if(!userPwdReg.test(userPwd))&#123; \n                userPwdMsg.innerText=&quot;密码必须是6位数字&quot;\n                return false\n            &#125;\n            // 格式OK,返回true 在页面上提示OK\n            userPwdMsg.innerText=&quot;OK&quot;\n            return true\n\n        &#125;\n\n        // 表单在提交时,校验用户名和密码格式,格式OK才会提交\n        function checkForm()&#123;\n            var flag1 =checkUsername()\n            var flag2 =checkUserPwd()\n\n            return flag1&amp;&amp;flag2\n        &#125;\n\n\n    &lt;/script&gt;\n\n    \n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1 class=&quot;ht&quot;&gt;欢迎使用日程管理系统&lt;/h1&gt;\n    &lt;h3 class=&quot;ht&quot;&gt;请登录&lt;/h3&gt;\n    &lt;form method=&quot;post&quot; action=&quot;/user/login&quot; onsubmit=&quot;return checkForm()&quot;&gt;\n        &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td&gt;请输入账号&lt;/td&gt;\n                &lt;td&gt;\n                    &lt;input class=&quot;ipt&quot; type=&quot;text&quot; id=&quot;usernameInput&quot; name=&quot;username&quot; onblur=&quot;checkUsername()&quot;&gt;\n                    &lt;span id=&quot;usernameMsg&quot;&gt;&lt;/span&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td&gt;请输入密码&lt;/td&gt;\n                &lt;td&gt;\n                    &lt;input class=&quot;ipt&quot; type=&quot;password&quot; id=&quot;userPwdInput&quot;  name=&quot;userPwd&quot; onblur=&quot;checkUserPwd()&quot;&gt;\n                    &lt;span id=&quot;userPwdMsg&quot;&gt;&lt;/span&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt;\n                    &lt;input class=&quot;btn1&quot; type=&quot;submit&quot; value=&quot;登录&quot;&gt;\n                    &lt;input class=&quot;btn1&quot; type=&quot;reset&quot; value=&quot;重置&quot;&gt;\n                    &lt;button class=&quot;btn1&quot;&gt;&lt;a href=&quot;regist.html&quot;&gt;去注册&lt;/a&gt;&lt;/button&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/table&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;1.2 注册页及校验效果演示\n\n代码实现\n\n\n\n\n\n\n\n\n\n\nstyle：设置 字体(颜色，居中，样式)，表格(边界，颜色) 。\nscript：checkUsername()：检验用户名格式是否合法。checkUserPwd()：检验密码格式是否合法的函数。checkReUserPwd()：检验确认密码格式是否正确以及和上一个密码框内容是否一致。checkForm()：表单在提交时，校验用户名和密码格式和确认密码格式，格式OK才会提交。\nhtml：基本页面设计\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n\n        .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 500px;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:60px;\n            background-color: antiquewhite;\n\n        &#125;\n\n        .msg &#123;\n            color: gold;\n        &#125;\n\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n    &lt;/style&gt;\n\n    &lt;script&gt;\n        function checkUsername()&#123;\n            var usernameReg = /^[a-zA-Z0-9]&#123;5,10&#125;$/\n            var usernameInput = document.getElementById(&quot;usernameInput&quot;)  \n            var username = usernameInput.value  \n            var usernameMsg = document.getElementById(&quot;usernameMsg&quot;)\n            if(!usernameReg.test(username))&#123;\n                usernameMsg.innerText=&quot;格式有误&quot;\n                return false\n            &#125; \n            usernameMsg.innerText=&quot;OK&quot;\n            return true \n        &#125;\n\n\n        function checkUserPwd()&#123;\n            var userPwdReg = /^\\d&#123;6&#125;$/\n            var userPwdInput = document.getElementById(&quot;userPwdInput&quot;)  \n            var userPwd = userPwdInput.value  \n            var userPwdMsg = document.getElementById(&quot;userPwdMsg&quot;)\n            if(!userPwdReg.test(userPwd))&#123;\n                userPwdMsg.innerText=&quot;格式有误&quot;\n                return false\n            &#125; \n            userPwdMsg.innerText=&quot;OK&quot;\n            return true \n        &#125;\n\n\n        function checkReUserPwd()&#123;\n            var userPwdReg = /^\\d&#123;6&#125;$/\n            // 再次输入的密码的格式\n            var reUserPwdInput = document.getElementById(&quot;reUserPwdInput&quot;)  \n            var reUserPwd = reUserPwdInput.value \n            var reUserPwdMsg = document.getElementById(&quot;reUserPwdMsg&quot;)\n            if(!userPwdReg.test(reUserPwd))&#123;\n                reUserPwdMsg.innerText=&quot;格式有误&quot;\n                return false\n            &#125; \n            // 获得上次密码,对比两次密码是否一致\n            var userPwdInput = document.getElementById(&quot;userPwdInput&quot;)  \n            var userPwd = userPwdInput.value  \n            if(reUserPwd != userPwd)&#123;\n                reUserPwdMsg.innerText=&quot;两次密码不一致&quot;\n                return false\n            &#125; \n            reUserPwdMsg.innerText=&quot;OK&quot;\n            return true \n        &#125;\n\n\n        function checkForm()&#123;\n            var flag1 = checkUsername()\n            var flag2 = checkUserPwd()\n            var flag3 = checkReUserPwd()\n\n            return flag1 &amp;&amp; flag2 &amp;&amp; flag3\n        &#125;\n\n\n    &lt;/script&gt;\n\n\n   \n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1 class=&quot;ht&quot;&gt;欢迎使用日程管理系统&lt;/h1&gt;\n&lt;h3 class=&quot;ht&quot;&gt;请注册&lt;/h3&gt;\n&lt;form method=&quot;post&quot; action=&quot;/user/regist&quot; onsubmit=&quot;return checkForm()&quot;&gt;\n    &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;请输入账号&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; id=&quot;usernameInput&quot; type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;checkUsername()&quot;&gt;\n                &lt;span id=&quot;usernameMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;请输入密码&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; id=&quot;userPwdInput&quot; type=&quot;password&quot; name=&quot;userPwd&quot; onblur=&quot;checkUserPwd()&quot;&gt;\n                &lt;span id=&quot;userPwdMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;确认密码&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; id=&quot;reUserPwdInput&quot; type=&quot;password&quot; onblur=&quot;checkReUserPwd()&quot;&gt;\n                &lt;span id=&quot;reUserPwdMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt;\n                &lt;input class=&quot;btn1&quot; type=&quot;submit&quot; value=&quot;注册&quot;&gt;\n                &lt;input class=&quot;btn1&quot; type=&quot;reset&quot; value=&quot;重置&quot;&gt;\n                &lt;button class=&quot;btn1&quot;&gt;&lt;a  href=&quot;login.html&quot;&gt;去登录&lt;/a&gt;&lt;/button&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n第二期简要概述\n\n\n\n\n\n\n\n\n\n学习完Servlet篇章后，运用Servlet篇章内容实现。\n\n按照MVC模式搭建整个项目\n\n根据MVC架构模式搭建了Controller层，DAO层，pojo层，service层，util层，以及测试功能的test包。\n\n根据业务需求注册和登陆功能在各层写下对应代码。能够更加体会MVC架构模式\n\n\n2.1 项目搭建2.1.1 数据库准备\n创建schedule_system数据库并执行如下语句\n\nsqlSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n\n-- ----------------------------\n-- 创建日程表\n-- ----------------------------\nDROP TABLE IF EXISTS `sys_schedule`;\nCREATE TABLE `sys_schedule`  (\n  `sid` int NOT NULL AUTO_INCREMENT,\n  `uid` int NULL DEFAULT NULL,\n  `title` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,\n  `completed` int(1) NULL DEFAULT NULL,\n  PRIMARY KEY (`sid`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- 插入日程数据\n-- ----------------------------\n\n-- ----------------------------\n-- 创建用户表\n-- ----------------------------\nDROP TABLE IF EXISTS `sys_user`;\nCREATE TABLE `sys_user`  (\n  `uid` int NOT NULL AUTO_INCREMENT,\n  `username` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,\n  `user_pwd` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`uid`) USING BTREE,\n  UNIQUE INDEX `username`(`username`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- 插入用户数据\n-- ----------------------------\nINSERT INTO `sys_user` VALUES (1, &#39;zhangsan&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;);\nINSERT INTO `sys_user` VALUES (2, &#39;lisi&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;);\n\nSET FOREIGN_KEY_CHECKS = 1;\n\n获得如下表格\n\n\n\n2.1.2 项目结构\n\n2.1.3 导入依赖\n2.1.4 pojo包处理\n\n\n\n\n\n\n\n\n 使用lombok处理getter setter equals hashcode 构造器 \nlombok使用步骤\n\n检查idea是否已经安装了lombok插件\n检查是否勾选了enable annotation processer\n导入lombok依赖\n\n步骤2：\n\njava//-----------------------------------------------------\npackage com.atguigu.schedule.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n@AllArgsConstructor\t//添加全参构造\n@NoArgsConstructor\t//添加无参构造\n@Data\t//添加getter,setter,equals，hashcode，tostring方法\npublic class SysUser  implements Serializable &#123;\n    private Integer uid;\n    private String username;\n    private String userPwd;\n&#125;\n//------------------------------------------------------\npackage com.atguigu.schedule.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport java.io.Serializable;\n\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class SysSchedule implements Serializable &#123;\n    private Integer sid;\n    private Integer uid;\n    private String title;\n    private Integer completed;\n&#125;\n//------------------------------------------------------pojo包处理\n\n2.1.5 dao包处理导入JDBCUtil连接池工具类并准备jdbc.properties配置文件\njavapackage com.atguigu.schedule.util;\n\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\npublic class JDBCUtil &#123;\n    private static ThreadLocal&lt;Connection&gt; threadLocal =new ThreadLocal&lt;&gt;();\n\n    private static DataSource dataSource;\n    // 初始化连接池\n    static&#123;\n        // 可以帮助我们读取.properties配置文件\n        Properties properties =new Properties();\n        InputStream resourceAsStream = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);\n        try &#123;\n            properties.load(resourceAsStream);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n\n        try &#123;\n            dataSource = DruidDataSourceFactory.createDataSource(properties);\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n\n\n    &#125;\n    /*1 向外提供连接池的方法*/\n    public static DataSource getDataSource()&#123;\n        return dataSource;\n    &#125;\n\n    /*2 向外提供连接的方法*/\n    public static Connection getConnection()&#123;\n        Connection connection = threadLocal.get();\n        if (null == connection) &#123;\n            try &#123;\n                connection = dataSource.getConnection();\n            &#125; catch (SQLException e) &#123;\n                throw new RuntimeException(e);\n            &#125;\n            threadLocal.set(connection);\n        &#125;\n\n        return connection;\n    &#125;\n\n\n    /*定义一个归还连接的方法 (解除和ThreadLocal之间的关联关系) */\n    public static void releaseConnection()&#123;\n        Connection connection = threadLocal.get();\n        if (null != connection) &#123;\n            threadLocal.remove();\n            // 把连接设置回自动提交的连接\n            try &#123;\n                connection.setAutoCommit(true);\n                // 自动归还到连接池\n                connection.close();\n            &#125; catch (SQLException e) &#123;\n                throw new RuntimeException(e);\n            &#125;\n        &#125;\n    &#125;\n&#125;\npropertiesdriverClassName=com.mysql.cj.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/schedule_system\nusername=root\npassword=root\ninitialSize=5\nmaxActive=10\nmaxWait=1000\n创建BaseDao对象并复制如下代码\n\njavapackage com.atguigu.schedule.dao;\n\n\nimport com.atguigu.schedule.util.JDBCUtil;\n\nimport java.lang.reflect.Field;\nimport java.sql.*;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class BaseDao &#123;\n    // 公共的查询方法  返回的是单个对象\n    public &lt;T&gt; T baseQueryObject(Class&lt;T&gt; clazz, String sql, Object ... args) &#123;\n        T t = null;\n        Connection connection = JDBCUtil.getConnection();\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        int rows = 0;\n        try &#123;\n            // 准备语句对象\n            preparedStatement = connection.prepareStatement(sql);\n            // 设置语句上的参数\n            for (int i = 0; i &lt; args.length; i++) &#123;\n                preparedStatement.setObject(i + 1, args[i]);\n            &#125;\n\n            // 执行 查询\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) &#123;\n                t = (T) resultSet.getObject(1);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            if (null != resultSet) &#123;\n                try &#123;\n                    resultSet.close();\n                &#125; catch (SQLException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            if (null != preparedStatement) &#123;\n                try &#123;\n                    preparedStatement.close();\n                &#125; catch (SQLException e) &#123;\n                    e.printStackTrace();\n                &#125;\n\n            &#125;\n            JDBCUtil.releaseConnection();\n        &#125;\n        return t;\n    &#125;\n    // 公共的查询方法  返回的是对象的集合\n\n    public &lt;T&gt; List&lt;T&gt; baseQuery(Class clazz, String sql, Object ... args)&#123;\n        List&lt;T&gt; list =new ArrayList&lt;&gt;();\n        Connection connection = JDBCUtil.getConnection();\n        PreparedStatement preparedStatement=null;\n        ResultSet resultSet =null;\n        int rows = 0;\n        try &#123;\n            // 准备语句对象\n            preparedStatement = connection.prepareStatement(sql);\n            // 设置语句上的参数\n            for (int i = 0; i &lt; args.length; i++) &#123;\n                preparedStatement.setObject(i+1,args[i]);\n            &#125;\n\n            // 执行 查询\n            resultSet = preparedStatement.executeQuery();\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            // 将结果集通过反射封装成实体类对象\n            while (resultSet.next()) &#123;\n                // 使用反射实例化对象\n                Object obj =clazz.getDeclaredConstructor().newInstance();\n\n                for (int i = 1; i &lt;= columnCount; i++) &#123;\n                    String columnName = metaData.getColumnLabel(i);\n                    Object value = resultSet.getObject(columnName);\n                    // 处理datetime类型字段和java.util.Data转换问题\n                    if(value.getClass().equals(LocalDateTime.class))&#123;\n                        value= Timestamp.valueOf((LocalDateTime) value);\n                    &#125;\n                    Field field = clazz.getDeclaredField(columnName);\n                    field.setAccessible(true);\n                    field.set(obj,value);\n                &#125;\n\n                list.add((T)obj);\n            &#125;\n\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            if (null !=resultSet) &#123;\n                try &#123;\n                    resultSet.close();\n                &#125; catch (SQLException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n            &#125;\n            if (null != preparedStatement) &#123;\n                try &#123;\n                    preparedStatement.close();\n                &#125; catch (SQLException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n            &#125;\n            JDBCUtil.releaseConnection();\n        &#125;\n        return list;\n    &#125;\n\n    // 通用的增删改方法\n    public int baseUpdate(String sql,Object ... args) &#123;\n        // 获取连接\n        Connection connection = JDBCUtil.getConnection();\n        PreparedStatement preparedStatement=null;\n        int rows = 0;\n        try &#123;\n            // 准备语句对象\n            preparedStatement = connection.prepareStatement(sql);\n            // 设置语句上的参数\n            for (int i = 0; i &lt; args.length; i++) &#123;\n                preparedStatement.setObject(i+1,args[i]);\n            &#125;\n\n            // 执行 增删改 executeUpdate\n            rows = preparedStatement.executeUpdate();\n            // 释放资源(可选)\n\n\n        &#125; catch (SQLException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            if (null != preparedStatement) &#123;\n                try &#123;\n                    preparedStatement.close();\n                &#125; catch (SQLException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n\n            &#125;\n            JDBCUtil.releaseConnection();\n        &#125;\n        // 返回的是影响数据库记录数\n        return rows;\n    &#125;\n&#125;\n\ndao层所有接口\n\njava//---------------------------------------------------\npackage com.atguigu.schedule.dao;\npublic interface SysUserDao &#123;\n&#125;\n//---------------------------------------------------\npackage com.atguigu.schedule.dao;\npublic interface SysScheduleDao &#123;\n&#125;\n//---------------------------------------------------\ndao层所有实现类\n\njava//------------------------------------------------------------------------------\npackage com.atguigu.schedule.dao.impl;\nimport com.atguigu.schedule.dao.BaseDao;\nimport com.atguigu.schedule.dao.SysUserDao;\npublic class SysUserDaoImpl extends BaseDao implements SysUserDao &#123;\n&#125;\n\n//------------------------------------------------------------------------------\npackage com.atguigu.schedule.dao.impl;\nimport com.atguigu.schedule.dao.BaseDao;\nimport com.atguigu.schedule.dao.SysScheduleDao;\npublic class SysScheduleDaoImpl extends BaseDao implements SysScheduleDao &#123;\n&#125;\n//------------------------------------------------------------------------------dao包处理结构目录如下\n\n2.1.6 service包处理\n接口\n\njava//------------------------------------------------------------------------------\npackage com.atguigu.schedule.service;\npublic interface SysUserService &#123;\n&#125;\n//------------------------------------------------------------------------------\npackage com.atguigu.schedule.service;\npublic interface SysScheduleService &#123;\n&#125;\n//------------------------------------------------------------------------------\n实现类\n\njava//------------------------------------------------------------------------------\npackage com.atguigu.schedule.service.impl;\nimport com.atguigu.schedule.service.SysUserService;\npublic class SysUserServiceImpl implements SysUserService &#123;\n&#125;\n//------------------------------------------------------------------------------\npackage com.atguigu.schedule.service.impl;\nimport com.atguigu.schedule.service.SysScheduleService;\npublic class SysScheduleServiceImpl implements SysScheduleService &#123;\n&#125;\n//------------------------------------------------------------------------------service包处理结构目录如下\n\n2.1.7 controller包处理\nBaseController处理请求路径问题\n\njavapackage com.atguigu.schedule.controller;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\n\npublic class BaseController extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        \n\n        String requestURI = req.getRequestURI();\n        String[] split = requestURI.split(&quot;/&quot;);\n        String methodName =split[split.length-1];\n        // 通过反射获取要执行的方法\n        Class clazz = this.getClass();\n        try &#123;\n            Method method=clazz.getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class);\n            // 设置方法可以访问\n            method.setAccessible(true);\n            // 通过反射执行代码\n            method.invoke(this,req,resp);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n           \n        &#125;\n    &#125;\n&#125;\n多个处理器继承BaseController\n\njava//----------------------------------------------------------------------------\npackage com.atguigu.schedule.controller;\n\nimport jakarta.servlet.annotation.WebServlet;\n\n@WebServlet(&quot;/user/*&quot;)\npublic class UserController extends BaseController&#123;\n&#125;\n//----------------------------------------------------------------------------\npackage com.atguigu.schedule.controller;\n\nimport jakarta.servlet.annotation.WebServlet;\n\n@WebServlet(&quot;/schedule/*&quot;)\npublic class SysScheduleController  extends BaseController&#123;\n&#125;\n//----------------------------------------------------------------------------controller包处理结构目录如下\n\n2.1.8 加密工具类的使用\n导入MD5Util工具类\n\njavapackage com.atguigu.schedule.util;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\npublic final class MD5Util &#123;\n    public static String encrypt(String strSrc) &#123;\n        try &#123;\n            char hexChars[] = &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,\n                    &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; &#125;;\n            byte[] bytes = strSrc.getBytes();\n            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);\n            md.update(bytes);\n            bytes = md.digest();\n            int j = bytes.length;\n            char[] chars = new char[j * 2];\n            int k = 0;\n            for (int i = 0; i &lt; bytes.length; i++) &#123;\n                byte b = bytes[i];\n                chars[k++] = hexChars[b &gt;&gt;&gt; 4 &amp; 0xf];\n                chars[k++] = hexChars[b &amp; 0xf];\n            &#125;\n            return new String(chars);\n        &#125; catch (NoSuchAlgorithmException e) &#123;\n            e.printStackTrace();\n            throw new RuntimeException(&quot;MD5加密出错!!!&quot;);\n        &#125;\n    &#125;\n&#125;\n2.1.9 页面文件的导入\n复制资源下的日程管理中的HTML到项目的web目录下即可\n\n\nshowSchedule.html需要用到Vue3知识，因此还没有实现，其余的页面只是简单的提示信息。\n2.3 业务代码2.3.1  注册业务处理思路\n\ncontroller层\ncontroller层接收客户端提交的参数，”username与userPwd“参数名称由regist.html确定。\n将获取的参数放入一个SysUser对象中，再调用service层的regist方法时传入参数。\n根据regist方法返回的注册结果做页面跳转\n\n\nservice层\n在SysUserService接口中设计regist方法，SysUserServiceImpl实现regist方法。\n注意在SysUserServiceImpl初始化一个SysUserDao对象\nregist方法将用户的明文密码转换为密文密码\n调用DAO层的方法将sysUser用户信息存入数据库\n\n\nDAO层\n在SysUserDao接口中设计addSysUser方法，SysUserDaoImpl实现addSysUser方法。\n注册功能，写添加到数据库的sql语句，获取sysUser对象的参数，添加到数据库中。\n\n\n\n\ncontroller层\n\njavapackage com.atguigu.schedule.controller;\n\nimport com.atguigu.schedule.pojo.SysUser;\nimport com.atguigu.schedule.service.SysUserService;\nimport com.atguigu.schedule.service.impl.SysUserServiceImpl;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\n\n@WebServlet(&quot;/user/*&quot;)\npublic class SysUserController  extends BaseContoller &#123;\n\n    private SysUserService userService =new SysUserServiceImpl();\n\n    /**\n     * 接收用户注册请求的业务处理方法( 业务接口 不是java中的interface  )\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 1 接收客户端提交的参数\n        String username = req.getParameter(&quot;username&quot;);\n        String userPwd = req.getParameter(&quot;userPwd&quot;);\n        // 2 调用服务层方法,完成注册功能\n            //将参数放入一个SysUser对象中,在调用regist方法时传入\n        SysUser sysUser =new SysUser(null,username,userPwd);\n        int rows = userService.regist(sysUser);\n        // 3 根据注册结果(成功  失败) 做页面跳转\n        if(rows&gt;0)&#123;\n            resp.sendRedirect(&quot;/registSuccess.html&quot;);\n        &#125;else&#123;\n            resp.sendRedirect(&quot;/registFail.html&quot;);\n        &#125;\n    &#125;\n&#125;\nservice层\n\njavapackage com.atguigu.schedule.service;\n\nimport com.atguigu.schedule.pojo.SysUser;\n\npublic interface SysUserService &#123;\n    /**\n     * 用户完成注册的业务方法\n     * @param registUser 用于保存注册用户名和密码的对象\n     * @return 注册成功返回&gt;0的整数,否则返回0\n     */\n    int regist(SysUser sysUser);\n&#125;SysUserServiceImpl.java\njavapackage com.atguigu.schedule.service.impl;\n\nimport com.atguigu.schedule.dao.SysUserDao;\nimport com.atguigu.schedule.dao.impl.SysUserDaoImpl;\nimport com.atguigu.schedule.pojo.SysUser;\nimport com.atguigu.schedule.service.SysUserService;\nimport com.atguigu.schedule.util.MD5Util;\n\npublic class SysUserServiceImpl  implements SysUserService &#123;\n    private SysUserDao userDao =new SysUserDaoImpl();\n    @Override\n    public int regist(SysUser sysUser) &#123;\n\n        // 将用户的明文密码转换为密文密码\n        sysUser.setUserPwd(MD5Util.encrypt(sysUser.getUserPwd()));\n        // 调用DAO 层的方法  将sysUser信息存入数据库\n        return userDao.addSysUser(sysUser);\n    &#125;\n&#125;\ndao层\n\njavapackage com.atguigu.schedule.dao;\n\nimport com.atguigu.schedule.pojo.SysUser;\n\npublic interface SysUserDao &#123;\n\n    /**\n     * 向数据库中增加一条用户记录的方法\n     * @param sysUser 要增加的记录的username和user_pwd字段以SysUser实体类对象的形式接收\n     * @return 增加成功返回1 增加失败返回0\n     */\n    int addSysUser(SysUser sysUser);\n&#125;\nSysUserDaoImpl.java\njavapackage com.atguigu.schedule.dao.impl;\n\nimport com.atguigu.schedule.dao.BaseDao;\nimport com.atguigu.schedule.dao.SysUserDao;\nimport com.atguigu.schedule.pojo.SysUser;\npublic class SysUserDaoImpl extends BaseDao implements SysUserDao &#123;\n    @Override\n    public int addSysUser(SysUser sysUser) &#123;\n        String sql =&quot;insert into sys_user values(DEFAULT,?,?)&quot;;\n        return baseUpdate(sql,sysUser.getUsername(),sysUser.getUserPwd());\n    &#125;\n&#125;2.3.2 登录业务处理思路\n\ncontroller层\ncontroller层接收客户端提交的参数，”username与userPwd“参数名称由login.html确定。\n调用service层的findByUsername方法，根据username返回一个SysUser对象。\n根据SysUser对象的信息做页面跳转\n\n\nservice层\n在SysUserService接口中设计findByUsername方法，SysUserServiceImpl实现findByUsername方法\nSysUserServiceImpl中直接调用DAO层方法继续查询\n\n\nDAO层\n在SysUserDao层设计查询方法，SysUserDaoImpl实现。\n编写sql语句，将数据库的信息转换成SysUser对象。注意数据库中的user_pwd要转换成SysUser对象中对应的userPwd。\n\n\n\n\ncontroller层\n\njavapackage com.atguigu.schedule.controller;\n\nimport com.atguigu.schedule.pojo.SysUser;\nimport com.atguigu.schedule.service.SysUserService;\nimport com.atguigu.schedule.service.impl.SysUserServiceImpl;\nimport com.atguigu.schedule.util.MD5Util;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\n\n@WebServlet(&quot;/user/*&quot;)\npublic class SysUserController  extends BaseContoller &#123;\n\n    private SysUserService userService =new SysUserServiceImpl();\n    /**\n     * 接收用登录请求,完成的登录业务接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //1 接收用户名和密码\n        String username = req.getParameter(&quot;username&quot;);\n        String userPwd = req.getParameter(&quot;userPwd&quot;);\n        //2 调用服务层方法,根据用户名查询用户信息\n        SysUser loginUser =userService.findByUsername(username);\n        if(null == loginUser)&#123;\n            // 跳转到用户名有误提示页\n            resp.sendRedirect(&quot;/loginUsernameError.html&quot;);\n        &#125;else if(! MD5Util.encrypt(userPwd).equals(loginUser.getUserPwd()))&#123;\n            //3 判断密码是否匹配\n            // 跳转到密码有误提示页\n            resp.sendRedirect(&quot;/loginUserPwdError.html&quot;);\n        &#125;else&#123;\n            //4 跳转到首页\n            resp.sendRedirect(&quot;/showSchedule.html&quot;);\n        &#125;\n    &#125;\n    \n&#125;\nservice层\n\njavapackage com.atguigu.schedule.service;\n\nimport com.atguigu.schedule.pojo.SysUser;\n\npublic interface SysUserService &#123;\n    /**\n     * 根据用户名获得完整用户信息的方法\n     * @param username 要查询的用户名\n     * @return 如果找到了返回SysUser对象,找不到返回null\n     */\n    SysUser findByUsername(String username);\n&#125;SysUserServiceImpl.java\njavapackage com.atguigu.schedule.service.impl;\n\nimport com.atguigu.schedule.dao.SysUserDao;\nimport com.atguigu.schedule.dao.impl.SysUserDaoImpl;\nimport com.atguigu.schedule.pojo.SysUser;\nimport com.atguigu.schedule.service.SysUserService;\nimport com.atguigu.schedule.util.MD5Util;\n\npublic class SysUserServiceImpl implements SysUserService &#123;\n    private SysUserDao userDao =new SysUserDaoImpl();\n\n    @Override\n    public SysUser findByUsername(String username) &#123;\n        // 调用DAO层方法,继续查询\n\n        return userDao.findByUsername(username);\n    &#125;\n&#125;\n\ndao层\n\njavapackage com.atguigu.schedule.dao;\n\nimport com.atguigu.schedule.pojo.SysUser;\n\npublic interface SysUserDao &#123;\n        /**\n     * 根据用户名获得完整用户信息的方法\n     * @param username 要查询的用户名\n     * @return 如果找到了返回SysUser对象,找不到返回null\n     */\n    SysUser findByUsername(String username);\n&#125;SysUserDaoImpl.java\njavaimport com.atguigu.schedule.dao.BaseDao;\nimport com.atguigu.schedule.dao.SysUserDao;\nimport com.atguigu.schedule.pojo.SysUser;\n\nimport java.util.List;\n\npublic class SysUserDaoImpl extends BaseDao implements SysUserDao &#123;\n    @Override\n    public SysUser findByUsername(String username) &#123;\n        //转换到SysUser对象时，数据库中的user_pwd应该别名成userPwd\n        String sql =&quot;select uid,username, user_pwd userPwd from sys_user where username = ?&quot;;\n        List&lt;SysUser&gt; userList = baseQuery(SysUser.class, sql, username);\n        return  null != userList&amp;&amp; userList.size()&gt;0? userList.get(0):null;\n    &#125;\n&#125;\n第三期简要概述\n\n\n\n\n\n\n\n\n\n学习完会话&amp;过滤器&amp;监听器篇章实现。\n\n需求说明：因为在未登录的状态不允许访问showShedule.html和SysScheduleController(相关增删改查处理)，因此需要设计过滤器\n在未登陆的状态下，访问上述内容重定向到login.html页面，而登陆之后可以自由访问\n设置过滤器对/showSchedule.html和/schedule/*资源进行过滤实现。(因为SysScheduleController的路径是/schedule/*)\n\n3.1 过滤器控制登录校验\n开发登录过滤器,对指定资源的请求进行过滤\n\njavapackage com.atguigu.schedule.filters;\n\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebFilter;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport jakarta.servlet.http.HttpSession;\n\nimport java.io.IOException;\n\n@WebFilter(urlPatterns = &#123;&quot;/showSchedule.html&quot;,&quot;/schedule/*&quot;&#125;)\npublic class LoginFilter  implements Filter &#123;\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        HttpServletRequest request =(HttpServletRequest) servletRequest;\n        HttpServletResponse response =(HttpServletResponse) servletResponse;\n        HttpSession session = request.getSession();\n        Object sysUser = session.getAttribute(&quot;sysUser&quot;);\n        if(null != sysUser)&#123;\n            // session中如果存在登录的用户 代表用户登录过,则放行\n            filterChain.doFilter(servletRequest,servletResponse);\n\n        &#125;else&#123;\n            //用户未登录,重定向到登录页\n            response.sendRedirect(&quot;/login.html&quot;);\n        &#125;\n    &#125;\n&#125;\n\n修改用户登录请求的login方法,登录成功时,将用户信息存入session\n\njava /**\n     * 用户登录的业务接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 接收用户请求参数\n        // 获取要注册的用户名密码\n        String username = req.getParameter(&quot;username&quot;);\n        String userPwd = req.getParameter(&quot;userPwd&quot;);\n        // 调用服务层方法,根据用户名查询数据库中是否有一个用户\n        SysUser loginUser =userService.findByUsername(username);\n        if(null == loginUser)&#123;\n            // 没有根据用户名找到用户,说明用户名有误\n            resp.sendRedirect(&quot;/loginUsernameError.html&quot;);\n        &#125;else if(! loginUser.getUserPwd().equals(MD5Util.encrypt(userPwd)))&#123;\n            // 用户密码有误,\n            resp.sendRedirect(&quot;/loginUserPwdError.html&quot;);\n        &#125;else&#123;\n            // 登录成功,将用户信息存入session\n            req.getSession().setAttribute(&quot;sysUser&quot;,loginUser);\n            // 登录成功,重定向到日程展示页\n            resp.sendRedirect(&quot;/showSchedule.html&quot;);\n        &#125;\n    &#125;\n第四期简要概述\n\n\n\n\n\n\n\n\n\n学习会话篇章中的Ajax内容实现。\n简要说明：在注册页面填写用户名的时候就进行分析，来确认名字是否被占用。\n\n在regist.html页面检验用户名的方法中，检测不合法后面添加新代码，发送ajax请求检验用户名是否被占用\n设置回调函数request.onreadystatechange = function()来处理返回的内容。设置请求资源路径为/user/...下。在对应路径下设计内容\n此处设置了Result类(JSON的内容)和ResultCodeEnum泛型(Result类中code码的说明)\n添加了Jackson依赖，将内容转为JSON串传给前端。\n\n产生的问题\n\n响应乱码问题。\n响应信息格式不规范，处理方式不规范。(前后端共同遵守规则，响应一个JSON串，也就是Result类的内容)\n校验不通过，无法阻止表单提交的问题。(还未学习到，使用VUE，axios结合promise处理)\n\n4.1 注册提交前校验用户名是否占用功能\n\n\n\n\n\n\n\n\n 客户端代码编写处理\n\nregist.html页面代码\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n\n        .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 500px;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:60px;\n            background-color: antiquewhite;\n\n        &#125;\n\n        .msg &#123;\n            color: gold;\n        &#125;\n\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n    &lt;/style&gt;\n\n    &lt;script&gt;\n\n        // 校验用户名的方法\n        function checkUsername()&#123;\n            // 定义正则\n            var usernameReg=/^[a-zA-Z0-9]&#123;5,10&#125;$/\n            var username =document.getElementById(&quot;usernameInput&quot;).value\n            var usernameMsgSpan =document.getElementById(&quot;usernameMsg&quot;)\n            if(!usernameReg.test(username))&#123;\n                usernameMsgSpan.innerText=&quot;不合法&quot;\n                return false\n            &#125;\n            // 发送ajax请求校验用户名是否被占用\n            var request;\n            if(window.XMLHttpRequest)&#123;\n                request= new XMLHttpRequest();\n            &#125;else&#123;\n                request= new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n            &#125;\n            request.onreadystatechange= function ()&#123;\n                // request.readyState == 4 代表请求结束,已经接收到响应结果\n                // request.status== 200  表示后端响应状态码是200\n                if(request.readyState == 4  &amp;&amp; request.status== 200)&#123;\n                    // 后端的响应的JSON字符串转换为前端的对象\n                    var response =JSON.parse(request.responseText)\n                    console.log(response)\n                    //  判断业务码是否是200\n                    if (response.code != 200)&#123;\n                        usernameMsgSpan.innerText=&quot;已占用&quot;\n                        return false\n                    &#125;\n                &#125;\n            &#125;\n            // 设置请求方式,请求资源路径,是否为异步请求\n            request.open(&quot;GET&quot;,&#39;/user/checkUsernameUsed?username=&#39;+username,true)\n            // 发送请求\n            request.send();\n            // 前面校验都通过\n            // usernameMsgSpan.innerText=&quot;OK&quot;\n            // return true\n\n        &#125;\n\n\n        // 校验密码的方法\n        function checkUserPwd()&#123;\n            // 定义正则\n            var passwordReg=/^[0-9]&#123;6&#125;$/\n            var userPwd =document.getElementById(&quot;userPwdInput&quot;).value\n            var userPwdMsgSpan =document.getElementById(&quot;userPwdMsg&quot;)\n            if(!passwordReg.test(userPwd))&#123;\n                userPwdMsgSpan.innerText=&quot;不合法&quot;\n                return false\n            &#125;\n            userPwdMsgSpan.innerText=&quot;OK&quot;\n            return true\n        &#125;\n\n        // 校验密码的方法\n        function checkReUserPwd()&#123;\n            // 定义正则\n            var passwordReg=/^[0-9]&#123;6&#125;$/\n            var userPwd =document.getElementById(&quot;userPwdInput&quot;).value\n            var reUserPwd =document.getElementById(&quot;reUserPwdInput&quot;).value\n            var reUserPwdMsgSpan =document.getElementById(&quot;reUserPwdMsg&quot;)\n            if(!passwordReg.test(userPwd))&#123;\n                reUserPwdMsgSpan.innerText=&quot;不合法&quot;\n                return false\n            &#125;\n            if(userPwd != reUserPwd)&#123;\n                reUserPwdMsgSpan.innerText=&quot;不一致&quot;\n                return false\n\n            &#125;\n            reUserPwdMsgSpan.innerText=&quot;OK&quot;\n            return true\n        &#125;\n\n        //表单提交时统一校验\n        function checkForm()&#123;\n            return checkUsername() &amp;&amp; checkUserPwd() &amp;&amp; checkReUserPwd()\n        &#125;\n\n\n\n    &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1 class=&quot;ht&quot;&gt;欢迎使用日程管理系统&lt;/h1&gt;\n&lt;h3 class=&quot;ht&quot;&gt;请注册&lt;/h3&gt;\n&lt;form method=&quot;post&quot; action=&quot;/user/regist&quot; onsubmit=&quot;return checkForm()&quot;&gt;\n    &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;请输入账号&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; id=&quot;usernameInput&quot; type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;checkUsername()&quot;&gt;\n                &lt;span id=&quot;usernameMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;请输入密码&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; id=&quot;userPwdInput&quot; type=&quot;password&quot; name=&quot;userPwd&quot; onblur=&quot;checkUserPwd()&quot;&gt;\n                &lt;span id=&quot;userPwdMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;确认密码&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; id=&quot;reUserPwdInput&quot; type=&quot;password&quot; onblur=&quot;checkReUserPwd()&quot;&gt;\n                &lt;span id=&quot;reUserPwdMsg&quot; class=&quot;msg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt;\n                &lt;input class=&quot;btn1&quot; type=&quot;submit&quot; value=&quot;注册&quot;&gt;\n                &lt;input class=&quot;btn1&quot; type=&quot;reset&quot; value=&quot;重置&quot;&gt;\n                &lt;button class=&quot;btn1&quot;&gt;&lt;a  href=&quot;/login.html&quot;&gt;去登录&lt;/a&gt;&lt;/button&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n 服务端代码处理\n\n添加公共的JSON数据响应格式类\n\njavapackage com.atguigu.schedule.common;\n\n/**\n * 业务含义和状态码对应关系的枚举\n *\n */\npublic enum ResultCodeEnum &#123;\n\n    SUCCESS(200,&quot;success&quot;),\n    USERNAME_ERROR(501,&quot;usernameError&quot;),\n    PASSWORD_ERROR(503,&quot;passwordError&quot;),\n    NOTLOGIN(504,&quot;notLogin&quot;),\n    USERNAME_USED(505,&quot;userNameUsed&quot;)\n    ;\n\n    private Integer code;\n    private String message;\n    private ResultCodeEnum(Integer code, String message) &#123;\n        this.code = code;\n        this.message = message;\n    &#125;\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n    public String getMessage() &#123;\n        return message;\n    &#125;\n&#125;\nResult类\njavapackage com.atguigu.schedule.common;\n\n\n/**\n * 全局统一响应的JSON格式处理类\n *&#123;\n *    &quot;code&quot;:&quot;100/200/300/400/401&quot;, //业务状态码, 本次请求的业务是否成功?如果失败了，是因为什么原因失败了\n *    &quot;message&quot;:&quot;业务状态码的 补充说明/描述&quot;,\n *    &quot;data&quot;:&#123;&#125; //本次响应的数据   成功/不成功 List&lt;Schedule&gt; ....\n * &#125;\n */\npublic class Result&lt;T&gt; &#123;\n    // 返回码\n    private Integer code;\n    // 返回消息\n    private String message;\n    // 返回数据\n    private T data;\n    public Result()&#123;&#125;\n    // 返回数据\n    protected static &lt;T&gt; Result&lt;T&gt; build(T data) &#123;\n        Result&lt;T&gt; result = new Result&lt;T&gt;();\n        if (data != null)\n            result.setData(data);\n        return result;\n    &#125;\n    public static &lt;T&gt; Result&lt;T&gt; build(T body, Integer code, String message) &#123;\n        Result&lt;T&gt; result = build(body);\n        result.setCode(code);\n        result.setMessage(message);\n        return result;\n    &#125;\n    public static &lt;T&gt; Result&lt;T&gt; build(T body, ResultCodeEnum resultCodeEnum) &#123;\n        Result&lt;T&gt; result = build(body);\n        result.setCode(resultCodeEnum.getCode());\n        result.setMessage(resultCodeEnum.getMessage());\n        return result;\n    &#125;\n    /**\n     * 操作成功\n     * @param data  baseCategory1List\n     * @param &lt;T&gt;\n     * @return\n     */\n    public static&lt;T&gt; Result&lt;T&gt; ok(T data)&#123;\n        Result&lt;T&gt; result = build(data);\n        return build(data, ResultCodeEnum.SUCCESS);\n    &#125;\n    public Result&lt;T&gt; message(String msg)&#123;\n        this.setMessage(msg);\n        return this;\n    &#125;\n    public Result&lt;T&gt; code(Integer code)&#123;\n        this.setCode(code);\n        return this;\n    &#125;\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n    public void setCode(Integer code) &#123;\n        this.code = code;\n    &#125;\n    public String getMessage() &#123;\n        return message;\n    &#125;\n    public void setMessage(String message) &#123;\n        this.message = message;\n    &#125;\n    public T getData() &#123;\n        return data;\n    &#125;\n    public void setData(T data) &#123;\n        this.data = data;\n    &#125;\n&#125;\n\n增加Jackson依赖\n\n\n\n添加WEBUtil工具类\n\njavapackage com.atguigu.schedule.util;\n\n\nimport com.atguigu.schedule.common.Result;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\n\npublic class WebUtil &#123;\n    private static ObjectMapper objectMapper;\n    // 初始化objectMapper\n    static&#123;\n        objectMapper=new ObjectMapper();\n        // 设置JSON和Object转换时的时间日期格式\n        objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));\n    &#125;\n    // 从请求中获取JSON串并转换为Object\n    public static &lt;T&gt; T readJson(HttpServletRequest request,Class&lt;T&gt; clazz)&#123;\n        T t =null;\n        BufferedReader reader = null;\n        try &#123;\n            reader = request.getReader();\n            StringBuffer buffer =new StringBuffer();\n            String line =null;\n            while((line = reader.readLine())!= null)&#123;\n                buffer.append(line);\n            &#125;\n\n            t= objectMapper.readValue(buffer.toString(),clazz);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n        return t;\n    &#125;\n    // 将Result对象转换成JSON串并放入响应对象\n    public static void writeJson(HttpServletResponse response, Result result)&#123;\n        response.setContentType(&quot;application/json;charset=UTF-8&quot;);\n        try &#123;\n            String json = objectMapper.writeValueAsString(result);\n            response.getWriter().write(json);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;\n\n用户名校验业务接口代码\n\njava  /** \n     * SysUserController下,注册时校验用户名是否被占用的业务接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void checkUsernameUsed(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        String username = req.getParameter(&quot;username&quot;);\n        SysUser registUser = userService.findByUsername(username);\n\n        //封装结果对象\n        Result result=null;\n        if(null ==registUser)&#123;\n            // 未占用,创建一个code为200的对象\n            result= Result.ok(null);\n        &#125;else&#123;\n            // 占用, 创建一个结果为505的对象\n            result= Result.build(null, ResultCodeEnum.USERNAME_USED);\n\n        &#125;\n        // 将result对象转换成JSON并响应给客户端\n        WebUtil.writeJson(resp,result);\n\n    &#125;构建完后，项目结构如下\n\n\n第五期简要概述\n\n\n\n\n\n\n\n\n\n学习到前端工程化Vue3路由机制router\n本期目标：重构全端工程，进行前后端分离\n5.1 重构前端工程\n\n\n\n\n\n\n\n\n业务目标展示\n\n登录页\n\n\n\n注册页\n\n\n\n日程管理页\n\n\n\n\n\n\n\n\n\n\n\n创建项目,安装依赖\nshellnpm create vite\ncd 项目目录\nnpm  install\nnpm  install vue-router\n项目结构如下\n\n\n\n\n\n\n\n\n\n\n\n开发视图\n\nHeader.vue视图\n\nvue&lt;script setup&gt;\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1 class=&quot;ht&quot;&gt;欢迎使用日程管理系统&lt;/h1&gt;\n    &lt;div&gt;\n      &lt;div  class=&quot;optionDiv&quot;&gt;\n        &lt;router-link to=&quot;/login&quot;&gt;\n          &lt;button class=&quot;b1s&quot;&gt;登录&lt;/button&gt;\n        &lt;/router-link&gt;   \n        &lt;router-link to=&quot;/regist&quot;&gt;\n          &lt;button class=&quot;b1s&quot;&gt;注册&lt;/button&gt;\n        &lt;/router-link&gt;\n      &lt;/div&gt;\n\n\n      &lt;div   class=&quot;optionDiv&quot;&gt;\n        欢迎xxx   \n        &lt;button class=&quot;b1b&quot;&gt;退出登录&lt;/button&gt; \n        &lt;router-link to=&quot;/showSchedule&quot;&gt;\n          &lt;button class=&quot;b1b&quot;&gt;查看我的日程&lt;/button&gt;\n        &lt;/router-link&gt;\n      &lt;/div&gt;\n\n      &lt;br&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n  .ht&#123;\n      text-align: center;\n      color: cadetblue;\n      font-family: 幼圆;\n  &#125;\n  .b1s&#123;\n        border: 2px solid powderblue;\n        border-radius: 4px;\n        width:60px;\n        background-color: antiquewhite;\n\n    &#125;\n\n    .b1b&#123;\n        border: 2px solid powderblue;\n        border-radius: 4px;\n        width:100px;\n        background-color: antiquewhite;\n    &#125;\n    .optionDiv&#123;\n      width: 300px;\n      float: right;\n    &#125;\n&lt;/style&gt;\n\nLogin.vue视图\n\nvue&lt;script setup&gt;\n  import &#123;ref,reactive&#125; from &#39;vue&#39;\n\n  let loginUser = reactive(&#123;\n    username:&quot;&quot;,\n    userPwd:&quot;&quot;\n  &#125;)\n\n  let usernameMsg = ref();\n  let userPwdMsg = ref();\n\n  //用户名校验\n  function checkUsername()&#123;\n    //正则表达式确认规则\n    let usernameReg = /^[a-zA-Z0-9]&#123;5,10&#125;$/\n    if(!usernameReg.test(loginUser.username))&#123;\n      usernameMsg.value=&quot;格式有误&quot;\n      return false\n    &#125;\n    usernameMsg.value = &quot;OK&quot;\n    return true\n  &#125;\n  //密码校验\n  function checkUserPwd()&#123;\n    let userPwdReg = /^[0-9]&#123;6&#125;$/\n    if(!userPwdReg.test(loginUser.userPwd))&#123;\n      userPwdMsg.value = &quot;格式有误&quot;\n      return false\n    &#125;\n    userPwdMsg.value = &quot;OK&quot;\n    return true\n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h3 class=&quot;ht&quot;&gt;请登录&lt;/h3&gt;\n        &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td&gt;请输入账号&lt;/td&gt;\n                &lt;td&gt;\n                    &lt;input class=&quot;ipt&quot; \n                    type=&quot;text&quot; \n                    v-model=&quot;loginUser.username&quot;\n                    @blur=&quot;checkUsername()&quot;&gt;\n                    &lt;span id=&quot;usernameMsg&quot; v-text=&quot;usernameMsg&quot;&gt;&lt;/span&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td&gt;请输入密码&lt;/td&gt;\n                &lt;td&gt;\n                    &lt;input class=&quot;ipt&quot; \n                    type=&quot;password&quot; \n                    v-model=&quot;loginUser.userPwd&quot;\n                    @blur=&quot;checkUserPwd()&quot;&gt;\n                    &lt;span id=&quot;userPwdMsg&quot; v-text=&quot;userPwdMsg&quot;&gt;&lt;/span&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt;\n                    &lt;input class=&quot;btn1&quot; type=&quot;button&quot; value=&quot;登录&quot;&gt;\n                    &lt;input class=&quot;btn1&quot; type=&quot;button&quot; value=&quot;重置&quot;&gt;\n                    &lt;router-link to=&quot;/regist&quot;&gt;\n                      &lt;button class=&quot;btn1&quot;&gt;去注册&lt;/button&gt;\n                    &lt;/router-link&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/table&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n        .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 500px;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:60px;\n            background-color: antiquewhite;\n        &#125;\n        #usernameMsg , #userPwdMsg &#123;\n            color: gold;\n        &#125;\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n&lt;/style&gt;\n\nRegist.vue视图\n\nvue&lt;script setup&gt;\n  import &#123;ref,reactive&#125; from &#39;vue&#39;\n  \n  let registUser = reactive(&#123;\n    username:&quot;&quot;,\n    userPwd:&quot;&quot;\n  &#125;)\n\n  let usernameMsg = ref()\n  let userPwdMsg = ref()\n  let reUserPwdMsg = ref()\n  let reUserPwd = ref()\n\n  //用户名校验\n  function checkUsername()&#123;\n    //正则表达式确认规则\n    let usernameReg = /^[a-zA-Z0-9]&#123;5,10&#125;$/\n    if(!usernameReg.test(registUser.username))&#123;\n      usernameMsg.value=&quot;格式有误&quot;\n      return false\n    &#125;\n    usernameMsg.value = &quot;OK&quot;\n    return true\n  &#125;\n  //密码校验\n  function checkUserPwd()&#123;\n    let userPwdReg = /^[0-9]&#123;6&#125;$/\n    if(!userPwdReg.test(registUser.userPwd))&#123;\n      userPwdMsg.value = &quot;格式有误&quot;\n      return false\n    &#125;\n    userPwdMsg.value = &quot;OK&quot;\n    return true\n  &#125;\n  //校验重复输入的密码\n  function checkReUserPwd()&#123;\n    let userPwdReg = /^[0-9]&#123;6&#125;$/\n\n    if(!userPwdReg.test(reUserPwd.value))&#123;\n      reUserPwdMsg.value = &quot;格式有误&quot;\n      return false\n    &#125;\n    if(!(registUser.userPwd == reUserPwd.value))&#123;\n      reUserPwdMsg.value = &quot;两次密码不一致&quot;\n      return false\n    &#125;\n    reUserPwdMsg.value = &quot;OK&quot;\n    return true\n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h3 class=&quot;ht&quot;&gt;请注册&lt;/h3&gt;\n\n    &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;请输入账号&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; \n                  id=&quot;usernameInput&quot; \n                  type=&quot;text&quot; \n                  name=&quot;username&quot; \n                  v-model=&quot;registUser.username&quot;\n                  @blur=&quot;checkUsername()&quot;&gt;\n\n                &lt;span id=&quot;usernameMsg&quot; class=&quot;msg&quot; v-text=&quot;usernameMsg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;请输入密码&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; \n                id=&quot;userPwdInput&quot; \n                type=&quot;password&quot; \n                name=&quot;userPwd&quot; \n                v-model=&quot;registUser.userPwd&quot;\n                @blur=&quot;checkUserPwd()&quot;&gt;\n                &lt;span id=&quot;userPwdMsg&quot; class=&quot;msg&quot; v-text=&quot;userPwdMsg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;确认密码&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; \n                id=&quot;reUserPwdInput&quot; \n                type=&quot;password&quot; \n                v-model=&quot;reUserPwd&quot;\n                @blur=&quot;checkReUserPwd()&quot;&gt;\n                &lt;span id=&quot;reUserPwdMsg&quot; class=&quot;msg&quot; v-text=&quot;reUserPwdMsg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt;\n                &lt;input class=&quot;btn1&quot; type=&quot;button&quot; value=&quot;注册&quot;&gt;\n                &lt;input class=&quot;btn1&quot; type=&quot;button&quot; value=&quot;重置&quot;&gt;\n                &lt;router-link to=&quot;/login&quot;&gt;\n                  &lt;button class=&quot;btn1&quot;&gt;去登录&lt;/button&gt;\n                &lt;/router-link&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n\n\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n       .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 500px;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:60px;\n            background-color: antiquewhite;\n\n        &#125;\n        .msg &#123;\n            color: gold;\n        &#125;\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n&lt;/style&gt;\n\nShowSchedule.vue视图\n\nvue&lt;script setup&gt;\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h3 class=&quot;ht&quot;&gt;您的日程如下&lt;/h3&gt;\n&lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n    &lt;tr class=&quot;ltr&quot;&gt;\n        &lt;th&gt;编号&lt;/th&gt;\n        &lt;th&gt;内容&lt;/th&gt;\n        &lt;th&gt;进度&lt;/th&gt;\n        &lt;th&gt;操作&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr class=&quot;ltr&quot;&gt;\n        &lt;td&gt;&lt;/td&gt;\n        &lt;td&gt;&lt;/td&gt;\n        &lt;td&gt;&lt;/td&gt;\n        &lt;td class=&quot;buttonContainer&quot;&gt;\n             &lt;button class=&quot;btn1&quot;&gt;删除&lt;/button&gt;\n            &lt;button class=&quot;btn1&quot;&gt;保存修改&lt;/button&gt;\n        &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr class=&quot;ltr buttonContainer&quot; &gt;\n        &lt;td colspan=&quot;4&quot;&gt;\n            &lt;button class=&quot;btn1&quot;&gt;新增日程&lt;/button&gt;\n        &lt;/td&gt;\n\n    &lt;/tr&gt;\n&lt;/table&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n      .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 80%;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:100px;\n            background-color: antiquewhite;\n\n        &#125;\n        #usernameMsg , #userPwdMsg &#123;\n            color: gold;\n        &#125;\n\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n\n&lt;/style&gt;\n\nApp.vue视图\n\nvue&lt;script setup&gt;\n\nimport Header from &#39;./components/Header.vue&#39;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;Header&gt;&lt;/Header&gt;\n    &lt;hr&gt;\n    &lt;!-- 用于路由切换视图使用 --&gt;\n    &lt;router-view&gt;&lt;/router-view&gt;\n  \n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;\n\n配置路由\n\njavascriptimport &#123;createRouter,createWebHashHistory&#125; from &#39;vue-router&#39;\n\n\nimport Login from &#39;../components/Login.vue&#39;\nimport Regist from &#39;../components/Regist.vue&#39;\nimport ShowScedule from &#39;../components/ShowSchedule.vue&#39;\n\nlet  router = createRouter(&#123;\n    history:createWebHashHistory(),\n    routes:[\n        &#123;\n            path:&quot;/&quot;,\n            component:Login\n        &#125;,\n        &#123;\n            path:&quot;/login&quot;,\n            component:Login\n        &#125;,\n        &#123;\n            path:&quot;/showSchedule&quot;,\n            component:ShowScedule\n        &#125;,\n        &#123;\n            path:&quot;/regist&quot;,\n            component:Regist\n        &#125;\n\n\n    ]\n&#125;)\n\nexport default router\n配置main.js\n\njavascriptimport &#123; createApp &#125; from &#39;vue&#39;\n\nimport App from &#39;./App.vue&#39;\n\n// 导入路由\nimport router from &#39;./router/router.js&#39;\n\nlet app =createApp(App)\n\n// 全局使用路由\napp.use(router)\n\napp.mount(&#39;#app&#39;)\n\n第六期简要概述\n\n\n\n\n\n\n\n\n\n学习到前端工程化Vue3axios\n本期目标：1：在注册页面用户名栏输入后，对用户名进行校验。2：对注册页面和登陆页面完善，按下按钮后，在后端进行业务处理。3：解决跨域问题\n前端代码处理\n\n创建发送请求的axios对象，注册页面和登录页面发送请求都需要用到。baseURL:&#39;http://localhost:8080/&#39;指定了后端服务器位置\n注册页面\ncheckUsername()向后端的user/checkUsernameUsed发送异步请求，检验用户名是否被占用，再通过返回的数据做出响应\nregist()注册方法：检验输入框是否合法，向后端的user/regist发送异步请求。通过返回的code码来判断是否成功\n\n\n登陆页面\nlogin()登录方法：先检验表单数据格式是否正确，向后端的user/login发送请求，通过返回的code码做出响应\n\n\n\n后端代码处理\n\n重构UserController业务处理代码，详情跳转下方\n\n6.1 前端代码处理6.1.1 创建src&#x2F;utils&#x2F;request.js文件发送请求的axios对象\njavascriptimport axios from &#39;axios&#39;\n\n//  创建instance实例\nconst instance = axios.create(&#123;\n    baseURL:&#39;http://localhost:8080/&#39;\n   \n&#125;)\n\n//  添加请求拦截\ninstance.interceptors.request.use(\n    // 设置请求头配置信息\n    config=&gt;&#123;\n        //处理指定的请求头\n        \n        return config\n    &#125;,\n    // 设置请求错误处理函数\n    error=&gt;&#123;\n    \n        return Promise.reject(error)\n    &#125;\n)\n// 添加响应拦截器\ninstance.interceptors.response.use(\n    // 设置响应正确时的处理函数\n    response=&gt;&#123;\n      \n        return response\n    &#125;,\n    // 设置响应异常时的处理函数\n    error=&gt;&#123;\n        return Promise.reject(error)\n    &#125;\n)\n// 默认导出\nexport default instance6.1.2 注册页面完成注册\n发送异步请求返回的数据用结构表达式&#123;data&#125;接收，这里的数据就是后端的result对象\n点击注册按钮，执行注册方法，检验所有输入框是否合法。因为checkUsername()是async修饰的，所以返回的是promise对象，用await接收结果。\nlet &#123;data&#125; = await request.post(&quot;...&quot;,...)向地址发送数据，返回的结果是一个promise对象，用await转换成response对象，需要的是response的data属性，因此再用解构表达式&#123;data&#125;接收数据。\n\nvue&lt;script setup&gt;\n    import &#123;ref,reactive&#125; from &#39;vue&#39;\n    /* 导入发送请求的axios对象 */\n    import request from&#39;../utils/request&#39;\n\n    import &#123;useRouter&#125; from &#39;vue-router&#39;\n    const router = useRouter()\n\n    let registUser = reactive(&#123;\n        username:&quot;&quot;,\n        userPwd:&quot;&quot;\n    &#125;)\n    let usernameMsg=ref(&#39;&#39;)\n    let userPwdMsg=ref(&#39;&#39;)\n    let reUserPwdMsg=ref(&#39;&#39;)\n    let reUserPwd=ref(&#39;&#39;)\n    async function checkUsername()&#123;\n        let usernameReg= /^[a-zA-Z0-9]&#123;5,10&#125;$/\n        if(!usernameReg.test(registUser.username))&#123;\n            usernameMsg.value=&quot;格式有误&quot;\n            return false\n        &#125;\n        // 发送异步请求   继续校验用户名是否被占用\n        let &#123;data&#125; = await request.post(`user/checkUsernameUsed?username=$&#123;registUser.username&#125;`)\n        if(data.code != 200)&#123;\n            usernameMsg.value=&quot;用户名占用&quot;\n            return false\n        &#125;\n        usernameMsg.value=&quot;可用&quot;\n        return true\n    &#125;\n\n    function checkUserPwd()&#123;\n        let userPwdReg = /^[0-9]&#123;6&#125;$/\n        if(!userPwdReg.test(registUser.userPwd))&#123;\n            userPwdMsg.value=&quot;格式有误&quot;\n            return false\n        &#125;\n        userPwdMsg.value=&quot;OK&quot;\n        return true\n    &#125;\n\n    function checkReUserPwd()&#123;\n        let userPwdReg = /^[0-9]&#123;6&#125;$/\n        if(!userPwdReg.test(reUserPwd.value))&#123;\n            reUserPwdMsg.value=&quot;格式有误&quot;\n            return false\n        &#125;\n        if(registUser.userPwd != reUserPwd.value)&#123;\n            reUserPwdMsg.value=&quot;两次密码不一致&quot;\n            return false\n        &#125;\n        reUserPwdMsg.value=&quot;OK&quot;\n        return true\n    &#125;\n\n    // 注册的方法\n    async function regist()&#123;\n        // 校验所有的输入框是否合法\n        let flag1 =await checkUsername()\n        let flag2 =await checkUserPwd()\n        let flag3 =await checkReUserPwd()\n        if(flag1 &amp;&amp; flag2 &amp;&amp; flag3)&#123;\n          let  &#123;data&#125;= await request.post(&quot;user/regist&quot;,registUser)\n          if(data.code == 200)&#123;\n            // 注册成功跳转 登录页\n            alert(&quot;注册成功,快去登录吧&quot;)\n            router.push(&quot;/login&quot;)\n          &#125;else&#123;\n            alert(&quot;抱歉,用户名被抢注了&quot;)\n          &#125;\n        &#125;else&#123;\n            alert(&quot;校验不通过,请求再次检查数据&quot;)\n        &#125;\n    &#125;\n\n    function clearForm()&#123;\n        registUser.username=&quot;&quot;\n        registUser.userPwd=&quot;&quot;\n        usernameMsg.value=&quot;&quot;\n        userPwdMsg.value=&quot;&quot;\n        reUserPwd.value=&quot;&quot;\n        reUserPwdMsg.value=&quot;&quot;\n\n    &#125;\n\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h3 class=&quot;ht&quot;&gt;请注册&lt;/h3&gt;\n\n    &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;请输入账号&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; \n                  id=&quot;usernameInput&quot; \n                  type=&quot;text&quot; \n                  name=&quot;username&quot; \n                  v-model=&quot;registUser.username&quot;\n                  @blur=&quot;checkUsername()&quot;&gt;\n\n                &lt;span id=&quot;usernameMsg&quot; class=&quot;msg&quot; v-text=&quot;usernameMsg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;请输入密码&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; \n                id=&quot;userPwdInput&quot; \n                type=&quot;password&quot; \n                name=&quot;userPwd&quot; \n                v-model=&quot;registUser.userPwd&quot;\n                @blur=&quot;checkUserPwd()&quot;&gt;\n                &lt;span id=&quot;userPwdMsg&quot; class=&quot;msg&quot; v-text=&quot;userPwdMsg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td&gt;确认密码&lt;/td&gt;\n            &lt;td&gt;\n                &lt;input class=&quot;ipt&quot; \n                id=&quot;reUserPwdInput&quot; \n                type=&quot;password&quot; \n                v-model=&quot;reUserPwd&quot;\n                @blur=&quot;checkReUserPwd()&quot;&gt;\n                &lt;span id=&quot;reUserPwdMsg&quot; class=&quot;msg&quot; v-text=&quot;reUserPwdMsg&quot;&gt;&lt;/span&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=&quot;ltr&quot;&gt;\n            &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt;\n                &lt;input class=&quot;btn1&quot; type=&quot;button&quot; @click=&quot;regist()&quot; value=&quot;注册&quot;&gt;\n                &lt;input class=&quot;btn1&quot; type=&quot;button&quot; @click=&quot;clearForm()&quot; value=&quot;重置&quot;&gt;\n                &lt;router-link to=&quot;/login&quot;&gt;\n                  &lt;button class=&quot;btn1&quot;&gt;去登录&lt;/button&gt;\n                &lt;/router-link&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;style scoped&gt;\n       .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 500px;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:60px;\n            background-color: antiquewhite;\n\n        &#125;\n        .msg &#123;\n            color: gold;\n        &#125;\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n&lt;/style&gt;6.1.3 登录页面完成登录vue&lt;script setup&gt;\n        import &#123;ref,reactive&#125; from &#39;vue&#39;\n        import &#123;useRouter&#125; from &#39;vue-router&#39;\n        const router = useRouter()\n\n        import request  from &#39;../utils/request&#39;\n\n        let loginUser =reactive(&#123;\n                username:&quot;&quot;,\n                userPwd:&quot;&quot;\n        &#125;)\n\n       let usernameMsg =ref(&quot;&quot;)\n       let userPwdMsg =ref(&quot;&quot;)\n\n\n       function checkUsername()&#123;\n            let usernameReg= /^[a-zA-Z0-9]&#123;5,10&#125;$/\n            if(!usernameReg.test(loginUser.username))&#123;\n                usernameMsg.value=&quot;格式有误&quot;\n                return false\n            &#125;\n            usernameMsg.value=&quot;OK&quot;\n            return true\n       &#125;\n\n       function checkUserPwd()&#123;\n            let userPwdReg = /^[0-9]&#123;6&#125;$/\n\n            if(!userPwdReg.test(loginUser.userPwd))&#123;\n                userPwdMsg.value=&quot;格式有误&quot;\n                return false\n            &#125;\n\n            userPwdMsg.value=&quot;OK&quot;\n            return true\n       &#125;\n\n       async function login()&#123;\n            // 表单数据格式都正确再提交\n            let flag1 =checkUsername()\n            let flag2 =checkUserPwd()\n            if(!(flag1 &amp;&amp; flag2))&#123;\n                return \n            &#125;\n           let &#123;data&#125; = await request.post(&quot;user/login&quot;,loginUser)\n           if(data.code == 200 )&#123;\n                alert(&quot;登录成功&quot;)\n                // 跳转到showSchedule\n                router.push(&quot;/showSchedule&quot;)\n           &#125; else if( data.code == 503)&#123;\n                alert(&quot;密码有误&quot;)\n\n           &#125;else if (data.code == 501 )&#123;\n                alert(&quot;用户名有误&quot;)\n           &#125;else &#123;\n                alert(&quot;未知错误&quot;)\n           &#125;\n           \n       &#125;\n\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h3 class=&quot;ht&quot;&gt;请登录&lt;/h3&gt;\n        &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td&gt;请输入账号&lt;/td&gt;\n                &lt;td&gt;\n                    &lt;input class=&quot;ipt&quot; \n                    type=&quot;text&quot; \n                    v-model=&quot;loginUser.username&quot;\n                    @blur=&quot;checkUsername()&quot;&gt;\n                    &lt;span id=&quot;usernameMsg&quot; v-text=&quot;usernameMsg&quot;&gt;&lt;/span&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td&gt;请输入密码&lt;/td&gt;\n                &lt;td&gt;\n                    &lt;input class=&quot;ipt&quot; \n                    type=&quot;password&quot; \n                    v-model=&quot;loginUser.userPwd&quot;\n                    @blur=&quot;checkUserPwd()&quot;&gt;\n                    &lt;span id=&quot;userPwdMsg&quot; v-text=&quot;userPwdMsg&quot;&gt;&lt;/span&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt;\n                    &lt;input class=&quot;btn1&quot; type=&quot;button&quot; @click=&quot;login()&quot; value=&quot;登录&quot;&gt;\n                    &lt;input class=&quot;btn1&quot; type=&quot;button&quot; value=&quot;重置&quot;&gt;\n                    &lt;router-link to=&quot;/regist&quot;&gt;\n                      &lt;button class=&quot;btn1&quot;&gt;去注册&lt;/button&gt;\n                    &lt;/router-link&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/table&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n        .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 500px;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:60px;\n            background-color: antiquewhite;\n        &#125;\n        #usernameMsg , #userPwdMsg &#123;\n            color: gold;\n        &#125;\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n&lt;/style&gt;\n\n6.2 后端代码处理6.2.1 添加跨域处理器6.2.1.1 什么是跨域\n\n\n\n\n\n\n\n\n同源策略（Sameoriginpolicy）是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。**同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号**\n6.2.1.2 为什么会产生跨域\n\n\n\n\n\n\n\n\n前后端分离模式下,客户端请求前端服务器获取视图资源,然后客户端自行向后端服务器获取数据资源,前端服务器的 协议,IP和端口和后端服务器很可能是不一样的,这样就产生了跨域\n\n6.2.1.3 如何解决跨域\n\n\n\n\n\n\n\n\n前端项目代理模式处理\n\n\n\n\n\n\n\n\n\n\n后端跨域过滤器方式处理\n\n\nCrosFilter过滤器\n\njavapackage com.atguigu.schedule.filter;\n\nimport com.atguigu.schedule.common.Result;\nimport com.atguigu.schedule.util.WebUtil;\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebFilter;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\n\n@WebFilter(&quot;/*&quot;)\npublic class CrosFilter implements Filter &#123;\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        System.out.println(request.getMethod());\n        HttpServletResponse response = (HttpServletResponse) servletResponse;\n        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, PUT,OPTIONS, DELETE, HEAD&quot;);\n        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);\n        response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;access-control-allow-origin, authority, content-type, version-info, X-Requested-With&quot;);\n        // 如果是跨域预检请求,则直接在此响应200业务码\n        if(request.getMethod().equalsIgnoreCase(&quot;OPTIONS&quot;))&#123;\n            WebUtil.writeJson(response, Result.ok(null));\n        &#125;else&#123;\n            // 非预检请求,放行即可\n            filterChain.doFilter(servletRequest, servletResponse);\n        &#125;\n    &#125;\n&#125;\n\n未来我们使用框架,直接用一个@CrossOrigin 就可以解决跨域问题了\n\n6.2.2 重构UserController后端代码接收前端发来的JSON参数，通过业务处理，返回JSON串并相应给前端，因此需要做出更改。\njavapackage com.atguigu.schedule.controller;\n\nimport com.atguigu.schedule.common.Result;\nimport com.atguigu.schedule.common.ResultCodeEnum;\nimport com.atguigu.schedule.pojo.SysUser;\nimport com.atguigu.schedule.service.SysUserService;\nimport com.atguigu.schedule.service.impl.SysUserServiceImpl;\nimport com.atguigu.schedule.util.MD5Util;\nimport com.atguigu.schedule.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\n\n@WebServlet(&quot;/user/*&quot;)\npublic class UserController extends BaseController&#123;\n    private SysUserService userService =new SysUserServiceImpl();\n\n\n    /**\n     * 注册时校验用户名是否被占用的业务接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void checkUsernameUsed(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        String username = req.getParameter(&quot;username&quot;);\n        SysUser registUser = userService.findByUsername(username);\n\n        //封装结果对象\n        Result result=null;\n        if(null ==registUser)&#123;\n            // 未占用,创建一个code为200的对象\n            result= Result.ok(null);\n        &#125;else&#123;\n            // 占用, 创建一个结果为505的对象\n            result= Result.build(null, ResultCodeEnum.USERNAME_USED);\n\n        &#125;\n        // 将result对象转换成JSON并响应给客户端\n        WebUtil.writeJson(resp,result);\n\n    &#125;\n\n    /**\n     * 用户注册的业务接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void regist(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 接收要注册的用户信息\n        SysUser registUser = WebUtil.readJson(req, SysUser.class);\n        // 调用服务层方法,将用户注册进入数据库\n        int rows =userService.regist(registUser);\n        Result result =null;\n        if(rows&gt;0)&#123;\n           result=Result.ok(null);\n        &#125;else&#123;\n           result =Result.build(null,ResultCodeEnum.USERNAME_USED);\n        &#125;\n        WebUtil.writeJson(resp,result);\n    &#125;\n\n    /**\n     * 用户登录的业务接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        // 接收用户请求参数\n        // 获取要登录的用户名密码\n        SysUser inputUser = WebUtil.readJson(req, SysUser.class);\n        // 调用服务层方法,根据用户名查询数据库中是否有一个用户\n        SysUser loginUser =userService.findByUsername(inputUser.getUsername());\n\n        Result result = null;\n\n        if(null == loginUser)&#123;\n            // 没有根据用户名找到用户,说明用户名有误\n            result=Result.build(null,ResultCodeEnum.USERNAME_ERROR);\n        &#125;else if(! loginUser.getUserPwd().equals(MD5Util.encrypt(inputUser.getUserPwd())))&#123;\n            // 用户密码有误,\n           result=Result.build(null,ResultCodeEnum.PASSWORD_ERROR);\n        &#125;else&#123;\n            // 登录成功\n            result=Result.ok(null);\n        &#125;\n\n        WebUtil.writeJson(resp,result);\n\n    &#125;\n&#125;\n6.2.3 删除登录校验过滤器\n这里不使用cookie和session方式记录用户状态,未来使用token,所以登录过滤器删除即可\n\n\n第七期简要概述\n\n\n\n\n\n\n\n\n\n学习到前端工程化Vue3pinia。\n本期目标：完善整个系统\n7.1 前端使用pinia存储数据内容详情\n\n设置两个pinia分别存储用户信息(sysUser)和存储用户的日程信息(schedule)。\n完善Header.vue，当sysUser.username不存在时，显示登录和注册，反之显示退出登录和查看日程\n按下退出登录后，将sysUser这个pinia恢复默认并返回登陆页\nLogin.vue中，登录成功后,接收后端响应回来的用户id和用户名,存储于userStore中\n后端中&#x3D;&gt;服务端登录处理方法,登录成功,返回登录用户的信息。\nrouter.js中,通过路由守卫控制只有登录状态下才可以进入showSchedule.vue\n\n\n安装pinia依赖\n\nshellnpm install pinia\nsrc下创建pinia.js文件\n\njavascript// 导入pinia组件\nimport &#123;createPinia&#125; from &#39;pinia&#39;\n// 创建pinia对象\nlet pinia = createPinia()\n// 导出默认的pinia\nexport default pinia\nmain.js中使用pinia\n\njavascriptimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\n// 导入路由\nimport router from &#39;./router/router.js&#39;\n// 导入pinia对象\nimport pinia from &#39;./pinia.js&#39;\nlet app =createApp(App)\n// 全局使用路由\napp.use(router)\n// 全局使用pinia\napp.use(pinia)\napp.mount(&#39;#app&#39;)\nsrc&#x2F;store&#x2F;userStore.js 用于存储用户信息\n\njavascriptimport &#123;defineStore&#125; from &#39;pinia&#39;\n\nexport const defineUser = defineStore(&#39;loginUser&#39;,&#123;\n    state:()=&gt;&#123;\n        return &#123;\n            uid:0,\n            username:&#39;&#39;\n        &#125;\n    &#125;,\n    getters :&#123;\n       \n    &#125;\n\n&#125;)\nsrc&#x2F;store&#x2F;scheduleStore.js 用于存储用户的日程信息\n\njavascriptimport &#123;defineStore&#125; from &#39;pinia&#39;\n\nexport const defineSchedule = defineStore(&#39;scheduleList&#39;,&#123;\n    state:()=&gt;&#123;\n        return &#123;\n            itemList:[\n                /*&#123;\n                    sid:1,\n                    uid:1,\n                    title:&#39;学java&#39;,\n                    completed:1\n                &#125;,\n                &#123;\n                    sid:2,\n                    uid:1,\n                    title:&#39;学前端&#39;,\n                    completed:0\n                &#125;*/\n            ]\n        &#125;\n    &#125;,\n    getters :&#123;\n       \n    &#125;,\n    actions:&#123;\n\n    &#125;\n\n&#125;)\nHeader.vue中,通过pinia的数据来判断展示何种提示 视图\n\nvue&lt;script setup&gt;\n    /* 导入pinia中的user数据 */\n    import &#123;defineUser&#125; from &#39;../store/userStore.js&#39;\n    import &#123;defineSchedule&#125; from &#39;../store/scheduleStore.js&#39;\n    let sysUser =defineUser()\n    let schedule = defineSchedule();\n\n    /* 导入编程式路由 */\n    import &#123;useRouter&#125; from &#39;vue-router&#39;\n    let  router =useRouter()\n    /* 退出登录接口 */\n    function logout()&#123;\n      // 清除userPina 和schedulepinia\n      sysUser.$reset()\n      schedule.$reset()\n      // 通过路由回到登录页\n      router.push(&quot;/login&quot;)\n    &#125;\n\n\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1 class=&quot;ht&quot;&gt;欢迎使用日程管理系统&lt;/h1&gt;\n    &lt;div&gt;\n      &lt;div  class=&quot;optionDiv&quot; v-if=&quot;sysUser.username == &#39;&#39;&quot;&gt;\n        &lt;router-link to=&quot;/login&quot;&gt;\n          &lt;button class=&quot;b1s&quot;&gt;登录&lt;/button&gt;\n        &lt;/router-link&gt;   \n        &lt;router-link to=&quot;/regist&quot;&gt;\n          &lt;button class=&quot;b1s&quot;&gt;注册&lt;/button&gt;\n        &lt;/router-link&gt;\n      &lt;/div&gt;\n\n\n      &lt;div   class=&quot;optionDiv&quot; v-else&gt;\n        欢迎&#123;&#123;sysUser.username&#125;&#125;   \n        &lt;button class=&quot;b1b&quot; @click=&quot;logout()&quot;&gt;退出登录&lt;/button&gt; \n        &lt;router-link to=&quot;/showSchedule&quot;&gt;\n          &lt;button class=&quot;b1b&quot;&gt;查看我的日程&lt;/button&gt;\n        &lt;/router-link&gt;\n      &lt;/div&gt;\n\n      &lt;br&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n  .ht&#123;\n      text-align: center;\n      color: cadetblue;\n      font-family: 幼圆;\n  &#125;\n  .b1s&#123;\n        border: 2px solid powderblue;\n        border-radius: 4px;\n        width:60px;\n        background-color: antiquewhite;\n\n    &#125;\n\n    .b1b&#123;\n        border: 2px solid powderblue;\n        border-radius: 4px;\n        width:100px;\n        background-color: antiquewhite;\n    &#125;\n    .optionDiv&#123;\n      width: 500px;\n      float: right;\n    &#125;\n&lt;/style&gt;\n\n\nLogin.vue中,登录成功后,接收后端响应回来的用户id和用户名,存储于userStore中\n\nvue&lt;script setup&gt;\n        /* 导入pinia中的user数据 */\n        import &#123;defineUser&#125; from &#39;../store/userStore.js&#39;\n        let sysUser =defineUser()\n        /* 获取 编程式路由对象 */\n        import &#123;useRouter&#125; from &#39;vue-router&#39;\n        let router =useRouter();\n        /* 导入axios请求对象 */\n        import request from &#39;../utils/request.js&#39;\n\n       // 导入ref,reactive处理响应式数据的方法\n       import&#123; ref,reactive&#125; from &#39;vue&#39;\n       // 响应式数据,保存用户输入的表单信息\n       let loginUser =reactive(&#123;\n        username:&#39;&#39;,\n        userPwd:&#39;&#39;\n       &#125;)\n\n       // 响应式数据,保存校验的提示信息\n       let usernameMsg =ref(&#39;&#39;)\n       let userPwdMsg = ref(&#39;&#39;)\n\n        // 校验用户名的方法\n        function checkUsername()&#123;\n            // 定义正则\n            var usernameReg=/^[a-zA-Z0-9]&#123;5,10&#125;$/\n            // 校验用户名\n            if(!usernameReg.test(loginUser.username))&#123;\n                // 格式不合法\n                usernameMsg.value=&quot;格式有误&quot;\n                return false\n            &#125;\n            usernameMsg.value=&quot;ok&quot;\n            return true\n        &#125;\n        // 校验密码的方法\n        function checkUserPwd()&#123;\n            // 定义正则\n            var passwordReg=/^[0-9]&#123;6&#125;$/\n             // 校验密码\n             if(!passwordReg.test(loginUser.userPwd))&#123;\n                // 格式不合法\n                userPwdMsg.value=&quot;格式有误&quot;\n                return false\n            &#125;\n            userPwdMsg.value=&quot;ok&quot;\n            return true\n        &#125;\n\n\n        // 登录的函数\n        async function  login()&#123;\n            console.log(&quot;发送异步请求&quot;)\n            let &#123;data&#125; = await request.post(&quot;/user/login&quot;,loginUser)\n            if(data.code == 200)&#123;\n                alert(&quot;登录成功&quot;)\n                // 更新pinia数据\n                sysUser.uid =data.data.loginUser.uid\n                sysUser.username =data.data.loginUser.username\n                // 跳转到日程查询页\n                router.push(&quot;/showSchedule&quot;)\n                \n            &#125;else if(data.code == 501)&#123;\n                alert(&quot;用户名有误,请重新输入&quot;)\n            &#125;else if(data.code == 503)&#123;\n                alert(&quot;密码有误,请重新输入&quot;)\n            &#125;else &#123;\n                alert(&quot;出现未知名错误&quot;)\n            &#125;\n        &#125;\n        // 清除表单信息的方法\n        function clearForm()&#123;\n            loginUser.username=&#39;&#39;\n            loginUser.userPwd=&#39;&#39;\n            usernameMsg.value=&#39;&#39;\n            userPwdMsg.value=&#39;&#39;\n        &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h3 class=&quot;ht&quot;&gt;请登录&lt;/h3&gt;\n        &lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td&gt;请输入账号&lt;/td&gt;\n                &lt;td&gt;\n                    &lt;input class=&quot;ipt&quot; \n                    type=&quot;text&quot; \n                    v-model=&quot;loginUser.username&quot;\n                    @blur=&quot;checkUsername()&quot;&gt;\n                    &lt;span id=&quot;usernameMsg&quot; v-text=&quot;usernameMsg&quot;&gt;&lt;/span&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td&gt;请输入密码&lt;/td&gt;\n                &lt;td&gt;\n                    &lt;input class=&quot;ipt&quot; \n                    type=&quot;password&quot; \n                    v-model=&quot;loginUser.userPwd&quot;\n                    @blur=&quot;checkUserPwd()&quot;&gt;\n                    &lt;span id=&quot;userPwdMsg&quot; v-text=&quot;userPwdMsg&quot;&gt;&lt;/span&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr class=&quot;ltr&quot;&gt;\n                &lt;td colspan=&quot;2&quot; class=&quot;buttonContainer&quot;&gt;\n                    &lt;input class=&quot;btn1&quot; type=&quot;button&quot; @click=&quot;login()&quot; value=&quot;登录&quot;&gt;\n                    &lt;input class=&quot;btn1&quot; type=&quot;button&quot; @click=&quot;clearForm()&quot; value=&quot;重置&quot;&gt;\n                    &lt;router-link to=&quot;/regist&quot;&gt;\n                      &lt;button class=&quot;btn1&quot;&gt;去注册&lt;/button&gt;\n                    &lt;/router-link&gt;\n                &lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/table&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n        .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 500px;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:60px;\n            background-color: antiquewhite;\n        &#125;\n        #usernameMsg , #userPwdMsg &#123;\n            color: gold;\n        &#125;\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n&lt;/style&gt;\n\n\n服务端登录处理方法,登录成功,返回登录用户的信息\n\njava /**\n     * 用户登录的业务接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void login(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n        // 接收用户请求参数\n        // 获取要登录的用户名密码\n        SysUser inputUser = WebUtil.readJson(req, SysUser.class);\n        // 调用服务层方法,根据用户名查询数据库中是否有一个用户\n        SysUser loginUser =userService.findByUsername(inputUser.getUsername());\n\n        Result result = null;\n\n        if(null == loginUser)&#123;\n            // 没有根据用户名找到用户,说明用户名有误\n            result=Result.build(null,ResultCodeEnum.USERNAME_ERROR);\n        &#125;else if(! loginUser.getUserPwd().equals(MD5Util.encrypt(inputUser.getUserPwd())))&#123;\n            // 用户密码有误,\n           result=Result.build(null,ResultCodeEnum.PASSWORD_ERROR);\n        &#125;else&#123;\n            // 登录成功,将用户信息存入session\n            req.getSession().setAttribute(&quot;sysUser&quot;,loginUser);\n            // 登录成功\n            // 将密码请空后,将用户信息响应给客户端\n            loginUser.setUserPwd(&quot;&quot;);\n            Map&lt;String,Object&gt; data =new HashMap&lt;&gt;();\n            data.put(&quot;loginUser&quot;,loginUser);\n            result=Result.ok(data);\n        &#125;\n\n        WebUtil.writeJson(resp,result);\n\n    &#125;\nrouter.js中,通过路由守卫控制只有登录状态下才可以进入showSchedule.vue\n\njavascriptimport &#123;createRouter,createWebHashHistory&#125; from &#39;vue-router&#39;\n\n\nimport pinia from &#39;../pinia.js&#39;\nimport &#123;defineUser&#125; from &#39;../store/userStore.js&#39;\n\nlet sysUser = defineUser(pinia)\n\nimport Login from &#39;../components/Login.vue&#39;\nimport Regist from &#39;../components/Regist.vue&#39;\nimport ShowScedule from &#39;../components/ShowSchedule.vue&#39;\n\nlet  router = createRouter(&#123;\n    history:createWebHashHistory(),\n    routes:[\n        &#123;\n            path:&quot;/&quot;,\n            component:Login\n        &#125;,\n        &#123;\n            path:&quot;/login&quot;,\n            component:Login\n        &#125;,\n        &#123;\n            path:&quot;/showSchedule&quot;,\n            component:ShowScedule\n        &#125;,\n        &#123;\n            path:&quot;/regist&quot;,\n            component:Regist\n        &#125;\n    ]\n&#125;)\n/* 配置路由的前置守卫,在登录状态下才可以范文showSchedule.vue */\nrouter.beforeEach( (to,from,next) =&gt;&#123;\n    // 如果是查看日程\n    if(to.path==&quot;/showSchedule&quot;)&#123;\n        // 如果尚未的登录\n        if(sysUser.username == &#39;&#39;)&#123;\n            alert(&quot;您尚未登录,请登录后再查看日程&quot;)\n            next(&quot;/login&quot;)\n        &#125;else&#123;\n            // 已经登录 放行\n            next()\n        &#125;\n        // 其他资源 放行\n    &#125;else&#123;\n        next()\n    &#125;\n&#125;)\nexport default router7.2 显示所有日程数据内容详情\n\n当用户登录完成跳转到ShowSchedule页面时，应当显示他的所有日程信息\n在第一次挂载就向后端发送请求，获取数据。要使用onMounted\n向后端/schedule/findAllScheduleController层发送用户uid，控制层再根据uid向Service层发送uid，服务层再向DAO层发送uid。\nDAO层执行sql语句返回一个数据对象加载到客户端上，再通过返回的数据进行显示。\n\n\nShowSchedule.vue中向后端发送异步请求查询数据并展示\n\nvue&lt;script setup&gt;\n    /* 引入axios */\n    import request from &#39;../utils/request.js&#39;\n    /* 引入pinia数据 */\n    import &#123;defineSchedule&#125; from &#39;../store/scheduleStore.js&#39;\n    import &#123;defineUser&#125; from &#39;../store/userStore.js&#39;\n    let schedule = defineSchedule();\n    let sysUser = defineUser()\n    /* 引入挂载生命周期 */\n    import &#123; onMounted,onUpdated,ref,reactive &#125; from &#39;vue&#39;;\n    \n    // 第一次挂载就立刻向后端发送请求,获取最新数据\n    onMounted(async function ()&#123;\n        showSchedule()\n    &#125;)\n    async function showSchedule()&#123;\n        let &#123;data&#125; = await request.get(&quot;/schedule/findAllSchedule&quot;,&#123;params:&#123;&quot;uid&quot;:sysUser.uid&#125;&#125;)\n        schedule.itemList =data.data.itemList\n    &#125;\n\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h3 class=&quot;ht&quot;&gt;您的日程如下&lt;/h3&gt;\n&lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n    &lt;tr class=&quot;ltr&quot;&gt;\n        &lt;th&gt;编号&lt;/th&gt;\n        &lt;th&gt;内容&lt;/th&gt;\n        &lt;th&gt;进度&lt;/th&gt;\n        &lt;th&gt;操作&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr class=&quot;ltr&quot; v-for=&quot;item,index in schedule.itemList&quot; :key=&quot;index&quot;&gt;\n        &lt;td v-text=&quot;index+1&quot;&gt;\n        &lt;/td&gt;\n        &lt;td&gt;\n            &lt;input type=&quot;input&quot; v-model=&quot;item.title&quot;&gt;\n        &lt;/td&gt;\n        &lt;td&gt;\n            &lt;input type=&quot;radio&quot;   value=&quot;1&quot; v-model=&quot;item.completed&quot;&gt; 已完成\n            &lt;input type=&quot;radio&quot;   value=&quot;0&quot; v-model=&quot;item.completed&quot;&gt; 未完成\n        &lt;/td&gt;\n        &lt;td class=&quot;buttonContainer&quot;&gt;\n             &lt;button class=&quot;btn1&quot;&gt;删除&lt;/button&gt;\n            &lt;button class=&quot;btn1&quot;&gt;保存修改&lt;/button&gt;\n        &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr class=&quot;ltr buttonContainer&quot; &gt;\n        &lt;td colspan=&quot;4&quot;&gt;\n            &lt;button class=&quot;btn1&quot;&gt;新增日程&lt;/button&gt;\n        &lt;/td&gt;\n\n    &lt;/tr&gt;\n&lt;/table&gt;\n&#123;&#123;schedule&#125;&#125;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n      .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 80%;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:100px;\n            background-color: antiquewhite;\n\n        &#125;\n        #usernameMsg , #userPwdMsg &#123;\n            color: gold;\n        &#125;\n\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n\n&lt;/style&gt;\n\nSysScheduleController中查询数据并响应json\n\njavapackage com.atguigu.schedule.controller;\n\nimport com.atguigu.schedule.common.Result;\nimport com.atguigu.schedule.pojo.SysSchedule;\nimport com.atguigu.schedule.service.SysScheduleService;\nimport com.atguigu.schedule.service.impl.SysScheduleServiceImpl;\nimport com.atguigu.schedule.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@WebServlet(&quot;/schedule/*&quot;)\npublic class SysScheduleController  extends BaseController&#123;\n    private SysScheduleService scheduleService =new SysScheduleServiceImpl();\n    /**\n     * 查询所有日程接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void findAllSchedule(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        int uid = Integer.parseInt(req.getParameter(&quot;uid&quot;));\n        //  调用服务层方法,查询所有日程\n        List&lt;SysSchedule&gt; itemList = scheduleService.findItemListByUid(uid);\n        // 将日程信息装入result,转换JSON给客户端\n        Map&lt;String,Object&gt; data =new HashMap&lt;&gt;();\n        data.put(&quot;itemList&quot;,itemList);\n        WebUtil.writeJson(resp,Result.ok(data));\n    &#125;\n&#125;\n\nSysScheduleService接口和实现类代码\n\njavapackage com.atguigu.schedule.service;\nimport com.atguigu.schedule.pojo.SysSchedule;\nimport java.util.List;\npublic interface SysScheduleService &#123;\n    List&lt;SysSchedule&gt; findItemListByUid(int uid);\n&#125;\n\n// ------------------------------------------------\npackage com.atguigu.schedule.service.impl;\nimport com.atguigu.schedule.dao.SysScheduleDao;\nimport com.atguigu.schedule.dao.impl.SysScheduleDaoImpl;\nimport com.atguigu.schedule.pojo.SysSchedule;\nimport com.atguigu.schedule.service.SysScheduleService;\nimport java.util.List;\npublic class SysScheduleServiceImpl implements SysScheduleService &#123;\n    private SysScheduleDao scheduleDao =new SysScheduleDaoImpl();\n    @Override\n    public List&lt;SysSchedule&gt; findItemListByUid(int uid) &#123;\n        return scheduleDao.findItemListByUid(uid);\n    &#125;\n&#125;\nSysScheduleDao接口和实现类代码\n\njavapackage com.atguigu.schedule.dao;\nimport com.atguigu.schedule.pojo.SysSchedule;\nimport java.util.List;\npublic interface SysScheduleDao &#123;\n    List&lt;SysSchedule&gt; findItemListByUid(int uid);\n&#125;\n//-----------------------------------------------------------\npackage com.atguigu.schedule.dao.impl;\nimport com.atguigu.schedule.dao.BaseDao;\nimport com.atguigu.schedule.dao.SysScheduleDao;\nimport com.atguigu.schedule.pojo.SysSchedule;\nimport java.util.List;\npublic class SysScheduleDaoImpl extends BaseDao implements SysScheduleDao &#123;\n    @Override\n    public List&lt;SysSchedule&gt; findItemListByUid(int uid) &#123;\n        String sql =&quot;select sid,uid,title, completed from sys_schedule  where uid = ? &quot;;\n        return baseQuery(SysSchedule.class,sql,uid);\n    &#125;\n&#125;7.3 增加和保存日程数据内容详情\n\n当用户登录完成跳转到ShowSchedule页面时，可以添加，修改，保存他的日程信息。\n向后端/schedule/业务函数名Controller层发送日程信息的index，控制层再向Service层发送index，服务层再向DAO层发送index\nDAO层根据业务详情执行sql语句处理数据库。\n客户端通过返回的code码判断业务是否成功并且刷新用户的日程信息。\n\n\nShowSchedule.vue下,为增加和修改按钮绑定事件\n\nvue&lt;script setup&gt;\n    /* 引入axios */\n    import request from &#39;../utils/request.js&#39;\n    /* 引入pinia数据 */\n    import &#123;defineSchedule&#125; from &#39;../store/scheduleStore.js&#39;\n    import &#123;defineUser&#125; from &#39;../store/userStore.js&#39;\n    let schedule = defineSchedule();\n    let sysUser = defineUser()\n    /* 引入挂载生命周期 */\n    import &#123; onMounted,onUpdated,ref,reactive &#125; from &#39;vue&#39;;\n    \n    // 第一次挂载就立刻向后端发送请求,获取最新数据\n    onMounted(async function ()&#123;\n        // 加载完毕后,立刻调用查询数据的方法\n        showSchedule()\n    &#125;)\n    async function  showSchedule()&#123;\n        let &#123;data&#125; = await request.get(&quot;/schedule/findAllSchedule&quot;,&#123;params:&#123;&quot;uid&quot;:sysUser.uid&#125;&#125;)\n        schedule.itemList =data.data.itemList\n    &#125;\n\n    // 新增日程\n    async function addItem()&#123;\n        // 立刻向后端发送一个请求,让后端先为当前用户在数据库中增加一个默认格式的空数据\n        let &#123;data&#125; = await request.get(&quot;/schedule/addDefaultSchedule&quot;,&#123;params:&#123;&quot;uid&quot;:sysUser.uid&#125;&#125;)\n        if(data.code == 200)&#123;\n            // 然后调用刷新页面数据方法,立刻获取最新数据\n            showSchedule()\n        &#125;else&#123;\n            alert(&quot;添加异常&quot;)\n        &#125;\n    &#125;\n\n    // 更新日程的方法\n    async function updateItem(index)&#123;\n        // 根据索引获取元素\n        \n        // 将元素通过 JSON串的形式 发送给服务端\n        let &#123;data&#125; =await request.post(&quot;/schedule/updateSchedule&quot;,schedule.itemList[index])\n        if(data.code == 200)&#123;\n            // 服务端修改完毕后,刷新页面数据\n            showSchedule()\n        &#125;else&#123;\n            alert(&quot;更新异常&quot;)\n        &#125;\n\n    &#125;\n\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h3 class=&quot;ht&quot;&gt;您的日程如下&lt;/h3&gt;\n&lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n    &lt;tr class=&quot;ltr&quot;&gt;\n        &lt;th&gt;编号&lt;/th&gt;\n        &lt;th&gt;内容&lt;/th&gt;\n        &lt;th&gt;进度&lt;/th&gt;\n        &lt;th&gt;操作&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr class=&quot;ltr&quot; v-for=&quot;item,index in schedule.itemList&quot; :key=&quot;index&quot;&gt;\n        &lt;td v-text=&quot;index+1&quot;&gt;\n        &lt;/td&gt;\n        &lt;td&gt;\n            &lt;input type=&quot;input&quot; v-model=&quot;item.title&quot;&gt;\n        &lt;/td&gt;\n        &lt;td&gt;\n            &lt;input type=&quot;radio&quot;   value=&quot;1&quot; v-model=&quot;item.completed&quot;&gt; 已完成\n            &lt;input type=&quot;radio&quot;   value=&quot;0&quot; v-model=&quot;item.completed&quot;&gt; 未完成\n        &lt;/td&gt;\n        &lt;td class=&quot;buttonContainer&quot;&gt;\n             &lt;button class=&quot;btn1&quot;&gt;删除&lt;/button&gt;\n            &lt;button class=&quot;btn1&quot; @click=&quot;updateItem(index)&quot;&gt;保存修改&lt;/button&gt;\n        &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr class=&quot;ltr buttonContainer&quot; &gt;\n        &lt;td colspan=&quot;4&quot;&gt;\n            &lt;button class=&quot;btn1&quot; @click=&quot;addItem()&quot;&gt;新增日程&lt;/button&gt;\n        &lt;/td&gt;\n\n    &lt;/tr&gt;\n&lt;/table&gt;\n&#123;&#123;schedule&#125;&#125;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n      .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 80%;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:100px;\n            background-color: antiquewhite;\n\n        &#125;\n        #usernameMsg , #userPwdMsg &#123;\n            color: gold;\n        &#125;\n\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n\n&lt;/style&gt;\n\nSysScheduleController处理 新增和保存修改业务处理接口\n\njavapackage com.atguigu.schedule.controller;\n\nimport com.atguigu.schedule.common.Result;\nimport com.atguigu.schedule.pojo.SysSchedule;\nimport com.atguigu.schedule.service.SysScheduleService;\nimport com.atguigu.schedule.service.impl.SysScheduleServiceImpl;\nimport com.atguigu.schedule.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@WebServlet(&quot;/schedule/*&quot;)\npublic class SysScheduleController  extends BaseController&#123;\n\n    private SysScheduleService scheduleService =new SysScheduleServiceImpl();\n    /**\n     * 向数据库中增加一个新的默认数据的方法\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void addDefaultSchedule(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        int uid = Integer.parseInt(req.getParameter(&quot;uid&quot;));\n        //  调用服务层方法,为当前用户新增一个默认空数据\n        scheduleService.addDefault(uid);\n\n        WebUtil.writeJson(resp,Result.ok(null));\n\n    &#125;\n\n\n    /**\n     * 更新日程业务接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void updateSchedule(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        SysSchedule sysSchedule = WebUtil.readJson(req, SysSchedule.class);\n        // 调用服务层方法,更新数据\n        scheduleService.updateSchedule(sysSchedule);\n\n        // 响应成功\n        WebUtil.writeJson(resp,Result.ok(null));\n    &#125;\n&#125;\n\nSysScheduleService接口和实现类处理业务逻辑\n\njavapackage com.atguigu.schedule.service;\nimport com.atguigu.schedule.pojo.SysSchedule;\nimport java.util.List;\npublic interface SysScheduleService &#123;\n    Integer addDefault(int uid);\n    Integer updateSchedule(SysSchedule sysSchedule);\n&#125;\n// ----------------------------------------------------------\npackage com.atguigu.schedule.service.impl;\n\nimport com.atguigu.schedule.dao.SysScheduleDao;\nimport com.atguigu.schedule.dao.impl.SysScheduleDaoImpl;\nimport com.atguigu.schedule.pojo.SysSchedule;\nimport com.atguigu.schedule.service.SysScheduleService;\n\nimport java.util.List;\n\npublic class SysScheduleServiceImpl implements SysScheduleService &#123;\n    private SysScheduleDao scheduleDao =new SysScheduleDaoImpl();\n    @Override\n    public Integer addDefault(int uid) &#123;\n        return scheduleDao.addDefault(uid);\n    &#125;\n\n    @Override\n    public Integer updateSchedule(SysSchedule sysSchedule) &#123;\n        return scheduleDao.updateSchedule(sysSchedule);\n    &#125;\n&#125;\nSysScheduleDao接口和实现类操作数据\n\njavapackage com.atguigu.schedule.dao;\n\nimport com.atguigu.schedule.pojo.SysSchedule;\n\nimport java.util.List;\n\npublic interface SysScheduleDao &#123;\n    Integer addDefault(int uid);\n    Integer updateSchedule(SysSchedule sysSchedule);\n&#125;\n//-------------------------------------------------\npackage com.atguigu.schedule.dao.impl;\n\nimport com.atguigu.schedule.dao.BaseDao;\nimport com.atguigu.schedule.dao.SysScheduleDao;\nimport com.atguigu.schedule.pojo.SysSchedule;\n\nimport java.util.List;\npublic class SysScheduleDaoImpl extends BaseDao implements SysScheduleDao &#123;\n    @Override\n    public Integer addDefault(int uid) &#123;\n        String sql = &quot;insert into sys_schedule value(default,?,&#39;请输入日程&#39;,0)&quot;;\n        return baseUpdate(sql,uid);\n    &#125;\n\n    @Override\n    public Integer updateSchedule(SysSchedule sysSchedule) &#123;\n        String sql =&quot;update sys_schedule set title = ? ,completed =  ? where sid =?&quot;;\n        return baseUpdate(sql,sysSchedule.getTitle(),sysSchedule.getCompleted(),sysSchedule.getSid());\n    &#125;\n&#125;\n7.5 删除日程数据内容详情\n\n当用户登录完成跳转到ShowSchedule页面时，可以删除他的日程信息。\n向后端/schedule/removeItemController层发送日程信息的sid，控制层再向Service层发送sid，服务层再向DAO层发送sid\nDAO层根据业务详情执行sql语句删除对应sid的数据。\n客户端通过返回的code码判断业务是否成功并且刷新用户的日程信息。\n\n\nShowSchedule.vue中,为删除按钮增加事件\n\nvue&lt;script setup&gt;\n    /* 引入axios */\n    import request from &#39;../utils/request.js&#39;\n    /* 引入pinia数据 */\n    import &#123;defineSchedule&#125; from &#39;../store/scheduleStore.js&#39;\n    import &#123;defineUser&#125; from &#39;../store/userStore.js&#39;\n    let schedule = defineSchedule();\n    let sysUser = defineUser()\n    /* 引入挂载生命周期 */\n    import &#123; onMounted,onUpdated,ref,reactive &#125; from &#39;vue&#39;;\n    \n    // 第一次挂载就立刻向后端发送请求,获取最新数据\n    onMounted(async function ()&#123;\n        // 加载完毕后,立刻调用查询数据的方法\n        showSchedule()\n    &#125;)\n    async function  showSchedule()&#123;\n        let &#123;data&#125; = await request.get(&quot;/schedule/findAllSchedule&quot;,&#123;params:&#123;&quot;uid&quot;:sysUser.uid&#125;&#125;)\n        schedule.itemList =data.data.itemList\n    &#125;\n\n    // 新增日程\n    async function addItem()&#123;\n        // 立刻向后端发送一个请求,让后端先为当前用户在数据库中增加一个默认格式的空数据\n        let &#123;data&#125; = await request.get(&quot;/schedule/addDefaultSchedule&quot;,&#123;params:&#123;&quot;uid&quot;:sysUser.uid&#125;&#125;)\n        if(data.code == 200)&#123;\n            // 然后调用刷新页面数据方法,立刻获取最新数据\n            showSchedule()\n        &#125;else&#123;\n            alert(&quot;添加异常&quot;)\n        &#125;\n    &#125;\n\n    // 更新日程的方法\n    async function updateItem(index)&#123;\n        // 根据索引获取元素\n        \n        // 将元素通过 JSON串的形式 发送给服务端\n        let &#123;data&#125; =await request.post(&quot;/schedule/updateSchedule&quot;,schedule.itemList[index])\n        if(data.code = 200)&#123;\n            // 服务端修改完毕后,刷新页面数据\n            showSchedule()\n        &#125;else&#123;\n            alert(&quot;更新异常&quot;)\n        &#125;\n\n    &#125;\n\n    // 删除日程的方法\n    async function removeItem(index)&#123;\n        // 弹窗提示是否删除\n        if(confirm(&quot;确定要删除该条数据&quot;))&#123;\n            // 根据索引获取要删除的item的id\n            let sid = schedule.itemList[index].sid\n            // 向服务端发送请求删除元素\n            let&#123;data&#125; = await request.get(&quot;/schedule/removeSchedule&quot;,&#123;params:&#123;&quot;sid&quot;:sid&#125;&#125;)\n            //根据业务码判断删除是否成功\n            if(data.code == 200)&#123;\n                // 删除成功,更新数据\n                showSchedule()\n            &#125;else&#123;\n                // 删除失败,提示失败\n                alert(&quot;删除失败&quot;)\n            &#125;\n        &#125;\n    &#125;\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h3 class=&quot;ht&quot;&gt;您的日程如下&lt;/h3&gt;\n&lt;table class=&quot;tab&quot; cellspacing=&quot;0px&quot;&gt;\n    &lt;tr class=&quot;ltr&quot;&gt;\n        &lt;th&gt;编号&lt;/th&gt;\n        &lt;th&gt;内容&lt;/th&gt;\n        &lt;th&gt;进度&lt;/th&gt;\n        &lt;th&gt;操作&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr class=&quot;ltr&quot; v-for=&quot;item,index in schedule.itemList&quot; :key=&quot;index&quot;&gt;\n        &lt;td v-text=&quot;index+1&quot;&gt;\n        &lt;/td&gt;\n        &lt;td&gt;\n            &lt;input type=&quot;input&quot; v-model=&quot;item.title&quot;&gt;\n        &lt;/td&gt;\n        &lt;td&gt;\n            &lt;input type=&quot;radio&quot;   value=&quot;1&quot; v-model=&quot;item.completed&quot;&gt; 已完成\n            &lt;input type=&quot;radio&quot;   value=&quot;0&quot; v-model=&quot;item.completed&quot;&gt; 未完成\n        &lt;/td&gt;\n        &lt;td class=&quot;buttonContainer&quot;&gt;\n             &lt;button class=&quot;btn1&quot;  @click=&quot;removeItem(index)&quot;&gt;删除&lt;/button&gt;\n            &lt;button class=&quot;btn1&quot; @click=&quot;updateItem(index)&quot;&gt;保存修改&lt;/button&gt;\n        &lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr class=&quot;ltr buttonContainer&quot; &gt;\n        &lt;td colspan=&quot;4&quot;&gt;\n            &lt;button class=&quot;btn1&quot; @click=&quot;addItem()&quot;&gt;新增日程&lt;/button&gt;\n        &lt;/td&gt;\n\n    &lt;/tr&gt;\n&lt;/table&gt;\n&#123;&#123;schedule&#125;&#125;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n      .ht&#123;\n            text-align: center;\n            color: cadetblue;\n            font-family: 幼圆;\n        &#125;\n        .tab&#123;\n            width: 80%;\n            border: 5px solid cadetblue;\n            margin: 0px auto;\n            border-radius: 5px;\n            font-family: 幼圆;\n        &#125;\n        .ltr td&#123;\n            border: 1px solid  powderblue;\n\n        &#125;\n        .ipt&#123;\n            border: 0px;\n            width: 50%;\n\n        &#125;\n        .btn1&#123;\n            border: 2px solid powderblue;\n            border-radius: 4px;\n            width:100px;\n            background-color: antiquewhite;\n\n        &#125;\n        #usernameMsg , #userPwdMsg &#123;\n            color: gold;\n        &#125;\n\n        .buttonContainer&#123;\n            text-align: center;\n        &#125;\n\n&lt;/style&gt;\n\nSysScheduleController中添加删除业务接口\n\njavapackage com.atguigu.schedule.controller;\n\nimport com.atguigu.schedule.common.Result;\nimport com.atguigu.schedule.pojo.SysSchedule;\nimport com.atguigu.schedule.service.SysScheduleService;\nimport com.atguigu.schedule.service.impl.SysScheduleServiceImpl;\nimport com.atguigu.schedule.util.WebUtil;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@WebServlet(&quot;/schedule/*&quot;)\npublic class SysScheduleController  extends BaseController&#123;\n\n    private SysScheduleService scheduleService =new SysScheduleServiceImpl();\n\n    /**\n     * 删除日程业务接口\n     * @param req\n     * @param resp\n     * @throws ServletException\n     * @throws IOException\n     */\n    protected void removeSchedule(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 获取要删除的日程id\n        int sid = Integer.parseInt(req.getParameter(&quot;sid&quot;));\n        // 调用服务层方法,删除日程\n        scheduleService.removeSchedule(sid);\n        // 响应200\n        WebUtil.writeJson(resp,Result.ok(null));\n    &#125;\n&#125;\nSysScheduleService层处理删除业务的接口和实现类\n\njavapackage com.atguigu.schedule.service;\n\nimport com.atguigu.schedule.pojo.SysSchedule;\n\nimport java.util.List;\n\npublic interface SysScheduleService &#123;\n    Integer removeSchedule(int sid);\n&#125;\n//------------------------------------------------------------------\npackage com.atguigu.schedule.service.impl;\n\nimport com.atguigu.schedule.dao.SysScheduleDao;\nimport com.atguigu.schedule.dao.impl.SysScheduleDaoImpl;\nimport com.atguigu.schedule.pojo.SysSchedule;\nimport com.atguigu.schedule.service.SysScheduleService;\n\nimport java.util.List;\n\npublic class SysScheduleServiceImpl implements SysScheduleService &#123;\n    private SysScheduleDao scheduleDao =new SysScheduleDaoImpl();\n    @Override\n    public Integer removeSchedule(int sid) &#123;\n        return scheduleDao.removeBySid(sid);\n    &#125;\n&#125;\nSysScheduleDao操作数据库的接口和实现类\n\njavapackage com.atguigu.schedule.dao;\n\nimport com.atguigu.schedule.pojo.SysSchedule;\n\nimport java.util.List;\n\npublic interface SysScheduleDao &#123;\n    Integer removeBySid(int sid);\n&#125;\n//---------------------------------------------------------\npackage com.atguigu.schedule.dao.impl;\n\nimport com.atguigu.schedule.dao.BaseDao;\nimport com.atguigu.schedule.dao.SysScheduleDao;\nimport com.atguigu.schedule.pojo.SysSchedule;\n\nimport java.util.List;\n\npublic class SysScheduleDaoImpl extends BaseDao implements SysScheduleDao &#123;\n    @Override\n    public Integer removeBySid(int sid) &#123;\n        String sql =&quot;delete from sys_schedule where sid = ?&quot;;\n\n        return baseUpdate(sql,sid);\n    &#125;\n&#125;\n\n","slug":"案例开发-日程管理","date":"2024-03-17T08:32:00.000Z","categories_index":"Javaweb","tags_index":"Javaweb","author_index":"白"},{"id":"b6ea38201a58b8772f1aa4c5b53a5d2e","title":"前端工程化笔记","content":"第六章 前端工程化学习笔记一、前端工程化开篇1.1 什么是前端工程化\n\n\n\n\n\n\n\n\n前端工程化是使用软件工程的方法来单独解决前端的开发流程中模块化、组件化、规范化、自动化的问题,其主要目的为了提高效率和降低成本。 \n\n1.2 前端工程化实现技术栈\n\n\n\n\n\n\n\n\n前端工程化实现的技术栈有很多,我们采用ES6+nodejs+npm+Vite+VUE3+router+pinia+axios+Element-plus组合来实现\n\nECMAScript6     ：VUE3中大量使用ES6语法\nNodejs                ：前端项目运行环境\nnpm                    ：依赖下载工具\nvite                      ：前端项目构建工具\nVUE3                   ：优秀的渐进式前端框架\nrouter                 ：通过路由实现页面切换\npinia                   ：通过状态管理实现组件数据传递\naxios                   ：ajax异步请求封装技术实现前后端数据交互\nElement-plus     ：可以提供丰富的快速构建网页的组件仓库\n\n\n二、ECMA6Script2.1. es6的介绍\n\n\n\n\n\n\n\n\nECMAScript 6，简称ES6，是JavaScript语言的一次重大更新。它于2015年发布，是原来的ECMAScript标准的第六个版本。ES6带来了大量的新特性，包括箭头函数、模板字符串、let和const关键字、解构、默认参数值、模块系统等等，大大提升了JavaScript的开发体验。由于VUE3中大量使用了ES6的语法,所以ES6成为了学习VUE3的门槛之一ES6对JavaScript的改进在以下几个方面：\n\n更加简洁：ES6引入了一些新的语法，如箭头函数、类和模板字符串等，使代码更加简洁易懂。\n更强大的功能：ES6引入了一些新的API、解构语法和迭代器等功能，从而使得JavaScript更加强大。\n更好的适用性：ES6引入的模块化功能为JavaScript代码的组织和管理提供了更好的方式，不仅提高了程序的可维护性，还让JavaScript更方便地应用于大型的应用程序。\n\n\n\n\n\n\n\n\n\n\n总的来说，ES6在提高JavaScript的核心语言特性和功能方面取得了很大的进展。由于ES6已经成为了JavaScript的标准，它的大多数新特性都已被现在浏览器所支持，因此现在可以放心地使用ES6来开发前端应用程序。\n历史版本：\n\n\n\n标准版本\n发布时间\n新特性\n\n\n\nES1\n1997年\n第一版 ECMAScript\n\n\nES2\n1998年\n引入setter和getter函数，增加了try&#x2F;catch，switch语句允许字符串\n\n\nES3\n1999年\n引入了正则表达式和更好的字符串处理\n\n\nES4\n取消\n取消，部分特性被ES3.1和ES5继承\n\n\nES5\n2009年\nObject.defineProperty，JSON，严格模式，数组新增方法等\n\n\nES5.1\n2011年\n对ES5做了一些勘误和例行修订\n\n\nES6\n2015年\n箭头函数、模板字符串、解构、let和const关键字、类、模块系统等\n\n\nES2016\n2016年\n数组.includes，指数操作符（**），Array.prototype.fill等\n\n\nES2017\n2017年\n异步函数async&#x2F;await，Object.values&#x2F;Object.entries，字符串填充\n\n\nES2018\n2018年\n正则表达式命名捕获组，几个有用的对象方法，异步迭代器等\n\n\nES2019\n2019年\nArray.prototype.{flat,flatMap}，Object.fromEntries等\n\n\nES2020\n2020年\nBigInt、动态导入、可选链操作符、空位合并操作符\n\n\nES2021\n2021年\nString.prototype.replaceAll，逻辑赋值运算符，Promise.any等\n\n\n… …\n\n\n\n\n2.2 es6的变量和模板字符串\n\n\n\n\n\n\n\n\nES6 新增了let和const，用来声明变量,使用的细节上也存在诸多差异\nlet 和var的差别\n\nlet 不能重复声明\n\nlet有块级作用域，非函数的花括号遇见let会有块级作用域，也就是只能在花括号里面访问。\n\nlet不会预解析进行变量提升\n\nlet 定义的全局变量不会作为window的属性\n\nlet在es6中推荐优先使用\n\nconst就是不可修改的let（像final修饰的变量）\n\n\nhtml&lt;script&gt;\n    //1. let只有在当前代码块有效代码块。代码块、函数、全局\n    &#123;\n      let a = 1\n      var b = 2\n    &#125;   \n    console.log(a);  // a is not defined   花括号外面无法访问\n    console.log(b);  // 可以正常输出\n\n    //2. 不能重复声明\n    let name = &#39;天真&#39;\n    let name = &#39;无邪&#39;\n\n    //3. 不存在变量提升（先声明，在使用）\n    console.log(test) //可以     但是值为undefined\n    var test = &#39;test&#39;\n    console.log(test1) //不可以  let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。\n    let test1 = &#39;test1&#39; \n\n\n    //4、不会成为window的属性   \n    var a = 100\n    console.log(window.a) //100\n    let b = 200\n    console.log(window.b) //undefined\n\n    //5. 循环中推荐使用\n    for (let i = 0; i &lt; 10; i++) &#123;\n      // ...\n    &#125;\n    console.log(i);\n    \n    //6、const就是不可修改的let（像final修饰的变量）\n    let a = 10\n    a = 20\n    const b = 10\n    const PI = 3.14\n    //可行的,因为相当于指向了一个数组地址,只要地址没改变就可以\n    const techers = [&quot;张老师&quot;,&quot;干老师&quot;,&quot;李老师&quot;]\n    //push只是在数组后面添加数据，并没有改变地址\n    techers.push(&quot;陈老师&quot;)\n    //techers = [&quot;&quot;, &quot;&quot;, &quot;&quot;] 就不行\n&lt;/script&gt;const和var的差异\n\n新增const和let类似，只是const定义的变量不能修改\n\n并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。\n\n\nhtml&lt;script&gt;\n    //声明场景语法,建议变量名大写区分\n    const PI = 3.1415926;\n\n    //1.常量声明必须有初始化值\n    //const A ; //报错\n\n    //2.常量值不可以改动\n    //const A  = &#39;atguigu&#39;\n    //A  = &#39;xx&#39; //不可改动\n\n    //3.和let一样，块级作用域\n    &#123;\n        const A = &#39;atguigu&#39;\n        console.log(A);\n    &#125;\n    //console.log(A);\n\n    //4.对应数组和对象元素修改，不算常量修改，修改值，不修改地址\n    const TEAM = [&#39;刘德华&#39;,&#39;张学友&#39;,&#39;郭富城&#39;];\n    TEAM.push(&#39;黎明&#39;);\n    TEAM=[] // 报错\n    console.log(TEAM)\n&lt;/script&gt;\n\n\n\n\n\n\n\n\n模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识  \n\n字符串中可以出现换行符\n\n可以使用 ${xxx} 形式输出变量和拼接变量\n\n\nhtml&lt;script&gt;\n    // 1 多行普通字符串\n    let ulStr =\n        &#39;&lt;ul&gt;&#39;+\n        &#39;&lt;li&gt;JAVA&lt;/li&gt;&#39;+\n        &#39;&lt;li&gt;html&lt;/li&gt;&#39;+\n        &#39;&lt;li&gt;VUE&lt;/li&gt;&#39;+\n        &#39;&lt;/ul&gt;&#39;\n    console.log(ulStr)    \n    // 2 多行模板字符串\n    let ulStr2 = `\n        &lt;ul&gt;\n            &lt;li&gt;JAVA&lt;/li&gt;\n            &lt;li&gt;html&lt;/li&gt;\n            &lt;li&gt;VUE&lt;/li&gt;\n        &lt;/ul&gt;`\n    console.log(ulStr2)        \n    // 3  普通字符串拼接\n    let name =&#39;张小明&#39;\n    let infoStr =name+&#39;被评为本年级优秀学员&#39;  \n    console.log(infoStr)\n    // 4  模板字符串拼接\n    let infoStr2 =`$&#123;name&#125;被评为本年级优秀学员`\n    console.log(infoStr2)\n&lt;/script&gt;2.3 es6的解构表达式\n\n\n\n\n\n\n\n\nES6 的解构赋值是一种方便的语法，可以快速将数组或对象中的值拆分并赋值给变量。解构赋值的语法使用花括号 &#123;&#125; 表示对象，方括号 [] 表示数组。通过解构赋值，函数更方便进行参数接受等！\n\n\n\n\n\n\n\n\n\n数组解构赋值\n\n可以通过数组解构将数组中的值赋值给变量，语法为：\n\njavascriptlet [a, b, c] = [1, 2, 3]; //新增变量名任意合法即可，本质是按照顺序进行初始化变量的值\nconsole.log(a); // 1\nconsole.log(b); // 2\nconsole.log(c); // 3\n该语句将数组 [1, 2, 3] 中的第一个值赋值给 a 变量，第二个值赋值给 b 变量，第三个值赋值给 c 变量。可以使用默认值为变量提供备选值，在数组中缺失对应位置的值时使用该默认值。例如：\n\njavascriptlet [a, b, c, d = 4] = [1, 2, 3];\nconsole.log(d); // 4\n\n\n\n\n\n\n\n\n对象解构赋值\n\n可以通过对象解构将对象中的值赋值给变量，语法为：\n\njavascriptlet &#123;a, b&#125; = &#123;a: 1, b: 2&#125;;\n//新增变量名必须和属性名相同，本质是初始化变量的值为对象中同名属性的值\n//等价于 let a = 对象.a  let b = 对象.b\n  \nconsole.log(a); // 1\nconsole.log(b); // 2\n该语句将对象 {a: 1, b: 2} 中的 a 属性值赋值给 a 变量，b 属性值赋值给 b 变量。可以为标识符分配不同的变量名称，使用 : 操作符指定新的变量名。例如：\n\njavascriptlet &#123;a: x, b: y&#125; = &#123;a: 1, b: 2&#125;;\nconsole.log(x); // 1\nconsole.log(y); // 2\n\n\n\n\n\n\n\n\n函数参数解构赋值\n\n解构赋值也可以用于函数参数。例如：\n\njavascriptfunction add([x, y]) &#123;\n  return x + y;\n&#125;\nadd([1, 2]); // 3\n该函数接受一个数组作为参数，将其中的第一个值赋给 x，第二个值赋给 y，然后返回它们的和。\nES6 解构赋值让变量的初始化更加简单和便捷。通过解构赋值，我们可以访问到对象中的属性，并将其赋值给对应的变量，从而提高代码的可读性和可维护性。\n\n2.4 es6的箭头函数\n\n\n\n\n\n\n\n\nES6 允许使用“箭头” 义函数。语法类似Java中的Lambda表达式\n2.4.1 声明和特点html&lt;script&gt;\n\n    //ES6 允许使用“箭头”（=&gt;）定义函数。\n    //1. 函数声明\n    let fn1 = function()&#123;&#125;\n    let fn2 = ()=&gt;&#123;&#125; //箭头函数,此处不需要书写function关键字\n    let fn3 = x =&gt;&#123;&#125; //单参数可以省略(),多参数无参数不可以!\n    let fn4 = x =&gt; console.log(x) //只有一行方法体可以省略&#123;&#125;;\n    let fun5 = x =&gt; x + 1 //当函数体只有一句返回值时，可以省略花括号和 return 语句\n    //2. 使用特点 箭头函数this关键字\n    // 在 JavaScript 中，this 关键字通常用来引用函数所在的对象，\n    // 或者在函数本身作为构造函数时，来引用新对象的实例。\n    // 但是在箭头函数中，this 的含义与常规函数定义中的含义不同，\n    // 并且是由箭头函数定义时的上下文来决定的，而不是由函数调用时的上下文来决定的。\n    // 箭头函数没有自己的this，this指向的是外层上下文环境的this\n    \n    let person =&#123;\n        name:&quot;张三&quot;,\n        showName:function ()&#123;\n            console.log(this) //  这里的this是person\n            console.log(this.name)\n        &#125;,\n        viewName: () =&gt;&#123;\n            console.log(this) //  这里的this是window\n            console.log(this.name)\n        &#125;\n    &#125;\n    person.showName()\n    person.viewName()\n \n    //this应用\n    function Counter() &#123;\n        this.count = 0;\n        setInterval(() =&gt; &#123;\n            // 这里的 this 是上一层作用域中的 this，即 Counter实例化对象\n            this.count++;\n            console.log(this.count);\n        &#125;, 1000);\n    &#125;\n    let counter = new Counter();\n\n&lt;/script&gt;2.4.2 实践和应用场景html&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n        #xdd&#123;\n            display: inline-block;\n            width: 200px;\n            height: 200px;\n            background-color: red;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;xdd&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n       let xdd = document.getElementById(&quot;xdd&quot;);\n       // 方案1 \n       xdd.onclick = function()&#123;\n            console.log(this)\n            let _this= this;  //this 是xdd\n            //开启定时器\n            setTimeout(function()&#123;\n                console.log(this)\n                //变粉色\n                _this.style.backgroundColor = &#39;pink&#39;;\n            &#125;,2000);\n        &#125;\n        // 方案2\n        xdd.onclick = function()&#123;\n            console.log(this)\n            //开启定时器\n            setTimeout(()=&gt;&#123;\n                console.log(this)// 使用setTimeout() 方法所在环境时的this对象\n                //变粉色\n                this.style.backgroundColor = &#39;pink&#39;;\n            &#125;,2000);\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;2.4.3 rest和spread\n\n\n\n\n\n\n\n\nrest参数,在形参上使用 和JAVA中的可变参数几乎一样\nhtml&lt;script&gt;\n    // 1 参数列表中多个普通参数  普通函数和箭头函数中都支持\n    let fun1 = function (a,b,c,d=10)&#123;console.log(a,b,c,d)&#125;\n    let fun2 = (a,b,c,d=10) =&gt;&#123;console.log(a,b,c,d)&#125;\n    fun1(1,2,3)\n    fun2(1,2,3,4)\n    // 2 ...作为参数列表,称之为rest参数 普通函数和箭头函数中都支持 ,因为箭头函数中无法使用arguments,rest是一种解决方案\n    let fun3 = function (...args)&#123;console.log(args)&#125;\n    let fun4 = (...args) =&gt;&#123;console.log(args)&#125;\n    fun3(1,2,3)\n    fun4(1,2,3,4)\n    // rest参数在一个参数列表中的最后一个只,这也就无形之中要求一个参数列表中只能有一个rest参数\n    //let fun5 =  (...args,...args2) =&gt;&#123;&#125; // 这里报错\n&lt;/script&gt;\n\n\n\n\n\n\n\n\nspread参数,在实参上使用rest\nhtml&lt;script&gt;\n    let arr =[1,2,3]\n    //let arrSpread = ...arr;// 这样不可以,...arr必须在调用方法时作为实参使用\n    let fun1 =(a,b,c) =&gt;&#123;\n        console.log(a,b,c)\n    &#125;\n    // 调用方法时,对arr进行转换 转换为1,2,3 \n    fun1(...arr)\n    //应用场景1 合并数组\n    let arr2=[4,5,6]\n    let arr3=[...arr,...arr2]\n    console.log(arr3)\n    //应用场景2 合并对象属性\n    let p1=&#123;name:&quot;张三&quot;&#125;\n    let p2=&#123;age:10&#125;\n    let p3=&#123;gender:&quot;boy&quot;&#125;\n    let person =&#123;...p1,...p2,...p3&#125;\n    console.log(person)\n\n&lt;/script&gt;2.5 es6的对象创建和拷贝2.5.1 对象创建的语法糖\n\n\n\n\n\n\n\n\nES6中新增了对象创建的语法糖,支持了class extends constructor等关键字,让ES6的语法和面向对象的语法更加接近\njavascriptclass Person&#123;\n      // 属性\n      #n;\t//私有属性。如果使用这个属性，下面this.n都要改为this.#n,否则this.n相当于新建了一个n属性\n      age;\n      get name()&#123;\n          return this.n;\n      &#125;\n      set name(n)&#123;\n          this.n =n;\n      &#125;\n      // 实例方法\n      eat(food)&#123;\n          console.log(this.age+&quot;岁的&quot;+this.n+&quot;用筷子吃&quot;+food)\n      &#125;\n      // 静态方法\n      static sum(a,b)&#123;\n          return a+b;\n      &#125;\n      // 构造器\n      constructor(name,age)&#123;\n          this.n=name;\n          this.age = age;\n\n      &#125;\n  &#125;\n  let person =new Person(&quot;张三&quot;,10); //构造器\n  // 访问对象属性\n  // 调用对象方法\n  console.log(person.name) //访问方法\n  console.log(person.n)\t//访问属性\n  person.name=&quot;小明&quot;\t//设置属性\n  console.log(person.age)\t//访问属性\n  person.eat(&quot;火锅&quot;)\t//实例方法\n  console.log(Person.sum(1,2))\t//静态方法\n  //继承\t\n  class Student extends  Person&#123; \n      grade ;\n      score ;\n      study()&#123;\n\n      &#125;\n      constructor(name,age ) &#123;\n          super(name,age);\n      &#125;\n  &#125;\n\n  let stu =new Student(&quot;学生小李&quot;,18);\n  stu.eat(&quot;面条&quot;)2.5.2  对象的深拷贝和浅拷贝\n\n\n\n\n\n\n\n\n对象的拷贝,快速获得一个和已有对象相同的对象的方式\n\n浅拷贝\n\nhtml&lt;script&gt;\n    let arr  =[&#39;java&#39;,&#39;c&#39;,&#39;python&#39;]\n    let person =&#123;\n        name:&#39;张三&#39;,\n        language:arr\n    &#125;\n    // 浅拷贝,person2和person指向相同的内存\n    let person2 = person;\n    person2.name=&quot;小黑&quot;\n    console.log(person.name)\n&lt;/script&gt;\n深拷贝\n\nhtml&lt;script&gt;\n    let arr  =[&#39;java&#39;,&#39;c&#39;,&#39;python&#39;]\n    let person =&#123;\n        name:&#39;张三&#39;,\n        language:arr\n    &#125;\n    // 深拷贝,通过JSON和字符串的转换形成一个新的对象\n    let person2 = JSON.parse(JSON.stringify(person))\n    person2.name=&quot;小黑&quot;\n    console.log(person.name)\n    console.log(person2.name) \n&lt;/script&gt;2.6 es6的模块化处理2.6.1模块化介绍\n\n\n\n\n\n\n\n\n模块化是一种组织和管理前端代码的方式，将代码拆分成小的模块单元，使得代码更易于维护、扩展和复用。它包括了定义、导出、导入以及管理模块的方法和规范。前端模块化的主要优势如下：\n\n提高代码可维护性：通过将代码拆分为小的模块单元，使得代码结构更为清晰，可读性更高，便于开发者阅读和维护。\n提高代码可复用性：通过将重复使用的代码变成可复用的模块，减少代码重复率，降低开发成本。\n提高代码可扩展性：通过模块化来实现代码的松耦合，便于更改和替换模块，从而方便地扩展功能。\n\n\n\n\n\n\n\n\n\n\n目前，前端模块化有多种规范和实现，包括 CommonJS、AMD 和 ES6 模块化。ES6 模块化是 JavaScript 语言的模块标准，使用 import 和 export 关键字来实现模块的导入和导出。现在，大部分浏览器都已经原生支持 ES6 模块化，因此它成为了最为广泛使用的前端模块化标准. &#96;\n\nES6模块化的几种暴露和导入方式\n分别导出\n统一导出\n默认导出\n\n\nES6中无论以何种方式导出,导出的都是一个对象,导出的内容都可以理解为是向这个对象中添加属性或者方法\n\n2.6.2 分别导出\n\nmodule.js 向外分别暴露成员\n\njavascript//1.分别暴露\n// 模块想对外导出,添加export关键字即可!\n// 导出一个变量\nexport const PI = 3.14\n// 导出一个函数\nexport function sum(a, b) &#123;\n  return a + b;\n&#125;\n// 导出一个类\nexport class Person &#123;\n  constructor(name, age) &#123;\n    this.name = name;\n    this.age = age;\n  &#125;\n  sayHello() &#123;\n    console.log(`Hello, my name is $&#123;this.name&#125;, I&#39;m $&#123;this.age&#125; years old.`);\n  &#125;\n&#125;\napp.js 导入module.js中的成员\n\njavascript/* \n    *代表module.js中的所有成员\n    m1代表所有成员所属的对象\n*/\nimport * as m1 from &#39;./module.js&#39;\n// 使用暴露的属性\nconsole.log(m1.PI)\n// 调用暴露的方法\nlet result =m1.sum(10,20)\nconsole.log(result)\n// 使用暴露的Person类\nlet person =new m1.Person(&#39;张三&#39;,10)\nperson.sayHello()\nindex.html作为程序启动的入口  导入 app.js\n\nhtml&lt;!-- 导入JS文件 添加type=&#39;module&#39; 属性,否则不支持ES6的模块化 --&gt;\n&lt;script src=&quot;./app.js&quot; type=&quot;module&quot; /&gt; 2.6.3 统一导出\n\nmodule.js向外统一导出成员\n\njavascript//2.统一暴露\n// 模块想对外导出,export统一暴露想暴露的内容!\n// 定义一个常量\nconst PI = 3.14\n// 定义一个函数\nfunction sum(a, b) &#123;\n  return a + b;\n&#125;\n// 定义一个类\nclass Person &#123;\n  constructor(name, age) &#123;\n    this.name = name;\n    this.age = age;\n  &#125;\n  sayHello() &#123;\n    console.log(`Hello, my name is $&#123;this.name&#125;, I&#39;m $&#123;this.age&#125; years old.`);\n  &#125;\n&#125;\n// 统一对外导出(暴露)\nexport &#123;\n    PI,\n    sum,\n    Person\n&#125;\napp.js导入module.js中的成员\n\njavascript/* \n    &#123;&#125;中导入要使用的来自于module.js中的成员\n    &#123;&#125;中导入的名称要和module.js中导出的一致,也可以在此处起别名\n    &#123;&#125;中如果定义了别名,那么在当前模块中就只能使用别名\n    &#123;&#125;中导入成员的顺序可以不是暴露的顺序\n    一个模块中可以同时有多个import\n    多个import可以导入多个不同的模块,也可以是同一个模块\n*/\n//import &#123;PI ,Person ,sum &#125;  from &#39;./module.js&#39;\n//import &#123;PI as pi,Person as People,sum as add&#125;  from &#39;./module.js&#39;\nimport &#123;PI ,Person ,sum,PI as pi,Person as People,sum as add&#125;  from &#39;./module.js&#39;\n// 使用暴露的属性\nconsole.log(PI)\nconsole.log(pi)\n// 调用暴露的方法\nlet result1 =sum(10,20)\nconsole.log(result1)\nlet result2 =add(10,20)\nconsole.log(result2)\n// 使用暴露的Person类\nlet person1 =new Person(&#39;张三&#39;,10)\nperson1.sayHello()\nlet person2 =new People(&#39;李四&#39;,11)\nperson2.sayHello()2.6.4 默认导出\n\nmodules混合向外导出\n\njavascript// 3默认和混合暴露\n/* \n    默认暴露语法  export default sum\n    默认暴露相当于是在暴露的对象中增加了一个名字为default的属性\n    三种暴露方式可以在一个module中混合使用\n\n*/\nexport const PI = 3.14\n// 导出一个函数\nfunction sum(a, b) &#123;\n  return a + b;\n&#125;\n// 导出一个类\nclass Person &#123;\n  constructor(name, age) &#123;\n    this.name = name;\n    this.age = age;\n  &#125;\n  sayHello() &#123;\n    console.log(`Hello, my name is $&#123;this.name&#125;, I&#39;m $&#123;this.age&#125; years old.`);\n  &#125;\n&#125;\n\n// 导出默认\nexport default sum\n// 统一导出\nexport &#123;\n   Person\n&#125;\n\napp.js 的default和其他导入写法混用\n\njavascript/* \n    *代表module.js中的所有成员\n    m1代表所有成员所属的对象\n*/\nimport * as m1 from &#39;./module.js&#39;\nimport &#123;default as add&#125; from &#39;./module.js&#39; // 用的少\nimport add2 from &#39;./module.js&#39; // 等效于 import &#123;default as add2&#125; from &#39;./module.js&#39;\n\n// 调用暴露的方法\nlet result =m1.default(10,20)\nconsole.log(result)\nlet result2 =add(10,20)\nconsole.log(result2)\nlet result3 =add2(10,20)\nconsole.log(result3)\n\n// 引入其他方式暴露的内容\nimport &#123;PI,Person&#125; from &#39;./module.js&#39;\n// 使用暴露的Person类\nlet person =new Person(&#39;张三&#39;,10)\nperson.sayHello()\n// 使用暴露的属性\nconsole.log(PI)\n三、前端工程化环境搭建3.1 nodejs的简介和安装3.1.1 什么是Nodejs\n\n\n\n\n\n\n\n\n\n\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，可以使 JavaScript 运行在服务器端。使用 Node.js，可以方便地开发服务器端应用程序，如 Web 应用、API、后端服务，还可以通过 Node.js 构建命令行工具等。相比于传统的服务器端语言（如 PHP、Java、Python 等），Node.js 具有以下特点：\n\n单线程，但是采用了事件驱动、异步 I&#x2F;O 模型，可以处理高并发请求。\n轻量级，使用 C++ 编写的 V8 引擎让 Node.js 的运行速度很快。\n模块化，Node.js 内置了大量模块，同时也可以通过第三方模块扩展功能。\n跨平台，可以在 Windows、Linux、Mac 等多种平台下运行。\n\n\n\n\n\n\n\n\n\n\nNode.js 的核心是其管理事件和异步 I&#x2F;O 的能力。Node.js 的异步 I&#x2F;O 使其能够处理大量并发请求，并且能够避免在等待 I&#x2F;O 资源时造成的阻塞。此外，Node.js 还拥有高性能网络库和文件系统库，可用于搭建 WebSocket 服务器、上传文件等。在 Node.js 中，我们可以使用 JavaScript 来编写服务器端程序，这也使得前端开发人员可以利用自己已经熟悉的技能来开发服务器端程序，同时也让 JavaScript 成为一种全栈语言。Node.js 受到了广泛的应用，包括了大型企业级应用、云计算、物联网、游戏开发等领域。常用的 Node.js 框架包括 Express、Koa、Egg.js 等，它们能够显著提高开发效率和代码质量。\n3.1.2 如何安装nodejs\n打开官网https://nodejs.org/en下载对应操作系统的 LTS 版本。\n双击安装包进行安装，安装过程中遵循默认选项即可(或者参照https://www.runoob.com/nodejs/nodejs-install-setup.html )。安装完成后，可以在命令行终端输入 node -v 和 npm -v 查看 Node.js 和 npm 的版本号。\n\n\n\n定义一个app.js文件,cmd到该文件所在目录,然后在dos上通过node app.js命令即可运行\n\njavascriptfunction sum(a,b)&#123;\n    return a+b;\n&#125;\nfunction main()&#123;\n    console.log(sum(10,20))\n&#125;\nmain()3.2 npm 配置和使用3.2.1 npm介绍\n\n\n\n\n\n\n\n\n\nNPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于后端的Maven 。\n3.2.2 npm 安装和配置\n\n\n\n\n\n\n\n\n1.安装\n\n安装node，自动安装npm包管理工具！\n\n\n\n\n\n\n\n\n\n\n2.配置依赖下载使用阿里镜像\n\nnpm 安装依赖包时默认使用的是官方源，由于国内网络环境的原因，有时会出现下载速度过慢的情况。为了解决这个问题，可以配置使用阿里镜像来加速 npm 的下载速度，具体操作如下：\n打开命令行终端，执行以下命令，配置使用阿里镜像：\n原来的 registry.npm.taobao.org 已替换为 registry.npmmirror.com\n\nshellnpm config set registry https://registry.npmmirror.com\n确认配置已生效，可以使用以下命令查看当前 registry 的配置：如果输出结果为 https://registry.npmmirror.com，说明配置已成功生效。\n\nshellnpm config get registry\n如果需要恢复默认的官方源，可以执行以下命令：\n\nshellnpm config set registry https://registry.npmjs.org/\n\n\n\n\n\n\n\n\n3.配置全局依赖下载后存储位置\n\n在 Windows 系统上，npm 的全局依赖默认安装在 &lt;用户目录&gt;\\AppData\\Roaming\\npm 目录下。\n\n如果需要修改全局依赖的安装路径，可以按照以下步骤操作：\n\n创建一个新的全局依赖存储目录，例如 D:\\GlobalNodeModules。\n\n打开命令行终端，执行以下命令来配置新的全局依赖存储路径：\nshellnpm config set prefix &quot;D:\\GlobalNodeModules&quot;\n确认配置已生效，可以使用以下命令查看当前的全局依赖存储路径：\nshellnpm config get prefix\n\n\n\n\n\n\n\n\n\n\n\n\n4.升级npm版本\n\ncmd 输入npm -v 查看版本\n\n如果node中自带的npm版本过低！则需要升级至9.6.6！\n\n\nshellnpm install -g npm@9.6.63.2.3 npm 常用命令\n\n\n\n\n\n\n\n\n1.项目初始化\n\nnpm init\n进入一个vscode创建好的项目中, 执行 npm init 命令后，npm 会引导您在命令行界面上回答一些问题,例如项目名称、版本号、作者、许可证等信息，并最终生成一个package.json 文件。package.json信息会包含项目基本信息！类似maven的pom.xml\n\n\nnpm init -y\n执行，-y yes的意思，所有信息使用当前文件夹的默认值！不用挨个填写！\n\n\n\n\n\n\n\n\n\n\n\n\n2.安装依赖  (查看所有依赖地址  https://www.npmjs.com )\n\nnpm install 包名 或者 npm install 包名@版本号\n安装包或者指定版本的依赖包(安装到当前项目中)\n\n\nnpm install -g 包名\n安装全局依赖包(安装到d:&#x2F;GlobalNodeModules)则可以在任何项目中使用它，而无需在每个项目中独立安装该包。\n\n\nnpm install\n安装package.json中的所有记录的依赖\n\n\n\n\n\n\n\n\n\n\n\n\n3.升级依赖\n\nnpm update 包名\n将依赖升级到最新版本\n\n\n\n\n\n\n\n\n\n\n\n\n4.卸载依赖\n\nnpm uninstall 包名\n\n\n\n\n\n\n\n\n\n\n5.查看依赖\n\nnpm ls\n\n查看项目依赖\n\n\nnpm list -g\n\n查看全局依赖\n\n\n\n\n\n\n\n\n\n\n\n\n6.运行命令\n\nnpm run 命令是在执行 npm 脚本时使用的命令。npm 脚本是一组在 package.json 文件中定义的可执行命令。npm 脚本可用于启动应用程序，运行测试，生成文档等，还可以自定义命令以及配置需要运行的脚本。\n在 package.json 文件中，scripts 字段是一个对象，其中包含一组键值对，键是要运行的脚本的名称，值是要执行的命令。\n\n例如，以下是一个简单的 package.json 文件：\njson&#123;\n    &quot;name&quot;: &quot;my-app&quot;,\n      &quot;version&quot;: &quot;1.0.0&quot;,\n    &quot;scripts&quot;: &#123;\n        &quot;start&quot;: &quot;node index.js&quot;,\n        &quot;test&quot;: &quot;jest&quot;,\n        &quot;build&quot;: &quot;webpack&quot;\n    &#125;,\n    &quot;dependencies&quot;: &#123;\n        &quot;express&quot;: &quot;^4.17.1&quot;,\n        &quot;jest&quot;: &quot;^27.1.0&quot;,\n        &quot;webpack&quot;: &quot;^5.39.0&quot;\n    &#125;\n&#125;代码说明\n\nscripts 对象包含 start、test 和 build 三个脚本。当您运行 npm run start 时，将运行 node index.js，并启动应用程序。同样，运行 npm run test 时，将运行 Jest 测试套件，而 npm run build 将运行 webpack 命令以生成最终的构建输出。\n总之，npm run 命令为您提供了一种在 package.json 文件中定义和管理一组指令的方法，可以在项目中快速且灵活地运行各种操作。\n\n\n四、Vue3简介和快速体验4.1 Vue3介绍\n\n\n\n\n\n\n\n\nVue (发音为 &#x2F;vjuː&#x2F;，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。官网为:https://cn.vuejs.org/\n Vue的两个核心功能：\n\n声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。\n响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM\n\n4.2 Vue3快速体验(非工程化方式)html&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n        &lt;title&gt;Document&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;!-- 这里也可以用浏览器打开连接,然后将获得的文本单独保存进入一个vue.js的文件,导入vue.js文件即可 --&gt;\n        &lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;\n        &lt;div id=&quot;app&quot;&gt;\n            &lt;!-- 给style属性绑定colorStyle数据 --&gt;\n            &lt;!-- &#123;&#123;插值表达式 直接将数据放在该位置&#125;&#125; --&gt;\n           &lt;h1 v-bind:style=&quot;colorStyle&quot;&gt;&#123;&#123;headline&#125;&#125;&lt;/h1&gt;\n           &lt;!-- v-text设置双标签中的文本 --&gt;\n           &lt;p v-text=&quot;article&quot;&gt;&lt;/p&gt;\n           &lt;!-- 给type属性绑定inputType数据 --&gt;\n           &lt;input v-bind:type =&quot;inputType&quot; value=&quot;helloVue3&quot;&gt; &lt;br&gt;\n           &lt;!-- 给按钮单击事件绑定函数 --&gt;\n           &lt;button  @click=&quot;sayHello()&quot;&gt;hello&lt;/button&gt;\n        &lt;/div&gt;\n\n        &lt;script&gt;\n            //组合api\n            const app = Vue.createApp(&#123;\n                // 在setup内部自由声明数据和方法即可!最终返回!\n                setup()&#123;\n                    //定义数据\n                    //在VUE中实现DOM的思路是: 通过修改修数据而影响页面元素\n                    // vue3中,数据默认不是响应式的,需要加ref或者reactive处理,后面会详细讲解\n                    let inputType =&#39;text&#39;\n                    let headline =&#39;hello vue3&#39;\n                    let article =&#39;vue is awesome&#39;  \n                    let colorStyle =&#123;&#39;color&#39;:&#39;red&#39;&#125;        \n                    // 定义函数\n                    let sayHello =()=&gt;&#123;\n                        alert(&quot;hello Vue&quot;)\n                    &#125;\n                    //在setup函数中,return返回的数据和函数可以在html使用\n                    return &#123;\n                       inputType,\n                       headline,\n                       article,\n                       colorStyle,\n                       sayHello\n                    &#125;\n                &#125;\n            &#125;);\n            //挂载到视图\n            app.mount(&quot;#app&quot;);\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n五、Vue3通过Vite实现工程化5.1 Vite的介绍\n\n\n\n\n\n\n\n\n\n\n在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。时过境迁，我们见证了诸如 webpack、Rollup 和 Parcel 等工具的变迁，它们极大地改善了前端开发者的开发体验\n\n当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。\n包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈：通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。\n\n\n\n\n\n\n\n\n\n\nVite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。https://cn.vitejs.dev/guide/why.html前端工程化的作用包括但不限于以下几个方面：\n\n快速创建项目：使用脚手架可以快速搭建项目基本框架，避免从零开始搭建项目的重复劳动和繁琐操作，从而节省时间和精力。\n统一的工程化规范：前端脚手架可以预设项目目录结构、代码规范、git提交规范等统一的工程化规范，让不同开发者在同一个项目上编写出风格一致的代码，提高协作效率和质量。\n代码模板和组件库：前端脚手架可以包含一些常用的代码模板和组件库，使开发者在实现常见功能时不再重复造轮子，避免因为轮子质量不高带来的麻烦，能够更加专注于项目的业务逻辑。\n自动化构建和部署：前端脚手架可以自动进行代码打包、压缩、合并、编译等常见的构建工作，可以通过集成自动化部署脚本，自动将代码部署到测试、生产环境等。\n\n5.2 Vite创建Vue3工程化项目5.2.1 Vite+Vue3项目的创建、启动、停止\n\n\n\n\n\n\n\n\n1 使用命令行创建工程\n\n在磁盘的合适位置上,创建一个空目录用于存储多个前端项目\n用vscode打开该目录\n在vocode中打开命令行运行如下命令\n\nshellnpm create vite@latest\n第一次使用vite时会提示下载vite,输入y回车即可,下次使用vite就不会出现了\n\n\n\n注意： 选择vue+JavaScript选项即可\n\n\n\n\n\n\n\n\n\n\n2 安装项目所需依赖\n\ncd进入刚刚创建的项目目录\nnpm install命令安装基础依赖\n\nshellcd ./vue3-demo1\nnpm install\n\n\n\n\n\n\n\n\n3 启动项目\n\n查看项目下的package.json\n\njson&#123;\n  &quot;name&quot;: &quot;vue3-demo1&quot;,\n  &quot;private&quot;: true,\n  &quot;version&quot;: &quot;0.0.0&quot;,\n  &quot;type&quot;: &quot;module&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;vite&quot;,\n    &quot;build&quot;: &quot;vite build&quot;,\n    &quot;preview&quot;: &quot;vite preview&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;bootstrap&quot;: &quot;^5.2.3&quot;,\n    &quot;sass&quot;: &quot;^1.62.1&quot;,\n    &quot;vue&quot;: &quot;^3.2.47&quot;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@vitejs/plugin-vue&quot;: &quot;^4.1.0&quot;,\n    &quot;vite&quot;: &quot;^4.3.2&quot;\n  &#125;\n&#125;shellnpm run dev\n\n\n\n\n\n\n\n\n\n5 停止项目\n\n命令行上 ctrl+c\n\n5.2.2 Vite+Vue3项目的目录结构\n\n\n\n\n\n\n\n\n1.下面是 Vite 项目结构和入口的详细说明：\n\n\npublic&#x2F; 目录：用于存放一些公共资源，如 HTML 文件、图像、字体等，这些资源会被直接复制到构建出的目标目录中。\nsrc&#x2F; 目录：存放项目的源代码，包括 JavaScript、CSS、Vue 组件、图像和字体等资源。在开发过程中，这些文件会被 Vite 实时编译和处理，并在浏览器中进行实时预览和调试。以下是src内部划分建议：\nassets/ 目录：用于存放一些项目中用到的静态资源，如图片、字体、样式文件等。\ncomponents/ 目录：用于存放组件相关的文件。组件是代码复用的一种方式，用于抽象出一个可复用的 UI 部件，方便在不同的场景中进行重复使用。\nlayouts/ 目录：用于存放布局组件的文件。布局组件通常负责整个应用程序的整体布局，如头部、底部、导航菜单等。\npages/ 目录：用于存放页面级别的组件文件，通常是路由对应的组件文件。在这个目录下，可以创建对应的文件夹，用于存储不同的页面组件。\nplugins/ 目录：用于存放 Vite 插件相关的文件，可以按需加载不同的插件来实现不同的功能，如自动化测试、代码压缩等。\nrouter/ 目录：用于存放 Vue.js 的路由配置文件，负责管理视图和 URL 之间的映射关系，方便实现页面之间的跳转和数据传递。\nstore/ 目录：用于存放 Vuex 状态管理相关的文件，负责管理应用程序中的数据和状态，方便统一管理和共享数据，提高开发效率。\nutils/ 目录：用于存放一些通用的工具函数，如日期处理函数、字符串操作函数等。\n\n\nvite.config.js 文件：Vite 的配置文件，可以通过该文件配置项目的参数、插件、打包优化等。该文件可以使用 CommonJS 或 ES6 模块的语法进行配置。\npackage.json 文件：标准的 Node.js 项目配置文件，包含了项目的基本信息和依赖关系。其中可以通过 scripts 字段定义几个命令，如 dev、build、serve 等，用于启动开发、构建和启动本地服务器等操作。\nVite 项目的入口为 src/main.js 文件，这是 Vue.js 应用程序的启动文件，也是整个前端应用程序的入口文件。在该文件中，通常会引入 Vue.js 及其相关插件和组件，同时会创建 Vue 实例，挂载到 HTML 页面上指定的 DOM 元素中。\n\n\n\n\n\n\n\n\n\n\n 2.vite的运行界面\n\n在安装了 Vite 的项目中，可以在 npm scripts 中使用 vite 可执行文件，或者直接使用 npx vite 运行它。下面是通过脚手架创建的 Vite 项目中默认的 npm scripts：(package.json)\n\njson&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;vite&quot;, // 启动开发服务器，别名：`vite dev`，`vite serve`\n    &quot;build&quot;: &quot;vite build&quot;, // 为生产环境构建产物\n    &quot;preview&quot;: &quot;vite preview&quot; // 本地预览生产构建产物\n  &#125;\n&#125;\n运行设置端口号：(vite.config.js)\n\njavascript//修改vite项目配置文件 vite.config.js\nexport default defineConfig(&#123;\n  plugins: [vue()],\n  server:&#123;\n    port:3000\n  &#125;\n&#125;)5.2.3 Vite+Vue3项目组件(SFC入门)\n\n\n\n\n\n\n\n\n什么是VUE的组件?\n\n一个页面作为整体,是由多个部分组成的,每个部分在这里就可以理解为一个组件\n每个.vue文件就可以理解为一个组件,多个.vue文件可以构成一个整体页面\n组件化给我们带来的另一个好处就是组件的复用和维护非常的方便\n\n\n\n\n\n\n\n\n\n\n\n什么是.vue文件?\n\n传统的页面有.html文件.css文件和.js文件三个文件组成(多文件组件) \n\nvue将这文件合并成一个.vue文件(Single-File Component，简称 SFC,单文件组件)\n\n.vue文件对js&#x2F;css&#x2F;html统一封装,这是VUE中的概念 该文件由三个部分组成    &lt;script&gt;    &lt;template&gt;    &lt;style&gt;\n\ntemplate标签     ：代表组件的html部分代码\t代替传统的.html文件\nscript标签           ：代表组件的js代码 代替传统的.js文件\nstyle标签            ：代表组件的css样式代码 代替传统的.css文件\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n工程化vue项目如何组织这些组件?\n\nindex.html是项目的入口,其中 &lt;div id =&#39;app&#39;&gt;&lt;/div&gt;是用于挂载所有组建的元素\nindex.html中的script标签引入了一个main.js文件,具体的挂载过程在main.js中执行\nmain.js是vue工程中非常重要的文件,他决定这项目使用哪些依赖,导入的第一个组件\nApp.vue是vue中的核心组件,所有的其他组件都要通过该组件进行导入,该组件通过路由可以控制页面的切换\n\n\n5.2.4 Vite+Vue3响应式入门和setup函数简要说明\n\n响应式数据：在数据变化时，vue框架会将变量最新的值更新到dom树中，页面数据就是实时最新的\n非响应式数据：在数据变化时，vue框架不会将变量最新的值更新到dom树中，页面数据就不是实时最新的\nvue2中，数据不做特殊处理，默认就是响应式的\nvue3中，数据要经过ref/reactive函数的处理才是响应式的(需要从vue框架导入)\nref处理的响应式数据，在操作时需要注意。在script标签中，操作ref的响应式数据需要通过.value的形式操作\n在template标签中，操作ref的响应式数据，无需使用.value\n\n\n&lt;script type = &quot;module&quot; setup&gt;通过setup关键字可以省略export default &#123;setup() &#123; return&#123;&#125;&#125;&#125;这些冗余的语法结构\n\n\n\n\n\n\n\n\n\n\n1 使用vite创建一个 vue+JavaScript项目\nshellnpm create vite\nnpm install \nnpm run dev\nApp.vue\n\nvue&lt;script&gt;\n    //存储vue页面逻辑js代码\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;!-- 页面的样式的是html代码--&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n    /** 存储的是css代码! &lt;style scoped&gt; 是 Vue.js 单文件组件中用于设置组件样式的一种方式。\n    它的含义是将样式局限在当前组件中，不对全局样式造成影响。 */\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n2 vue3响应式数据入门\nvue&lt;script type=&quot;module&quot;&gt;\n    //存储vue页面逻辑js代码\n    import &#123;ref&#125; from &#39;vue&#39;\n    export default&#123;\n        setup()&#123;\n            //非响应式数据: 修改后VUE不会更新DOM\n            //响应式数据:   修改后VUE会更新DOM\n            //VUE2中数据默认是响应式的\n            //VUE3中数据要经过ref或者reactive处理后才是响应式的\n            //ref是VUE3框架提供的一个函数,需要导入\n            //let counter = 1\n            //ref处理的响应式数据在js编码修改的时候需要通过.value操作\n            //ref响应式数据在绑定到html上时不需要.value\n\n            let counter = ref(1)\n            function increase()&#123;\n                // 通过.value修改响应式数据\n                counter.value++\n            &#125;\n            function decrease()&#123;\n                counter.value--\n            &#125;\n            return &#123;\n                counter,\n                increase,\n                decrease\n            &#125;\n        &#125;\n    &#125;\n&lt;/script&gt;\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;button @click=&quot;decrease()&quot;&gt;-&lt;/button&gt;\n      &#123;&#123; counter &#125;&#125;\n      &lt;button @click=&quot;increase()&quot;&gt;+&lt;/button&gt;\n    &lt;/div&gt;\n    \n&lt;/template&gt;\n\n&lt;style scoped&gt;\n    button&#123;\n        border: 1px solid red;\n    &#125;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n3 vue3 setup函数和语法糖\n\n位置：src&#x2F;App.vue\n\nvue&lt;script type=&quot;module&quot; setup&gt;\n   \n/* &lt;script type=&quot;module&quot; setup&gt; 通过setup关键字\n可以省略 export default &#123;setup()&#123;   return&#123;&#125;&#125;&#125;这些冗余的语法结构 */\n    import &#123;ref&#125; from &#39;vue&#39;\n    // 定义响应式数据\n    let counter = ref(1)\n    // 定义函数\n    function increase()&#123;\n        counter.value++\n    &#125;\n    function decrease()&#123;\n        counter.value--\n    &#125;\n    \n&lt;/script&gt;\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;button @click=&quot;decrease()&quot;&gt;-&lt;/button&gt;\n      &#123;&#123; counter &#125;&#125;\n      &lt;button @click=&quot;increase()&quot;&gt;+&lt;/button&gt;\n    &lt;/div&gt;\n    \n&lt;/template&gt;\n\n&lt;style scoped&gt;\n    button&#123;\n        border: 1px solid red;\n    &#125;\n&lt;/style&gt;\n5.2.5 Vite+Vue3关于样式的导入方式\n全局引入main.js\njavascriptimport &#39;./style/reset.css&#39; //书写引入的资源的相对路径即可！\nvue文件script代码处引入\njavascriptimport &#39;./style/reset.css&#39;\nVue文件style代码处引入\njavascript@import &#39;./style/reset.css&#39;\n\n5.2.6 关于JS和TS选择的问题\n\n\n\n\n\n\n\n\nTS是JS的一个超集,使用TS之后,JS的语法更加的像JAVA,实际开发中用的确实更多,那么这里为什么我们没有立即使用TS进行开发,原因如下\n\n为了降低难度,提高前端工程化的效率\n\n对于学JAVA的我们来说,学习TS非常容易,但是还是需要一些时间\n\nTS不是非学不可,不用TS仍然可以正常开发工程化的前端项目\n\n尚硅谷已经发布了TS的专项课程,请大家在B站上自行搜索 “尚硅谷  TS” \n\n建议大家先学完完整的前端工程化内容,然后再根据需求单独学习TS即可\n\n\n\n六、Vue3视图渲染技术6.1 模版语法\n\n\n\n\n\n\n\n\nVue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。\n6.1.1 插值表达式和文本渲染\n\n\n\n\n\n\n\n\n插值表达式:最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 ,即双大括号&#123;&#123;&#125;&#125;\n插值表达式注意事项\n\n插值表达式是将数据渲染到元素的指定位置的手段之一\n插值表达式不绝对依赖标签,其位置相对自由\n插值表达式中支持javascript的运算表达式\n插值表达式中也支持函数的调用\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n  let msg =&quot;hello vue3&quot;\n  let getMsg= ()=&gt;&#123;\n    return &#39;hello vue3 message&#39;\n  &#125;\n  let age = 19\n  let bee = &#39;蜜 蜂&#39;\n  // 购物车\n  const carts = [&#123;name:&#39;可乐&#39;,price:3,number:10&#125;,&#123;name:&#39;薯片&#39;,price:6,number:8&#125;];\n  //计算购物车总金额\n  function compute()&#123;\n      let count = 0;\n      for(let index in carts)&#123;\n          count += carts[index].price*carts[index].number;\n      &#125;\n      return count;\n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;\n    msg的值为: &#123;&#123; msg &#125;&#125; &lt;br&gt;\n    getMsg返回的值为:&#123;&#123; getMsg() &#125;&#125;  &lt;br&gt;\n    是否成年: &#123;&#123; age>=18?'true':'false' &#125;&#125; &lt;br&gt;\n    反转: &#123;&#123; bee.split(' ').reverse().join('-') &#125;&#125; &lt;br&gt;\n    购物车总金额: &#123;&#123; compute() &#125;&#125; &lt;br/&gt;\n    购物车总金额: &#123;&#123;carts[0].price*carts[0].number + carts[1].price*carts[1].number&#125;&#125; &lt;br&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n为了渲染双标中的文本,我们也可以选择使用v-text和v-html命令\nv-***注意事项\n\nv-***这种写法的方式使用的是vue的命令\nv-***的命令必须依赖元素,并且要写在元素的开始标签中\nv-***指令支持ES6中的字符串模板\nv-***的命令支持javascript的运算表达式\nv-***的命令支持常见对象API的调用\nv-***的命令中也支持函数的调用\n\nv-***和插值表达式的区别 \n\nv-text可以将数据渲染成双标签中间的文本,但是不识别html元素结构的文本\nv-html可以将数据渲染成双标签中间的文本,识别html元素结构的文本\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n  let msg =&#39;hello vue3&#39;\n  let getMsg= ()=&gt;&#123;\n    return msg\n  &#125;\n  let age = 19\n  let bee = &#39;蜜 蜂&#39;\n  &lt;!--含有html元素结构，要用v-html渲染，如下--&gt;\n  let redMsg =&#39;&lt;font color=\\&#39;red\\&#39;&gt;msg&lt;/font&gt;&#39;\n  let greenMsg =`&lt;font color=\\&#39;green\\&#39;&gt;$&#123;msg&#125;&lt;/font&gt;`\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;span v-text=&#39;msg&#39;&gt;&lt;/span&gt; &lt;br&gt;\n    &lt;span v-text=&#39;redMsg&#39;&gt;&lt;/span&gt; &lt;br&gt;\n      &lt;!--函数调用--&gt;\n    &lt;span v-text=&#39;getMsg()&#39;&gt;&lt;/span&gt; &lt;br&gt;\n    &lt;span v-text=&#39;age&gt;18?&quot;成年&quot;:&quot;未成年&quot;&#39;&gt;&lt;/span&gt; &lt;br&gt;\n      &lt;!--常见API调用--&gt;\n    &lt;span v-text=&#39;bee.split(&quot; &quot;).reverse().join(&quot;-&quot;)&#39;&gt;&lt;/span&gt; &lt;br&gt;\n    &lt;span v-html=&#39;msg&#39;&gt;&lt;/span&gt; &lt;br&gt;\n    &lt;span v-html=&#39;redMsg&#39;&gt;&lt;/span&gt; &lt;br&gt;\n      &lt;!--支持模版字符串--&gt;\n    &lt;span v-html=&#39;greenMsg&#39;&gt;&lt;/span&gt; &lt;br&gt;\n    &lt;span v-html=&quot;`&lt;font color=&#39;green&#39;&gt;$&#123;msg&#125;&lt;/font&gt;`&quot;&gt;&lt;/span&gt; &lt;br&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;6.1.2 Attribute属性渲染\n\n\n\n\n\n\n\n\n想要渲染一个元素的 attribute，应该使用 v-bind指令\nAttribute属性渲染注意事项\n\n由于插值表达式不能直接放在标签的属性中,所有要渲染元素的属性就应该使用v-bind\nv-bind可以用于渲染任何元素的属性,语法为 v-bind:属性名=&#39;数据名&#39;, 可以简写为 :属性名=&#39;数据名&#39;\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n  const data = &#123;\n    name:&#39;尚硅谷&#39;,\n    url:&quot;http://www.atguigu.com&quot;,\n    logo:&quot;http://www.atguigu.com/images/index_new/logo.png&quot;\n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;a \n      v-bind:href=&#39;data.url&#39; \n      target=&quot;_self&quot;&gt;\n      &lt;img \n        :src=&quot;data.logo&quot; \n        :title=&quot;data.name&quot;&gt;\n      &lt;br&gt;\n      &lt;input type=&quot;button&quot; \n             :value=&quot;`点击访问$&#123;data.name&#125;`&quot;&gt;\n    &lt;/a&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;6.1.3 事件的绑定\n\n\n\n\n\n\n\n\n我们可以使用 v-on 来监听 DOM 事件，并在事件触发时执行对应的 Vue的JavaScript代码。\nv-on绑定事件命令说明\n\n用法：v-on:click=&quot;handler&quot; 或简写为 @click=&quot;handler&quot;\nvue中的事件名&#x3D;原生事件名去掉on 前缀   如:onClick --&gt; click\nhandler的值可以是方法事件处理器,也可以是内联事件处理器\n绑定事件时,可以通过一些绑定的修饰符,常见的事件修饰符如下\n.once：只触发一次事件。[重点]\n.prevent：阻止默认事件。[重点]\n.stop：阻止事件冒泡。\n.capture：使用事件捕获模式而不是冒泡模式。\n.self：只在事件发送者自身触发时才触发事件。\n\n\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n  import &#123;ref&#125; from &#39;vue&#39;\n  // 响应式数据 当发生变化时,会自动更新 dom树\n  let count=ref(0)\n  let addCount= ()=&gt;&#123;\n    count.value++\n  &#125;\n  let incrCount= (event)=&gt;&#123;\n    count.value++\n    // 通过事件对象阻止组件的默认行为\n    event.preventDefault();\n    \n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;count的值是:&#123;&#123; count &#125;&#125;&lt;/h1&gt;\n    &lt;!-- 方法事件处理器 --&gt;\n    &lt;button v-on:click=&quot;addCount()&quot;&gt;addCount&lt;/button&gt; &lt;br&gt;\n    &lt;!-- 内联事件处理器 --&gt;\n    &lt;button @click=&quot;count++&quot;&gt;incrCount&lt;/button&gt; &lt;br&gt;\n    &lt;!-- 事件修饰符 once 只绑定事件一次 --&gt;\n    &lt;button @click.once=&quot;count++&quot;&gt;addOnce&lt;/button&gt; &lt;br&gt;\n    &lt;!-- 事件修饰符 prevent 阻止组件的默认行为 --&gt;\n    &lt;a href=&quot;http://www.atguigu.com&quot; target=&quot;_blank&quot; @click.prevent=&quot;count++&quot;&gt;prevent&lt;/a&gt; &lt;br&gt;\n    &lt;!-- 原生js方式阻止组件默认行为 (推荐) --&gt;\n    &lt;a href=&quot;http://www.atguigu.com&quot; target=&quot;_blank&quot; @click=&quot;incrCount($event)&quot;&gt;prevent&lt;/a&gt; &lt;br&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;6.2 响应式基础\n\n\n\n\n\n\n\n\n 此处的响应式是指  : 数据模型发生变化时,自动更新DOM树内容,页面上显示的内容会进行同步变化,vue3的数据模型不是自动响应式的,需要我们做一些特殊的处理\n让一个普通数据转换为响应式数据两种方式\n\nref函数：更适合单个变量\n在script标签中操作ref响应式数据要通过.value\n在template中操作ref响应式数据则无需.value \n\n\nreactive函数：更适合对象\n在script和template操作reactive响应式数据都直接使用对象名.属性名的方式即可\n\n\n\n6.2.1 响应式需求案例\n\n\n\n\n\n\n\n\n需求：实现 +  - 按钮,实现数字加一减一 \nvue&lt;script type=&quot;module&quot; setup&gt;\n    let counter = 0;\n    function show()&#123;\n        alert(counter);\n    &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=&quot;counter--&quot;&gt;-&lt;/button&gt; \n    &#123;&#123; counter &#125;&#125; \n    &lt;button @click=&quot;counter++&quot;&gt;+&lt;/button&gt;\n    &lt;hr&gt;\n    &lt;!-- 此案例,我们发现counter值,会改变,但是页面不改变! 默认Vue3的数据是非响应式的!--&gt;\n    &lt;button @click=&quot;show()&quot;&gt;显示counter值&lt;/button&gt;\n   &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n\n&lt;/style&gt;\n6.2.2 响应式实现关键字ref\n\n\n\n\n\n\n\n\nref 可以将一个基本类型的数据（如字符串，数字等）转换为一个响应式对象。 ref 只能包裹单一元素\nvue&lt;script type=&quot;module&quot; setup&gt;\n    /* 从vue中引入ref方法 */\n    import &#123;ref&#125; from &#39;vue&#39;\n    let counter = ref(0);\n    function show()&#123;\n        alert(counter.value);\n    &#125;\n    /* 函数中要操作ref处理过的数据,需要通过.value形式 */\n    let decr = () =&gt;&#123;\n      counter.value--;\n    &#125;\n    let incr = () =&gt;&#123;\n      counter.value++;\n    &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=&quot;counter--&quot;&gt;-&lt;/button&gt; \n    &lt;button @click=&quot;decr()&quot;&gt;-&lt;/button&gt; \n    &#123;&#123; counter &#125;&#125; \n    &lt;button @click=&quot;counter++&quot;&gt;+&lt;/button&gt;\n    &lt;button @click=&quot;incr()&quot;&gt;+&lt;/button&gt; \n    &lt;hr&gt;\n    &lt;button @click=&quot;show()&quot;&gt;显示counter值&lt;/button&gt;\n   &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n\n&lt;/style&gt;\n在上面的例子中，我们使用 ref 包裹了一个数字，在代码中给这个数字加 1 后，视图也会跟着动态更新。需要注意的是，由于使用了 ref，因此需要在访问该对象时使用 .value 来获取其实际值。\n\n6.2.3 响应式实现关键字reactive\n\n\n\n\n\n\n\n\n我们可以使用 reactive() 函数创建一个响应式对象或数组：\nvue&lt;script type=&quot;module&quot; setup&gt;\n    /* 从vue中引入reactive方法 */\n    import &#123;ref,reactive&#125; from &#39;vue&#39;\n    let data = reactive(&#123;\n      counter:0\n    &#125;)\n    function show()&#123;\n        alert(data.counter);\n    &#125;\n    /* 函数中要操作reactive处理过的数据,需要通过 对象名.属性名的方式 */\n    let decr = () =&gt;&#123;\n      data.counter--;\n    &#125;\n    let incr = () =&gt;&#123;\n      data.counter++;\n    &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=&quot;data.counter--&quot;&gt;-&lt;/button&gt; \n    &lt;button @click=&quot;decr()&quot;&gt;-&lt;/button&gt; \n    &#123;&#123; data.counter &#125;&#125; \n    &lt;button @click=&quot;data.counter++&quot;&gt;+&lt;/button&gt;\n    &lt;button @click=&quot;incr()&quot;&gt;+&lt;/button&gt; \n    &lt;hr&gt;\n    &lt;button @click=&quot;show()&quot;&gt;显示counter值&lt;/button&gt;\n   &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n对比ref和reactive:\n\n使用 ref 适用于以下开发场景：\n包装基本类型数据：ref 主要用于包装基本类型数据（如字符串、数字等），即只有一个值的数据，如果你想监听这个值的变化，用 ref 最为方便。在组件中使用时也很常见。\n访问方式简单：ref 对象在访问时与普通的基本类型值没有太大区别，只需要通过 .value 访问其实际值即可。\n\n\n使用 reactive 适用于以下开发场景：\n包装复杂对象：reactive 可以将一个普通对象转化为响应式对象，这样在数据变化时会自动更新界面，特别适用于处理复杂对象或者数据结构。\n需要递归监听的属性：使用 reactive 可以递归追踪所有响应式对象内部的变化，从而保证界面的自动更新。\n\n\n综上所述，ref 适用与简单情形下的数据双向绑定，对于只有一个字符等基本类型数据或自定义组件等情况，建议可以使用 ref；而对于对象、函数等较为复杂的数据结构，以及需要递归监听的属性变化，建议使用 reactive。当然，在实际项目中根据需求灵活选择也是十分必要的。\n\n6.2.4 扩展响应式关键字toRefs 和 toRef\n\n\n\n\n\n\n\n\ntoRef基于reactive响应式对象上的一个属性，创建一个对应的ref响应式数据。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。\ntoRefs将一个响应式对象多个属性转换为一个多个ref数据，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。\n案例：响应显示reactive对象属性\nvue&lt;script type=&quot;module&quot; setup&gt;\n    /* 从vue中引入reactive方法 */\n    import &#123;ref,reactive,toRef,toRefs&#125; from &#39;vue&#39;\n    let data = reactive(&#123;\n      counter:0,\n      name:&quot;test&quot;\n    &#125;)\n\n    // 将一个reactive响应式对象中的某个属性转换成一个ref响应式对象\n    let ct = toRef(data,&#39;counter&#39;);\n    // 将一个reactive响应式对象中的多个属性转换成多个ref响应式对象\n    let &#123;counter,name&#125; = toRefs(data)\n\n    function show()&#123;\n        alert(data.counter);\n        // 获取ref的响应对象,需要通过.value属性\n        alert(counter.value);\n        alert(name.value)\n    &#125;\n    /* 函数中要操作ref处理过的数据,需要通过.value形式 */\n    let decr = () =&gt;&#123;\n      data.counter--;\n    &#125;\n    let incr = () =&gt;&#123;\n      /* ref响应式数据,要通过.value属性访问 */\n      counter.value++;\n    &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click=&quot;data.counter--&quot;&gt;-&lt;/button&gt; \n    &lt;button @click=&quot;decr()&quot;&gt;-&lt;/button&gt; \n    &#123;&#123; data.counter &#125;&#125; \n    &amp;amp;\n    &#123;&#123; ct &#125;&#125; \n    &lt;button @click=&quot;data.counter++&quot;&gt;+&lt;/button&gt;\n    &lt;button @click=&quot;incr()&quot;&gt;+&lt;/button&gt; \n    &lt;hr&gt;\n    &lt;button @click=&quot;show()&quot;&gt;显示counter值&lt;/button&gt;\n   &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n\n&lt;/style&gt;\n\n6.3 条件和列表渲染6.3.1 条件渲染简要说明\n\nv-if = &quot;表达式/数据&quot;：数据为true则当前元素会渲染进入dom树 \nv-else：自动和前一个v-if做取反操作\nv-show=&quot;&quot;：数据为true元素则展示在页面上，否则不展示\n\n\n\n\n\n\n\n\n\n\nv-if 条件渲染\n\nv-if=&#39;表达式&#39; 只会在指令的表达式返回真值时才被渲染\n\n也可以使用 v-else 为 v-if 添加一个“else 区块”。\n\n一个 v-else 元素必须跟在一个 v-if 元素后面，否则它将不会被识别。\n\n\nvue&lt;script type=&quot;module&quot; setup&gt;\n    import &#123;ref&#125; from &#39;vue&#39;\n    let awesome = ref(true)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;\n    &lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;\n    &lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\nv-show条件渲染扩展：\n\n另一个可以用来按条件显示一个元素的指令是 v-show。其用法基本一样：\n\n不同之处在于 v-show 会在 DOM 渲染中保留该元素；v-show 仅切换了该元素上名为 display 的 CSS 属性。\n\nv-show 不支持在 &lt;template&gt; 元素上使用，也不能和 v-else 搭配使用。\n\n\nvue&lt;script type=&quot;module&quot; setup&gt;\n    import &#123;ref&#125; from &#39;vue&#39;\n    let awesome = ref(true)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1 id=&quot;ha&quot;  v-show=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;\n    &lt;h1 id=&quot;hb&quot;  v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;\n    &lt;h1 id=&quot;hc&quot;  v-else&gt;Oh no 😢&lt;/h1&gt;\n    &lt;button @click=&quot;awesome = !awesome&quot;&gt;Toggle&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n\nv-if    vs v-show\n\nv-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。\nv-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。\n相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。\n总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。\nv-if数据为falsel时，元素则不再dom树中了 \nv-show数据为false时，元素仍在dom树中，通过display的css样式控制元素隐藏\n\n6.3.2 列表渲染\n\n\n\n\n\n\n\n\n我们可以使用 v-for 指令基于一个数组来渲染一个列表。\n\nv-for 指令的值需要使用 item in items 形式的特殊语法，其中 items 是源数据的数组，而 item 是迭代项的别名：\n\n在 v-for 块中可以完整地访问父作用域内的属性和变量。v-for 也支持使用可选的第二个参数表示当前项的位置索引。\n\n\nvue&lt;script type=&quot;module&quot; setup&gt;\n    import &#123;ref,reactive&#125; from &#39;vue&#39;\n    let parentMessage= ref(&#39;产品&#39;)\n    let items =reactive([\n      &#123;\n        id:&#39;item1&#39;,\n        message:&quot;薯片&quot;\n      &#125;,\n      &#123;\n        id:&#39;item2&#39;,\n        message:&quot;可乐&quot;\n      &#125;\n    ])\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;ul&gt;\n      &lt;!-- :key不写也可以 --&gt;\n      &lt;li v-for=&#39;item in items&#39; :key=&#39;item.id&#39;&gt;\n        &#123;&#123; item.message &#125;&#125;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n\n    &lt;ul&gt;\n      &lt;!-- index表示索引,当然不是非得使用index这个单词 --&gt;\n      &lt;li v-for=&quot;(item, index) in items&quot; :key=&quot;index&quot;&gt;\n        &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n   \n  &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n&lt;/style&gt;\n案例：实现购物车显示和删除购物项\n\nvue&lt;script type=&quot;module&quot; setup&gt;\n\n    //引入模块\n    import &#123; reactive&#125; from &#39;vue&#39;\n    //准备购物车数据,设置成响应数据\n    const carts = reactive([&#123;name:&#39;可乐&#39;,price:3,number:10&#125;,&#123;name:&#39;薯片&#39;,price:6,number:8&#125;])\n\n    //计算购物车总金额\n    function compute()&#123;\n      let count = 0;\n      for(let index in carts)&#123;\n        count += carts[index].price*carts[index].number;\n      &#125;\n      return count;\n    &#125;\n    //删除购物项方法\n    function removeCart(index)&#123;\n      carts.splice(index,1);\n    &#125;\n    \n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;table&gt;\n           &lt;thead&gt;\n               &lt;tr&gt;\n                  &lt;th&gt;序号&lt;/th&gt;\n                  &lt;th&gt;商品名&lt;/th&gt;\n                  &lt;th&gt;价格&lt;/th&gt;\n                  &lt;th&gt;数量&lt;/th&gt;\n                  &lt;th&gt;小计&lt;/th&gt;\n                  &lt;th&gt;操作&lt;/th&gt;\n               &lt;/tr&gt;\n           &lt;/thead&gt;\n           &lt;tbody v-if=&quot;carts.length &gt; 0&quot;&gt;\n               &lt;!-- 有数据显示--&gt;\n               &lt;tr v-for=&quot;cart,index in carts&quot; :key=&quot;index&quot;&gt;\n                  &lt;th&gt;&#123;&#123; index+1 &#125;&#125;&lt;/th&gt;\n                  &lt;th&gt;&#123;&#123; cart.name &#125;&#125;&lt;/th&gt;\n                  &lt;th&gt;&#123;&#123; cart.price + '元' &#125;&#125;&lt;/th&gt;\n                  &lt;th&gt;&#123;&#123; cart.number &#125;&#125;&lt;/th&gt;\n                  &lt;th&gt;&#123;&#123; cart.price*cart.number  + '元'&#125;&#125;&lt;/th&gt;\n                  &lt;th&gt; &lt;button @click=&quot;removeCart(index)&quot;&gt;删除&lt;/button&gt; &lt;/th&gt;\n               &lt;/tr&gt;\n           &lt;/tbody&gt;\n           &lt;tbody v-else&gt;\n               &lt;!-- 没有数据显示--&gt;\n               &lt;tr&gt;\n                  &lt;td colspan=&quot;6&quot;&gt;购物车没有数据!&lt;/td&gt;\n               &lt;/tr&gt;\n           &lt;/tbody&gt;\n        &lt;/table&gt;\n        购物车总金额: &#123;&#123; compute() &#125;&#125; 元\n    &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n&lt;/style&gt;6.4 双向绑定\n\n\n\n\n\n\n\n\n单项绑定和双向绑定\n\n单向绑定: 响应式数据的变化会更新dom树,但是dom树上用户的操作造成的数据改变不会同步更新到响应式数据\n双向绑定: 响应式数据的变化会更新dom树,但是dom树上用户的操作造成的数据改变会同步更新到响应式数据\n用户通过表单标签才能够输入数据,所以双向绑定都是应用到表单标签上的,其他标签不行\nv-model专门用于双向绑定表单标签的value属性,语法为 v-model:value=&#39;&#39;,可以简写为 v-model=&#39;&#39;\nv-model还可以用于各种不同类型的输入，&lt;textarea&gt;、&lt;select&gt; 元素。\n\n\n\nvue&lt;script type=&quot;module&quot; setup&gt;\n\n  //引入模块\n  import &#123; reactive,ref&#125; from &#39;vue&#39; \n  let hbs = ref([]); //装爱好的值\n  let user = reactive(&#123;username:null,password:null,introduce:null,pro:null&#125;)   \n  function login()&#123;\n    alert(hbs.value);\n    alert(JSON.stringify(user));\n  &#125;\n  function clearx()&#123;\n    //user = &#123;&#125;;// 这中写法会将数据变成非响应的,应该是user.username=&quot;&quot;\n    user.username=&#39;&#39;\n    user.password=&#39;&#39;\n    user.introduce=&#39;&#39;\n    user.pro=&#39;&#39;\n    //hbs是ref响应,因此注意要加.value\n    hbs.value.splice(0,hbs.value.length);;\n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n      账号： &lt;input type=&quot;text&quot; placeholder=&quot;请输入账号！&quot; v-model=&quot;user.username&quot;&gt; &lt;br&gt;\n      密码： &lt;input type=&quot;text&quot; placeholder=&quot;请输入账号！&quot; v-model=&quot;user.password&quot;&gt; &lt;br&gt;\n      &lt;!--如果type是radio,就会有互斥效果,只会存在一个数据--&gt;\n      爱好： \n        吃 &lt;input type=&quot;checkbox&quot; name=&quot;hbs&quot; v-model=&quot;hbs&quot; value=&quot;吃&quot;&gt;  \n        喝 &lt;input type=&quot;checkbox&quot; name=&quot;hbs&quot; v-model=&quot;hbs&quot; value=&quot;喝&quot;&gt;\n        玩 &lt;input type=&quot;checkbox&quot; name=&quot;hbs&quot; v-model=&quot;hbs&quot; value=&quot;玩&quot;&gt;\n        乐 &lt;input type=&quot;checkbox&quot; name=&quot;hbs&quot; v-model=&quot;hbs&quot; value=&quot;乐&quot;&gt;\n      &lt;br&gt;\n      简介:&lt;textarea v-model=&quot;user.introduce&quot;&gt;&lt;/textarea&gt;\n      &lt;br&gt;\n      籍贯:\n          &lt;select v-model=&quot;user.pro&quot;&gt;\n            &lt;option value=&quot;1&quot;&gt;黑&lt;/option&gt;\n            &lt;option value=&quot;2&quot;&gt;吉&lt;/option&gt;\n            &lt;option value=&quot;3&quot;&gt;辽&lt;/option&gt;\n            &lt;option value=&quot;4&quot;&gt;京&lt;/option&gt;\n            &lt;option value=&quot;5&quot;&gt;津&lt;/option&gt;\n            &lt;option value=&quot;6&quot;&gt;冀&lt;/option&gt;\n          &lt;/select&gt; \n      &lt;br&gt;\n      &lt;button @click=&quot;login()&quot;&gt;登录&lt;/button&gt; \n      &lt;button @click=&quot;clearx()&quot;&gt;重置&lt;/button&gt;\n      &lt;hr&gt;\n      显示爱好:&#123;&#123; hbs &#125;&#125;\n      &lt;hr&gt;\n      显示用户信息:&#123;&#123; user &#125;&#125;\n  &lt;/div&gt; \n&lt;/template&gt; \n\n&lt;style scoped&gt;\n&lt;/style&gt;\n6.5 属性计算\n\n\n\n\n\n\n\n\n模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象：\nvue&lt;script type=&quot;module&quot; setup&gt;\n  //引入模块\n  import &#123; reactive,computed&#125; from &#39;vue&#39;\n  const author = reactive(&#123;\n    name: &#39;John Doe&#39;,\n    books: [\n      &#39;Vue 2 - Advanced Guide&#39;,\n      &#39;Vue 3 - Basic Guide&#39;,\n      &#39;Vue 4 - The Mystery&#39;\n    ]\n  &#125;)\n \n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;p&gt;&#123;&#123;author.name&#125;&#125; Has published books?:&lt;/p&gt;\n    &lt;span&gt;&#123;&#123; author.books.length > 0 ? 'Yes' : 'No' &#125;&#125;&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n&lt;/style&gt;\n这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 author.books。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。\n\n\n\n\n\n\n\n\n\n\n因此我们推荐使用计算属性来描述依赖响应式状态的复杂逻辑。这是重构后的示例：\nvue&lt;script type=&quot;module&quot; setup&gt;\n  //引入模块\n  import &#123; reactive,computed&#125; from &#39;vue&#39;\n  const author = reactive(&#123;\n    name: &#39;John Doe&#39;,\n    books: [\n      &#39;Vue 2 - Advanced Guide&#39;,\n      &#39;Vue 3 - Basic Guide&#39;,\n      &#39;Vue 4 - The Mystery&#39;\n    ]\n  &#125;)\n  // 一个计算属性 ref\n  const publishedBooksMessage = computed(() =&gt; &#123;\n    console.log(&quot;publishedBooksMessage&quot;)\n    return author.books.length &gt; 0 ? &#39;Yes&#39; : &#39;No&#39;\n  &#125;)\n  // 一个函数\n  let hasBooks = ()=&gt;&#123;\n    console.log(&quot;hasBooks&quot;)\n    return author.books.length &gt; 0?&#39;Yes&#39;:&#39;no&#39;\n  &#125;\n\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;p&gt;&#123;&#123;author.name&#125;&#125; Has published books?:&lt;/p&gt;\n    &lt;span&gt;&#123;&#123; author.books.length > 0 ? 'Yes' : 'No' &#125;&#125;&lt;/span&gt;\n    &lt;span&gt;&#123;&#123; hasBooks() &#125;&#125;&lt;/span&gt;&lt;!-- 调用方法,每个标签都会调用一次 --&gt;\n    &lt;span&gt;&#123;&#123; hasBooks() &#125;&#125;&lt;/span&gt;\n\n    &lt;p&gt;&#123;&#123;author.name&#125;&#125; Has published books?:&lt;/p&gt;\n    &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;&lt;!-- 属性计算,属性值不变时,多个个标签只会调用一次 --&gt;\n    &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n我们在这里定义了一个计算属性 publishedBooksMessage。computed() 方法期望接收一个 getter 函数，返回值为一个计算属性 ref。和其他一般的 ref 类似，你可以通过 publishedBooksMessage.value 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。\nVue 的计算属性会自动追踪响应式依赖。它会检测到 publishedBooksMessage 依赖于 author.books，所以当 author.books 改变时，任何依赖于 publishedBooksMessage 的绑定都会同时更新。\n\n\n\n\n\n\n\n\n\n\n计算属性缓存 vs 方法\n\n通过方法返回数据：每使用一次，就执行一次\n通过计算属性获得数据：每次使用时，如果和上次使用时数据没有变化，则直接使用上一次的结果(针对大型计算会有用)\n\n详细说明：若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 author.books 不改变，无论多少次访问 publishedBooksMessage 都会立即返回先前的计算结果!\n6.6 数据监听器\n\n\n\n\n\n\n\n\n计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数：\nwatch主要用于以下场景\n\n当数据发生变化时需要执行相应的操作\n监听数据变化，当满足一定条件时触发相应操作\n在异步操作前或操作后需要执行相应的操作\n\n\n\n\n\n\n\n\n\n\n监控响应式数据（watch）：\nvue&lt;script type=&quot;module&quot; setup&gt;\n  //引入模块\n  import &#123; ref,reactive,watch&#125; from &#39;vue&#39;\n \n  let firstname=ref(&#39;&#39;)\n  let lastname=reactive(&#123;name:&#39;&#39;&#125;)\n  let fullname=ref(&#39;&#39;)\n\n  //监听一个ref响应式数据\n  watch(firstname,(newValue,oldValue)=&gt;&#123;\n    console.log(`$&#123;oldValue&#125;变为$&#123;newValue&#125;`)\n    fullname.value=firstname.value+lastname.name\n  &#125;)\n  //监听reactive响应式数据的指定属性\n  watch(()=&gt;lastname.name,(newValue,oldValue)=&gt;&#123;\n    console.log(`$&#123;oldValue&#125;变为$&#123;newValue&#125;`)\n    fullname.value=firstname.value+lastname.name\n  &#125;)\n  //监听reactive响应式数据的所有属性(深度监视,一般不推荐)\n  //deep:true 深度监视\n  //immediate:true 深度监视在进入页面时立即执行一次\n  watch(()=&gt;lastname,(newValue,oldValue)=&gt;&#123;\n    // 此时的newValue和oldValue一样,都是lastname\n    console.log(newValue)\n    console.log(oldValue)\n    fullname.value=firstname.value+lastname.name\n  &#125;,&#123;deep:true,immediate:false&#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    全名:&#123;&#123;fullname&#125;&#125; &lt;br&gt;\n    姓氏:&lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; &lt;br&gt;\n    名字:&lt;input type=&quot;text&quot; v-model=&quot;lastname.name&quot; &gt; &lt;br&gt;\n  &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n监控响应式数据(watchEffect)：\n\nwatchEffect默认监听所有的响应式数据\n\nvue&lt;script type=&quot;module&quot; setup&gt;\n  //引入模块\n  import &#123; ref,reactive,watch, watchEffect&#125; from &#39;vue&#39;\n \n  let firstname=ref(&#39;&#39;)\n  let lastname=reactive(&#123;name:&#39;&#39;&#125;)\n  let fullname=ref(&#39;&#39;)\n\n  //监听所有响应式数据\n  watchEffect(()=&gt;&#123;\n    //直接在内部使用监听属性即可！不用外部声明\n    //也不需要，即时回调设置！默认初始化就加载！\n    console.log(firstname.value)\n    console.log(lastname.name)\n    fullname.value=`$&#123;firstname.value&#125;$&#123;lastname.name&#125;`\n  &#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    全名:&#123;&#123;fullname&#125;&#125; &lt;br&gt;\n    姓氏:&lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt; &lt;br&gt;\n    名字:&lt;input type=&quot;text&quot; v-model=&quot;lastname.name&quot; &gt; &lt;br&gt;\n  &lt;/div&gt;\n&lt;/template&gt; \n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\nwatch vs. watchEffect\nwatch 和 watchEffect 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：\n\nwatch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。\nwatchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。\n\n6.7. Vue生命周期6.7.1 生命周期简介\n\n\n\n\n\n\n\n\n每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码!\n\n周期图解：\n\n\n\n\n常见钩子函数\nonMounted()              ：注册一个回调函数，在组件挂载完成后执行。 \nonUpdated()               ：注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。 \nonUnmounted()          ：注册一个回调函数，在组件实例被卸载之后调用。 \nonBeforeMount()       ：注册一个钩子，在组件被挂载之前被调用。 \nonBeforeUpdate()      ：注册一个钩子，在组件即将因为响应式状态变更而更新其 DOM 树之前调用。 \nonBeforeUnmount()  ：注册一个钩子，在组件实例被卸载之前调用。\n\n\n\n6.7.2 生命周期案例vue&lt;script setup&gt;\n\n    import &#123;ref,onUpdated,onMounted,onBeforeUpdate&#125; from &#39;vue&#39;\n    \n    let message =ref(&#39;hello&#39;)\n   \n    // 挂载完毕生命周期\n    onMounted(()=&gt;&#123;\n      console.log(&#39;-----------onMounted---------&#39;)\n      let span1 =document.getElementById(&quot;span1&quot;)\n      console.log(span1.innerText)\n    &#125;)\n    // 更新前生命周期\n    onBeforeUpdate(()=&gt;&#123;\n      console.log(&#39;-----------onBeforeUpdate---------&#39;)\n      console.log(message.value)\n      let span1 =document.getElementById(&quot;span1&quot;)\n      console.log(span1.innerText)\n    &#125;)\n    // 更新完成生命周期\n    onUpdated(()=&gt;&#123;\n      console.log(&#39;-----------onUpdated---------&#39;)\n      let span1 =document.getElementById(&quot;span1&quot;)\n      console.log(span1.innerText)\n    &#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;span id=&quot;span1&quot; v-text=&quot;message&quot;&gt;&lt;/span&gt; &lt;br&gt;\n    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;\n  &lt;/div&gt;\n  \n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;6.8 Vue组件6.8.1 组件基础\n\n\n\n\n\n\n\n\n组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。组件就是实现应用中局部功能代码和资源的集合！在实际应用中，组件常常被组织成层层嵌套的树状结构：\n\n\n这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。\n\n\n\n\n\n\n\n\n\n\n传统方式编写应用\n\n\n\n\n\n\n\n\n\n\n\n组件方式编写应用\n\n\n\n组件化：对js/css/html统一封装,这是VUE中的概念\n\n模块化：对js的统一封装,这是ES6中的概念\n\n组件化中,对js部分代码的处理使用&#96;ES6中的模块化\n\n\n6.8.2 组件化入门案例\n\n\n\n\n\n\n\n\n案例需求： 创建一个页面，包含头部和菜单以及内容显示区域，每个区域使用独立组建！\n\n\n\n\n\n\n\n\n\n\n\n1 准备vue项目\nshellnpm create vite\ncd vite项目\nnpm install\n\n\n\n\n\n\n\n\n2 安装相关依赖\nshellnpm install sass\nnpm install bootstrap\n\n\n\n\n\n\n\n\n 3 创建子组件 在src&#x2F;components文件下 vscode需要安装Vetur插件，这样vue文件有快捷提示\n\nHeader.vue\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        欢迎： xx &lt;a href=&quot;#&quot;&gt;退出登录&lt;/a&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\nNavigator.vue\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;!-- 推荐写一个根标签--&gt;\n    &lt;div&gt;\n       &lt;ul&gt;\n          &lt;li&gt;学员管理&lt;/li&gt;\n          &lt;li&gt;图书管理&lt;/li&gt;\n          &lt;li&gt;请假管理&lt;/li&gt;\n          &lt;li&gt;考试管理&lt;/li&gt;\n          &lt;li&gt;讲师管理&lt;/li&gt;\n       &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\nContent.vue\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        展示的主要内容！\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\nApp.vue  入口组件App引入组件\n\nvue&lt;script setup&gt;\n    import Header  from &#39;./components/Header.vue&#39;\n    import Navigator  from &#39;./components/Navigator.vue&#39;\n    import Content  from &#39;./components/Content.vue&#39;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n     &lt;Header class=&quot;header&quot;&gt;&lt;/Header&gt;\n     &lt;Navigator class=&quot;navigator&quot;&gt;&lt;/Navigator&gt;\n     &lt;Content class=&quot;content&quot;&gt;&lt;/Content&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n    .header&#123;\n       height: 80px;\n       border: 1px solid red;\n    &#125;\n\n    .navigator&#123;\n      width: 15%;\n      height: 800px;\n      display: inline-block;\n      border: 1px blue solid;\n      float: left;\n    &#125;\n\n    .content&#123;\n      width: 83%;\n      height: 800px;\n      display: inline-block;\n      border: 1px goldenrod solid;\n      float: right;\n    &#125;\n\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n4 启动测试\nshellnpm run dev6.8.3 组件之间传递数据6.8.3.1 父传子\n\n\n\n\n\n\n\n\nVue3 中父组件向子组件传值可以通过 props 进行，具体操作如下：\n\n首先，在父组件中定义需要传递给子组件的值，接着，在父组件的模板中引入子组件，同时在引入子组件的标签中添加 props 属性并为其设置需要传递的值。\n在 Vue3 中，父组件通过 props 传递给子组件的值是响应式的。也就是说，如果在父组件中的传递的值发生了改变，子组件中的值也会相应地更新。\n\n\n父组件代码：App.vue\n\nvue&lt;script setup&gt;\n\n  import Son from &#39;./components/Son.vue&#39;\n  import &#123;ref,reactive,toRefs&#125; from &#39;vue&#39;\n\n  let menu = ref(&#39;parent data!&#39;)\n  let title = ref(42)\n\n  function changeMessage()&#123;\n    message.value = &#39;修改数据！&#39;\n    title.value++ \n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;&#123;&#123; menu &#125;&#125;&lt;/h2&gt;\n    &lt;hr&gt;\n    &lt;!-- 使用子组件，并且传递数据！ --&gt;\n    &lt;Son :message=&quot;menu&quot; :title=&quot;title&quot;&gt;&lt;/Son&gt;\n    &lt;hr&gt;\n    &lt;button @click=&quot;changeMessage&quot;&gt;点击更新&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n子组件代码：Son.vue\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n    import &#123;ref,isRef,defineProps&#125; from &#39;vue&#39;\n    //声明父组件传递属性值\n    defineProps(&#123;\n        message:String ,\n        title:Number\n    &#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n    &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;\n    &lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style&gt;\n&lt;/style&gt;6.8.3.2 子传父\n父组件： App.vue\n\nvue&lt;script setup&gt;\n    import Son from &#39;./components/Son.vue&#39;\n    import &#123;ref&#125; from &#39;vue&#39;\n\n    let pdata = ref(&#39;&#39;)\n\n    const padd = (data) =&gt; &#123;\n        console.log(&#39;2222&#39;);\n        pdata.value =data;\n    &#125;\n\n    //自定义接收，子组件传递数据方法！ 参数为数据！\n    const psub = (data) =&gt; &#123;\n        console.log(&#39;11111&#39;);\n        pdata.value = data;\n    &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;!-- 声明@事件名应该等于子模块对应事件名！调用方法可以是当前自定义！--&gt;\n        &lt;Son @add=&quot;padd&quot; @sub=&quot;psub&quot;&gt;&lt;/Son&gt;\n        &lt;hr&gt;\n        &#123;&#123; pdata &#125;&#125;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n\n\n&lt;style&gt;\n&lt;/style&gt;\n子组件：Son.vue\n\nvue&lt;script setup&gt;\n\n    import &#123;ref,defineEmits&#125; from &#39;vue&#39;\n\n    //1.定义要发送给父组件的方法，可以1或者多个\n    let emites = defineEmits([&#39;add&#39;,&#39;sub&#39;]);\n\n    let data = ref(1);\n\n    function sendMsgToParent()&#123;\n        console.log(&#39;-------son--------&#39;);\n\n        //2.出发父组件对应的方法，调用defineEmites对应的属性\n        emites(&#39;add&#39;,&#39;add data!&#39;+data.value)\n        emites(&#39;sub&#39;,&#39;sub data!&#39;+data.value)\n\n        data.value ++;\n    &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;button @click=&quot;sendMsgToParent&quot;&gt;发送消息给父组件&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n  6.8.3.3 兄弟传参\n\n\nNavigator.vue: 发送数据到App.vue\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n    import &#123;defineEmits&#125; from &#39;vue&#39;\n    const emits = defineEmits([&#39;sendMenu&#39;]);\n    //触发事件，向父容器发送数据\n    function send(data)&#123;\n        emits(&#39;sendMenu&#39;,data);\n    &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;!-- 推荐写一个根标签--&gt;\n    &lt;div&gt;\n       &lt;ul&gt;\n          &lt;li @click=&quot;send(&#39;学员管理&#39;)&quot;&gt;学员管理&lt;/li&gt;\n          &lt;li @click=&quot;send(&#39;图书管理&#39;)&quot;&gt;图书管理&lt;/li&gt;\n          &lt;li @click=&quot;send(&#39;请假管理&#39;)&quot;&gt;请假管理&lt;/li&gt;\n          &lt;li @click=&quot;send(&#39;考试管理&#39;)&quot;&gt;考试管理&lt;/li&gt;\n          &lt;li @click=&quot;send(&#39;讲师管理&#39;)&quot;&gt;讲师管理&lt;/li&gt;\n       &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style&gt;\n\n&lt;/style&gt;\nApp.vue: 发送数据到Content.vue\n\nvue&lt;script setup&gt;\n  \n  import Header  from &#39;./components/Header.vue&#39;\n  import Navigator  from &#39;./components/Navigator.vue&#39;\n  import Content  from &#39;./components/Content.vue&#39;\n\n  import &#123;ref&#125; from &quot;vue&quot;\n  //定义接受navigator传递参数\n  var navigator_menu = ref(&#39;ceshi&#39;);\n\n  const receiver = (data) =&gt;&#123;\n    navigator_menu.value = data;\n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n      &lt;hr&gt;\n      &#123;&#123; navigator_menu &#125;&#125;\n      &lt;hr&gt;\n     &lt;Header class=&quot;header&quot;&gt;&lt;/Header&gt;\n     &lt;Navigator @sendMenu=&quot;receiver&quot; class=&quot;navigator&quot;&gt;&lt;/Navigator&gt;\n     &lt;!-- 向子组件传递数据--&gt;\n     &lt;Content class=&quot;content&quot; :message=&quot;navigator_menu&quot;&gt;&lt;/Content&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n    .header&#123;\n       height: 80px;\n       border: 1px solid red;\n    &#125;\n\n    .navigator&#123;\n      width: 15%;\n      height: 800px;\n      display: inline-block;\n      border: 1px blue solid;\n      float: left;\n    &#125;\n\n    .content&#123;\n      width: 83%;\n      height: 800px;\n      display: inline-block;\n      border: 1px goldenrod solid;\n      float: right;\n    &#125;\n\n&lt;/style&gt;\nContent.vue\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n    defineProps(&#123;\n        message:String\n    &#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n    \n    &lt;div&gt;\n        展示的主要内容！\n        &lt;hr&gt;\n        &#123;&#123; message &#125;&#125;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style&gt;\n&lt;/style&gt;\n七、Vue3路由机制router7.1 路由简介\n\n\n\n\n\n\n\n\n1 什么是路由？\n\n定义：路由就是根据不同的 URL 地址展示不同的内容或页面。\n通俗理解：路由就像是一个地图，我们要去不同的地方，需要通过不同的路线进行导航。\n\n\n\n\n\n\n\n\n\n\n2 路由的作用\n\n单页应用程序（SPA）中，路由可以实现不同视图之间的无刷新切换，提升用户体验；\n路由还可以实现页面的认证和权限控制，保护用户的隐私和安全；\n路由还可以利用浏览器的前进与后退，帮助用户更好地回到之前访问过的页面。\n\n7.2 路由入门案例\n\n\n\n\n\n\n\n\n1 案例需求分析\n​    \n\n\n\n\n\n\n\n\n\n2 创建项目和导入路由依赖\nshellnpm create vite //创建项目cd 项目文件夹 //进入项目文件夹\nnpm install //安装项目需求依赖\nnpm install vue-router@4 --save //安装全局的vue-router 4版本\n\n\n\n\n\n\n\n\n3 准备页面和组件    \nrouter-link可放在其他页面用作跳转\n\ncomponents&#x2F;Home.vue\n\nvue&lt;script setup&gt;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;router-link to=&quot;/add&quot;&gt;Add页&lt;/router-link&gt; &lt;br&gt;\n        &lt;h1&gt;Home页面&lt;/h1&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\ncomponents&#x2F;List.vue\n\nvue&lt;script setup&gt;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;router-link to=&quot;/Update&quot;&gt;Update页&lt;/router-link&gt; &lt;br&gt;\n        &lt;h1&gt;List页面&lt;/h1&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\ncomponents&#x2F;Add.vue\n\nvue&lt;script setup&gt;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;router-link to=&quot;/list&quot;&gt;List页&lt;/router-link&gt; &lt;br&gt;\n        &lt;h1&gt;Add页面&lt;/h1&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\ncomponents&#x2F;Update.vue\n\nvue&lt;script setup&gt;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;router-link to=&quot;/&quot;&gt;Home页&lt;/router-link&gt; &lt;br&gt;\n        &lt;h1&gt;Update页面&lt;/h1&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\nApp.vue\n\nvue&lt;script setup&gt;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;h1&gt;App页面&lt;/h1&gt;\n      &lt;hr/&gt;\n        &lt;!-- 路由的连接 --&gt;\n        &lt;router-link to=&quot;/&quot;&gt;home页&lt;/router-link&gt; &lt;br&gt;\n        &lt;router-link to=&quot;/list&quot;&gt;list页&lt;/router-link&gt; &lt;br&gt;\n        &lt;router-link to=&quot;/add&quot;&gt;add页&lt;/router-link&gt; &lt;br&gt;\n        &lt;router-link to=&quot;/update&quot;&gt;update页&lt;/router-link&gt; &lt;br&gt;\n      &lt;hr/&gt;\n      &lt;!-- 路由连接对应视图的展示位置 --&gt;\n      &lt;hr&gt;\n      默认展示位置:&lt;router-view&gt;&lt;/router-view&gt;\n      &lt;hr&gt;\n      Home视图展示:&lt;router-view name=&quot;homeView&quot;&gt;&lt;/router-view&gt;\n      &lt;hr&gt;\n      List视图展示:&lt;router-view name=&quot;listView&quot;&gt;&lt;/router-view&gt;\n      &lt;hr&gt;\n      Add视图展示:&lt;router-view name=&quot;addView&quot;&gt;&lt;/router-view&gt;\n      &lt;hr&gt;\n      Update视图展示:&lt;router-view name=&quot;updateView&quot;&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n4 准备路由配置\n\nsrc&#x2F;routers&#x2F;router.js\n\njavascript// 导入路由创建的相关方法\nimport &#123;createRouter,createWebHashHistory&#125; from &#39;vue-router&#39;\n\n// 导入vue组件\nimport Home from &#39;../components/Home.vue&#39;\nimport List from &#39;../components/List.vue&#39;\nimport Add from &#39;../components/Add.vue&#39;\nimport Update from &#39;../components/Update.vue&#39;\n\n// 创建路由对象,声明路由规则\nconst router = createRouter(&#123;\n    //createWebHashHistory() 是 Vue.js 基于 hash 模式创建路由的工厂函数。在使用这种模式下，路由信息保存在 URL 的 hash 中，\n    //使用 createWebHashHistory() 方法，可以创建一个路由历史记录对象，用于管理应用程序的路由。在 Vue.js 应用中，\n    //通常使用该方法来创建路由的历史记录对象。\n    //就是路由中缓存历史记录的对象，vue-router提供\n    history: createWebHashHistory(),\n    routes:[\n        &#123;\n            path:&#39;/&#39;,\n            /* \n                component指定组件在默认的路由视图位置展示\n                components:Home\n                components指定组件在name为某个值的路由视图位置展示\n                components:&#123;\n                    default:Home,// 默认路由视图位置\n                    homeView:Home// name为homeView的路由视图位置\n                &#125;   \n            */\n            components:&#123;\n                default:Home,\n                homeView:Home\n            &#125;      \n        &#125;,\n        &#123;\n            path:&#39;/list&#39;,\n            components:&#123;\n                listView : List\n            &#125; \n        &#125;,\n        &#123;\n            path:&#39;/add&#39;,\n            components:&#123;\n                addView:Add\n            &#125; \n        &#125;,\n        &#123;\n            path:&#39;/update&#39;,\n            components:&#123;\n                updateView:Update\n            &#125;  \n        &#125;,\n    ]\n\n&#125;)\n\n// 对外暴露路由对象\nexport default router;\n\n\n\n\n\n\n\n\n5 main.js引入router配置\n\n修改文件：main.js (入口文件)\n\njavascriptimport &#123; createApp &#125; from &#39;vue&#39;\nimport &#39;./style.css&#39;\nimport App from &#39;./App.vue&#39;\n//导入router模块\nimport router from &#39;./routers/router.js&#39;\nlet app = createApp(App)\n//绑定路由对象\napp.use(router)\n//挂在视图\napp.mount(&quot;#app&quot;)\n\n\n\n\n\n\n\n\n6 启动测试\nshellnpm run dev7.3 路由重定向\n\n\n\n\n\n\n\n\n重定向的作用：将一个路由重定向到另一个路由上\n\n修改案例：访问/list和/showAll都定向到List.vue\nrouter.js\n\njavascript// 导入路由创建的相关方法\nimport &#123;createRouter,createWebHashHistory&#125; from &#39;vue-router&#39;\n\n// 导入vue组件\nimport Home from &#39;../components/Home.vue&#39;\nimport List from &#39;../components/List.vue&#39;\nimport Add from &#39;../components/Add.vue&#39;\nimport Update from &#39;../components/Update.vue&#39;\n\n// 创建路由对象,声明路由规则\nconst router = createRouter(&#123;\n    history: createWebHashHistory(),\n    routes:[\n        &#123;\n            path:&#39;/&#39;,\n            components:&#123;\n                default:Home,\n                homeView:Home\n            &#125;      \n        &#125;,\n        &#123;\n            path:&#39;/list&#39;,\n            components:&#123;\n                listView : List\n            &#125; \n        &#125;,\n        &#123;\n            path:&#39;/showAll&#39;,\n            // 重定向\n            redirect :&#39;/list&#39;\n        &#125;,\n        &#123;\n            path:&#39;/add&#39;,\n            components:&#123;\n                addView:Add\n            &#125; \n        &#125;,\n        &#123;\n            path:&#39;/update&#39;,\n            components:&#123;\n                updateView:Update\n            &#125;  \n        &#125;,\n    ]\n\n&#125;)\n\n// 对外暴露路由对象\nexport default router;\nApp.vue\n\nvue&lt;script setup&gt;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;h1&gt;App页面&lt;/h1&gt;\n      &lt;hr/&gt;\n        &lt;!-- 路由的连接 --&gt;\n        &lt;router-link to=&quot;/&quot;&gt;home页&lt;/router-link&gt; &lt;br&gt;\n        &lt;router-link to=&quot;/list&quot;&gt;list页&lt;/router-link&gt; &lt;br&gt;\n        &lt;router-link to=&quot;/showAll&quot;&gt;showAll页&lt;/router-link&gt; &lt;br&gt;\n        &lt;router-link to=&quot;/add&quot;&gt;add页&lt;/router-link&gt; &lt;br&gt;\n        &lt;router-link to=&quot;/update&quot;&gt;update页&lt;/router-link&gt; &lt;br&gt;\n      &lt;hr/&gt;\n      &lt;!-- 路由连接对应视图的展示位置 --&gt;\n      &lt;hr&gt;\n      默认展示位置:&lt;router-view&gt;&lt;/router-view&gt;\n      &lt;hr&gt;\n      Home视图展示:&lt;router-view name=&quot;homeView&quot;&gt;&lt;/router-view&gt;\n      &lt;hr&gt;\n      List视图展示:&lt;router-view name=&quot;listView&quot;&gt;&lt;/router-view&gt;\n      &lt;hr&gt;\n      Add视图展示:&lt;router-view name=&quot;addView&quot;&gt;&lt;/router-view&gt;\n      &lt;hr&gt;\n      Update视图展示:&lt;router-view name=&quot;updateView&quot;&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;7.4 编程式路由(useRouter)\n\n\n\n\n\n\n\n\n普通路由\n\n&lt;router-link to=&quot;/list&quot;&gt;list页&lt;/router-link&gt;  这种路由,to中的内容目前是固定的,点击后只能切换/list对象组件(声明式路由)\n\n\n\n\n\n\n\n\n\n\n编程式路由\n\n通过useRouter,动态决定向那个组件切换的路由\n在 Vue 3 和 Vue Router 4 中，你可以使用 useRouter 来实现动态路由(编程式路由)\n这里的 useRouter 方法返回的是一个 router 对象，你可以用它来做如导航到新页面、返回上一页面等操作。\n\n\n\n\n\n\n\n\n\n\n案例需求: 通过普通按钮配合事件绑定实现路由页面跳转,不直接使用router-link标签\n\nApp.vue\n\nvue&lt;script setup&gt;\n  import &#123;useRouter&#125; from &#39;vue-router&#39;\n  import &#123;ref&#125; from &#39;vue&#39;\n  const router = useRouter()\n  let myPath = ref(&quot;&quot;)\n\n  function showList() &#123;\n    router.push(&quot;/list&quot;)\n  &#125;\n  //通过输入的数据实现跳转\n  function goMyPage() &#123;\n    router.push(myPath.value)\n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;!--声明式路由--&gt;\n    &lt;router-link to=&quot;/home&quot;&gt;home&lt;/router-link&gt; &lt;br&gt;\n    &lt;router-link to=&quot;/list&quot;&gt;list&lt;/router-link&gt; &lt;br&gt;\n    &lt;router-link to=&quot;/add&quot;&gt;add&lt;/router-link&gt; &lt;br&gt;\n    &lt;router-link to=&quot;/update&quot;&gt;update&lt;/router-link&gt; &lt;br&gt;\n    &lt;!--编程式路由--&gt;\n    &lt;button @click=&quot;showList()&quot;&gt;list&lt;/button&gt; &lt;br&gt;\n    &lt;button @click=&quot;goMyPage()&quot;&gt;Go&lt;/button&gt; &lt;input type=&quot;text&quot; v-model=&quot;myPath&quot;&gt;\n    &lt;hr&gt;\n    &lt;router-view&gt;&lt;/router-view&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;7.5 路由传参(useRoute)\n\n\n\n\n\n\n\n\n路径参数\n\n在路径中使用一个动态字段来实现，我们称之为 路径参数\n例如： 查看数据详情  /showDetail/1  ,1就是要查看详情的id,可以动态添值！\n\n\n\n\n\n\n\n\n\n\n键值对参数\n类似与get请求通过url传参,数据是键值对形式的\n\n例如:  查看数据详情/showDetail?hid=1,hid=1就是要传递的键值对参数\n\n在 Vue 3 和 Vue Router 4 中，你可以使用  useRoute 这个函数从 Vue 的组合式 API 中获取路由对象。\n\nuseRoute 方法返回的是当前的 route 对象，你可以用它来获取关于当前路由的信息，如当前的路径、查询参数等。\n\n\n\n\n\n\n\n\n\n\n\n案例需求 : 切换到ShowDetail.vue组件时,向该组件通过路由传递参数\n\n修改App.vue文件\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n\n  import &#123;useRouter&#125; from &#39;vue-router&#39;\n\n  //创建动态路由对象\n  let router = useRouter()\n  //动态路由路径传参方法\n  let showDetail= (id,language)=&gt;&#123;\n      // 尝试使用拼接字符串方式传递路径参数\n      //router.push(`showDetail/$&#123;id&#125;/$&#123;languange&#125;`)\n      /*路径参数,需要使用params  */\n      router.push(&#123;name:&quot;showDetail&quot;,params:&#123;id:id,language:language&#125;&#125;)\n  &#125;\n  let showDetail2= (id,language)=&gt;&#123;\n      /*uri键值对参数,需要使用query */\n      router.push(&#123;path:&quot;/showDetail2&quot;,query:&#123;id:id,language:language&#125;&#125;)\n  &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;h1&gt;App页面&lt;/h1&gt;\n      &lt;hr/&gt;\n      &lt;!-- 路径参数   --&gt;\n      &lt;router-link to=&quot;/showDetail/1/JAVA&quot;&gt;showDetail路径传参显示JAVA&lt;/router-link&gt; \n      &lt;button @click=&quot;showDetail(1,&#39;JAVA&#39;)&quot;&gt;showDetail动态路由路径传参显示JAVA&lt;/button&gt;\n      &lt;hr/&gt;\n      &lt;!-- 键值对参数 --&gt;\n      &lt;router-link v-bind:to=&quot;&#123;path:&#39;/showDetail2&#39;,query:&#123;id:1,language:&#39;Java&#39;&#125;&#125;&quot;&gt;showDetail2键值对传参显示JAVA&lt;/router-link&gt; \n      &lt;button @click=&quot;showDetail2(1,&#39;JAVA&#39;)&quot;&gt;showDetail2动态路由键值对传参显示JAVA&lt;/button&gt;\n      &lt;hr&gt;\n      showDetail视图展示:&lt;router-view name=&quot;showDetailView&quot;&gt;&lt;/router-view&gt;\n      &lt;hr&gt;\n      showDetail2视图展示:&lt;router-view name=&quot;showDetailView2&quot;&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n修改router.js增加路径参数占位符\n\njavascript// 导入路由创建的相关方法\nimport &#123;createRouter,createWebHashHistory&#125; from &#39;vue-router&#39;\n\n// 导入vue组件\n\nimport ShowDetail from &#39;../components/ShowDetail.vue&#39;\nimport ShowDetail2 from &#39;../components/ShowDetail2.vue&#39;\n\n// 创建路由对象,声明路由规则\nconst router = createRouter(&#123;\n    history: createWebHashHistory(),\n    routes:[\n        \n        &#123;\n            /* 此处:id  :language作为路径的占位符 */\n            path:&#39;/showDetail/:id/:language&#39;,\n            /* 动态路由传参时,根据该名字找到该路由 */\n            name:&#39;showDetail&#39;,\n            components:&#123;\n                showDetailView:ShowDetail\n            &#125;  \n        &#125;,\n        &#123;\n            path:&#39;/showDetail2&#39;,\n            components:&#123;\n                showDetailView2:ShowDetail2\n            &#125;  \n        &#125;,\n    ]\n\n&#125;)\n\n// 对外暴露路由对象\nexport default router;\nShowDetail.vue 通过useRoute获取路径参数\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n    import&#123;useRoute&#125; from &#39;vue-router&#39;\n    import &#123; onUpdated,ref &#125; from &#39;vue&#39;;\n    // 获取当前的route对象\n    let route =useRoute()\n    let languageId = ref(0)\n    let languageName = ref(&#39;&#39;)\n    //  借助更新时生命周期,将数据更新进入响应式对象\n    onUpdated (()=&gt;&#123;\n        // 获取对象中的参数\n        languageId.value=route.params.id\n        languageName.value=route.params.language\n        console.log(languageId.value)\n        console.log(languageName.value)\n    &#125;)\n    \n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;ShowDetail页面&lt;/h1&gt;\n        &lt;h3&gt;编号&#123;&#123;route.params.id&#125;&#125;:&#123;&#123;route.params.language&#125;&#125;是世界上最好的语言&lt;/h3&gt;\n        &lt;h3&gt;编号&#123;&#123;languageId&#125;&#125;:&#123;&#123;languageName&#125;&#125;是世界上最好的语言&lt;/h3&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\nShowDetail2.vue通过useRoute获取键值对参数\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n    import&#123;useRoute&#125; from &#39;vue-router&#39;\n    import &#123; onUpdated,ref &#125; from &#39;vue&#39;;\n    // 获取当前的route对象\n    let route =useRoute()\n    let languageId = ref(0)\n    let languageName = ref(&#39;&#39;)\n    //  借助更新时生命周期,将数据更新进入响应式对象\n    onUpdated (()=&gt;&#123;\n        // 获取对象中的参数(通过query获取参数,此时参数是key-value形式的)\n        console.log(route.query)\n        console.log(languageId.value)\n        console.log(languageName.value)\n        languageId.value=route.query.id\n        languageName.value=route.query.language\n       \n    &#125;)\n    \n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;ShowDetail2页面&lt;/h1&gt;\n        &lt;h3&gt;编号&#123;&#123;route.query.id&#125;&#125;:&#123;&#123;route.query.language&#125;&#125;是世界上最好的语言&lt;/h3&gt;\n        &lt;h3&gt;编号&#123;&#123;languageId&#125;&#125;:&#123;&#123;languageName&#125;&#125;是世界上最好的语言&lt;/h3&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n7.6 路由守卫\n\n\n\n\n\n\n\n\n在 Vue 3 中，路由守卫是用于在路由切换期间进行一些特定任务的回调函数。路由守卫可以用于许多任务，例如验证用户是否已登录、在路由切换前提供确认提示、请求数据等。Vue 3 为路由守卫提供了全面的支持，并提供了以下几种类型的路由守卫：\n\n全局前置守卫：在路由切换前被调用，可以用于验证用户是否已登录、中断导航、请求数据等。\n全局后置守卫：在路由切换之后被调用，可以用于处理数据、操作 DOM 、记录日志等。\n守卫代码的位置: 在router.js中\n\njavascript//全局前置路由守卫\nrouter.beforeEach( (to,from,next) =&gt; &#123;\n    //to 是目标地包装对象  .path属性可以获取地址\n    //from 是来源地包装对象 .path属性可以获取地址\n    //next是方法，不调用默认拦截！ next() 放行,直接到达目标组件\n    //next(&#39;/地址&#39;)可以转发到其他地址,到达目标组件前会再次经过前置路由守卫\n    console.log(to.path,from.path,next)\n\n    //需要判断，注意避免无限重定向\n    if(to.path == &#39;/index&#39;)&#123;\n        next()\n    &#125;else&#123;\n        next(&#39;/index&#39;)\n    &#125;\n    \n&#125; )\n\n//全局后置路由守卫\nrouter.afterEach((to, from) =&gt; &#123;\n    console.log(`Navigate from $&#123;from.path&#125; to $&#123;to.path&#125;`);\n&#125;);\n\n\n\n\n\n\n\n\n\n登录案例：登录以后才可以进入home,否则必须进入login\n\n定义Login.vue\n\nvue&lt;script setup&gt;\n    import &#123;ref&#125; from &#39;vue&#39;\n    import &#123;useRouter&#125; from &#39;vue-router&#39;\n    let username =ref(&#39;&#39;)\n    let password =ref(&#39;&#39;)\n    let router = useRouter();\n    let login = () =&gt;&#123;\n        console.log(username.value,password.value)\n        if(username.value == &#39;root&#39; &amp; password.value == &#39;123456&#39;)&#123;\n            router.push(&#123;path:&#39;/home&#39;,query:&#123;&#39;username&#39;:username.value&#125;&#125;)\n            //登录成功利用前端存储机制，存储账号！\n            localStorage.setItem(&#39;username&#39;,username.value)\n            //sessionStorage.setItem(&#39;username&#39;,username)\n        &#125;else&#123;\n            alert(&#39;登录失败，账号或者密码错误！&#39;);\n        &#125;\n    &#125;\n\n&lt;/script&gt;\n\n&lt;template&gt;\n    \n    &lt;div&gt;\n        账号： &lt;input type=&quot;text&quot; v-model=&quot;username&quot; placeholder=&quot;请输入账号！&quot;&gt;&lt;br&gt;\n        密码： &lt;input type=&quot;password&quot; v-model=&quot;password&quot; placeholder=&quot;请输入密码！&quot;&gt;&lt;br&gt;\n        &lt;button @click=&quot;login()&quot;&gt;登录&lt;/button&gt;\n    &lt;/div&gt;\n\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n定义Home.vue\n\nvue&lt;script setup&gt;\n import &#123;ref&#125; from &#39;vue&#39;\n import &#123;useRoute,useRouter&#125; from &#39;vue-router&#39;\n\n let route =useRoute()\n let router = useRouter()\n //  并不是每次进入home页时,都有用户名参数传入\n //let username = route.query.username\n let username =window.localStorage.getItem(&#39;username&#39;); \n\n let logout= ()=&gt;&#123;\n    // 清除localStorge中的username\n    //window.sessionStorage.removeItem(&#39;username&#39;)\n    window.localStorage.removeItem(&#39;username&#39;)\n    // 动态路由到登录页\n    router.push(&quot;/login&quot;)\n\n &#125;\n\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;Home页面&lt;/h1&gt;\n        &lt;h3&gt;欢迎&#123;&#123;username&#125;&#125;登录&lt;/h3&gt;\n            &lt;button @click=&quot;logout&quot;&gt;退出登录&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;\n\nApp.vue\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n\n  \n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      \n      &lt;router-view&gt;&lt;/router-view&gt;\n      \n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n定义routers.js\n\njavascript// 导入路由创建的相关方法\nimport &#123;createRouter,createWebHashHistory&#125; from &#39;vue-router&#39;\n\n// 导入vue组件\n\nimport Home from &#39;../components/Home.vue&#39;\nimport Login from &#39;../components/login.vue&#39;\n// 创建路由对象,声明路由规则\nconst router = createRouter(&#123;\n    history: createWebHashHistory(),\n    routes:[\n        &#123;\n            path:&#39;/home&#39;,\n            component:Home\n        &#125;,\n        &#123;\n            path:&#39;/&#39;,\n            redirect:&quot;/home&quot;\n        &#125;,\n        &#123;\n            path:&#39;/login&#39;,\n            component:Login\n        &#125;,\n    ]\n\n&#125;)\n\n// 设置路由的全局前置守卫\nrouter.beforeEach((to,from,next)=&gt;&#123;\n    /* \n    to 要去那\n    from 从哪里来\n    next 放行路由时需要调用的方法,不调用则不放行\n    */\n    console.log(`从哪里来:$&#123;from.path&#125;,到哪里去:$&#123;to.path&#125;`)\n\n    if(to.path == &#39;/login&#39;)&#123;\n        //放行路由  注意放行不要形成循环  \n        next()\n    &#125;else&#123;\n        //let username =window.sessionStorage.getItem(&#39;username&#39;); \n        let username =window.localStorage.getItem(&#39;username&#39;); \n        if(null != username)&#123;\n            next()\n        &#125;else&#123;\n            next(&#39;/login&#39;)\n        &#125;\n\n    &#125;\n&#125;)\n// 设置路由的全局后置守卫\nrouter.afterEach((to,from)=&gt;&#123;\n    console.log(`从哪里来:$&#123;from.path&#125;,到哪里去:$&#123;to.path&#125;`)\n&#125;)\n\n// 对外暴露路由对象\nexport default router;\n启动测试\n\nshellnpm run dev\n八、Vue3数据交互axios8.0 预讲知识-promise8.0.1 普通函数和回调函数\n\n\n\n\n\n\n\n\n普通函数: 正常调用的函数,一般函数执行完毕后才会继续执行下一行代码\nhtml&lt;script&gt;\n    let fun1 = () =&gt;&#123;\n        console.log(&quot;fun1 invoked&quot;)\n    &#125;\n    // 调用函数\n    fun1()\n    // 函数执行完毕,继续执行后续代码\n    console.log(&quot;other code processon&quot;)\n&lt;/script&gt;\n\n\n\n\n\n\n\n\n回调函数: 一些特殊的函数,表示未来才会执行的一些功能,后续代码不会等待该函数执行完毕就开始执行了\nhtml&lt;script&gt;\n    // 设置一个2000毫秒后会执行一次的定时任务\n    setTimeout(function ()&#123;\n        console.log(&quot;setTimeout invoked&quot;)\n    &#125;,2000)\n    console.log(&quot;other code processon&quot;)\n&lt;/script&gt;8.0.2 Promise 简介\n\n\n\n\n\n\n\n\n前端中的异步编程技术，类似Java中的多线程+线程结果回调！\n\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n\n\n\n\n\n\n\n\n\nPromise对象有以下两个特点。\n\nPromise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。\n\n8.0.3 Promise 基本用法\n\n\n\n\n\n\n\n\nES6规定，Promise对象是一个构造函数，用来生成Promise实例。\nhtml    &lt;script&gt;\n        \n       /*  \n        1.实例化promise对象,并且执行(类似Java创建线程对象,并且start)\n        参数: resolve,reject随意命名,但是一般这么叫!\n        参数: resolve,reject分别处理成功和失败的两个函数! 成功resolve(结果)  失败reject(结果)\n        参数: 在function中调用这里两个方法,那么promise会处于两个不同的状态\n        状态: promise有三个状态\n                pending   正在运行\n                resolved  内部调用了resolve方法\n                rejected  内部调用了reject方法\n        参数: 在第二步回调函数中就可以获取对应的结果 \n        */\n        let promise =new Promise(function(resolve,reject)&#123;\n            console.log(&quot;promise do some code ... ...&quot;)\n            //resolve(&quot;promise success&quot;)\n            reject(&quot;promise fail&quot;)\n        &#125;)\n        console.log(&#39;other code1111 invoked&#39;)\n        //2.获取回调函数结果  then在这里会等待promise中的运行结果,但是不会阻塞代码继续运行\n        promise.then(\n            function(value)&#123;console.log(`promise中执行了resolve:$&#123;value&#125;`)&#125;,\n            function(error)&#123;console.log(`promise中执行了reject:$&#123;error&#125;`)&#125;\n        )\n        // 3 其他代码执行   \n        console.log(&#39;other code2222 invoked&#39;)\n    &lt;/script&gt;8.0.4 Promise catch()\n\n\n\n\n\n\n\n\nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\nhtml&lt;script&gt;\n    let promise =new Promise(function(resolve,reject)&#123;\n        console.log(&quot;promise do some code ... ...&quot;)\n        // 故意响应一个异常对象\n        throw new Error(&quot;error message&quot;)\n    &#125;)\n    console.log(&#39;other code1111 invoked&#39;)\n    /* \n        then中的reject()的对应方法可以在产生异常时执行,接收到的就是异常中的提示信息\n        then中可以只留一个resolve()的对应方法,reject()方法可以用后续的catch替换\n        then中的reject对应的回调函数被后续的catch替换后,catch中接收的数据是一个异常对象\n        */\n    promise.then(\n        function(resolveValue)&#123;console.log(`promise中执行了resolve:$&#123;resolveValue&#125;`)&#125;\n        //,\n        //function(rejectValue)&#123;console.log(`promise中执行了reject:$&#123;rejectValue&#125;`)&#125;\n    ).catch(\n        function(error)&#123;console.log(error)&#125; \n    )\n    console.log(&#39;other code2222 invoked&#39;)\n&lt;/script&gt;8.0.5 async和await的使用\n\n\n\n\n\n\n\n\n&#x20;async和await是ES6中用于处理异步操作的新特性。通常，异步操作会涉及到Promise对象，而async&#x2F;await则是在Promise基础上提供了更加直观和易于使用的语法。\n\n\n\n\n\n\n\n\n\n async 用于标识函数的\n\nasync标识函数后,async函数的返回值会变成一个promise对象\n\n如果函数内部返回的数据是一个非promise对象,async函数的结果会返回一个成功状态 promise对象\n\n如果函数内部返回的是一个promise对象,则async函数返回的状态与结果由该对象决定\n\n如果函数内部抛出的是一个异常,则async函数返回的是一个失败的promise对象\n\n\nhtml&lt;script&gt;\n\n    /* \n        async 用于标识函数的\n            1. async标识函数后,async函数的返回值会变成一个promise对象\n            2. 如果函数内部返回的数据是一个非promise对象,async函数的结果会返回一个成功状态 promise对象\n            3. 如果函数内部返回的是一个promise对象,则async函数返回的状态与结果由该对象决定\n            4. 如果函数内部抛出的是一个异常,则async函数返回的是一个失败的promise对象\n\n        */\n        async function fun1()&#123;\n            //return 10\n            //throw new Error(&quot;something wrong&quot;)\n            let promise = Promise.reject(&quot;heihei&quot;)\n            return promise\n        &#125;\n\n        let promise =fun1()\n\n        promise.then(\n            function(value)&#123;\n                console.log(&quot;success:&quot;+value)\n            &#125;\n        ).catch(\n            function(value)&#123;\n                console.log(&quot;fail:&quot;+value)\n            &#125;\n        )\n&lt;/script&gt;\n\n\n\n\n\n\n\n\nawait\n\nawait右侧的表达式一般为一个promise对象,但是也可以是一个其他值\n如果表达式是promise对象,await返回的是promise成功的值\nawait会等右边的promise对象执行结束,然后再获取结果,await后续代码也会等待await的执行\n如果表达式是其他值,则直接返回该值\nawait必须在async函数中,但是async函数中可以没有await\n如果await右边的promise失败了,就会抛出异常,需要通过 try … catch捕获处理\n\nhtml&lt;script&gt;\n    /* \n            1. await右侧的表达式一般为一个promise对象,但是也可以是一个其他值\n            2. 如果表达式是promise对象,await返回的是promise成功的值\n            3. await会等右边的promise对象执行结束,然后再获取结果,后续代码也会等待await的执行\n            4. 如果表达式是其他值,则直接返回该值\n            5. await必须在async函数中,但是async函数中可以没有await\n            6. 如果await右边的promise失败了,就会抛出异常,可以通过 try ... catch捕获处理\n        */\n\n        async function fun1()&#123;\n            return 10\n        \n        &#125;\n\n        async function fun2()&#123;\n            try&#123;\n                \n                let res = await fun1()\n                //let res = await Promise.reject(&quot;something wrong&quot;)\n            &#125;catch(e)&#123;\n                console.log(&quot;catch got:&quot;+e)   \n            &#125;\n            \n            console.log(&quot;await got:&quot;+res)\n        &#125;\n\n        fun2()\n&lt;/script&gt;8.1 Axios介绍\n\n\n\n\n\n\n\n\n ajax\n\nAJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\n\nAJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n\nAJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。\n\nAJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。\n\nXMLHttpRequest 只是实现 Ajax 的一种方式。\n\n\najax工作原理：\n\n\n\n\n\n\n\n\n\n\n 原生javascript方式进行ajax(了解):\nhtml&lt;script&gt;\n  function loadXMLDoc()&#123;\n    var xmlhttp;\n    if (window.XMLHttpRequest)&#123;\n      //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码\n      xmlhttp=new XMLHttpRequest();\n    &#125;\n    else&#123;\n      // IE6, IE5 浏览器执行代码\n      xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n    &#125;\n      // 设置回调函数处理响应结果\n    xmlhttp.onreadystatechange=function()&#123;\n      if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)\n      &#123;\n        document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;\n      &#125;\n    &#125;\n      // 设置请求方式和请求的资源路径\n    xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true);\n      // 发送请求\n    xmlhttp.send();\n  &#125;\n&lt;/script&gt;   \n\n\n\n\n\n\n\n\n 什么是axios  官网介绍:https://axios-http.com/zh/docs/intro\nAxios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。它有如下特性\n\n从浏览器创建 XMLHttpRequests\n从 node.js 创建 http 请求\n支持 Promise API\n拦截请求和响应\n转换请求和响应数据\n取消请求\n自动转换JSON数据\n客户端支持防御XSRF\n\n如何使用axios\naxios(&#123;设置请求的参数&#125;)：请求三要素\n\n请求的url\n请求的方式\n请求的参数key-value或json\n\n8.2 Axios 入门案例\n\n\n\n\n\n\n\n\n1 案例需求:请求后台获取随机土味情话\n\n请求的url\n\nhttphttps://api.uomg.com/api/rand.qinghua?format=json    或者使用  http://forum.atguigu.cn/api/rand.qinghua?format=json\n请求的方式\n\nhttpGET/POST\n数据返回的格式\n\njson&#123;&quot;code&quot;:1,&quot;content&quot;:&quot;我努力不是为了你而是因为你。&quot;&#125;\n\n\n\n\n\n\n\n\n2 准备项目\njavascriptnpm create vite\nnpm install \n/*npm install vue-router@4 --save\nnpm install pinia */\n\n\n\n\n\n\n\n\n 3 安装axios\nshellnpm install axios\n\n\n\n\n\n\n\n\n4 设计页面（App.Vue）\n\n请求方式是get，需要通过params进行发送。params都是以键值对方式将数据放入url后\n请求方式是post，并且使用data。则data中的数据会 以JSNO形式放入请求体\n\nhtml&lt;script setup type=&quot;module&quot;&gt;\n  import axios from &#39;axios&#39;\n  import &#123; onMounted,reactive &#125; from &#39;vue&#39;;\n    \n  let jsonData =reactive(&#123;code:1,content:&#39;我努力不是为了你而是因为你&#39;&#125;)\n\n  let getLoveMessage =()=&gt;&#123;\n    axios(&#123;\n      method:&quot;post&quot;, // 请求方式\n      url:&quot;https://api.uomg.com/api/rand.qinghua?format=json&quot;,  // 请求的url\n      data:&#123; // 当请求方式为post时,data下的数据以JSON串放入请求体,否则以key=value形式放url后\n        username:&quot;123456&quot;\n      &#125;\n    &#125;).then( function (response)&#123;//响应成功时要执行的函数\n      console.log(response)\n      Object.assign(jsonData,response.data)\n    &#125;).catch(function (error)&#123;// 响应失败时要执行的函数\n      console.log(error)\n    &#125;)\n  &#125;\n\n  /* 通过onMounted生命周期,自动加载一次 */\n  onMounted(()=&gt;&#123;\n    getLoveMessage()\n  &#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;h1&gt;今日土味情话:&#123;&#123;jsonData.content&#125;&#125;&lt;/h1&gt;\n      &lt;button  @click=&quot;getLoveMessage&quot;&gt;获取今日土味情话&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n 5 启动测试\nshellnpm run dev\n\n\n\n\n\n\n\n\n异步响应的数据结构\n\n响应的数据是经过包装返回的！一个请求的响应包含以下信息。\n\njson&#123;\n  // `data` 由服务器提供的响应\n  data: &#123;&#125;,\n  // `status` 来自服务器响应的 HTTP 状态码\n  status: 200,\n  // `statusText` 来自服务器响应的 HTTP 状态信息\n  statusText: &#39;OK&#39;,\n  // `headers` 是服务器响应头\n  // 所有的 header 名称都是小写，而且可以使用方括号语法访问\n  // 例如: `response.headers[&#39;content-type&#39;]`\n  headers: &#123;&#125;,\n  // `config` 是 `axios` 请求的配置信息\n  config: &#123;&#125;,\n  // `request` 是生成此响应的请求\n  // 在node.js中它是最后一个ClientRequest实例 (in redirects)，\n  // 在浏览器中则是 XMLHttpRequest 实例\n  request: &#123;&#125;\n&#125;\nthen取值\n\njavascriptthen(function (response) &#123;\n    console.log(response.data);\n    console.log(response.status);\n    console.log(response.statusText);\n    console.log(response.headers);\n    console.log(response.config);\n&#125;);\n\n\n\n\n\n\n\n\n6 通过async和await处理异步请求\nhtml&lt;script setup type=&quot;module&quot;&gt;\n  import axios from &#39;axios&#39;\n  import &#123; onMounted,reactive &#125; from &#39;vue&#39;;\n    \n  let jsonData =reactive(&#123;code:1,content:&#39;我努力不是为了你而是因为你&#39;&#125;)\n\n  let getLoveWords = async ()=&gt;&#123;\n    return await axios(&#123;\n      method:&quot;post&quot;,\n      url:&quot;https://api.uomg.com/api/rand.qinghua?format=json&quot;,\n      data:&#123;\n        username:&quot;123456&quot;\n      &#125;\n    &#125;)\n  &#125;\n\n  let getLoveMessage =()=&gt;&#123;\n        let &#123;data&#125;  = await getLoveWords()\n     Object.assign(message,data)\n  &#125;\n\n  /* 通过onMounted生命周期,自动加载一次 */\n  onMounted(()=&gt;&#123;\n    getLoveMessage()\n  &#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;h1&gt;今日土味情话:&#123;&#123;jsonData.content&#125;&#125;&lt;/h1&gt;\n      &lt;button  @click=&quot;getLoveMessage&quot;&gt;获取今日土味情话&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n axios在发送异步请求时的可选配置：\njson&#123;\n  // `url` 是用于请求的服务器 URL\n  url: &#39;/user&#39;,\n  // `method` 是创建请求时使用的方法\n  method: &#39;get&#39;, // 默认值\n  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: &#39;https://some-domain.com/api/&#39;,\n  // `transformRequest` 允许在向服务器发送前，修改请求数据\n  // 它只能用于 &#39;PUT&#39;, &#39;POST&#39; 和 &#39;PATCH&#39; 这几个请求方法\n  // 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream\n  // 你可以修改请求头。\n  transformRequest: [function (data, headers) &#123;\n    // 对发送的 data 进行任意转换处理\n    return data;\n  &#125;],\n  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) &#123;\n    // 对接收的 data 进行任意转换处理\n    return data;\n  &#125;],\n  // 自定义请求头\n  headers: &#123;&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;&#125;,\n  // `params` 是与请求一起发送的 URL 参数\n  // 必须是一个简单对象或 URLSearchParams 对象\n  params: &#123;\n    ID: 12345\n  &#125;,\n  // `paramsSerializer`是可选方法，主要用于序列化`params`\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function (params) &#123;\n    return Qs.stringify(params, &#123;arrayFormat: &#39;brackets&#39;&#125;)\n  &#125;,\n  // `data` 是作为请求体被发送的数据\n  // 仅适用 &#39;PUT&#39;, &#39;POST&#39;, &#39;DELETE 和 &#39;PATCH&#39; 请求方法\n  // 在没有设置 `transformRequest` 时，则必须是以下类型之一:\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - 浏览器专属: FormData, File, Blob\n  // - Node 专属: Stream, Buffer\n  data: &#123;\n    firstName: &#39;Fred&#39;\n  &#125;,\n  // 发送请求体数据的可选语法\n  // 请求方式 post\n  // 只有 value 会被发送，key 则不会\n  data: &#39;Country=Brasil&amp;City=Belo Horizonte&#39;,\n  // `timeout` 指定请求超时的毫秒数。\n  // 如果请求时间超过 `timeout` 的值，则请求会被中断\n  timeout: 1000, // 默认值是 `0` (永不超时)\n  // `withCredentials` 表示跨域请求时是否需要使用凭证\n  withCredentials: false, // default\n  // `adapter` 允许自定义处理请求，这使测试更加容易。\n  // 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。\n  adapter: function (config) &#123;\n    /* ... */\n  &#125;,\n  // `auth` HTTP Basic Auth\n  auth: &#123;\n    username: &#39;janedoe&#39;,\n    password: &#39;s00pers3cret&#39;\n  &#125;,\n  // `responseType` 表示浏览器将要响应的数据类型\n  // 选项包括: &#39;arraybuffer&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;\n  // 浏览器专属：&#39;blob&#39;\n  responseType: &#39;json&#39;, // 默认值\n  // `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)\n  // 注意：忽略 `responseType` 的值为 &#39;stream&#39;，或者是客户端请求\n  // Note: Ignored for `responseType` of &#39;stream&#39; or client-side requests\n  responseEncoding: &#39;utf8&#39;, // 默认值\n  // `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称\n  xsrfCookieName: &#39;XSRF-TOKEN&#39;, // 默认值\n  // `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称\n  xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;, // 默认值\n  // `onUploadProgress` 允许为上传处理进度事件\n  // 浏览器专属\n  onUploadProgress: function (progressEvent) &#123;\n    // 处理原生进度事件\n  &#125;,\n  // `onDownloadProgress` 允许为下载处理进度事件\n  // 浏览器专属\n  onDownloadProgress: function (progressEvent) &#123;\n    // 处理原生进度事件\n  &#125;,\n  // `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数\n  maxContentLength: 2000,\n  // `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数\n  maxBodyLength: 2000,\n  // `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。\n  // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，\n  // 则promise 将会 resolved，否则是 rejected。\n  validateStatus: function (status) &#123;\n    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认值\n  &#125;,\n  // `maxRedirects` 定义了在node.js中要遵循的最大重定向数。\n  // 如果设置为0，则不会进行重定向\n  maxRedirects: 5, // 默认值\n  // `socketPath` 定义了在node.js中使用的UNIX套接字。\n  // e.g. &#39;/var/run/docker.sock&#39; 发送请求到 docker 守护进程。\n  // 只能指定 `socketPath` 或 `proxy` 。\n  // 若都指定，这使用 `socketPath` 。\n  socketPath: null, // default\n  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http\n  // and https requests, respectively, in node.js. This allows options to be added like\n  // `keepAlive` that are not enabled by default.\n  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),\n  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),\n  // `proxy` 定义了代理服务器的主机名，端口和协议。\n  // 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。\n  // 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。\n  // `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。\n  // 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。\n  // 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`\n  proxy: &#123;\n    protocol: &#39;https&#39;,\n    host: &#39;127.0.0.1&#39;,\n    port: 9000,\n    auth: &#123;\n      username: &#39;mikeymike&#39;,\n      password: &#39;rapunz3l&#39;\n    &#125;\n  &#125;,\n  // see https://axios-http.com/zh/docs/cancellation\n  cancelToken: new CancelToken(function (cancel) &#123;\n  &#125;),\n  // `decompress` indicates whether or not the response body should be decompressed \n  // automatically. If set to `true` will also remove the &#39;content-encoding&#39; header \n  // from the responses objects of all decompressed responses\n  // - Node only (XHR cannot turn off decompression)\n  decompress: true // 默认值\n&#125;8.3 Axios get和post方法\n\n\n\n\n\n\n\n\n配置添加语法\njavascript发送get请求的方法\naxios.get(url)\n\naxios.get(url[, config])\n\naxios.get(url,&#123;\n   上面指定配置key:配置值,\n   上面指定配置key:配置值\n&#125;)\n\naxios.post(url[, data[, config]])\n\naxios.post(url,&#123;key:value //此位置数据，没有空对象即可&#123;&#125;&#125;,&#123;\n   上面指定配置key:配置值,\n   上面指定配置key:配置值\n&#125;)\n\n\n\n\n\n\n\n\n测试get参数\nhtml&lt;script setup type=&quot;module&quot;&gt;\n  import axios from &#39;axios&#39;\n  import &#123; onMounted,ref,reactive,toRaw &#125; from &#39;vue&#39;;\n  let jsonData =reactive(&#123;code:1,content:&#39;我努力不是为了你而是因为你&#39;&#125;)\n\n  let getLoveWords= async ()=&gt;&#123;\n    try&#123;\n      return await axios.get(\n        &#39;https://api.uomg.com/api/rand.qinghua&#39;,\n        &#123;\n          params:&#123;// 向url后添加的键值对参数\n            format:&#39;json&#39;,\n            username:&#39;zhangsan&#39;,\n            password:&#39;123456&#39;\n          &#125;,\n          headers:&#123;// 设置请求头\n            &#39;Accept&#39; : &#39;application/json, text/plain, text/html,*/*&#39;\n          &#125;\n        &#125;\n      )\n    &#125;catch (e)&#123;\n      return await e\n    &#125;\n  &#125;\n\n  let getLoveMessage =()=&gt;&#123;\n     let &#123;data&#125;  = await getLoveWords()\n     Object.assign(message,data)\n  &#125;\n  /* 通过onMounted生命周期,自动加载一次 */\n  onMounted(()=&gt;&#123;\n    getLoveMessage()\n  &#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;h1&gt;今日土味情话:&#123;&#123;jsonData.content&#125;&#125;&lt;/h1&gt;\n      &lt;button  @click=&quot;getLoveMessage&quot;&gt;获取今日土味情话&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n浏览器查询如下\n\n\n\n\n\n\n\n\n\n\n测试post参数\nhtml&lt;script setup type=&quot;module&quot;&gt;\n  import axios from &#39;axios&#39;\n  import &#123; onMounted,ref,reactive,toRaw &#125; from &#39;vue&#39;;\n  let jsonData =reactive(&#123;code:1,content:&#39;我努力不是为了你而是因为你&#39;&#125;)\n\n  let getLoveWords= async ()=&gt;&#123;\n    try&#123;\n      return await axios.post(\n        &#39;https://api.uomg.com/api/rand.qinghua&#39;,\n        &#123;//请求体中的JSON数据\n            username:&#39;zhangsan&#39;,\n            password:&#39;123456&#39;\n        &#125;,\n        &#123;// 其他参数\n             params:&#123;// url上拼接的键值对参数\n                format:&#39;json&#39;,\n              &#125;,\n              headers:&#123;// 请求头\n                &#39;Accept&#39; : &#39;application/json, text/plain, text/html,*/*&#39;,\n                &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;\n              &#125;\n        &#125;\n      )\n    &#125;catch (e)&#123;\n      return await e\n    &#125;\n  &#125;\n\n  let getLoveMessage =()=&gt;&#123;\n     let &#123;data&#125;  = await getLoveWords()\n     Object.assign(message,data)\n  &#125;\n  /* 通过onMounted生命周期,自动加载一次 */\n  onMounted(()=&gt;&#123;\n    getLoveMessage()\n  &#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;h1&gt;今日土味情话:&#123;&#123;jsonData.content&#125;&#125;&lt;/h1&gt;\n      &lt;button  @click=&quot;getLoveMessage&quot;&gt;获取今日土味情话&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n浏览器查询如下\n\n8.4 Axios 拦截器\n\n\n\n\n\n\n\n\n如果想在axios发送请求之前,或者是数据响应回来在执行then方法之前做一些额外的工作,可以通过拦截器完成\n拦截器具体实现\n\n拦截器的设计\njavascript// 添加请求拦截器 请求发送之前\naxios.interceptors.request.use(\n  function (config) &#123;\n    // 在发送请求之前做些什么\n    return config;\n  &#125;, \n  function (error) &#123;\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  &#125;\n);\n\n// 添加响应拦截器 数据响应回来\naxios.interceptors.response.use(\n  function (response) &#123;\n    // 2xx 范围内的状态码都会触发该函数。\n    // 对响应数据做点什么\n    return response; \n  &#125;, \n  function (error) &#123;\n    // 超出 2xx 范围的状态码都会触发该函数。\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  &#125;\n);\n定义src/axios.js提取拦截器和配置语法\n\njavascriptimport axios from &#39;axios&#39;\n\n//使用axios函数创建一个可以发送请求的实例对象\nconst instance = axios.create(&#123;\n    baseURL:&#39;https://api.uomg.com&#39;,\n    timeout:10000\n&#125;)\n\n//设置请求拦截器\ninstance.interceptors.request.use(\n    (config)=&gt;&#123;\n        console.log(&quot;before request&quot;)\n        //请求之前，设置请求信息的方法\n        config.headers.Accept = &quot;application/json,text/plain,text/html,*/*&quot;\n        return config\n    &#125;\n    ,\n    //请求失败\n    error =&gt; &#123;\n        console.log(&quot;请求前拦截器异常方法&quot;)\n        //返回一个失败状态的promise\n        return Promise.reject(&quot;something wrong&quot;)\n    &#125;\n)\n\n//设置响应拦截器\ninstance.interceptors.response.use(\n    function(response)&#123;\n        //响应状态码为200要执行的方法\n        //处理相应数据\n        //最后要返回response\n        console.log(&quot;response success&quot; + response)\n        return response\n    &#125;\n    ,\n    function(error)&#123;\n        console.log(&quot;response fail:&quot;)\n        console.log(error)\n        //最后一定要响应一个promise\n        return Promise.reject(&quot;something wrong&quot;)\n    &#125;\n)\n\n\n//默认导出\nexport default instance\nApp.vue\n\nhtml&lt;script setup type=&quot;module&quot;&gt;\n  // 导入我们自己定义的axios.js文件,而不是导入axios依赖  \n  import axios from &#39;./axios.js&#39;\n  import &#123; onMounted,ref,reactive,toRaw &#125; from &#39;vue&#39;;\n  let jsonData =reactive(&#123;code:1,content:&#39;我努力不是为了你而是因为你&#39;&#125;)\n\n  let getLoveWords= async ()=&gt;&#123;\n    try&#123;\n      return await axios.post(\n        &#39;api/rand.qinghua&#39;,\n        &#123;\n            username:&#39;zhangsan&#39;,\n            password:&#39;123456&#39;\n        &#125;,//请求体中的JSON数据\n        &#123;\n          params:&#123;\n            format:&#39;json&#39;,\n          &#125;\n        &#125;// 其他键值对参数\n      )\n    &#125;catch (e)&#123;\n      return await e\n    &#125;\n  &#125;\n\n  let getLoveMessage =()=&gt;&#123;\n    // 这里返回的是一个fullfilled状态的promise\n    getLoveWords().then(\n        (response) =&gt;&#123;\n          console.log(&quot;after getloveWords&quot;)\n          console.log(response)\n          Object.assign(jsonData,response.data)\n        &#125;\n    )\n  &#125;\n  /* 通过onMounted生命周期,自动加载一次 */\n  onMounted(()=&gt;&#123;\n    getLoveMessage()\n  &#125;)\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;h1&gt;今日土味情话:&#123;&#123;jsonData.content&#125;&#125;&lt;/h1&gt;\n      &lt;button  @click=&quot;getLoveMessage&quot;&gt;获取今日土味情话&lt;/button&gt;\n    &lt;/div&gt;\n   \n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;对于响应拦截器最后一定要响应一个promise的图解\n\n\n九、Vue3状态管理Pinia9.1 Pinia介绍\n\n\n\n\n\n\n\n\n如何实现多个组件之间的数据传递?\n\n方式1：组件传参   \n\n方式2：路由传参  \n\n方式3：通过pinia状态管理定义共享数据\n\n\n\n\n\n\n\n\n\n\n\n当我们有多个组件共享一个共同的状态(数据源)时，多个视图可能都依赖于同一份状态。来自不同视图的交互也可能需要更改同一份状态。虽然我们的手动状态管理解决方案（props,组件间通信,模块化）在简单的场景中已经足够了，但是在大规模的生产应用中还有很多其他事项需要考虑：\n\n更强的团队协作约定\n与 Vue DevTools 集成，包括时间轴、组件内部审查和时间旅行调试\n模块热更新 (HMR)\n服务端渲染支持\n\n\n\n\n\n\n\n\n\n\n Pinia 就是一个实现了上述需求的状态管理库，由 Vue 核心团队维护，对 Vue 2 和 Vue 3 都可用。https://pinia.vuejs.org/zh/introduction.html\n9.2 Pinia基本用法\n\n\n\n\n\n\n\n\n 1 准备vite项目\nshellnpm create vite\nnpm install \nnpm install vue-router@4 --save\n\n\n\n\n\n\n\n\n 2 安装pinia\nshellnpm install pinia\n\n\n\n\n\n\n\n\n3 定义pinia store对象 src&#x2F;store&#x2F;store.js [推荐这么命名不是强制]\njavascriptimport &#123;defineStore &#125; from &#39;pinia&#39;\n\n//定义数据并且对外暴露\n// store就是定义共享状态的包装对象\n// 内部包含四个属性： id 唯一标识 state 完整类型推理，推荐使用箭头函数 存放的数据 getters 类似属性计算，存储放对数据\n// 操作的方法  actions 存储数据的复杂业务逻辑方法\n// 理解： store类似Java中的实体类， id就是类名， state 就是装数据值的属性  getters就是get方法，actions就是对数据操作的其他方法\nexport const definedPerson = defineStore(\n    &#123;\n        id: &#39;personPinia&#39;, //必须唯一\n        state:()=&gt;&#123; // state中用于定义数据\n            return &#123;\n                username:&#39;张三&#39;,\n                age:0,\n                hobbies:[&#39;唱歌&#39;,&#39;跳舞&#39;]\n            &#125;\n        &#125;,\n        getters:&#123;// 用于定义一些通过数据计算而得到结果的一些方法 一般在此处不做对数据的修改操作\n                 // getters中的方法可以当做属性值方式使用\n            getHobbiesCount()&#123;\n                return this.hobbies.length\n            &#125;,\n            getAge()&#123;\n                return this.age\n            &#125;\n        &#125;,\n        actions:&#123; // 用于定义一些对数据修改的方法\n            doubleAge()&#123;\n                this.age=this.age*2\n            &#125;\n        &#125;\n    &#125;\n)\n\n\n\n\n\n\n\n\n 4 在main.js配置pinia组件到vue中 \njavascriptimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./routers/router.js&#39;\n// 导pinia\nimport &#123; createPinia &#125; from &#39;pinia&#39;\n// 创建pinia对象\nlet pinia= createPinia()\n\nlet app =createApp(App)\napp.use(router)\n// app中使用pinia功能\napp.use(pinia) \napp.mount(&#39;#app&#39;)\n\n\n\n\n\n\n\n\n5 Operate.vue 中操作Pinia数据\nvue&lt;script setup type=&quot;module&quot;&gt;\n    import &#123; ref&#125; from &#39;vue&#39;;\n    import &#123; definedPerson&#125; from &#39;../store/store&#39;;\n    // 读取存储的数据\n    let person= definedPerson()\n\n    let hobby = ref(&#39;&#39;)\n   \n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;operate视图,用户操作Pinia中的数据&lt;/h1&gt;\n        请输入姓名:&lt;input type=&quot;text&quot; v-model=&quot;person.username&quot;&gt; &lt;br&gt;\n        请输入年龄:&lt;input type=&quot;text&quot; v-model=&quot;person.age&quot;&gt; &lt;br&gt;\n        请增加爱好:\n        &lt;input type=&quot;checkbox&quot; value=&quot;吃饭&quot;  v-model=&quot;person.hobbies&quot;&gt; 吃饭\n        &lt;input type=&quot;checkbox&quot; value=&quot;睡觉&quot;  v-model=&quot;person.hobbies&quot;&gt; 睡觉\n        &lt;input type=&quot;checkbox&quot; value=&quot;打豆豆&quot;  v-model=&quot;person.hobbies&quot;&gt; 打豆豆 &lt;br&gt;\n        \n        &lt;!-- 事件中调用person的doubleAge()方法 --&gt;\n        &lt;button @click=&quot;person.doubleAge()&quot;&gt;年龄加倍&lt;/button&gt; &lt;br&gt;\n        &lt;!-- 事件中调用pinia提供的$reset()方法恢复数据的默认值 --&gt;\n        &lt;button @click=&quot;person.$reset()&quot;&gt;恢复默认值&lt;/button&gt; &lt;br&gt;\n        &lt;!-- 事件中调用$patch方法一次性修改多个属性值 --&gt;\n        &lt;button @click=&quot;person.$patch(&#123;username:&#39;奥特曼&#39;,age:100,hobbies:[&#39;晒太阳&#39;,&#39;打怪兽&#39;]&#125;)&quot;&gt;变身奥特曼&lt;/button&gt; &lt;br&gt;\n        显示pinia中的person数据:&#123;&#123;person&#125;&#125;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n6 List.vue中展示Pinia数据\nvue&lt;script setup type=&quot;module&quot;&gt;\n    import &#123; definedPerson&#125; from &#39;../store/store&#39;;\n    // 读取存储的数据\n    let person= definedPerson()\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;List页面,展示Pinia中的数据&lt;/h1&gt;\n        读取姓名:&#123;&#123;person.username&#125;&#125; &lt;br&gt;\n        读取年龄:&#123;&#123;person.age&#125;&#125; &lt;br&gt;\n        通过get年龄:&#123;&#123;person.getAge&#125;&#125; &lt;br&gt;\n        爱好数量:&#123;&#123;person.getHobbiesCount&#125;&#125; &lt;br&gt;\n        所有的爱好:\n        &lt;ul&gt;\n            &lt;li v-for=&#39;(hobby,index) in person.hobbies&#39; :key=&quot;index&quot; v-text=&quot;hobby&quot;&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n7 定义组件路由router.js\njavascript// 导入路由创建的相关方法\nimport &#123;createRouter,createWebHashHistory&#125; from &#39;vue-router&#39;\n\n// 导入vue组件\nimport List  from &#39;../components/List.vue&#39;\nimport Operate  from &#39;../components/Operate.vue&#39;\n// 创建路由对象,声明路由规则\nconst router = createRouter(&#123;\n    history: createWebHashHistory(),\n    routes:[\n        &#123;\n            path:&#39;/opearte&#39;,\n            component:Operate\n        &#125;,\n        \n        &#123;\n            path:&#39;/list&#39;,\n            component:List\n        &#125;,\n    ]\n\n&#125;)\n\n// 对外暴露路由对象\nexport default router;\n\n\n\n\n\n\n\n\n8 App.vue中通过路由切换组件\nvue&lt;script setup type=&quot;module&quot;&gt;\n\n  \n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n      &lt;hr&gt;\n      &lt;router-link to=&quot;/opearte&quot;&gt;显示操作页&lt;/router-link&gt; &lt;br&gt;\n      &lt;router-link to=&quot;/list&quot;&gt;显示展示页&lt;/router-link&gt; &lt;br&gt;\n      &lt;hr&gt;\n      &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n 9 启动测试\nshellnpm run dev9.3 Pinia其他细节\n\n\n\n\n\n\n\n\n State (状态) 在大多数情况下，state 都是你的 store 的核心。人们通常会先定义能代表他们 APP 的 state。在 Pinia 中，state 被定义为一个返回初始状态的函数。\n\nstore.js\n\njavascriptimport &#123;defineStore&#125; from &#39;pinia&#39;\n\nexport const definedPerson = defineStore(&#39;personPinia&#39;,\n    &#123;\n        state:()=&gt;&#123;\n            return &#123;\n                username:&#39;&#39;,\n                age:0,\n                hobbies:[&#39;唱歌&#39;,&#39;跳舞&#39;]\n            &#125;\n        &#125;,\n        getters:&#123;\n            getHobbiesCount()&#123;\n                return this.hobbies.length\n            &#125;,\n            getAge()&#123;\n                return this.age\n            &#125;\n        &#125;,\n        actions:&#123;\n            doubleAge()&#123;\n                this.age=this.age*2\n            &#125;\n        &#125;\n    &#125;\n)\nOperate.vue\n\nvue&lt;script setup type=&quot;module&quot;&gt;\n    import &#123; ref&#125; from &#39;vue&#39;;\n    import &#123; definedPerson&#125; from &#39;../store/store&#39;;\n    // 读取存储的数据\n    let person= definedPerson()\n\n    let hobby = ref(&#39;&#39;)\n    let addHobby= ()=&gt; &#123;\n        console.log(hobby.value)\n        person.hobbies.push(hobby.value)\n    &#125;\n    // 监听状态\n    person.$subscribe((mutation,state)=&gt;&#123;\n        console.log(&#39;---subscribe---&#39;)\n        /* \n        mutation.storeId\n            person.$id一样\n        mutation.payload\n            传递给 cartStore.$patch() 的补丁对象。\n        state 数据状态,其实是一个代理\n        */\n        console.log(mutation)\n        console.log(mutation.type)\n        console.log(mutation.payload)\n        console.log(mutation.storeId)\n        console.log(person.$id)\n        // 数据 其实是一个代理对象\n        console.log(state)\n    &#125;)\n\n\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;div&gt;\n        &lt;h1&gt;operate视图,用户操作Pinia中的数据&lt;/h1&gt;\n        请输入姓名:&lt;input type=&quot;text&quot; v-model=&quot;person.username&quot;&gt; &lt;br&gt;\n        请输入年龄:&lt;input type=&quot;text&quot; v-model=&quot;person.age&quot;&gt; &lt;br&gt;\n        请增加爱好:\n        &lt;input type=&quot;checkbox&quot; value=&quot;吃饭&quot;  v-model=&quot;person.hobbies&quot;&gt; 吃饭\n        &lt;input type=&quot;checkbox&quot; value=&quot;睡觉&quot;  v-model=&quot;person.hobbies&quot;&gt; 睡觉\n        &lt;input type=&quot;checkbox&quot; value=&quot;打豆豆&quot;  v-model=&quot;person.hobbies&quot;&gt; 打豆豆 &lt;br&gt;\n        &lt;input type=&quot;text&quot; @change=&quot;addHobby&quot; v-model=&quot;hobby&quot;&gt; &lt;br&gt;  \n        &lt;!-- 事件中调用person的doubleAge()方法 --&gt;\n        &lt;button @click=&quot;person.doubleAge()&quot;&gt;年龄加倍&lt;/button&gt; &lt;br&gt;\n        &lt;!-- 事件中调用pinia提供的$reset()方法恢复数据的默认值 --&gt;\n        &lt;button @click=&quot;person.$reset()&quot;&gt;恢复默认值&lt;/button&gt; &lt;br&gt;\n        &lt;!-- 事件中调用$patch方法一次性修改多个属性值 --&gt;\n        &lt;button @click=&quot;person.$patch(&#123;username:&#39;奥特曼&#39;,age:100,hobbies:[&#39;晒太阳&#39;,&#39;打怪兽&#39;]&#125;)&quot;&gt;变身奥特曼&lt;/button&gt; &lt;br&gt;\n        person:&#123;&#123;person&#125;&#125;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;style scoped&gt;\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n 2 Getter 完全等同于 store 的 state 的计算值。可以通过 defineStore() 中的 getters 属性来定义它们。推荐使用箭头函数，并且它将接收 state 作为第一个参数：\njavascriptexport const useStore = defineStore(&#39;main&#39;, &#123;\n  state: () =&gt; (&#123;\n    count: 0,\n  &#125;),\n  getters: &#123;\n    doubleCount: (state) =&gt; state.count * 2,\n  &#125;,\n&#125;)\n\n\n\n\n\n\n\n\n 3  Action 相当于组件中的 method。它们可以通过 defineStore() 中的 actions 属性来定义，并且它们也是定义业务逻辑的完美选择。类似 getter，action 也可通过 this 访问整个 store 实例，并支持**完整的类型标注(以及自动补全)**。不同的是，action 可以是异步的，你可以在它们里面 await 调用任何 API，以及其他 action！\njavascriptexport const useCounterStore = defineStore(&#39;main&#39;, &#123;\n  state: () =&gt; (&#123;\n    count: 0,\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.count++\n    &#125;,\n    randomizeCounter() &#123;\n      this.count = Math.round(100 * Math.random())\n    &#125;,\n  &#125;,\n&#125;)\n十、Element-plus组件库10.1 Element-plus介绍\n\n\n\n\n\n\n\n\nElement Plus 是一套基于 Vue 3 的开源 UI 组件库，是由饿了么前端团队开发的升级版本 Element UI。Element Plus 提供了丰富的 UI 组件、易于使用的 API 接口和灵活的主题定制功能，可以帮助开发者快速构建高质量的 Web 应用程序。\n\nElement Plus 支持按需加载，且不依赖于任何第三方 CSS 库，它可以轻松地集成到任何 Vue.js 项目中。Element Plus 的文档十分清晰，提供了各种组件的使用方法和示例代码，方便开发者快速上手。\n\nElement Plus 目前已经推出了大量的常用 UI 组件，如按钮、表单、表格、对话框、选项卡等，此外还提供了一些高级组件，如日期选择器、时间选择器、级联选择器、滑块、颜色选择器等。这些组件具有一致的设计和可靠的代码质量，可以为开发者提供稳定的使用体验。\n\n与 Element UI 相比，Element Plus 采用了现代化的技术架构和更加先进的设计理念，同时具备更好的性能和更好的兼容性。Element Plus 的更新迭代也更加频繁，可以为开发者提供更好的使用体验和更多的功能特性。\n\nElement Plus 可以在支持 ES2018 和 ResizeObserver 的浏览器上运行。 如果您确实需要支持旧版本的浏览器，请自行添加 Babel 和相应的 Polyfill \n\n官网https://element-plus.gitee.io/zh-CN/\n\n由于 Vue 3 不再支持 IE11，Element Plus 也不再支持 IE 浏览器。\n\n\n\n10.2 Element-plus入门案例\n\n\n\n\n\n\n\n\n 1 准备vite项目\nshellnpm create vite  // 注意选择 vue+typeScript\nnpm install \nnpm install vue-router@4 --save\nnpm install pinia\nnpm install axios\n\n\n\n\n\n\n\n\n 2 安装element-plus\nshellnpm install element-plus\n\n\n\n\n\n\n\n\n3 完整引入element-plus\n\nmain.js\n\njavascriptimport &#123; createApp &#125; from &#39;vue&#39;\n//导入element-plus相关内容\nimport ElementPlus from &#39;element-plus&#39;\nimport &#39;element-plus/dist/index.css&#39;\n\nimport App from &#39;./App.vue&#39;\n\nconst app = createApp(App)\n\napp.use(ElementPlus)\napp.mount(&#39;#app&#39;)\n\n\n\n\n\n\n\n\n 4 入门案例\n\nApp.vue\n\nhtml&lt;script setup&gt;\n  import &#123; ref &#125; from &#39;vue&#39;\n\n  const value = ref(true)\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;!-- 直接使用element-plus组件即可 --&gt;\n    &lt;el-button&gt;按钮&lt;/el-button&gt;\n    &lt;br&gt;\n    &lt;el-switch\n      v-model=&quot;value&quot;\n      size=&quot;large&quot;\n      active-text=&quot;Open&quot;\n      inactive-text=&quot;Close&quot;\n    /&gt;\n    &lt;br /&gt;\n    &lt;el-switch v-model=&quot;value&quot; active-text=&quot;Open&quot; inactive-text=&quot;Close&quot; /&gt;\n    &lt;br /&gt;\n    &lt;el-switch\n      v-model=&quot;value&quot;\n      size=&quot;small&quot;\n      active-text=&quot;Open&quot;\n      inactive-text=&quot;Close&quot;\n    /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n5 启动测试\nshellnpm run dev10.3 Element-plus常用组件https://element-plus.gitee.io/zh-CN/component/button.html\n","slug":"Javaweb_前端工程化","date":"2024-03-09T13:29:00.000Z","categories_index":"Javaweb","tags_index":"Javaweb","author_index":"白"},{"id":"726534163fb975f745b43adb13833fcf","title":"会话&过滤器&监听器笔记","content":"第五章 会话&amp;过滤器&amp;监听器笔记一  会话1.1 会话管理概述1.1.1 为什么需要会话管理\n\n\n\n\n\n\n\n\nHTTP是无状态协议\n\n无状态就是不保存状态,即无状态协议(stateless),HTTP协议自身不对请求和响应之间的通信状态进行保存,也就是说,在HTTP协议这个级别,协议对于发送过的请求或者响应都不做持久化处理\n简单理解:浏览器发送请求,服务器接收并响应,但是服务器不记录请求是否来自哪个浏览器,服务器没记录浏览器的特征,就是客户端的状态\n\n\n\n\n\n\n\n\n\n\n举例: 张三去一家饭馆点了几道菜,觉得味道不错,第二天又去了,对老板说,还点上次的那几道菜\n\n无状态: 老板没有记录张三是否来过,更没有记录上次他点了那些菜,张三只能重新再点一遍\n有状态: 老板把每次来吃饭的用户都做好记录,查阅一下之前的记录,查到了张三之前的菜单,直接下单\n\n1.1.2 会话管理实现的手段\n\n\n\n\n\n\n\n\nCookie和Session配合解决\n\ncookie是在客户端保留少量数据的技术,主要通过响应头向客户端响应一些客户端要保留的信息\nsession是在服务端保留更多数据的技术,主要通过HttpSession对象保存一些和客户端相关的信息\ncookie和session配合记录请求状态\n\n\n\n\n\n\n\n\n\n\n举例: 张三去银行办业务\n\n张三第一次去某个银行办业务,银行会为张三开户(Session),并向张三发放一张银行卡(cookie)\n张三后面每次去银行,就可以携带之间的银行卡(cookie),银行根据银行卡找到之前张三的账户(session)\n\n1.2 Cookie1.2.1 Cookie概述\n\n\n\n\n\n\n\n\ncookie是一种客户端会话技术,cookie由服务端产生,它是服务器存放在浏览器的一小份数据,浏览器以后每次访问该服务器的时候都会将这小份数据携带到服务器去。\n\n服务端创建cookie,将cookie放入响应对象中,Tomcat容器将cookie转化为set-cookie响应头,响应给客户端\n客户端在收到cookie的响应头时,在下次请求该服务的资源时,会以cookie请求头的形式携带之前收到的Cookie\ncookie是一种键值对格式的数据,从tomcat8.5开始可以保存中文,但是不推荐\n由于cookie是存储于客户端的数据,比较容易暴露,一般不存储一些敏感或者影响安全的数据\n\n\n\n\n\n\n\n\n\n\n原理图\n\n\n\n\n\n\n\n\n\n\n应用场景举例\n\n记录用户名\n当我们在用户名的输入框中输入完用户名后,浏览器记录用户名,下一次再访问登录页面时,用户名自动填充到用户名的输入框.\n\n保存电影播放进度\n在网页上播放电影的时候,如果中途退出浏览器了,下载再打开浏览器播放同一部电影的时候,会自动跳转到上次退出时候的进度,因为在播放的时候会将播放进度保存到cookie中\n\n\n1.2.2 Cookie的使用\n\n\n\n\n\n\n\n\nservletA向响应中增加Cookie\njava@WebServlet(&quot;/servletA&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 创建Cookie\n        Cookie cookie1 =new Cookie(&quot;c1&quot;,&quot;c1_message&quot;);\n        Cookie cookie2 =new Cookie(&quot;c2&quot;,&quot;c2_message&quot;);\n        // 将cookie放入响应对象\n        resp.addCookie(cookie1);\n        resp.addCookie(cookie2);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\nservletB从请求中读取Cookie\njava@WebServlet(&quot;/servletB&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //获取请求中的cookie\n        Cookie[] cookies = req.getCookies();\n        //迭代cookies数组\n        if (null != cookies &amp;&amp; cookies.length!= 0) &#123;\n            for (Cookie cookie : cookies) &#123;\n                System.out.println(cookie.getName()+&quot;:&quot;+cookie.getValue());\n            &#125;\n        &#125;\n    &#125;\n&#125;\n1.2.2  Cookie的时效性\n\n\n\n\n\n\n\n\n默认情况下Cookie的有效期是一次会话范围内，我们可以通过cookie的setMaxAge()方法让Cookie持久化保存到浏览器上\n\n会话级Cookie\n服务器端并没有明确指定Cookie的存在时间\n在浏览器端，Cookie数据存在于内存中\n只要浏览器还开着，Cookie数据就一直都在\n浏览器关闭，内存中的Cookie数据就会被释放\n\n\n持久化Cookie\n服务器端明确设置了Cookie的存在时间\n在浏览器端，Cookie数据会被保存到硬盘上\nCookie在硬盘上存在的时间根据服务器端限定的时间来管控，不受浏览器关闭的影响\n持久化Cookie到达了预设的时间会被释放\n\n\n\n\n\n\n\n\n\n\n\n\ncookie.setMaxAge(int expiry)参数单位是秒，表示cookie的持久化时间，如果设置参数为0，表示将浏览器中保存的该cookie删除\n\nservletA设置一个Cookie为持久化cookie\n\njava@WebServlet(&quot;/servletA&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 创建Cookie\n        Cookie cookie1 =new Cookie(&quot;c1&quot;,&quot;c1_message&quot;);\n        cookie1.setMaxAge(60);\n        Cookie cookie2 =new Cookie(&quot;c2&quot;,&quot;c2_message&quot;);\n        // 将cookie放入响应对象\n        resp.addCookie(cookie1);\n        resp.addCookie(cookie2);\n    &#125;\n&#125;\n\nservletB接收Cookie,浏览器中间发生一次重启再请求servletB测试\n\njava@WebServlet(&quot;/servletB&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //获取请求中的cookie\n        Cookie[] cookies = req.getCookies();\n        //迭代cookies数组\n        if (null != cookies &amp;&amp; cookies.length!= 0) &#123;\n            for (Cookie cookie : cookies) &#123;\n                System.out.println(cookie.getName()+&quot;:&quot;+cookie.getValue());\n            &#125;\n        &#125;\n    &#125;\n&#125;\n1.2.3 Cookie的提交路径\n\n\n\n\n\n\n\n\n访问互联网资源时不能每次都需要把所有Cookie带上。访问不同的资源时,可以携带不同的cookie,我们可以通过cookie的setPath(String path) 对cookie的路径进行设置\n\n从ServletA中获取cookie\n\njavapublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 创建Cookie\n        Cookie cookie1 =new Cookie(&quot;c1&quot;,&quot;c1_message&quot;);\n        // 设置cookie的提交路径\n        cookie1.setPath(&quot;/web03_war_exploded/servletB&quot;);\n        Cookie cookie2 =new Cookie(&quot;c2&quot;,&quot;c2_message&quot;);\n        // 将cookie放入响应对象\n        resp.addCookie(cookie1);\n        resp.addCookie(cookie2);\n    &#125;\n&#125;\n\n\n向ServletB请求时携带携带了 c1\n\n\n\n向其他资源请求时就不携带c1了\n\n\n1.3 Session1.3.1 HttpSession概述\n\n\n\n\n\n\n\n\n HttpSession是一种保留更多信息在服务端的一种技术,服务器会为每一个客户端开辟一块内存空间,即session对象. 客户端在发送请求时,都可以使用自己的session. 这样服务端就可以通过session来记录某个客户端的状态了\n\n服务端在为客户端创建session时,会同时将session对象的id,即JSESSIONID以cookie的形式放入响应对象\n后端创建完session后,客户端会收到一个特殊的cookie,叫做JSESSIONID\n客户端下一次请求时携带JSESSIONID,后端收到后,根据JSESSIONID找到对应的session对象\n通过该机制,服务端通过session就可以存储一些专门针对某个客户端的信息了\nsession也是域对象(后续详细讲解)\n\n\n\n\n\n\n\n\n\n\n原理图如下\n\n\n\n\n\n\n\n\n\n\n应用场景\n\n记录用户的登录状态\n用户登录后,将用户的账号等敏感信息存入session\n\n记录用户操作的历史\n例如记录用户的访问痕迹,用户的购物车信息等临时性的信息\n\n\n1.3.2 HttpSession的使用\n\n\n\n\n\n\n\n\n用户提交form表单到ServletA,携带用户名,ServletA获取session 将用户名存到Session,用户再请求其他任意Servlet,获取之间存储的用户\n\n定义表单页,提交用户名,提交后\n\nhtml    &lt;form action=&quot;servletA&quot; method=&quot;post&quot;&gt;\n        用户名:\n        &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;\n    &lt;/form&gt;\n定义ServletA,将用户名存入session\n\njava@WebServlet(&quot;/servletA&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 获取请求中的参数\n        String username = req.getParameter(&quot;username&quot;);\n        // 获取session对象\n        HttpSession session = req.getSession();\n         // 获取Session的ID\n        String jSessionId = session.getId();\n        System.out.println(jSessionId);\n        // 判断session是不是新创建的session\n        boolean isNew = session.isNew();\n        System.out.println(isNew);\n        // 向session对象中存入数据\n        session.setAttribute(&quot;username&quot;,username);\n\n    &#125;\n&#125;\n响应中收到了一个JSESSIONID的cookie\n\n\n\n定义其他Servlet,从session中读取用户名\n\njava@WebServlet(&quot;/servletB&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 获取session对象\n        HttpSession session = req.getSession();\n         // 获取Session的ID\n        String jSessionId = session.getId();\n        System.out.println(jSessionId);\n        // 判断session是不是新创建的session\n        boolean isNew = session.isNew();\n        System.out.println(isNew);\n        // 从session中取出数据\n        String username = (String)session.getAttribute(&quot;username&quot;);\n        System.out.println(username);\n    &#125;\n&#125;\n请求中携带了一个JSESSIONID的cookie\n\n\n\n\n\n\n\n\n\n\n\ngetSession方法的处理逻辑\n\n1.3.3 HttpSession时效性\n\n\n\n\n\n\n\n\n为什么要设置session的时效\n\n用户量很大之后，Session对象相应的也要创建很多。如果一味创建不释放，那么服务器端的内存迟早要被耗尽。\n客户端关闭行为无法被服务端直接侦测,或者客户端较长时间不操作也经常出现,类似这些的情况,就需要对session的时限进行设置了\n\n\n\n\n\n\n\n\n\n\n默认的session最大闲置时间(两次使用同一个session中的间隔时间) 在tomcat&#x2F;conf&#x2F;web.xml配置为30分钟\n\n\n\n\n\n\n\n\n\n\n我们可以自己在当前项目的web.xml对最大闲置时间进行重新设定\n\n\n\n\n\n\n\n\n\n\n也可以通过HttpSession的API 对最大闲置时间进行设定\njava// 设置最大闲置时间\nsession.setMaxInactiveInterval(60);\n\n\n\n\n\n\n\n\n也可以直接让session失效\njava// 直接让session失效\nsession.invalidate();1.4 三大域对象1.4.1 域对象概述\n\n\n\n\n\n\n\n\n域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同\n\nweb项目中,我们一定要熟练使用的域对象分别是 请求域,会话域,应用域\n请求域对象是HttpServletRequest ,传递数据的范围是一次请求之内及请求转发\n会话域对象是HttpSession,传递数据的范围是一次会话之内,可以跨多个请求\n应用域对象是ServletContext,传递数据的范围是本应用之内,可以跨多个会话\n\n\n\n\n\n\n\n\n\n\n生活举例: 热水器摆放位置不同,使用的范围就不同\n\n摆在张三工位下,就只有张三一个人能用\n摆在办公室的公共区,办公室内的所有人都可以用\n摆在楼层的走廊区,该楼层的所有人都可以用\n\n\n\n\n\n\n\n\n\n\n三大域对象的数据作用范围图解\n\n请求域（重定向相当于重新发一个请求，申请了一个新的请求域）\n\n\n\n会话域\n\n\n\n应用域\n\n\n\n所有域在一起\n\n\n1.4.2 域对象的使用\n\n\n\n\n\n\n\n\n域对象的API\n\n\n\nAPI\n功能\n\n\n\nvoid setAttribute(String name,String value)\n向域对象中添加&#x2F;修改数据\n\n\nObject getAttribute(String name);\n从域对象中获取数据\n\n\nremoveAttribute(String name);\n移除域对象中的数据\n\n\n\n\n\n\n\n\n\n\n\nAPI测试\n\nServletA向三大域中放入数据\n\njava@WebServlet(&quot;/servletA&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 向请求域中放入数据\n        req.setAttribute(&quot;request&quot;,&quot;request-message&quot;);\n        //req.getRequestDispatcher(&quot;servletB&quot;).forward(req,resp);\n        // 向会话域中放入数据\n        HttpSession session = req.getSession();\n        session.setAttribute(&quot;session&quot;,&quot;session-message&quot;);\n        // 向应用域中放入数据\n        ServletContext application = getServletContext();\n        application.setAttribute(&quot;application&quot;,&quot;application-message&quot;);\n\n    &#125;\n&#125;\n\nServletB从三大于中取出数据\n\njava@WebServlet(&quot;/servletB&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 从请求域中获取数据\n        String reqMessage =(String)req.getAttribute(&quot;request&quot;);\n        System.out.println(reqMessage);\n        \n        // 从会话域中获取数据\n        HttpSession session = req.getSession();\n        String sessionMessage =(String)session.getAttribute(&quot;session&quot;);\n        System.out.println(sessionMessage);\n        // 从应用域中获取数据\n        ServletContext application = getServletContext();\n        String applicationMessage =(String)application.getAttribute(&quot;application&quot;);\n        System.out.println(applicationMessage);\n    &#125;\n&#125;三大域对象总结\n\n请求转发时,请求域可以传递数据请求域内一般放本次请求业务有关的数据,如:查询到的所有的部门信息\n同一个会话内,不用请求转发,会话域可以传递数据会话域内一般放本次会话的客户端有关的数据,如:当前客户端登录的用户 \n同一个APP内,不同的客户端,应用域可以传递数据应用域内一般放本程序应用有关的数据 如:Spring框架的IOC容器\n\n\n二 过滤器2.1 过滤器概述\n\n\n\n\n\n\n\n\nFilter,即过滤器,是JAVAEE技术规范之一,作用目标资源的请求进行过滤的一套技术规范,是Java Web项目中最为实用的技术之一\n\nFilter接口定义了过滤器的开发规范,所有的过滤器都要实现该接口\nFilter的工作位置是项目中所有目标资源之前,容器在创建HttpServletRequest和HttpServletResponse对象后,会先调用Filter的doFilter方法\nFilter的doFilter方法可以控制请求是否继续,如果放行,则请求继续,如果拒绝,则请求到此为止,由过滤器本身做出响应\nFilter不仅可以对请求做出过滤,也可以在目标资源做出响应前,对响应再次进行处理\nFilter是GOF中责任链模式的典型案例\nFilter的常用应用包括但不限于: 登录权限检查,解决网站乱码,过滤敏感字符,日志记录,性能分析… …\n\n\n\n\n\n\n\n\n\n\n生活举例: 公司前台,停车场安保,地铁验票闸机\n\n公司前台对来访人员进行审核,如果是游客则拒绝进入公司,如果是客户则放行 . 客户离开时提醒客户不要遗忘物品\n停车场保安对来访车辆进行控制,如果没有车位拒绝进入,如果有车位,发放停车卡并放行,车辆离开时收取请车费\n地铁验票闸机在人员进入之前检查票,没票拒绝进入,有票验票后放行,人员离开时同样验票\n\n\n\n\n\n\n\n\n\n\n过滤器开发中应用的场景\n\n日志的记录\n性能的分析\n乱码的处理\n事务的控制\n登录的控制\n跨域的处理\n… …\n\n\n\n\n\n\n\n\n\n\n过滤器工作位置图解\n\n\n\n\n\n\n\n\n\n\nFilter接口API\n\n源码\n\njavapackage jakarta.servlet;\nimport java.io.IOException;\n\npublic interface Filter &#123;\n    default public void init(FilterConfig filterConfig) throws ServletException &#123;\n    &#125;\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException;\n    default public void destroy() &#123;\n    &#125;\n&#125;\n\nAPI目标\n\n\n\n\nAPI\n目标\n\n\n\ndefault public void init(FilterConfig filterConfig)\n初始化方法,由容器调用并传入初始配置信息filterConfig对象\n\n\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n过滤方法,核心方法,过滤请求,决定是否放行,响应之前的其他处理等都在该方法中\n\n\ndefault public void destroy()\n销毁方法,容器在回收过滤器对象之前调用的方法\n\n\n2.2 过滤器使用\n\n\n\n\n\n\n\n\n目标:开发一个日志记录过滤器\n\n用户请求到达目标资源之前,记录用户的请求资源路径\n响应之前记录本次请求目标资源运算的耗时\n可以选择将日志记录进入文件,为了方便测试,这里将日志直接在控制台打印\n\n\n\n\n\n\n\n\n\n\n 定义一个过滤器类,编写功能代码\njavapackage com.atguigu.filters;\n\n\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebFilter;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\npublic class LoggingFilter  implements Filter &#123;\n\n    private SimpleDateFormat dateFormat =new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        // 参数父转子\n        HttpServletRequest request =(HttpServletRequest)  servletRequest;\n        HttpServletResponse  response =(HttpServletResponse)  servletResponse;\n        // 拼接日志文本\n        String requestURI = request.getRequestURI();\n        String time = dateFormat.format(new Date());\n        String beforeLogging =requestURI+&quot;在&quot;+time+&quot;被请求了&quot;;\n        // 打印日志\n        System.out.println(beforeLogging);\n        // 获取系统时间\n        long t1 = System.currentTimeMillis();\n        // 放行请求\n        filterChain.doFilter(request,response);\n        // 获取系统时间\n        long t2 = System.currentTimeMillis();\n        //  拼接日志文本\n        String afterLogging =requestURI+&quot;在&quot;+time+&quot;的请求耗时:&quot;+(t2-t1)+&quot;毫秒&quot;;\n        // 打印日志\n        System.out.println(afterLogging);\n\n    &#125;\n&#125;\n\n说明\ndoFilter方法中的请求和响应对象是以父接口的形式声明的,实际传入的实参就是HttpServletRequest和HttpServletResponse子接口级别的,可以安全强转\nfilterChain.doFilter(request,response); 这行代码的功能是放行请求,如果没有这一行代码,则请求到此为止\nfilterChain.doFilter(request,response);在放行时需要传入request和response,意味着请求和响应对象要继续传递给后续的资源,这里没有产生新的request和response对象\n\n\n\n\n\n\n\n\n\n\n\n\n定义两个Servlet作为目标资源\n\nServletA\n\njava@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 处理器请求\n        System.out.println(&quot;servletA处理请求的方法,耗时10毫秒&quot;);\n        // 模拟处理请求耗时\n        try &#123;\n            Thread.sleep(10);\n        &#125; catch (InterruptedException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n\n    &#125;\n&#125;\nServletB\n\njava@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 处理器请求\n        System.out.println(&quot;servletB处理请求的方法,耗时15毫秒&quot;);\n        // 模拟处理请求耗时\n        try &#123;\n            Thread.sleep(15);\n        &#125; catch (InterruptedException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n配置过滤器以及过滤器的过滤范围\n\nweb.xml\n\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;\n         version=&quot;5.0&quot;&gt;\n\n    &lt;!--配置filter,并为filter起别名--&gt;\n   &lt;filter&gt;\n       &lt;filter-name&gt;loggingFilter&lt;/filter-name&gt;\n       &lt;filter-class&gt;com.atguigu.filters.LoggingFilter&lt;/filter-class&gt;\n   &lt;/filter&gt;\n    &lt;!--为别名对应的filter配置要过滤的目标资源--&gt;\n    &lt;!--和@WebServlet设置的内容一致,servletname是不加/的--&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;loggingFilter&lt;/filter-name&gt;\n        &lt;!--通过映射路径确定过滤资源--&gt;\n        &lt;url-pattern&gt;/servletA&lt;/url-pattern&gt;\n        &lt;!--通过后缀名确定过滤资源--&gt;\n        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;\n        &lt;!--通过servlet别名确定过滤资源--&gt;\n        &lt;servlet-name&gt;servletBName&lt;/servlet-name&gt;\n\n    &lt;/filter-mapping&gt;\n&lt;/web-app&gt;说明\n\nfilter-mapping标签中定义了过滤器对那些资源进行过滤\n子标签url-pattern通过映射路径确定过滤范围\n/servletA ：精确匹配,表示对servletA资源的请求进行过滤\n*.html ：表示对以.action结尾的路径进行过滤\n/* ：表示对所有资源进行过滤\n/a/*：表示过滤以a开头的资源\n一个filter-mapping下可以配置多个url-pattern\n\n\n子标签servlet-name通过servlet别名确定对那些servlet进行过滤\n使用该标签确定目标资源的前提是servlet已经起了别名\n一个filter-mapping下可以定义多个servlet-name\n一个filter-mapping下,servlet-name和url-pattern子标签可以同时存在\n\n\n\n\n\n\n\n\n\n\n\n\n过滤过程图解\n\n2.3 过滤器生命周期\n\n\n\n\n\n\n\n\n过滤器作为web项目的组件之一,和Servlet的生命周期类似,略有不同,没有servlet的load-on-startup的配置,默认就是系统启动立刻构造\n\n\n\n阶段\n对应方法\n执行时机\n执行次数\n\n\n\n创建对象\n构造器\nweb应用启动时\n1\n\n\n初始化方法\nvoid init(FilterConfig filterConfig)\n构造完毕\n1\n\n\n过滤请求\nvoid doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)\n每次请求\n多次\n\n\n销毁\ndefault void destroy()\nweb应用关闭时\n1次\n\n\n\n\n\n\n\n\n\n\n\n测试代码\nLifeCycleFilter.java\njavapackage com.atguigu.filters;\n\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebServlet;\n\nimport java.io.IOException;\n\n\n@WebServlet(&quot;/*&quot;)\npublic class LifeCycleFilter implements Filter &#123;\n    public LifeCycleFilter()&#123;\n        System.out.println(&quot;LifeCycleFilter constructor method invoked&quot;);\n    &#125;\n    \n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n        System.out.println(&quot;LifeCycleFilter init method invoked&quot;);\n        \n    &#125;\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        System.out.println(&quot;LifeCycleFilter doFilter method invoked&quot;);\n        //放行代码\n        filterChain.doFilter(servletRequest,servletResponse);\n    &#125;\n\n    @Override\n    public void destroy() &#123;\n        System.out.println(&quot;LifeCycleFilter destory method invoked&quot;);\n    &#125;\n&#125; web.xml\nhtml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;\n         version=&quot;5.0&quot;&gt;\n\n    &lt;!--配置filter,并为filter起别名--&gt;\n   &lt;fiter&gt;\n        &lt;filter-name&gt;lifeCycleFilter&lt;/filter-name&gt;\n        &lt;filter-class&gt;com.filters.LifeCycleFilter&lt;/filter-class&gt;\n        &lt;!--使用构造器--&gt;\n       &lt;init-parm&gt;\n               &lt;param-name&gt;dateTimePattern&lt;/param-name&gt;\n               &lt;param-value&gt;yyyy-MM-dd HH:mm:ss&lt;/param-value&gt;\n       &lt;/init-parm&gt;\n    &lt;/fiter&gt;\n    &lt;!--为别名对应的filter配置要过滤的目标资源--&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;lifeCycleFiter&lt;/filter-name&gt;\n        &lt;!--测试,这里对所有资源都启用了过滤器--&gt;\n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n&lt;/web-app&gt;2.4 过滤器链的使用\n\n\n\n\n\n\n\n\n一个web项目中,可以同时定义多个过滤器,多个过滤器对同一个资源进行过滤时,工作位置有先后,整体形成一个工作链,称之为过滤器链\n\n过滤器链中的过滤器的顺序由filter-mapping顺序决定\n如果是使用注解方式，那么过滤器的顺序根据类名来决定。例如：filter1,filter2。\n每个过滤器过滤的范围不同,针对同一个资源来说,过滤器链中的过滤器个数可能是不同的\n如果某个Filter是使用ServletName进行匹配规则的配置，那么这个Filter执行的优先级要更低\n\n\n\n\n\n\n\n\n\n\n图解过滤器链\n\n\n\n\n\n\n\n\n\n\n过滤器链功能测试\n\n定义三个过滤器,对目标资源Servlet的请求进行过滤\n\n目标Servlet资源代码\n\n\njavapackage com.atguigu.servlet;\n\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\n\n@WebServlet(&quot;/servletC&quot;)\npublic class ServletC extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        System.out.println(&quot;servletC service method  invoked&quot;);\n    &#125;\n&#125;\n\n三个过滤器代码\n\njavapublic class Filter1  implements Filter &#123;\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        System.out.println(&quot;filter1 before chain.doFilter code invoked&quot;);\n\n        filterChain.doFilter(servletRequest,servletResponse);\n\n        System.out.println(&quot;filter1 after  chain.doFilter code invoked&quot;);\n\n    &#125;\n&#125;\n\n\npublic class Filter2 implements Filter &#123;\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        System.out.println(&quot;filter2 before chain.doFilter code invoked&quot;);\n\n        filterChain.doFilter(servletRequest,servletResponse);\n\n        System.out.println(&quot;filter2 after  chain.doFilter code invoked&quot;);\n\n    &#125;\n&#125;\n\n\npublic class Filter3 implements Filter &#123;\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        System.out.println(&quot;filter3 before chain.doFilter code invoked&quot;);\n\n        filterChain.doFilter(servletRequest,servletResponse);\n\n        System.out.println(&quot;filter3 after  chain.doFilter code invoked&quot;);\n\n    &#125;\n&#125;\n过滤器配置代码\n\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;\n         version=&quot;5.0&quot;&gt;\n    &lt;filter&gt;\n        &lt;filter-name&gt;filter1&lt;/filter-name&gt;\n        &lt;filter-class&gt;com.atguigu.filters.Filter1&lt;/filter-class&gt;\n    &lt;/filter&gt;\n\n    &lt;filter&gt;\n        &lt;filter-name&gt;filter2&lt;/filter-name&gt;\n        &lt;filter-class&gt;com.atguigu.filters.Filter2&lt;/filter-class&gt;\n    &lt;/filter&gt;\n\n    &lt;filter&gt;\n        &lt;filter-name&gt;filter3&lt;/filter-name&gt;\n        &lt;filter-class&gt;com.atguigu.filters.Filter3&lt;/filter-class&gt;\n    &lt;/filter&gt;\n\n    &lt;!--filter-mapping的顺序决定了过滤器的工作顺序--&gt;\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;filter1&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/servletC&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;filter2&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/servletC&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n\n    &lt;filter-mapping&gt;\n        &lt;filter-name&gt;filter3&lt;/filter-name&gt;\n        &lt;url-pattern&gt;/servletC&lt;/url-pattern&gt;\n    &lt;/filter-mapping&gt;\n\n&lt;/web-app&gt;\n\n\n\n\n\n\n\n\n工作流程图解\n\n2.5 注解方式配置过滤器\n\n\n\n\n\n\n\n\n@WebFilter注解的使用\n\n源码\n\njavapackage jakarta.servlet.annotation;\n\nimport jakarta.servlet.DispatcherType;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WebFilter &#123;\n    String description() default &quot;&quot;;\n\n    String displayName() default &quot;&quot;;\n\n    WebInitParam[] initParams() default &#123;&#125;;\n\n    String filterName() default &quot;&quot;;\n\n    String smallIcon() default &quot;&quot;;\n\n    String largeIcon() default &quot;&quot;;\n\n    String[] servletNames() default &#123;&#125;;\n\n    String[] value() default &#123;&#125;;\n\n    String[] urlPatterns() default &#123;&#125;;\n\n    DispatcherType[] dispatcherTypes() default &#123;DispatcherType.REQUEST&#125;;\n\n    boolean asyncSupported() default false;\n&#125;\n\n一个比较完整的Filter的XML配置\n\nxml&lt;!--配置filter,并为filter起别名--&gt;\n&lt;filter&gt;\n    &lt;filter-name&gt;loggingFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;com.atguigu.filters.LoggingFilter&lt;/filter-class&gt;\n    &lt;!--配置filter的初始参数--&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;dateTimePattern&lt;/param-name&gt;\n        &lt;param-value&gt;yyyy-MM-dd HH:mm:ss&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;!--为别名对应的filter配置要过滤的目标资源--&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;loggingFilter&lt;/filter-name&gt;\n    &lt;!--通过映射路径确定过滤资源--&gt;\n    &lt;url-pattern&gt;/servletA&lt;/url-pattern&gt;\n    &lt;!--通过后缀名确定过滤资源--&gt;\n    &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;\n    &lt;!--通过servlet别名确定过滤资源--&gt;\n    &lt;servlet-name&gt;servletBName&lt;/servlet-name&gt;\n&lt;/filter-mapping&gt;\n将xml配置转换成注解方式实现\n\njavapackage com.atguigu.filters;\n\n\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebFilter;\nimport jakarta.servlet.annotation.WebInitParam;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n\n\n@WebFilter(\n        filterName = &quot;loggingFilter&quot;,\n        initParams = &#123;@WebInitParam(name=&quot;dateTimePattern&quot;,value=&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;,\n        urlPatterns = &#123;&quot;/servletA&quot;,&quot;*.html&quot;&#125;,\n        servletNames = &#123;&quot;servletBName&quot;&#125;\n)\npublic class LoggingFilter  implements Filter &#123;\n    private SimpleDateFormat dateFormat ;\n\n    /*init初始化方法,通过filterConfig获取初始化参数\n    * init方法中,可以用于定义一些其他初始化功能代码\n    * */\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n        // 获取初始参数\n        String dateTimePattern = filterConfig.getInitParameter(&quot;dateTimePattern&quot;);\n        // 初始化成员变量\n        dateFormat=new SimpleDateFormat(dateTimePattern);\n    &#125;\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        // 参数父转子\n        HttpServletRequest request =(HttpServletRequest)  servletRequest;\n        HttpServletResponse  response =(HttpServletResponse)  servletResponse;\n        // 拼接日志文本\n        String requestURI = request.getRequestURI();\n        String time = dateFormat.format(new Date());\n        String beforeLogging =requestURI+&quot;在&quot;+time+&quot;被请求了&quot;;\n        // 打印日志\n        System.out.println(beforeLogging);\n        // 获取系统时间\n        long t1 = System.currentTimeMillis();\n        // 放行请求\n        filterChain.doFilter(request,response);\n        // 获取系统时间\n        long t2 = System.currentTimeMillis();\n        String afterLogging =requestURI+&quot;在&quot;+time+&quot;的请求耗时:&quot;+(t2-t1)+&quot;毫秒&quot;;\n        // 打印日志\n        System.out.println(afterLogging);\n\n    &#125;\n&#125;\n三 监听器3.1 监听器概述\n\n\n\n\n\n\n\n\n监听器：专门用于对域对象对象身上发生的事件或状态改变进行监听和相应处理的对象\n\n监听器是GOF设计模式中,观察者模式的典型案例\n\n观察者模式: 当被观察的对象发生某些改变时, 观察者自动采取对应的行动的一种设计模式\n\n监听器使用的感受类似JS中的事件,被观察的对象发生某些情况时,自动触发代码的执行\n\n监听器并不监听web项目中的所有组件,仅仅是对三大域对象做相关的事件监听\n\n\n\n\n\n\n\n\n\n\n\n监听器的分类\n\nweb中定义八个监听器接口作为监听器的规范,这八个接口按照不同的标准可以形成不同的分类\n\n按监听的对象划分\n\napplication域监听器 ServletContextListener  ServletContextAttributeListener \nsession域监听器 HttpSessionListener  HttpSessionAttributeListener  HttpSessionBindingListener  HttpSessionActivationListener  \nrequest域监听器 ServletRequestListener  ServletRequestAttributeListener\n\n\n按监听的事件分\n\n域对象的创建和销毁监听器 ServletContextListener   HttpSessionListener   ServletRequestListener  \n域对象数据增删改事件监听器 ServletContextAttributeListener  HttpSessionAttributeListener   ServletRequestAttributeListener \n其他监听器  HttpSessionBindingListener  HttpSessionActivationListener\n\n\n\n3.2 监听器的六个主要接口3.2.1 application域监听器\n\n\n\n\n\n\n\n\nServletContextListener  监听ServletContext对象的创建与销毁\n\n\n\n方法名\n作用\n\n\n\ncontextInitialized(ServletContextEvent sce)\nServletContext创建时调用\n\n\ncontextDestroyed(ServletContextEvent sce)\nServletContext销毁时调用\n\n\n\nServletContextEvent对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象。\n\n\n\n\n\n\n\n\n\n\nServletContextAttributeListener 监听ServletContext中属性的添加、移除和修改\n\n\n\n方法名\n作用\n\n\n\nattributeAdded(ServletContextAttributeEvent scab)\n向ServletContext中添加属性时调用\n\n\nattributeRemoved(ServletContextAttributeEvent scab)\n从ServletContext中移除属性时调用\n\n\nattributeReplaced(ServletContextAttributeEvent scab)\n当ServletContext中的属性被修改时调用\n\n\n\nServletContextAttributeEvent对象代表属性变化事件，它包含的方法如下：\n\n\n\n\n方法名\n作用\n\n\n\ngetName()\n获取修改或添加的属性名\n\n\ngetValue()\n获取被修改或添加的属性值\n\n\ngetServletContext()\n获取ServletContext对象\n\n\n\n\n\n\n\n\n\n\n\n测试代码\n\n定义监听器\n\njavapackage com.atguigu.listeners;\n\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebListener;\n\n\n@WebListener\npublic class ApplicationListener implements ServletContextListener , ServletContextAttributeListener &#123;\n    // 监听初始化\n    @Override\n    public void contextInitialized(ServletContextEvent sce) &#123;\n        ServletContext application = sce.getServletContext();\n        System.out.println(&quot;application&quot;+application.hashCode()+&quot; initialized&quot;);\n    &#125;\n    // 监听销毁\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) &#123;\n        ServletContext application = sce.getServletContext();\n        System.out.println(&quot;application&quot;+application.hashCode()+&quot; destroyed&quot;);\n    &#125;\n\n    // 监听数据增加\n    @Override\n    public void attributeAdded(ServletContextAttributeEvent scae) &#123;\n        String name = scae.getName();\n        Object value = scae.getValue();\n        ServletContext application = scae.getServletContext();\n        System.out.println(&quot;application&quot;+application.hashCode()+&quot; add:&quot;+name+&quot;=&quot;+value);\n    &#125;\n\n    // 监听数据移除\n    @Override\n    public void attributeRemoved(ServletContextAttributeEvent scae) &#123;\n        String name = scae.getName();\n        Object value = scae.getValue();\n        ServletContext application = scae.getServletContext();\n        System.out.println(&quot;application&quot;+application.hashCode()+&quot; remove:&quot;+name+&quot;=&quot;+value);\n    &#125;\n    // 监听数据修改\n    @Override\n    public void attributeReplaced(ServletContextAttributeEvent scae) &#123;\n        String name = scae.getName();\n        Object value = scae.getValue();\n        ServletContext application = scae.getServletContext();\n        Object newValue = application.getAttribute(name);\n        System.out.println(&quot;application&quot;+application.hashCode()+&quot; change:&quot;+name+&quot;=&quot;+value+&quot; to &quot;+newValue);\n    &#125;\n\n\n&#125;\n\n定义触发监听器的代码\n\njava// ServletA用于向application域中放入数据\n@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 向application域中放入数据\n        ServletContext application = this.getServletContext();\n        application.setAttribute(&quot;k1&quot;,&quot;v1&quot;);\n        application.setAttribute(&quot;k2&quot;,&quot;v2&quot;);\n    &#125;\n&#125;\n\n\n// ServletB用于向application域中修改和移除数据\n@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        ServletContext appliation  = getServletContext();\n        //  修改application域中的数据\n        appliation.setAttribute(&quot;k1&quot;,&quot;value1&quot;);\n        //  删除application域中的数据\n        appliation.removeAttribute(&quot;k2&quot;);\n    &#125;\n&#125;3.2.2 session域监听器\n\n\n\n\n\n\n\n\nHttpSessionListener  监听HttpSession对象的创建与销毁\n\n\n\n方法名\n作用\n\n\n\nsessionCreated(HttpSessionEvent hse)\nHttpSession对象创建时调用\n\n\nsessionDestroyed(HttpSessionEvent hse)\nHttpSession对象销毁时调用\n\n\n\nHttpSessionEvent对象代表从HttpSession对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpSession对象。\n\n\n\n\n\n\n\n\n\n\nHttpSessionAttributeListener 监听HttpSession中属性的添加、移除和修改\n\n\n\n方法名\n作用\n\n\n\nattributeAdded(HttpSessionBindingEvent se)\n向HttpSession中添加属性时调用\n\n\nattributeRemoved(HttpSessionBindingEvent se)\n从HttpSession中移除属性时调用\n\n\nattributeReplaced(HttpSessionBindingEvent se)\n当HttpSession中的属性被修改时调用\n\n\n\nHttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：\n\n\n\n\n方法名\n作用\n\n\n\ngetName()\n获取修改或添加的属性名\n\n\ngetValue()\n获取被修改或添加的属性值\n\n\ngetSession()\n获取触发事件的HttpSession对象\n\n\n\n\n\n\n\n\n\n\n\n测试代码\n\n定义监听器\n\njavapackage com.atguigu.listeners;\n\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebListener;\nimport jakarta.servlet.http.*;\n\n\n@WebListener\npublic class SessionListener implements HttpSessionListener, HttpSessionAttributeListener &#123;\n    // 监听session创建\n    @Override\n    public void sessionCreated(HttpSessionEvent se) &#123;\n        HttpSession session = se.getSession();\n        System.out.println(&quot;session&quot;+session.hashCode()+&quot; created&quot;);\n    &#125;\n\n    // 监听session销毁\n    @Override\n    public void sessionDestroyed(HttpSessionEvent se) &#123;\n        HttpSession session = se.getSession();\n        System.out.println(&quot;session&quot;+session.hashCode()+&quot; destroyed&quot;);\n    &#125;\n    // 监听数据增加\n    @Override\n    public void attributeAdded(HttpSessionBindingEvent se) &#123;\n        String name = se.getName();\n        Object value = se.getValue();\n        HttpSession session = se.getSession();\n        System.out.println(&quot;session&quot;+session.hashCode()+&quot; add:&quot;+name+&quot;=&quot;+value);\n    &#125;\n    // 监听数据移除\n    @Override\n    public void attributeRemoved(HttpSessionBindingEvent se) &#123;\n        String name = se.getName();\n        Object value = se.getValue();\n        HttpSession session = se.getSession();\n        System.out.println(&quot;session&quot;+session.hashCode()+&quot; remove:&quot;+name+&quot;=&quot;+value);\n    &#125;\n    // 监听数据修改\n    @Override\n    public void attributeReplaced(HttpSessionBindingEvent se) &#123;\n        String name = se.getName();\n        Object value = se.getValue();\n        HttpSession session = se.getSession();\n        Object newValue = session.getAttribute(name);\n        System.out.println(&quot;session&quot;+session.hashCode()+&quot; change:&quot;+name+&quot;=&quot;+value+&quot; to &quot;+newValue);\n    &#125;\n\n&#125;\n定义触发监听器的代码\n\njava// servletA用于创建session并向session中放数据\n@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 创建session,并向session中放入数据\n        HttpSession session = req.getSession();\n\n        session.setAttribute(&quot;k1&quot;,&quot;v1&quot;);\n        session.setAttribute(&quot;k2&quot;,&quot;v2&quot;);\n    &#125;\n&#125;\n\n\n// servletB用于修改删除session中的数据并手动让session不可用\n@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        HttpSession session = req.getSession();\n        //  修改session域中的数据\n        session.setAttribute(&quot;k1&quot;,&quot;value1&quot;);\n        //  删除session域中的数据\n        session.removeAttribute(&quot;k2&quot;);\n        // 手动让session不可用\n        session.invalidate();\n    &#125;\n&#125;3.2.3 request域监听器\n\n\n\n\n\n\n\n\nServletRequestListener 监听ServletRequest对象的创建与销毁\n\n\n\n方法名\n作用\n\n\n\nrequestInitialized(ServletRequestEvent sre)\nServletRequest对象创建时调用\n\n\nrequestDestroyed(ServletRequestEvent sre)\nServletRequest对象销毁时调用\n\n\n\nServletRequestEvent对象代表从HttpServletRequest对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpServletRequest对象。另外还有一个方法可以获取到当前Web应用的ServletContext对象。\n\n\n\n\n\n\n\n\n\n\nServletRequestAttributeListener 监听ServletRequest中属性的添加、移除和修改\n\n\n\n方法名\n作用\n\n\n\nattributeAdded(ServletRequestAttributeEvent srae)\n向ServletRequest中添加属性时调用\n\n\nattributeRemoved(ServletRequestAttributeEvent srae)\n从ServletRequest中移除属性时调用\n\n\nattributeReplaced(ServletRequestAttributeEvent srae)\n当ServletRequest中的属性被修改时调用\n\n\n\nServletRequestAttributeEvent对象代表属性变化事件，它包含的方法如下：\n\n\n\n\n方法名\n作用\n\n\n\ngetName()\n获取修改或添加的属性名\n\n\ngetValue()\n获取被修改或添加的属性值\n\n\ngetServletRequest ()\n获取触发事件的ServletRequest对象\n\n\n\n定义监听器\n\njavapackage com.atguigu.listeners;\n\nimport jakarta.servlet.*;\nimport jakarta.servlet.annotation.WebListener;\n\n\n@WebListener\npublic class RequestListener implements ServletRequestListener , ServletRequestAttributeListener &#123;\n    // 监听初始化\n    @Override\n    public void requestInitialized(ServletRequestEvent sre) &#123;\n        ServletRequest request = sre.getServletRequest();\n        System.out.println(&quot;request&quot;+request.hashCode()+&quot; initialized&quot;);\n    &#125;\n\n    // 监听销毁\n    @Override\n    public void requestDestroyed(ServletRequestEvent sre) &#123;\n        ServletRequest request = sre.getServletRequest();\n        System.out.println(&quot;request&quot;+request.hashCode()+&quot; destoryed&quot;);\n    &#125;\n\n\n    // 监听数据增加\n    @Override\n    public void attributeAdded(ServletRequestAttributeEvent srae) &#123;\n        String name = srae.getName();\n        Object value = srae.getValue();\n        ServletRequest request = srae.getServletRequest();\n        System.out.println(&quot;request&quot;+request.hashCode()+&quot; add:&quot;+name+&quot;=&quot;+value);\n    &#125;\n\n    //  监听数据移除\n    @Override\n    public void attributeRemoved(ServletRequestAttributeEvent srae) &#123;\n        String name = srae.getName();\n        Object value = srae.getValue();\n        ServletRequest request = srae.getServletRequest();\n        System.out.println(&quot;request&quot;+request.hashCode()+&quot; remove:&quot;+name+&quot;=&quot;+value);\n    &#125;\n    // 监听数据修改\n    @Override\n    public void attributeReplaced(ServletRequestAttributeEvent srae) &#123;\n        String name = srae.getName();\n        Object value = srae.getValue();\n        ServletRequest request = srae.getServletRequest();\n        Object newValue = request.getAttribute(name);\n        System.out.println(&quot;request&quot;+request.hashCode()+&quot; change:&quot;+name+&quot;=&quot;+value+&quot; to &quot;+newValue);\n    &#125;\n&#125;\n定义触发监听器的代码\n\njava//  servletA向请求域中放数据\n@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 向request中增加数据\n        req.setAttribute(&quot;k1&quot;,&quot;v1&quot;);\n        req.setAttribute(&quot;k2&quot;,&quot;v2&quot;);\n        // 请求转发\n        req.getRequestDispatcher(&quot;servletB&quot;).forward(req,resp);\n    &#125;\n&#125;\n\n// servletB修改删除域中的数据\n@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //  修改request域中的数据\n        req.setAttribute(&quot;k1&quot;,&quot;value1&quot;);\n        //  删除session域中的数据\n        req.removeAttribute(&quot;k2&quot;);\n\n    &#125;\n&#125;3.3 session域的两个特殊监听器3.3.3  session绑定监听器\n\n\n\n\n\n\n\n\nHttpSessionBindingListener 监听当前监听器对象在Session域中的增加与移除\n\n\n\n方法名\n作用\n\n\n\nvalueBound(HttpSessionBindingEvent event)\n该类的实例被放到Session域中时调用\n\n\nvalueUnbound(HttpSessionBindingEvent event)\n该类的实例从Session中移除时调用\n\n\n\nHttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：\n\n\n\n\n方法名\n作用\n\n\n\ngetName()\n获取当前事件涉及的属性名\n\n\ngetValue()\n获取当前事件涉及的属性值\n\n\ngetSession()\n获取触发事件的HttpSession对象\n\n\n\n\n\n\n\n\n\n\n\n测试代码\n\n定义监听器\n\njavapackage com.atguigu.listeners;\n\nimport jakarta.servlet.http.HttpSession;\nimport jakarta.servlet.http.HttpSessionBindingEvent;\nimport jakarta.servlet.http.HttpSessionBindingListener;\n\npublic class MySessionBindingListener  implements HttpSessionBindingListener &#123;\n    //  监听绑定\n    @Override\n    public void valueBound(HttpSessionBindingEvent event) &#123;\n        HttpSession session = event.getSession();\n        String name = event.getName();\n        System.out.println(&quot;MySessionBindingListener&quot;+this.hashCode()+&quot; binding into session&quot;+session.hashCode()+&quot; with name &quot;+name);\n    &#125;\n\n    // 监听解除绑定\n    @Override\n    public void valueUnbound(HttpSessionBindingEvent event) &#123;\n        HttpSession session = event.getSession();\n        String name = event.getName();\n        System.out.println(&quot;MySessionBindingListener&quot;+this.hashCode()+&quot; unbond outof session&quot;+session.hashCode()+&quot; with name &quot;+name);\n    &#125;\n&#125;\n定义触发监听器的代码\n\njava@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        HttpSession session = req.getSession();\n        // 绑定监听器\n        session.setAttribute(&quot;bindingListener&quot;,new MySessionBindingListener());\n        // 解除绑定监听器\n        session.removeAttribute(&quot;bindingListener&quot;);\n    &#125;\n&#125;3.3.4 钝化活化监听器\n\n\n\n\n\n\n\n\nHttpSessionActivationListener  监听某个对象在Session中的序列化与反序列化。\n\n\n\n方法名\n作用\n\n\n\nsessionWillPassivate(HttpSessionEvent se)\n该类实例和Session一起钝化到硬盘时调用\n\n\nsessionDidActivate(HttpSessionEvent se)\n该类实例和Session一起活化到内存时调用\n\n\n\nHttpSessionEvent对象代表事件对象，通过getSession()方法获取事件涉及的HttpSession对象。\n\n\n\n\n\n\n\n\n\n\n什么是钝化活化\n\nsession对象在服务端是以对象的形式存储于内存的,session过多,服务器的内存也是吃不消的\n而且一旦服务器发生重启,所有的session对象都将被清除,也就意味着session中存储的不同客户端的登录状态丢失\n为了分摊内存 压力并且为了保证session重启不丢失,我们可以设置将session进行钝化处理\n在关闭服务器前或者到达了设定时间时,对session进行序列化到磁盘,这种情况叫做session的钝化\n在服务器启动后或者再次获取某个session时,将磁盘上的session进行反序列化到内存,这种情况叫做session的活化\n\n\n\n\n\n\n\n\n\n\n如何配置钝化活化\n\n在web目录下,添加 META-INF下创建Context.xml\n\n\n\n文件中配置钝化\n\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;Context&gt;\n    &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt;\n        &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;d:\\mysession&quot;&gt;&lt;/Store&gt;\n    &lt;/Manager&gt;\n&lt;/Context&gt;\n请求servletA,获得session,并存入数据,然后重启服务器\n\njava@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        HttpSession session = req.getSession();\n        // 添加数据\n        session.setAttribute(&quot;k1&quot;,&quot;v1&quot;);\n    &#125;\n&#125;\n请求servletB获取session,获取重启前存入的数据\n\njava@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        HttpSession session = req.getSession();\n        Object v1 = session.getAttribute(&quot;k1&quot;);\n        System.out.println(v1);\n\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n如何监听钝化活化\n\n定义监听器\n\njavapackage com.atguigu.listeners;\n\nimport jakarta.servlet.http.HttpSession;\nimport jakarta.servlet.http.HttpSessionActivationListener;\nimport jakarta.servlet.http.HttpSessionEvent;\n\nimport java.io.Serializable;\n\npublic class ActivationListener  implements HttpSessionActivationListener, Serializable &#123;\n    //  监听钝化\n    @Override\n    public void sessionWillPassivate(HttpSessionEvent se) &#123;\n        HttpSession session = se.getSession();\n        System.out.println(&quot;session with JSESSIONID &quot;+ session.getId()+&quot; will passivate&quot;);\n    &#125;\n\n    //  监听活化\n    @Override\n    public void sessionDidActivate(HttpSessionEvent se) &#123;\n        HttpSession session = se.getSession();\n        System.out.println(&quot;session with JSESSIONID &quot;+ session.getId()+&quot; did activate&quot;);\n    &#125;\n&#125;\n\n定义触发监听器的代码\n\njava@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        HttpSession session = req.getSession();\n        // 添加数据\n        session.setAttribute(&quot;k1&quot;,&quot;v1&quot;);\n        // 添加钝化活化监听器\n        session.setAttribute(&quot;activationListener&quot;,new ActivationListener());\n    &#125;\n&#125;\n四 Ajax4.1 什么是ajax\nAJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\n\nAJAX 不是新的编程语言，而是一种使用现有标准的新方法。\n\nAJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。\n\nAJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。\n\nXMLHttpRequest 只是实现 Ajax 的一种方式。\n\n\najax工作原理：\n\n\n简单来说,我们之前发的请求通过类似  form表单标签,a标签 这种方式,现在通过 运行js代码动态决定什么时候发送什么样的请求\n通过运行JS代码发送的请求浏览器可以不用跳转页面 ,我们可以在JS代码中决定是否要跳转页面\n通过运行JS代码发送的请求,接收到返回结果后,我们可以将结果通过dom编程渲染到页面的某些元素上,实现局部更新\n\n4.2 如何实现ajax请求\n\n\n\n\n\n\n\n\n原生javascript方式进行ajax(了解):\nhtml&lt;script&gt;\n  function loadXMLDoc()&#123;\n    var xmlhttp=new XMLHttpRequest();\n      // 设置回调函数处理响应结果\n    xmlhttp.onreadystatechange=function()&#123;\n      if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)\n      &#123;\n        document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;\n      &#125;\n    &#125;\n      // 设置请求方式和请求的资源路径\n    xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true);\n      // 发送请求\n    xmlhttp.send();\n  &#125;\n&lt;/script&gt; \n","slug":"Javaweb_会话_过滤器_监听器","date":"2024-03-07T08:14:00.000Z","categories_index":"Javaweb","tags_index":"Javaweb","author_index":"白"},{"id":"b5f25607708364dec62476e3b1407a22","title":"算法学习_双指针篇","content":"算法学习_双指针篇学习至：代码随想录 (programmercarl.com)\n移除元素题目\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1：\ntxt输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。示例 2：\ntxt输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,3,0,4]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。思路\n双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。\n定义快慢指针\n\n快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组\n慢指针：指向更新 新数组下标的位置\n\n删除过程如下\n\n代码实现\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n设置快慢指针，快指针从头开始遍历数组，将符合条件的筛选出来。例如本题val=3的话，将val!=3的数据加入到数组中，在本题中就利用慢指针开始覆盖掉原数组内容，快指针遍历数组并进行筛选。\njavapublic int removeElement(int[] nums, int val) &#123;\n    int slowIndex = 0;\n    for (int flastIndex = 0; flastIndex &lt; nums.length; flastIndex++) &#123;\n        if(nums[flastIndex] != val) &#123;\n            nums[slowIndex++] = nums[flastIndex];\n        &#125;\n    &#125;\n    return slowIndex;\n&#125;\n反转字符串力扣题目链接\n题目\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n示例 1：\ntxt输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]\n输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]示例 2：\ntxt输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]\n输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]思路\n对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。\n以字符串hello为例，过程如下：\n\n代码实现\njavaclass Solution &#123;\n    public void reverseString(char[] s) &#123;\n        int left = 0, right = s.length - 1;\n        char temp;\n        while (left &lt; right) &#123;\n            temp = s[left];\n            s[left] = s[right];\n            s[right] = temp;\n            left++;\n            right--;\n        &#125;\n    &#125;\n&#125;\n替换数字卡码网题目链接\n题目描述\n给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。\n输入描述\n输入一个字符串 s,s 仅包含小写字母和数字字符。\n输出描述\n打印一个新的字符串，其中每个数字字符都被替换为了number\n输入示例\ntxta1b2c3输出示例\ntxtanumberbnumbercnumber提示信息\n数据范围：1 &lt;&#x3D; s.length &lt; 10000。\n代码实现\njavaimport java.util.Scanner;\n\nclass Main &#123;\n    public static void main(String[] args)&#123;\n        Scanner in = new Scanner(System.in);\n        String s = in.nextLine();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; s.length(); i++) &#123;\n            if (Character.isDigit(s.charAt(i))) &#123;\n                sb.append(&quot;number&quot;);\n            &#125; else &#123;\n                sb.append(s.charAt(i));\n            &#125;\n        &#125;\n        System.out.println(sb);\n    &#125; \n&#125;\n反转链表206. 反转链表 - 力扣（LeetCode）\n题目\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n\ntxt输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]示例 2：\ntxt输入：head = [1,2]\n输出：[2,1]示例 3：\ntxt输入：head = []\n输出：[]思路\n如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。\n其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。\n之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改变next指针的方向。\n\n动画应该是先移动pre，在移动cur\n\n首先定义一个cur指针，指向头结点，再定义一个prev指针，初始化为null。\n然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。\n为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向，将cur-&gt;next 指向prev ，此时已经反转了第一个节点了。\n反转过后应该遍历链表。循环条件：while(cur != null)，遍历链表：prev = cur，cur = temp。\n最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。\n\n\n代码实现\n双指针法\n时间复杂度: O(n)\n空间复杂度: O(1)\n\njavapublic ListNode reverseList(ListNode head) &#123;\n    //设置头指针pre方便逆转\n    ListNode pre = null;\n    ListNode cur = head;\n    //设置temp指针用来存储下一个节点\n    ListNode temp = null;\n    while (cur != null) &#123;\n        temp = cur.next; //保存下一个节点\n        //逆转链表\n        cur.next = pre;\n        pre = cur;\n        cur = temp;\n    &#125;\n    //最后一次逆转时，cur指向了链表的后一位null了，pre指向链表最后一个\n    //所以返回pre\n    return pre;\n&#125;递归法\n时间复杂度: O(n), 要递归处理链表的每个节点\n空间复杂度: O(n), 递归调用了 n 层栈空间\n\njavapublic ListNode reverseList(ListNode head) &#123;\n        return reverse(null, head);\n&#125;\nprivate ListNode reverse(ListNode prev, ListNode cur) &#123;\n    if (cur == null) &#123;\n        //如果cur指向null则表示已经反转了链表\n       return prev;\n    &#125;\n    ListNode temp = null;\n    temp = cur.next; //保存下一个结点\n    cur.next = prev; //反转\n    //更新prev和cur位置\n    //prev = cur;\n    //cur = temp;\n    return reverse(cur, temp);\n&#125;\n删除链表的倒数第N个结点19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）\n题目\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n 示例 1：\n\ntxt输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]示例 2：\ntxt输入：head = [1], n = 1\n输出：[]示例 3：\ntxt输入：head = [1,2], n = 1\n输出：[1]思路\n双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。\n但是需要注意一些细节\n\n定义fast指针和slow指针，初始值为虚拟头结点。\n\nfast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： \n\nfast和slow同时移动，直到fast指向末尾，如题： \n\n删除slow指向的下一个节点，如图： \n\n\n代码实现\njavapublic ListNode removeNthFromEnd(ListNode head, int n) &#123;\n    //设置虚拟头结点，用来返回\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    //设置快慢指针\n    ListNode slow = dummy;\n    ListNode fast = dummy;\n    //fast指针先移动n+1个位置，这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作）\n    for (int i = 0; i &lt; n + 1; i++) &#123;\n        fast = fast.next;\n    &#125;\n    //同时移动快慢指针，当fast指向null时，slow就定位到了删除节点的上一个节点\n    while (fast != null) &#123;\n        slow = slow.next;\n        fast = fast.next;\n    &#125;\n    //删除倒数第n个节点\n    slow.next = slow.next.next;\n    //返回链表\n    return dummy.next;\n&#125;\n面试题 02.07. 链表相交面试题 02.07. 链表相交 - 力扣（LeetCode）\n题目\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1：\n\ntxt输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at &#39;8&#39;\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。示例 2：\n\ntxt输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at &#39;2&#39;\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。示例 3：\n\ntxt输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。思路\n简单来说，就是求两个链表交点节点的指针。 这里要注意，交点不是数值相等，而是指针相等。\n为了方便举例，假设节点元素数值相等，则节点指针相等。\n看如下两个链表，目前curA指向链表A的头结点，curB指向链表B的头结点：\n\n我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，如图：\n\n此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。\n否则循环退出返回空指针。\n代码实现\njavapublic class Solution &#123;\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\n        //设置两个指针，分别指向A,B链表的头结点\n        //用来计算AB链表的长度\n        ListNode curA = headA;\n        ListNode curB = headB;\n        int lenA = 0;\n        int lenB = 0;\n        while (curA != null) &#123;\n            curA = curA.next;\n            lenA++;\n        &#125;\n        while (curB != null) &#123;\n            curB = curB.next;\n            lenB++;\n        &#125;\n        curA = headA;\n        curB = headB;\n        //让curA为最长链表的头,lenA为其长度\n        if (lenA &lt; lenB) &#123;\n            //交换链表curA,curB\n            ListNode temp = curA;\n            curA = curB;\n            curB = temp;\n            //交换链表长度lenA,lenB\n            int temp1 = lenA;\n            lenA = lenB;\n            lenB = temp1;\n        &#125;\n        //此时curA是最长链表的头\n        //计算两链表的差值，将A移动单位次数再进行比较\n        int gap = lenA - lenB;\n        for (int i = 0; i &lt; gap; i++) &#123;\n           curA = curA.next;\n        &#125;\n        //同时遍历curA,curB.遇到相同的时候返回\n        while (curA != null) &#123;\n            if (curA == curB) &#123;\n                return curA;\n            &#125;\n            curA = curA.next;\n            curB = curB.next;\n        &#125;\n        //遍历完链表表示没找到\n        return null;\n    &#125;\n&#125;\n环形链表142. 环形链表 II - 力扣（LeetCode）\n题目\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n示例 1：\n\ntxt输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。示例 2：\n\ntxt输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。示例 3：\n\ntxt输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。思路\n注意：判断时是判断指针是否相等，而不是判断val值是否相等。\n考察两知识点：\n\n判断链表是否环\n如果有环，如何找到这个环的入口\n\n1、判断链表是否有环\n可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。\n为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢\n首先第一点：fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。\n那么来看一下，为什么fast指针和slow指针一定会相遇呢？\n可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。\n会发现最终都是这种情况， 如下图：\n\nfast和slow各自再走一步， fast和slow就相遇了\n这是因为fast是走两步，slow是走一步，其实相对于slow来说，fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合。\n动画如下：\n\n2、如果有环，如何找到这个环的入口\n此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。\n假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：\n\n那么相遇时： slow指针走过的节点数为: x + y， fast指针走过的节点数：x + y + n (y + z)，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。\n因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 &#x3D; slow指针走过的节点数 * 2：\ntxt(x + y) * 2 = x + y + n (y + z)两边消掉一个（x+y）: x + y = n (y + z)\n因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。\n所以要求x ，将x单独放在左面：x = n (y + z) - y ,\n再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。\n这个公式说明什么呢？\n先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。\n当 n为1的时候，公式就化解为 x = z，\n这就意味着，从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\n也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。\n让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。\n动画如下：\n\n那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。\n其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。\n代码实现\njavapublic class Solution &#123;\n    public ListNode detectCycle(ListNode head) &#123;\n        //定义快慢指针,fast指针每次移动2个节点，slow指针每次移动1个节点\n        ListNode slow = head;\n        ListNode fast = head;\n        //寻找相遇节点\n        while (fast != null &amp;&amp; fast.next != null) &#123;\n            fast = fast.next.next;\n            slow = slow.next;\n            //相遇则为环\n            if (fast == slow) &#123;\n                //根据数形结合可知，设置index1(相遇结点)和index2(链表头节点)\n                // 每次移动一个节点，相遇的位置为环形链表入口\n                ListNode index1 = fast;\n                ListNode index2 = head;\n                //移动结点找到入口\n                while (index1 != index2) &#123;\n                    index1 = index1.next;\n                    index2 = index2.next;\n                &#125;\n                return index1;\n            &#125;\n        &#125;\n        return null;\n    &#125;\n&#125;\n三数之和力扣题目链接\n题目\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n示例 1：\ntxt输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。示例 2：\ntxt输入：nums = [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。示例 3：\ntxt输入：nums = [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。思路\n双指针法\n\n拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。\n依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这里相当于 a &#x3D; nums[i]，b &#x3D; nums[left]，c &#x3D; nums[right]。\n接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。\n如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。\n时间复杂度：O(n^2)。\n去重逻辑的思考a的去重说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]\na 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。\n但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。\n有同学可能想，这不都一样吗。\n其实不一样！\n都是和 nums[i]进行比较，是比较它的前一个，还是比较它的后一个。\n如果我们的写法是 这样：\njavaif (nums[i] == nums[i + 1]) &#123; // 去重操作\n    continue;\n&#125;那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。\n我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！\n所以这里是有两个重复的维度。\n那么应该这么写：\ntxtif (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;\n    continue;\n&#125;这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。\n这是一个非常细节的思考过程。\nb与c的去重很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）\njavawhile (right &gt; left) &#123;\n    if (nums[i] + nums[left] + nums[right] &gt; 0) &#123;\n        right--;\n        // 去重 right\n        while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;\n    &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123;\n        left++;\n        // 去重 left\n        while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++;\n    &#125; else &#123;\n    &#125;\n&#125;但细想一下，这种去重其实对提升程序运行效率是没有帮助的。\n拿right去重为例，即使不加这个去重逻辑，依然根据 while (right &gt; left) 和 if (nums[i] + nums[left] + nums[right] &gt; 0) 去完成right– 的操作。\n多加了 while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--; 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。\n最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。\n所以这种去重 是可以不加的。 仅仅是 把去重的逻辑提前了而已。\n代码实现\njavaclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;\n        //设置二维数组存储结果\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        //将数组先排序为有序数组，才能使用双指针法\n        Arrays.sort(nums);\n        //遍历数组找到三数之和为0\n        int len = nums.length;\n        for (int i = 0; i &lt; len; i++) &#123;\n            //如果排序过后第一个数&gt;0则直接返回\n            if (nums[i] &gt; 0) &#123;\n                return result;\n            &#125;\n            //去重a\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;\n                continue;\n            &#125;\n            //===内容实现===\n            //设置left和right指针\n            int left = i + 1;\n            int right = len - 1;\n            while (left &lt; right) &#123;\n                //计算三数之和，根据结果来移动双指针\n                int res = nums[i] + nums[left] + nums[right];\n                if (res &gt; 0) &#123;\n                    //三数之和大了,移动right\n                    right = right - 1;\n                &#125; else if (res &lt; 0) &#123;\n                    //三数之和小了,移动left\n                    left = left + 1;\n                &#125; else &#123;\n                    //满足三数之和为0,添加到数组\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    //去重逻辑应该放在找到一个三元组后，对b和c去重\n                    while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;\n                    while (right &gt; left &amp;&amp; nums[left] == nums[left] + 1) left++;\n\n                    right--;\n                    left++;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n四数之和力扣题目链接\n题目\n给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n\n0 &lt;= a, b, c, d &lt; n\na、b、c 和 d 互不相同\nnums[a] + nums[b] + nums[c] + nums[d] == target\n\n你可以按 任意顺序 返回答案 。\n示例 1：\ntxt输入：nums = [1,0,-1,0,-2,2], target = 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]示例 2：\ntxt输入：nums = [2,2,2,2,2], target = 8\n输出：[[2,2,2,2]]思路\n四数之和，和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。\n但是有一些细节需要注意，例如： 不要判断nums[k] &gt; target 就返回了，三数之和 可以通过 nums[i] &gt; 0 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是[-4, -3, -2, -1]，target是-10，不能因为-4 &gt; -10而跳过。但是我们依旧可以去做剪枝，逻辑变成nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)就可以了。\n15.三数之和的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] &#x3D;&#x3D; 0。\n四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。\n那么一样的道理，五数之和、六数之和等等都采用这种解法。\n代码实现\njavaclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;\n        //二维数组存放结果\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        //对数组先进行排序\n        Arrays.sort(nums);\n        //四数之和在三数之和基础上再套一层for循环即可\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            //如果nums[i]数大于目标数，则直接返回.前提是大于0的情况\n            if (nums[i] &gt; target &amp;&amp; nums[i] &gt; 0) &#123;\n                return result;\n            &#125;\n            //对nums[i]去重\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;\n                continue;\n            &#125;\n            //第2个数j的处理\n            for (int j = i + 1; j &lt; nums.length; j++) &#123;\n                //对nums[j]去重\n                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;\n                    continue;\n                &#125;\n                //设置left和right指针\n                int left = j + 1;\n                int right = nums.length - 1;\n                while (left &lt; right) &#123;\n                    //注意int会溢出 nums[k] + nums[i] + nums[left] + nums[right] &gt; target\n                    long res = (long) nums[i] + nums[j] + nums[left] + nums[right];\n                    if (res &gt; target) &#123;\n                        right--;\n                    &#125; else if (res &lt; target) &#123;\n                        left++;\n                    &#125; else &#123;\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        // 对nums[left]和nums[right]去重\n                        while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;\n                        while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;\n\n                        left++;\n                        right--;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n双指针总结篇数组篇在数组：就移除个元素很难么？中，原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。\n可能会写出如下代码（伪代码）：\njavafor (int i = 0; i &lt; array.size(); i++) &#123;\n    if (array[i] == target) &#123;\n        array.erase(i);\n    &#125;\n&#125;这个代码看上去好像是O(n)的时间复杂度，其实是O(n^2)的时间复杂度，因为erase操作也是O(n)的操作。\n所以此时使用双指针法才展现出效率的优势：通过两个指针在一个for循环下完成两个for循环的工作。\n字符串篇在字符串：这道题目，使用库函数一行代码搞定中讲解了反转字符串，注意这里强调要原地反转，要不然就失去了题目的意义。\n使用双指针法，定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。，时间复杂度是O(n)。\n在替换空格中介绍使用双指针填充字符串的方法，如果想把这道题目做到极致，就不要只用额外的辅助空间了！\n思路就是首先扩充数组到每个空格替换成”%20”之后的大小。然后双指针从后向前替换空格。\n有同学问了，为什么要从后向前填充，从前向后填充不行么？\n从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。\n其实很多数组（字符串）填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。\n那么在字符串：花式反转还不够！中，我们使用双指针法，用O(n)的时间复杂度完成字符串删除类的操作，因为题目要删除冗余空格。\n在删除冗余空格的过程中，如果不注意代码效率，很容易写成了O(n^2)的时间复杂度。其实使用双指针法O(n)就可以搞定。\n主要还是大家用erase用的比较随意，一定要注意for循环下用erase的情况，一般可以用双指针写效率更高！\n链表篇翻转链表是现场面试，白纸写代码的好题，考察了候选者对链表以及指针的熟悉程度，而且代码也不长，适合在白纸上写。\n在[链表：听说过两天反转链表又写不出来了？中，讲如何使用双指针法来翻转链表，只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。\n思路还是很简单的，代码也不长，但是想在白纸上一次性写出bugfree的代码，并不是容易的事情。\n在链表中求环，应该是双指针在链表里最经典的应用，在链表：环找到了，那入口呢？中讲解了如何通过双指针判断是否有环，而且还要找到环的入口。\n使用快慢指针（双指针法），分别定义 fast 和 slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。\n那么找到环的入口，其实需要点简单的数学推理，我在文章中把找环的入口清清楚楚的推理的一遍，如果对找环入口不够清楚的同学建议自己看一看[链表：环找到了，那入口呢？。\nN数之和篇在哈希表：解决了两数之和，那么能解决三数之和么？中，讲到使用哈希法可以解决1.两数之和的问题\n其实使用双指针也可以解决1.两数之和的问题，只不过1.两数之和求的是两个元素的下标，没法用双指针，如果改成求具体两个元素的数值就可以了，大家可以尝试用双指针做一个leetcode上两数之和的题目，就可以体会到我说的意思了。\n使用了哈希法解决了两数之和，但是哈希法并不使用于三数之和！\n使用哈希法的过程中要把符合条件的三元组放进vector中，然后在去去重，这样是非常费时的，很容易超时，也是三数之和通过率如此之低的根源所在。\n去重的过程不好处理，有很多小细节，如果在面试中很难想到位。\n时间复杂度可以做到O(n^2)，但还是比较费时的，因为不好做剪枝操作。\n所以这道题目使用双指针法才是最为合适的，用双指针做这道题目才能就能真正体会到，通过前后两个指针不算向中间逼近，在一个for循环下完成两个for循环的工作。\n只用双指针法时间复杂度为O(n^2)，但比哈希法的O(n^2)效率高得多，哈希法在使用两层for循环的时候，能做的剪枝操作很有限。\n在双指针法：一样的道理，能解决四数之和中，讲到了四数之和，其实思路是一样的，在三数之和的基础上再套一层for循环，依然是使用双指针法。\n对于三数之和使用双指针法就是将原本暴力O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴力O(n^4)的解法，降为O(n^3)的解法。\n同样的道理，五数之和，n数之和都是在这个基础上累加。\n","slug":"算法-双指针法","date":"2024-03-05T05:27:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"白"},{"id":"5a4ce9e13a344bde47e43f91b68dbc5a","title":"算法学习_字符串篇","content":"算法学习_字符串篇学习至：代码随想录 (programmercarl.com)\n移除元素力扣题目链接\n题目\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1：\ntxt输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。示例 2：\ntxt输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,3,0,4]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。思路\n双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n定义快慢指针\n\n快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组\n慢指针：指向更新 新数组下标的位置\n\n删除过程如下：\n\n代码实现\njavaclass Solution &#123;\n    public int removeElement(int[] nums, int val) &#123;\n        //慢指针定位到需要更新的位置\n        int slow = 0;\n        //快指针找到不为val值的位置，更新slow\n        for (int fast = 0; fast &lt; nums.length; fast++) &#123;\n            if (nums[fast] != val) &#123;\n                nums[slow++] = nums[fast];\n            &#125;\n        &#125;\n        return slow;\n    &#125;\n&#125;\n反转字符串力扣题目链接\n题目\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n示例 1：\ntxt输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]\n输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]示例 2：\ntxt输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]\n输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]思路\n对于字符串，我们定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。\n以字符串hello为例，过程如下：\n\n代码实现\njavaclass Solution &#123;\n    public void reverseString(char[] s) &#123;\n        int left = 0, right = s.length - 1;\n        char temp;\n        while (left &lt; right) &#123;\n            temp = s[left];\n            s[left] = s[right];\n            s[right] = temp;\n            left++;\n            right--;\n        &#125;\n    &#125;\n&#125;\n替换数字卡码网题目链接\n题目描述\n给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。\n输入描述\n输入一个字符串 s,s 仅包含小写字母和数字字符。\n输出描述\n打印一个新的字符串，其中每个数字字符都被替换为了number\n输入示例\ntxta1b2c3输出示例\ntxtanumberbnumbercnumber提示信息\n数据范围：1 &lt;&#x3D; s.length &lt; 10000。\n代码实现\njavaimport java.util.Scanner;\n\nclass Main &#123;\n    public static void main(String[] args)&#123;\n        Scanner in = new Scanner(System.in);\n        String s = in.nextLine();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; s.length(); i++) &#123;\n            if (Character.isDigit(s.charAt(i))) &#123;\n                sb.append(&quot;number&quot;);\n            &#125; else &#123;\n                sb.append(s.charAt(i));\n            &#125;\n        &#125;\n        System.out.println(sb);\n    &#125; \n&#125;\n翻转字符串里的单词力扣题目链接\n题目\n给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n示例 1：\ntxt输入：s = &quot;the sky is blue&quot;\n输出：&quot;blue is sky the&quot;示例 2：\ntxt输入：s = &quot;  hello world  &quot;\n输出：&quot;world hello&quot;\n解释：反转后的字符串中不能存在前导空格和尾随空格。示例 3：\ntxt输入：s = &quot;a good   example&quot;\n输出：&quot;example good a&quot;\n解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。思路\n想一下，我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了。\n所以解题思路如下：\n\n移除多余空格\n将整个字符串反转\n将每个单词反转\n\n举个例子，源字符串为：&quot;the sky is blue &quot;\n\n移除多余空格 : &quot;the sky is blue&quot;\n字符串反转：&quot;eulb si yks eht&quot;\n单词反转：&quot;blue is sky the&quot;\n\n这样我们就完成了翻转字符串里的单词。\n代码实现\njavaclass Solution &#123;\n    public String reverseWords(String s) &#123;\n        //1.去除首尾以及中间多余空格\n        StringBuilder sb =  removeSpace(s);\n        //2.反转整个字符串\n        reverseString(sb, 0, sb.length() - 1);\n        //3.反转各个单词\n        reverseEachWord(sb);\n        return sb.toString();\n    &#125;\n    //去除首位以及中间多余空格\n    private StringBuilder removeSpace(String s) &#123;\n        int start = 0;\n        int end = s.length() - 1;\n        //去除首尾空格\n        while (s.charAt(start) == &#39; &#39;) start++;\n        while (s.charAt(end) == &#39; &#39;) end--;\n        //去除中间多余空格\n        StringBuilder sb = new StringBuilder();\n        while (start &lt;= end) &#123;\n            char c = s.charAt(start);\n            //s字符串当前位置不为空格，或者sb字符串最后的位置不为空格则可以添加\n            if (c != &#39; &#39; || sb.charAt(sb.length() - 1) != &#39; &#39;) &#123;\n                sb.append(c);\n            &#125;\n            start++;\n        &#125;\n        return sb;\n    &#125;\n    //反转字符串的指定位置\n    private void reverseString(StringBuilder sb,int start, int end) &#123;\n        while (start &lt; end) &#123;\n            char temp = sb.charAt(start);\n            //交换字符\n            sb.setCharAt(start, sb.charAt(end));\n            sb.setCharAt(end, temp);\n            start++;\n            end--;\n        &#125;\n    &#125;\n    //反转各个单词\n    private void reverseEachWord(StringBuilder sb) &#123;\n        int start = 0;\n        int end = 1;\n        int n = sb.length();\n        while (start &lt; n) &#123;\n            //end每次找到单词的末尾\n            while (end &lt; n &amp;&amp; sb.charAt(end) != &#39; &#39;) &#123;\n                end++;\n            &#125;\n            //反转找到的单词\n            reverseString(sb, start, end - 1);\n            start = end + 1;\n            end = start + 1;\n        &#125;\n    &#125;\n&#125;\n右旋字符串卡码网题目链接\n题目描述\n字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 \n例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。\n输入描述\n输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。\n输出描述\n输出共一行，为进行了右旋转操作后的字符串。\n输入示例\ntxt2\nabcdefg输出示例\ntxtfgabcde提示信息\n数据范围：1 &lt;&#x3D; k &lt; 10000，1 &lt;&#x3D; s.length &lt; 10000;\n思路\n重点：使用整体反转+局部反转就可以实现反转单词顺序的目的。\n\n我们需要将字符串右移n位，字符串相当于分成了两个部分，如果n为2，符串相当于分成了两个部分\n右移n位， 就是将第二段放在前面，第一段放在后面，先不考虑里面字符的顺序，是不是整体倒叙就行了。\n此时第一段和第二段的顺序是我们想要的，但里面的字符位置被我们倒叙，那么此时我们在把 第一段和第二段里面的字符再倒叙一把，这样字符顺序就正确了。\n\n其实，思路就是 通过 整体倒叙，把两段子串顺序颠倒，两个段子串里的的字符在倒叙一把，负负得正，这样就不影响子串里面字符的顺序了。\n\n代码实现\njavaimport java.util.Scanner;\n\nclass Main &#123;\n    public static void main(String[] args) &#123;\n        Scanner scanner = new Scanner(System.in);\n        //读取数字和字符串\n        int n = Integer.parseInt(scanner.nextLine());\n        String s = scanner.nextLine();\n\n        //获取字符串长度\n        int len = s.length();\n        //转为char数组，进行反转操作\n        char[] chars = s.toCharArray();\n        //注意：数组从0下标开始\n        reverseString(chars, 0 ,len - 1); //反转整个数组\n        reverseString(chars, 0, n - 1); //反转从0到右旋位置的字符\n        reverseString(chars, n, len -1); //反转剩下的字符\n        //打印结果\n        System.out.println(chars);\n    &#125;\n    //反转字符串指定位置\n    private static void reverseString(char[] s, int start, int end) &#123;\n        while (start &lt; end) &#123;\n            char temp = s[start];\n            s[start] = s[end];\n            s[end] = temp;\n            start++;\n            end--;\n        &#125;\n    &#125;\n&#125;\n实现 strStr()力扣题目链接\n题目\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。\n示例 1：\ntxt输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;\n输出：0\n解释：&quot;sad&quot; 在下标 0 和 6 处匹配。\n第一个匹配项的下标是 0 ，所以返回 0 。示例 2：\ntxt输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;\n输出：-1\n解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。思路\n前缀表与next数组很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？\nnext数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。\n其实这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。\n使用next数组来匹配\n有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。\n注意next数组是新前缀表（旧前缀表统一减一了）。\n匹配过程动画如下：\n\n构造next数组我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。 代码如下：\njavavoid getNext(int* next, const string&amp; s)构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步：\n\n初始化\n处理前后缀不相同的情况\n处理前后缀相同的情况\n\n接下来我们详解一下。\n1、初始化定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。\n然后还要对next数组进行初始化赋值，如下：\ncppint j = -1;\nnext[0] = j;j 为什么要初始化为 -1呢，因为之前说过 前缀表要统一减一的操作仅仅是其中的一种实现，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。\nnext[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）\n所以初始化next[0] &#x3D; j 。\n2、处理前后缀不相同的情况因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。\n所以遍历模式串s的循环下标i 要从 1开始，代码如下：\ncppfor (int i = 1; i &lt; s.size(); i++) &#123;如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。\n怎么回退呢？\nnext[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。\n那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。\n所以，处理前后缀不相同的情况代码如下：\ncppwhile (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123; // 前后缀不相同了\n    j = next[j]; // 向前回退\n&#125;3、处理前后缀相同的情况如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。\n代码如下：\ntxtif (s[i] == s[j + 1]) &#123; // 找到相同的前后缀\n    j++;\n&#125;\nnext[i] = j;最后整体构建next数组的函数代码如下：\ncppvoid getNext(int* next, const string&amp; s)&#123;\n    int j = -1;\n    next[0] = j;\n    for(int i = 1; i &lt; s.size(); i++) &#123; // 注意i从1开始\n        while (j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123; // 前后缀不相同了\n            j = next[j]; // 向前回退\n        &#125;\n        if (s[i] == s[j + 1]) &#123; // 找到相同的前后缀\n            j++;\n        &#125;\n        next[i] = j; // 将j（前缀的长度）赋给next[i]\n    &#125;\n&#125;代码构造next数组的逻辑流程动画如下。得到了next数组之后，就要用这个来做匹配了。\n\n使用next数组来做匹配在文本串s里 找是否出现过模式串t。\n定义两个下标j 指向模式串起始位置，i指向文本串起始位置。\n那么j初始值依然为-1，为什么呢？ 依然因为next数组里记录的起始位置为-1。\ni就从0开始，遍历文本串，代码如下：\ncppfor (int i = 0; i &lt; s.size(); i++) 接下来就是 s[i] 与 t[j + 1] （因为j从-1开始的） 进行比较。\n如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。\n代码如下：\ncppwhile(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) &#123;\n    j = next[j];\n&#125;如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：\ncppif (s[i] == t[j + 1]) &#123;\n    j++; // i的增加在for循环里\n&#125;如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。\n本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。\n代码如下：\ncppif (j == (t.size() - 1) ) &#123;\n    return (i - t.size() + 1);\n&#125;那么使用next数组，用模式串匹配文本串的整体代码如下：\ncppint j = -1; // 因为next数组里记录的起始位置为-1\nfor (int i = 0; i &lt; s.size(); i++) &#123; // 注意i就从0开始\n    while(j &gt;= 0 &amp;&amp; s[i] != t[j + 1]) &#123; // 不匹配\n        j = next[j]; // j 寻找之前匹配的位置\n    &#125;\n    if (s[i] == t[j + 1]) &#123; // 匹配，j和i同时向后移动\n        j++; // i的增加在for循环里\n    &#125;\n    if (j == (t.size() - 1) ) &#123; // 文本串s里出现了模式串t\n        return (i - t.size() + 1);\n    &#125;\n&#125;代码实现\njavaclass Solution &#123;\n    public int strStr(String haystack, String needle) &#123;\n        if (needle.length() == 0) return 0;\n        int[] next = new int[needle.length()];\n        //构造模式串的前缀表\n        getNext(next, needle);\n\n        int j = 0;\n        //遍历主串\n        for (int i = 0; i &lt; haystack.length(); i++) &#123;\n            //不匹配\n            while (j &gt; 0 &amp;&amp; needle.charAt(j) != haystack.charAt(i))\n                j = next[j - 1];\n            if (needle.charAt(j) == haystack.charAt(i))\n                j++;\n            if (j == needle.length())\n                return i - needle.length() + 1;\n        &#125;\n        return -1;\n    &#125;\n    //构造前缀表\n    private void getNext(int[] next, String s) &#123;\n        int j = 0;\n        next[0] = 0;\n        for (int i = 1; i &lt; s.length(); i++) &#123;\n            //处理前后缀不相同的情况\n            while (j &gt; 0 &amp;&amp; s.charAt(j) != s.charAt(i)) &#123;\n                j = next[j - 1]; //不相同向前回退\n            &#125;\n            //前后缀相同的情况\n            if (s.charAt(j) == s.charAt(i))\n                j++;\n            //给前缀表赋值\n            next[i] = j;\n        &#125;\n    &#125;\n&#125;\n重复的子字符串\n\n\n\n\n\n\n\n\nKMP算法还能干这个\n459. 重复的子字符串 - 力扣（LeetCode）\n题目\n给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。\n示例 1:\ntxt输入: s = &quot;abab&quot;\n输出: true\n解释: 可由子串 &quot;ab&quot; 重复两次构成。示例 2:\ntxt输入: s = &quot;aba&quot;\n输出: false示例 3:\ntxt输入: s = &quot;abcabcabcabc&quot;\n输出: true\n解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。)思路\n在一个串中查找是否出现过另一个串，这是KMP的看家本领。那么寻找重复子串怎么也涉及到KMP算法了呢？\nKMP算法中next数组为什么遇到字符不匹配的时候可以找到上一个匹配过的位置继续匹配，靠的是有计算好的前缀表。 前缀表里，统计了各个位置为终点字符串的最长相同前后缀的长度。\n那么 最长相同前后缀和重复子串的关系又有什么关系呢。\n\n前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；\n后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串\n\n在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串s：abababab 来举例，ab就是最小重复单位，如图所示：\n\n如何找到最小重复子串\n\n步骤一：因为这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和 s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。\n步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与 k[1]相同。\n步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3] 相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与 s[4]s[5]相同。\n步骤四：循环往复。\n所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。\n正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。\n重要推理\n\n假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是x，所以s是由n * x组成。\n因为字符串s的最长相同前后缀的长度一定是不包含s本身，所以 最长相同前后缀长度必然是m * x，而且 n - m &#x3D; 1。\n所以如果 nx % (n - m)x &#x3D; 0，就可以判定有重复出现的子字符串。\n\n数组长度为：len。\n如果len % (len - (next[len - 1] + 1)) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。\n如图：\n\nnext[len - 1] &#x3D; 7，next[len - 1] + 1 &#x3D; 8，8就是此时字符串asdfasdfasdf的最长相同前后缀的长度。\n(len - (next[len - 1] + 1)) 也就是： 12(字符串的长度) - 8(最长公共前后缀的长度) &#x3D; 4， 4正好可以被 12(字符串的长度) 整除，所以说明有重复的子字符串（asdf）。\n代码实现\njavaclass Solution &#123;\n    public boolean repeatedSubstringPattern(String s) &#123;\n        //处理边界\n        if (s.equals(&quot;&quot;)) return false;\n\n        int len = s.length();\n        // 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了\n        s = &quot; &quot; + s;\n        char[] chars = s.toCharArray();\n        //创建前缀表\n        int[] next = new int[len + 1];\n\n        //构造next数组\n        for (int i = 2, j = 0; i &lt;= len; i++) &#123;\n            //匹配不成功\n            while (j &gt; 0 &amp;&amp; chars[i] != chars[j + 1]) &#123;\n                j = next[j];\n            &#125;\n            //匹配成功\n            if (chars[i] == chars[j + 1])\n                j++;\n            //更新next数组的值\n            next[i] = j;\n        &#125;\n\n        //最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值\n        if (next[len] &gt; 0 &amp;&amp; (len % (len - next[len]) == 0)) &#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;\n字符串总结双指针法在344.反转字符串，使用双指针法实现了反转字符串的操作，双指针法在数组，链表和字符串中很常用。\n接着在字符串：替换空格，同样还是使用双指针法在时间复杂度O(n)的情况下完成替换空格。\n其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。\n那么针对数组删除操作的问题，其实在27. 移除元素中就已经提到了使用双指针法进行移除操作。\n同样的道理在151.翻转字符串里的单词中我们使用O(n)的时间复杂度，完成了删除冗余空格。\n一些同学会使用for循环里调用库函数erase来移除元素，这其实是O(n^2)的操作，因为erase就是O(n)的操作，所以这也是典型的不知道库函数的时间复杂度，上来就用的案例了。\n反转系列在反转上还可以在加一些玩法，其实考察的是对代码的掌控能力。\n541.反转字符串II中，一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。\n其实当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。\n只要让 i +&#x3D; (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。\n因为要找的也就是每2 * k 区间的起点，这样写程序会高效很多。\n在151.翻转字符串里的单词中要求翻转字符串里的单词，这道题目可以说是综合考察了字符串的多种操作。是考察字符串的好题。\n这道题目通过 先整体反转再局部反转，实现了反转字符串里的单词。\n后来发现反转字符串还有一个牛逼的用处，就是达到左旋的效果。\n在字符串：反转个字符串还有这个用处？中，我们通过先局部反转再整体反转达到了左旋的效果。\nKMPKMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。\nKMP的精髓所在就是前缀表，在KMP精讲中提到了，什么是KMP，什么是前缀表，以及为什么要用前缀表。\n前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。\n那么使用KMP可以解决两类经典问题：\n\n匹配问题：28. 实现 strStr()\n重复子串问题：459.重复的子字符串\n\n再一次强调了什么是前缀，什么是后缀，什么又是最长相等前后缀。\n前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。\n后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。\n然后针对前缀表到底要不要减一，这其实是不同KMP实现的方式，我们在KMP精讲中针对之前两个问题，分别给出了两个不同版本的的KMP实现。\n其中主要理解j&#x3D;next[x]这一步最为关键！\n","slug":"算法-字符串","date":"2024-02-04T05:39:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"白"},{"id":"d4dcb880244ae82689abb579db94c1da","title":"算法学习_哈希表篇","content":"算法学习_哈希表篇学习至：代码随想录 (programmercarl.com)\n哈希表理论基础哈希表哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：\n\n那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。\n例如要查询一个名字是否在这所学校里。\n要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。\n我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。\n将学生姓名映射到哈希表上就涉及到了hash function ，也就是哈希函数。\n哈希函数希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。\n哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。\n\n如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？\n此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。\n此时问题又来了，哈希表我们刚刚说过，就是一个数组。\n如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。\n接下来哈希碰撞登场\n哈希碰撞如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希碰撞。\n\n一般哈希碰撞有两种解决方法， 拉链法和线性探测法。\n拉链法刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了\n\n（数据规模是dataSize， 哈希表的大小为tableSize）\n其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。\n线性探测法使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。\n例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：\n\n常见的三种哈希结构当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。\n\n数组\nset （集合）\nmap(映射)\n\n这里数组就没啥可说的了，我们来看一下set。\n在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：\n\n\n\n集合\n底层实现\n是否有序\n数值是否可以重复\n能否更改数值\n查询效率\n增删效率\n\n\n\nstd::set\n红黑树\n有序\n否\n否\nO(log n)\nO(log n)\n\n\nstd::multiset\n红黑树\n有序\n是\n否\nO(logn)\nO(logn)\n\n\nstd::unordered_set\n哈希表\n无序\n否\n否\nO(1)\nO(1)\n\n\nstd::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。\n\n\n\n映射\n底层实现\n是否有序\n数值是否可以重复\n能否更改数值\n查询效率\n增删效率\n\n\n\nstd::map\n红黑树\nkey有序\nkey不可重复\nkey不可修改\nO(logn)\nO(logn)\n\n\nstd::multimap\n红黑树\nkey有序\nkey可重复\nkey不可修改\nO(log n)\nO(log n)\n\n\nstd::unordered_map\n哈希表\nkey无序\nkey不可重复\nkey不可修改\nO(1)\nO(1)\n\n\nstd::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。\n当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\n那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\n其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。\n虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。\n总结当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。\n但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。\n\n有效的字母异位词力扣题目链接\n题目\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。\n示例\n示例 1:\ntxt输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;\n输出: true示例 2:\ntxt输入: s = &quot;rat&quot;, t = &quot;car&quot;\n输出: false思路\n数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。需要定义一个多大的数组呢，定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。\n为了方便举例，判断一下字符串s= &quot;aee&quot;, t = &quot;eae&quot;。\n操作动画如下：\n\n定义一个数组叫做record用来上记录字符串s里字符出现的次数。\n需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。\n再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。\n那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。\n那么最后检查一下，record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。\n最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。\n时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。\n代码\njavaclass Solution &#123;\n    public boolean isAnagram(String s, String t) &#123;\n        int[] record = new int[26];\n        //遍历s字符串，计数\n        // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了\n        for (int i = 0; i &lt; s.length(); i++) &#123;\n            record[s.charAt(i) - &#39;a&#39;]++;\n        &#125;\n        for (int i = 0; i &lt; t.length(); i++) &#123;\n            record[t.charAt(i) - &#39;a&#39;]--;\n        &#125;\n        //查看record数组中是否非0，如果有则说明两字符串不匹配。\n        for (int count : record) &#123;\n            if(count != 0)&#123; // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。\n                return false;\n            &#125;\n        &#125;\n        return true;    // record数组所有元素都为零0，说明字符串s和t是字母异位词\n    &#125;\n&#125;\n找到字符串中所有字母异位词438. 找到字符串中所有字母异位词 - 力扣（LeetCode）\n题目\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。\n示例 1:\ntxt输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;\n输出: [0,6]\n解释:\n起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。\n起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。 示例 2:\ntxt输入: s = &quot;abab&quot;, p = &quot;ab&quot;\n输出: [0,1,2]\n解释:\n起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。\n起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。\n起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。思路\n利用滑动窗口解题\n\n\n\n\n\n\n\n\n\n\n用target数组记录p字符串的字符及数量。\n用window数组记录窗口中的字符及数量。\n用ans集合存储target匹配window时的left。\n遍历s字符串，直到right到达s字符串的末端。\n将right位置的字符添加到window中\n判断窗口大小与p字符串长度一致\n如果target与window一致，则添加left到ans中。\n减去window中left位置的数量。\nleft向右移动一位。\n\n\nright向右移动一位。\n\n\n返回ans集合\n\n\n代码\njavaclass Solution &#123;\n    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;\n        //设置一个target记录p字符串的字符与数量\n        int[] target = new int[26];\n        for (int i = 0; i &lt; p.length(); i++) &#123;\n            target[p.charAt(i)-&#39;a&#39;]++;  //记录数量\n        &#125;\n        //双指针构建滑动窗口思路\n        //1.右指针right向右滑动，同时window记录窗口中的字符与数量\n        //2.当窗口大小长度与p字符长度相同的时候进行比较，判断是否是异位词\n        //3.比较完后同时移动左右指针1位，再次比较\n        //4.一直重复2，3步骤，直到right指针走到字符串s的末尾\n\n        int left = 0, right = 0;    //滑动窗口的左右指针\n        int[] window = new int[26]; //window记录窗口中的字符与数量\n        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();  //ans作为返回的数组\n        //遍历s字符串\n        while(right &lt; s.length()) &#123;\n            window[s.charAt(right) - &#39;a&#39;]++; //记录right位置的字母\n            if((right - left + 1) == p.length())&#123;   //窗口大小与p字符长度相同进行比较\n                if(Arrays.equals(window, target))&#123;  //相同添加left\n                    ans.add(left);\n                &#125;\n                window[s.charAt(left) - &#39;a&#39;]--; //移动左指针需要删除window对应的字母\n                left++;\n            &#125;\n            right++;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n两个数组的交集力扣题目链接\n题目\n给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\n示例 1：\ntxt输入：nums1 = [1,2,2,1], nums2 = [2,2]\n输出：[2]示例 2：\ntxt输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出：[9,4]\n解释：[4,9] 也是可通过的思路\n输出结果中的每个元素一定是唯一的，也就是说输出的结果是去重的，同时可以不考虑输出结果的顺序。\n需要注意的是，使用数组来做哈希表的题目，是因为题目限制了数值的大小。这题没有限制数值的大小，就无法使用数组来做哈希表了。\n而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。\n\n代码\njavapublic int[] intersection(int[] nums1, int[] nums2) &#123;\n    //判断边界条件\n    if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0)&#123;\n        return new int[0];\n    &#125;\n    //构建两个hashset\n    Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;();\n    Set&lt;Integer&gt; resSet = new HashSet&lt;&gt;();\n    //遍历数组1\n    for (int i : nums1) &#123;\n        set1.add(i);    //添加到set1中\n    &#125;\n    //遍历数组过程中判断哈希表中是否存在该元素\n    for (int i : nums2) &#123;\n        if(set1.contains(i)) &#123;\n            resSet.add(i);\n        &#125;\n    &#125;\n    //将结果集合转为数组\n    int[] arr = new int[resSet.size()];\n    int j = 0;\n    for (Integer i : resSet) &#123;\n        arr[j++] = i;\n    &#125;\n    return arr;\n&#125;\n两个数组的交集 II350. 两个数组的交集 II - 力扣（LeetCode）\n题目\n给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\n示例 1：\ntxt输入：nums1 = [1,2,2,1], nums2 = [2,2]\n输出：[2,2]示例 2:\ntxt输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出：[4,9]思路\n\n\n用hashmap记录nums1中的数字和个数，数字作为key值，对应的个数作为value值。\n遍历nums2数组，对每个元素进行比较。如果在hashmap中找到且对应的个数大于1，添加到res数组中，将hashmap对应的个数减1，方便下个元素进行比较。\n返回一个新数组，res数组记录的交集从0到index位置。\n\n代码实现\njavaclass Solution &#123;\n    public int[] intersect(int[] nums1, int[] nums2) &#123;\n        //用HashMap记录nums1数组的元素和个数\n        //数组作为key值，个数作为value值\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        //遍历nums1数组\n        for (int i : nums1) &#123;\n            map.put(i, map.getOrDefault(i, 0) + 1);\n        &#125;\n        int[] res = new int[nums1.length]; //记录交集\n        int index = 0;\n        //遍历nums2数组2，找交集\n        for (int num : nums2) &#123;\n            //找到相同数字，且个数大于1，添加到res中。并且map个数减1，不影响下一个数字匹配\n            if(map.containsKey(num) &amp;&amp; map.get(num) &gt; 0) &#123;\n                res[index++] = num;;\n                map.put(num, map.get(num) - 1);\n            &#125;\n        &#125;\n        //创建并返回res副本，从0开始到index-1处的元素\n        return Arrays.copyOfRange(res, 0, index);\n    &#125;\n&#125;\n快乐数力扣题目链接\n题目\n编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」 定义为：\n\n对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\n如果这个过程 结果为 1，那么这个数就是快乐数。\n\n如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\n示例 1：\ntxt输入：n = 19\n输出：true\n解释：\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1示例 2：\ntxt输入：n = 2\n输出：false 思路\n\n题目中说了会 无限循环，那么也就是说求和的过程中，sum会重复出现，这对解题很重要！\n在哈希表理论基础中说过，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。\n所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。\n\n代码实现\njavaclass Solution &#123;\n    public boolean isHappy(int n) &#123;\n        Set&lt;Integer&gt; record = new HashSet&lt;&gt;(); //记录每次的sum\n        while (n != 1 &amp;&amp; !record.contains(n)) &#123; //返回的数为1或者已经重复出现了则退出循环\n            record.add(n);\n            n = getNextNumber(n); //计算快乐数\n        &#125;\n        return n == 1; //当前n是否为1\n    &#125;\n    private int getNextNumber(int n) &#123;\n        //res作为结果返回\n        int res = 0;\n        //遍历n的每一位数\n        while(n &gt; 0) &#123;\n            int temp = n % 10;\n            res += temp * temp;\n            n = n / 10;\n        &#125;\n        return res;\n    &#125;\n&#125;\n两数之和力扣题目链接\n题目\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\ntxt输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2：\ntxt输入：nums = [3,2,4], target = 6\n输出：[1,2]示例 3：\ntxt输入：nums = [3,3], target = 6\n输出：[0,1]思路\n\n再强调一下 什么时候使用哈希法，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。\n本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。那么我们就应该想到使用哈希法了。\n因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适。\n再来看一下使用数组和set来做哈希法的局限。\n数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。\nset是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。\n\n\n此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value再保存数值所在的下标。\n\n分析：\n\n用map存放已遍历的数组，元素作为key值，下标作为value值。因为哈希表查询的是key值，所以应该是元素作为key值。\n每次遍历数组的时候，判断前面是否有符号条件的元素已经存放在map中。\n如果符合条件，则用数组记录当前下标和找到的元素下标。\n返回数组结果\n\n代码实现\njavaclass Solution &#123;\n    public int[] twoSum(int[] nums, int target) &#123;\n        int[] res = new int[2];\n        //边界\n        if (nums == null || nums.length == 0) &#123;\n            return res;\n        &#125;\n        //用map存已经遍历的数组\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        //遍历nums数组。元素作为key值，下标作为value值\n        //查找元素是否存在，查找的是key值\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            int temp = target - nums[i];\n            //判断前面是否有符合的元素已经存放在map中\n            if(map.containsKey(temp))&#123;\n                res[0] = map.get(temp);\n                res[1] = i;\n            &#125;\n            //将当前元素添加到map中。数字作为key，下标作为value\n            map.put(nums[i], i);\n        &#125;\n        return res;\n    &#125;\n&#125;\n四数相加II力扣题目链接\n题目\n给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：\n\n0 &lt;= i, j, k, l &lt; n\nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0\n\n示例 1：\ntxt输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n输出：2\n解释：\n两个元组如下：\n1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0示例 2：\ntxt输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n输出：1思路\n\n首先定义 一个map，key放a和b两数之和，value 放a和b两数之和出现的次数。\n遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。\n定义int变量count，用来统计 a+b+c+d &#x3D; 0 出现的次数。\n在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。\n最后返回统计值 count 就可以了\n\n代码实现\njavaclass Solution &#123;\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;\n        //count计数\n        int count = 0;\n        //key放a和b两数之和，value放a和b两数之和出现的次数\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; nums1.length; i++) &#123;\n            for (int j = 0; j &lt; nums2.length; j++) &#123;\n                int number = nums1[i] + nums2[j];\n                //key存放和，value存放出现的次数\n                map.put(number, map.getOrDefault(number, 0) + 1);\n            &#125;\n        &#125;\n        //遍历c和d数组，在map中找到0-(c+d)的元素\n        for (int i = 0; i &lt; nums3.length; i++) &#123;\n            for (int j = 0; j &lt; nums4.length; j++) &#123;\n                int temp = 0 - (nums3[i] + nums4[j]);\n                //如果找到符合条件的，为count计数\n                if (map.containsKey(temp)) &#123;\n                    count = count + map.get(temp);\n                &#125;\n            &#125;\n        &#125;\n        //返回最后记录的数字\n        return count;\n    &#125;\n&#125;\n赎金信力扣题目链接\n题目\n给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。\n如果可以，返回 true ；否则返回 false 。\nmagazine 中的每个字符只能在 ransomNote 中使用一次。\n示例 1：\ntxt输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;\n输出：false示例 2：\ntxt输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;\n输出：false示例 3：\ntxt输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;\n输出：true思路\n\n因为题目说只有小写字母，那可以采用空间换取时间的哈希策略，用一个长度为26的数组来记录magazine里字母出现的次数。\n然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。\n依然是数组在哈希法中的应用。\n\n代码实现\njavaclass Solution &#123;\n    public boolean canConstruct(String ransomNote, String magazine) &#123;\n        //记录magazine字符串中每个字母的数量\n        int[] record = new int[26];\n        //边界\n        if (ransomNote.length() &gt; magazine.length()) &#123;\n            return false;\n        &#125;\n        //添加record\n        for (int i = 0; i &lt; magazine.length(); i++) &#123;\n            record[magazine.charAt(i) - &#39;a&#39;]++;\n        &#125;\n        //遍历ransomNote，判断个数是否包含\n        for (int i = 0; i &lt; ransomNote.length(); i++) &#123;\n            //在record里对应的字符个数做--操作\n            record[ransomNote.charAt(i) - &#39;a&#39;]--;\n            //如果小于0，则说明ransomNote出现的字符，magazine没有\n            if(record[ransomNote.charAt(i) - &#39;a&#39;] &lt; 0)&#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n三数之和力扣题目链接\n题目\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n你返回所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n示例 1：\ntxt输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。示例 2：\ntxt输入：nums = [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。示例 3：\ntxt输入：nums = [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。思路\n双指针法\n\n拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。\n依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这里相当于 a &#x3D; nums[i]，b &#x3D; nums[left]，c &#x3D; nums[right]。\n接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。\n如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。\n时间复杂度：O(n^2)。\n去重逻辑的思考a的去重说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]\na 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。\n但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。\n有同学可能想，这不都一样吗。\n其实不一样！\n都是和 nums[i]进行比较，是比较它的前一个，还是比较它的后一个。\n如果我们的写法是 这样：\ntxtif (nums[i] == nums[i + 1]) &#123; // 去重操作\n    continue;\n&#125;那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。\n我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！\n所以这里是有两个重复的维度。\n那么应该这么写：\ntxtif (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;\n    continue;\n&#125;这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。\n这是一个非常细节的思考过程。\nb与c的去重很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）\ntxtwhile (right &gt; left) &#123;\n    if (nums[i] + nums[left] + nums[right] &gt; 0) &#123;\n        right--;\n        // 去重 right\n        while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;\n    &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123;\n        left++;\n        // 去重 left\n        while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++;\n    &#125; else &#123;\n    &#125;\n&#125;但细想一下，这种去重其实对提升程序运行效率是没有帮助的。\n拿right去重为例，即使不加这个去重逻辑，依然根据 while (right &gt; left) 和 if (nums[i] + nums[left] + nums[right] &gt; 0) 去完成right– 的操作。\n多加了 while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--; 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。\n最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。\n所以这种去重 是可以不加的。 仅仅是 把去重的逻辑提前了而已。\n代码实现\njavaclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;\n        //二维数组返回结果\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        //先将数组排列为有序数组，然后才能用双指针法\n        Arrays.sort(nums);\n        //遍历数组找到三数之和为0\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            //如果排序之后第一个数大于0，则直接返回结果\n            if (nums[i] &gt; 0) &#123;\n                return result;\n            &#125;\n            //去重a\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) &#123;\n                continue;\n            &#125;\n            //设置左右指针\n            int left = i + 1;\n            int right = nums.length - 1;\n            while (left &lt; right) &#123;\n                int sum = nums[i] + nums[left] + nums[right];\n                if (sum &gt; 0) &#123;\n                    right--;\n                &#125; else if (sum &lt; 0) &#123;\n                    left++;\n                &#125; else &#123; //三数之和为0\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    //去重逻辑应该放在找到一个三元组后，对b和c去重\n                    while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;\n                    while (right &gt; left &amp;&amp; nums[left] == nums[left] + 1) left++;\n\n                    right--;\n                    left++;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n四数之和力扣题目链接\n题目\n给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n\n0 &lt;= a, b, c, d &lt; n\na、b、c 和 d 互不相同\nnums[a] + nums[b] + nums[c] + nums[d] == target\n\n你可以按 任意顺序 返回答案 。\n示例 1：\ntxt输入：nums = [1,0,-1,0,-2,2], target = 0\n输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]示例 2：\ntxt输入：nums = [2,2,2,2,2], target = 8\n输出：[[2,2,2,2]]思路\n四数之和，和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。\n但是有一些细节需要注意，例如： 不要判断nums[k] &gt; target 就返回了，三数之和 可以通过 nums[i] &gt; 0 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是[-4, -3, -2, -1]，target是-10，不能因为-4 &gt; -10而跳过。但是我们依旧可以去做剪枝，逻辑变成nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)就可以了。\n15.三数之和的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] &#x3D;&#x3D; 0。\n四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。\n那么一样的道理，五数之和、六数之和等等都采用这种解法。\n代码实现\njavaclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;\n        //二维数组存放结果\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        Arrays.sort(nums);\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            // nums[i] &gt; target直接返回，剪枝操作\n            if (nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) &#123;\n                return result;\n            &#125;\n            //对nums[i]去重\n            if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) &#123;\n                continue;\n            &#125;\n\n            for (int j = i + 1; j &lt; nums.length; j++) &#123;\n                //对nums[j]去重\n                if (j &gt; i + 1 &amp;&amp; nums[j - 1] == nums[j]) &#123;\n                    continue;\n                &#125;\n                int left = j +1;\n                int right = nums.length - 1;\n                while (right &gt; left) &#123;\n                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];\n                    if (sum &gt; target) &#123;\n                        right--;\n                    &#125; else if (sum &lt; target) &#123;\n                        left++;\n                    &#125; else &#123;\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        //对nums[left]和nums[right]去重\n                        while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;\n                        while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;\n\n                        left++;\n                        right--;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n哈希表总结哈希表理论基础一般来说哈希表都是用来快速判断一个元素是否出现集合里。\n对于哈希表，要知道哈希函数和哈希碰撞在哈希表中的作用。\n哈希函数是把传入的key映射到符号表的索引上。\n哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。\n接下来是常见的三种哈希结构：\n\n数组\nset（集合）\nmap（映射）\n\n只有对这些数据结构的底层实现很熟悉，才能灵活使用，否则很容易写出效率低下的程序。\n哈希表经典题目数组作为哈希表一些应用场景就是为数组量身定做的。\n在242.有效的字母异位词中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！\n这道题目包含小写字母，那么使用数组来做哈希最合适不过。\n在383.赎金信中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！\n本题和242.有效的字母异位词很像，242.有效的字母异位词是求 字符串a 和 字符串b 是否可以相互组成，在383.赎金信中是求字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。\n一些同学可能想，用数组干啥，都用map不就完事了。\n上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！\nset作为哈希表在349. 两个数组的交集中我们给出了什么时候用数组就不行了，需要用set。\n这道题目没有限制数值的大小，就无法使用数组来做哈希表了。\n主要因为如下两点：\n\n数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。\n如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。\n\n所以此时一样的做映射的话，就可以使用set了。\n在202.快乐数中，我们再次使用了set来判断一个数是否重复出现过。\nmap作为哈希表在1.两数之和中map正式登场。\n来说一说：使用数组和set来做哈希法的局限。\n\n数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。\nset是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。\n\nmap是一种&lt;key, value&gt;的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。\n在454.四数相加中我们提到了其实需要哈希的地方都能找到map的身影。\n本题咋眼一看好像和18. 四数之和，15.三数之和差不多，其实差很多！\n关键差别是本题为四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] &#x3D; 0就可以，不用考虑重复问题，而18. 四数之和，15.三数之和.三数之和.html)是一个数组（集合）里找到和为0的组合，可就难很多了！\n用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。\n其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。\n在15.三数之和可以体会到，使用哈希法还是比较麻烦的。\n所以18. 四数之和，15.三数之和都推荐使用双指针法！\n","slug":"算法-哈希表","date":"2024-01-19T09:50:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"白"},{"id":"d0a240fd5b2dfdf31774017c571467a1","title":"Servlet笔记","content":"第四章 Servlet笔记一 Servlet简介1.1 动态资源和静态资源\n\n\n\n\n\n\n\n\n静态资源\n\n无需在程序运行时通过代码运行生成的资源,在程序运行之前就写好的资源. 例如:html css js img ,音频文件和视频文件\n\n\n\n\n\n\n\n\n\n\n动态资源 \n\n需要在程序运行时通过代码运行生成的资源,在程序运行之前无法确定的数据,运行时动态生成,例如Servlet,Thymeleaf … …\n动态资源指的不是视图上的动画效果或者是简单的人机交互效果\n\n\n\n\n\n\n\n\n\n\n生活举例\n\n去蛋糕店买蛋糕\n直接买柜台上已经做好的  : 静态资源\n和柜员说要求后现场制作  : 动态资源\n\n\n\n1.2 Servlet简介\n\n\n\n\n\n\n\n\nServlet  (server applet) 是运行在服务端(tomcat)的Java小程序，是sun公司提供一套定义动态资源规范; 从代码层面上来讲Servlet就是一个接口\n\n用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。我们可以把Servlet称为Web应用中的控制器\n\n\n\n不是所有的JAVA类都能用于处理客户端请求,能处理客户端请求并做出响应的一套技术标准就是Servlet\nServlet是运行在服务端的,所以 Servlet必须在WEB项目中开发且在Tomcat这样的服务容器中运行\n\n\n\n\n\n\n\n\n\n\n请求响应与HttpServletRequest和HttpServletResponse之间的对应关系\n\n\n\n\n\n\n\n\n\n\nServlet运行的流程\n运行流程如下，蓝色的序号是执行顺序\n\n\n二 Servlet开发流程2.1 目标\n\n\n\n\n\n\n\n\n校验注册时,用户名是否被占用. 通过客户端向一个Servlet发送请求,携带username,如果用户名是’atguigu’,则向客户端响应 NO,如果是其他,响应YES\n2.2 开发过程\n\n\n\n\n\n\n\n\n步骤1 开发一个web类型的module \n\n过程参照之前\n\n\n\n\n\n\n\n\n\n\n步骤2 开发一个UserServlet\njavapublic class UserServlet  extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 获取请求中的参数\n        String username = req.getParameter(&quot;username&quot;);\n        if(&quot;atguigu&quot;.equals(username))&#123;\n            //通过响应对象响应信息\n            resp.getWriter().write(&quot;NO&quot;);\n        &#125;else&#123;\n            resp.getWriter().write(&quot;YES&quot;);\n        &#125;\n\n    &#125;\n&#125;\n自定义一个类,要继承HttpServlet类\n重写service方法,该方法主要就是用于处理用户请求的服务方法\nHttpServletRequest 代表请求对象,是有请求报文经过tomcat转换而来的,通过该对象可以获取请求中的信息\nHttpServletResponse 代表响应对象,该对象会被tomcat转换为响应的报文,通过该对象可以设置响应中的信息\nServlet对象的生命周期(创建,初始化,处理服务,销毁)是由tomcat管理的,无需我们自己new\nHttpServletRequest HttpServletResponse 两个对象也是有tomcat负责转换,在调用service方法时传入给我们用的\n\n\n\n\n\n\n\n\n\n\n步骤3 在web.xml为UseServlet配置请求的映射路径\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;\n         version=&quot;5.0&quot;&gt;\n\n    &lt;servlet&gt;\n        &lt;!--给UserServlet起一个别名--&gt;\n        &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.atguigu.servlet.UserServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n\n\n    &lt;servlet-mapping&gt;\n        &lt;!--关联别名和映射路径--&gt;\n        &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;\n        &lt;!--可以为一个Servlet匹配多个不同的映射路径,但是不同的Servlet不能使用相同的url-pattern--&gt;\n        &lt;url-pattern&gt;/userServlet&lt;/url-pattern&gt;\n       &lt;!-- &lt;url-pattern&gt;/userServlet2&lt;/url-pattern&gt;--&gt;\n        &lt;!--\n            /        表示通配所有资源,不包括jsp文件\n            /*       表示通配所有资源,包括jsp文件\n            /a/*     匹配所有以a前缀的映射路径\n            *.action 匹配所有以action为后缀的映射路径\n        --&gt;\n       &lt;!-- &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;\n    &lt;/servlet-mapping&gt;\n\n&lt;/web-app&gt;\nServlet并不是文件系统中实际存在的文件或者目录,所以为了能够请求到该资源,我们需要为其配置映射路径\nservlet的请求映射路径配置在web.xml中\nservlet-name作为servlet的别名,可以自己随意定义,见名知意就好\nurl-pattern标签用于定义Servlet的请求映射路径\n一个servlet可以对应多个不同的url-pattern\n多个servlet不能使用相同的url-pattern\nurl-pattern中可以使用一些通配写法\n&#x2F;        表示通配所有资源,不包括jsp文件\n&#x2F;*      表示通配所有资源,包括jsp文件\n&#x2F;a&#x2F;*     匹配所有以a前缀的映射路径\n*.action 匹配所有以action为后缀的映射路径\n\n\n\n\n\n\n\n\n\n\n\n\n步骤4 开发一个form表单,向servlet发送一个get请求并携带username参数\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;form action=&quot;userServlet&quot;&gt;\n        请输入用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;校验&quot;&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n启动项目,访问index.html ,提交表单测试\n\n使用debug模式运行测试\n\n\n\n\n\n\n\n\n\n\n\n映射关系图\n\n2.3 开发前准备步骤\n\n\n\n\n\n\n\n\n创建新模块后，打开模块设置添加Tomcat库\n\n\n\n\n\n\n\n\n\n\n然后再添加Web框架支持，版本要5.0以上\n\n\n\n\n\n\n\n\n\n\n\n不填写路径默认跳转到index.html代码，编写代码如下\n\n\n\n\n\n\n\n\n\n\n需要实现Servlet接口，属于jakarta.servlet的。\n也可以继承HttpServlet类，该类间接实现了Servlet接口。\n\n\n\n\n\n\n\n\n\n\n将项目部署到tomcat中，并为项目设置上下文路径\n\n2.4 servlet开发流程（举例实现）\n\n\n\n\n\n\n\n\n1.创建javaWEB项目，同时将tomcat添加为当前项目的依赖（准备步骤已经有了）\n\n\n\n\n\n\n\n\n\n2.重写service方法\tservice(HttpServletRequest req, HttpServletResponse resp)\n\n\n\n\n\n\n\n\n\n3.在service方法中，定义业务处理代码\n\n\n\n\n\n\n\n\n\n\n4.在web.xml中，配置Servlet对应的请求映射路径\n\n修改index.html提交之后的路径方便查看结果\n\n然后运行tomcat，进入到对应项目的url地址即可查看效果。从而了解实现了Servlet。\n2.5 sevlet-api.jar导入问题servlet-api编码的时候需要，运行的时候，在服务器的环境中，由服务软件(Tomcat)提供\n因此我们的们AVAWEB顶目中，在打包&#x2F;构建的时候是无需携带servlet-api的ar包\n2.6 Content-Type响应头的问题MIME类型响应头\t煤体类型，文件类型，响应的数据类型 \nMIME类型用于告诉客户端响应的数据是什么类型的数据，客户端以此类型决定用什么方式解析响应体\n代码演示\n可以设置Content-Type响应头的内容，通过查看web.xml文件来写上对应的MIME类型。conf/web.xml记录了几乎所有的文件类型对应的MIME类型。\njavaprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //1. 从request对象中获取请求中的任何信息(比如username参数)\n        String username = req.getParameter(&quot;username&quot;); //根据参数名获取参数值，无论参数是在url?后 还是在请求体中\n        //2. 处理业务的代码\n        String info = &quot;&lt;h1&gt;YES&lt;h1&gt;&quot;;\n        if(&quot;baipandun&quot;.equals(username))&#123;\n            info=&quot;&lt;h1&gt;No&lt;h1&gt;&quot;;\n        &#125;\n        //3. 将要响应的数据放入response\n        //应该设置Content-Type响应头\n        resp.setContentType(&quot;text/html&quot;);\n\n        PrintWriter writer = resp.getWriter(); //该方法返回的是一个向响应体重打印字符串的 打印流\n        writer.write(info);\n    &#125;\n三 Servlet注解方式配置快速引入用注解方式配置映射路径后，就不用在web.xml中配置了\n原web.xml内容\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd&quot;\n         version=&quot;6.0&quot;&gt;\n\n    &lt;!--\n    1. 配置Servlet类，并起一个别名\n        servlet-class 告诉Tomcat对应的要实例化的Servlet类\n        servlet-name 用于关联请求的映射路径\n        servlet-mapping\n            servlet-name 对应上面的别名\n            url-pattern 浏览器访问的路径名\n    --&gt;\n    &lt;!--下面这一段就可以注释掉了 --&gt;\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.servlet.UserSerlvet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/userServlet&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n&lt;/web-app&gt;Servlet1.java代码内容，当访问部署的项目下的s1路径时，可在控制台查看输出结果。\njava@WebServlet(&quot;/s1&quot;)\npublic class Servlet1 extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        System.out.println(&quot;servlet1执行了&quot;);\n    &#125;\n&#125;\n3.1 @WebServlet注解源码\n\n\n\n\n\n\n\n\n官方JAVAEEAPI文档下载地址\n\nJava EE - Technologies (oracle.com) \n\n@WebServlet注解的源码阅读\n\n\njava\npackage jakarta.servlet.annotation;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @since Servlet 3.0\n */\n@Target(&#123; ElementType.TYPE &#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface WebServlet &#123;\n\n    /**\n     * The name of the servlet\n     * 相当于 servlet-name\n     * @return the name of the servlet\n     */\n    String name() default &quot;&quot;;\n\n    /**\n     * The URL patterns of the servlet\n     * 如果只配置一个url-pattern ,则通过该属性即可,和urlPatterns属性互斥\n     * @return the URL patterns of the servlet\n     */\n    String[] value() default &#123;&#125;;\n\n    /**\n     * The URL patterns of the servlet\n     * 如果要配置多个url-pattern ,需要通过该属性,和value属性互斥\n     * @return the URL patterns of the servlet\n     */\n    String[] urlPatterns() default &#123;&#125;;\n\n    /**\n     * The load-on-startup order of the servlet\n     * 配置Servlet是否在项目加载时实例化\n     * @return the load-on-startup order of the servlet\n     */\n    int loadOnStartup() default -1;\n\n    /**\n     * The init parameters of the servlet\n     * 配置初始化参数\n     * @return the init parameters of the servlet\n     */\n    WebInitParam[] initParams() default &#123;&#125;;\n\n    /**\n     * Declares whether the servlet supports asynchronous operation mode.\n     *\n     * @return &#123;@code true&#125; if the servlet supports asynchronous operation mode\n     * @see jakarta.servlet.ServletRequest#startAsync\n     * @see jakarta.servlet.ServletRequest#startAsync( jakarta.servlet.ServletRequest,jakarta.servlet.ServletResponse)\n     */\n    boolean asyncSupported() default false;\n\n    /**\n     * The small-icon of the servlet\n     *\n     * @return the small-icon of the servlet\n     */\n    String smallIcon() default &quot;&quot;;\n\n    /**\n     * The large-icon of the servlet\n     *\n     * @return the large-icon of the servlet\n     */\n    String largeIcon() default &quot;&quot;;\n\n    /**\n     * The description of the servlet\n     *\n     * @return the description of the servlet\n     */\n    String description() default &quot;&quot;;\n\n    /**\n     * The display name of the servlet\n     *\n     * @return the display name of the servlet\n     */\n    String displayName() default &quot;&quot;;\n\n&#125;\n3.2 @WebServlet注解使用\n\n\n\n\n\n\n\n\n使用@WebServlet注解替换Servlet配置\njava@WebServlet(\n        name = &quot;userServlet&quot;,\n        //value = &quot;/user&quot;,\n        urlPatterns = &#123;&quot;/userServlet1&quot;,&quot;/userServlet2&quot;,&quot;/userServlet&quot;&#125;,\n        initParams = &#123;@WebInitParam(name = &quot;encoding&quot;,value = &quot;UTF-8&quot;)&#125;,\n        loadOnStartup = 6\n)\npublic class UserServlet  extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        String encoding = getServletConfig().getInitParameter(&quot;encoding&quot;);\n        System.out.println(encoding);\n        // 获取请求中的参数\n        String username = req.getParameter(&quot;username&quot;);\n        if(&quot;atguigu&quot;.equals(username))&#123;\n            //通过响应对象响应信息\n            resp.getWriter().write(&quot;NO&quot;);\n        &#125;else&#123;\n            resp.getWriter().write(&quot;YES&quot;);\n        &#125;\n    &#125;\n&#125;\n四 Servlet生命周期4.1 生命周期简介\n\n\n\n\n\n\n\n\n什么是Servlet的生命周期\n\n应用程序中的对象不仅在空间上有层次结构的关系，在时间上也会因为处于程序运行过程中的不同阶段而表现出不同状态和不同行为——这就是对象的生命周期。\n简单的叙述生命周期，就是对象在容器中从开始创建到销毁的过程。\n\n\n\n\n\n\n\n\n\n\nServlet容器\n\nServlet对象是Servlet容器创建的，生命周期方法都是由容器(目前我们使用的是Tomcat)调用的。这一点和我们之前所编写的代码有很大不同。在今后的学习中我们会看到，越来越多的对象交给容器或框架来创建，越来越多的方法由容器或框架来调用，开发人员要尽可能多的将精力放在业务逻辑的实现上。\n\n\n\n\n\n\n\n\n\n\nServlet主要的生命周期执行特点\n\n\n\n生命周期\n对应方法\n执行时机\n执行次数\n\n\n\n构造对象\n构造器\n第一次请求或者容器启动\n1\n\n\n初始化\ninit()\n构造完毕后\n1\n\n\n处理服务\nservice(HttpServletRequest req,HttpServletResponse resp)\n每次请求\n多次\n\n\n销毁\ndestory()\n容器关闭\n1\n\n\n4.2 生命周期测试\n\n\n\n\n\n\n\n\n开发servlet代码\njavapackage com.atguigu.servlet;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\n\npublic class ServletLifeCycle  extends HttpServlet &#123;\n    public ServletLifeCycle()&#123;\n        System.out.println(&quot;构造器&quot;);\n    &#125;\n\n    @Override\n    public void init() throws ServletException &#123;\n        System.out.println(&quot;初始化方法&quot;);\n    &#125;\n\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        System.out.println(&quot;service方法&quot;);\n    &#125;\n\n    @Override\n    public void destroy() &#123;\n        System.out.println(&quot;销毁方法&quot;);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n配置Servlet\nxml  \n    &lt;servlet&gt;\n        &lt;servlet-name&gt;servletLifeCycle&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.atguigu.servlet.ServletLifeCycle&lt;/servlet-class&gt;\n        &lt;!--load-on-startup\n           默认值是-1，含义是tomcat启动时不会实例化该servlet\n            如果配置的是正整数则表示容器在启动时就要实例化Servlet,\n            数字表示的是实例化的顺序\n           如果序号冲突了，tomcat会自动协调启动顺序\n        --&gt;\n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;servletLifeCycle&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/servletLiftCycle&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n请求Servlet测试\n\n略\n4.3 生命周期总结\n通过生命周期测试我们发现Servlet对象在容器中是单例的\n容器是可以处理并发的用户请求的,每个请求在容器中都会开启一个线程\n多个线程可能会使用相同的Servlet对象,所以在Servlet中,我们不要轻易定义一些容易经常发生修改的成员变量\nload-on-startup中定义的正整数表示实例化顺序,如果数字重复了,容器会自行解决实例化顺序问题,但是应该避免重复\nTomcat容器中,已经定义了一些随系统启动实例化的servlet,我们自定义的servlet的load-on-startup尽量不要占用数字1-5\n\n4.4 defaultServletdefaultServlet：当tomcat发现客户端请求的资源和任何一个现有的servlet都没有匹配的时候，就会交给defaultServlet进行处理。defaultServlet就会根据请求的资源路径去找对应的文件区，通过读取IO流读取文件，把文件数据放在response对象上，同时判断文件拓展名等等内容加载到response对象上，返回报文给客户端。静态资源基本是通过defaultServlet加载的。\n\n五 Servlet继承结构5.1 Servlet 接口\n\n\n\n\n\n\n\n\n源码及功能解释\n\n通过idea查看: 此处略\n\n\n\n\n\n\n\n\n\n\n接口及方法说明\n\nServlet 规范接口,所有的Servlet必须实现 \npublic void init(ServletConfig config) throws ServletException;   \n初始化方法,容器在构造servlet对象后,自动调用的方法,容器负责实例化一个ServletConfig对象,并在调用该方法时传入\nServletConfig对象可以为Servlet 提供初始化参数\n\n\npublic ServletConfig getServletConfig();\n获取ServletConfig对象的方法,后续可以通过该对象获取Servlet初始化参数\n\n\npublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;\n处理请求并做出响应的服务方法,每次请求产生时由容器调用\n容器创建一个ServletRequest对象和ServletResponse对象,容器在调用service方法时,传入这两个对象\n\n\npublic String getServletInfo();\n获取ServletInfo信息的方法\n\n\npublic void destroy();\nServlet实例在销毁之前调用的方法\n\n\n\n\n\n5.2 GenericServlet 抽象类\n\n\n\n\n\n\n\n\n源码\n\n通过idea查看: 此处略\n\n\n\n\n\n\n\n\n\n\n源码解释\n\nGenericServlet 抽象类是对Servlet接口一些固定功能的粗糙实现,以及对service方法的再次抽象声明,并定义了一些其他相关功能方法。GenericServlet 抽象类，侧重除了service方法以外的其他方法的基础处理。\nprivate transient ServletConfig config; \n初始化配置对象作为属性\n\n\npublic GenericServlet() &#123; &#125; \n构造器,为了满足继承而准备\n\n\npublic void destroy() &#123; &#125; \n销毁方法的平庸实现，将抽象方法重写为普通方法。\n\n\npublic String getInitParameter(String name) \n获取初始参数的快捷方法\n\n\npublic Enumeration&lt;String&gt; getInitParameterNames() \n返回所有初始化参数名的方法\n\n\npublic ServletConfig getServletConfig()\n获取初始Servlet初始配置对象ServletConfig的方法\n\n\npublic ServletContext getServletContext()\n获取上下文对象ServletContext的方法\n\n\npublic String getServletInfo() \n获取Servlet信息的平庸实现\n\n\npublic void init(ServletConfig config) throws ServletException() \n初始化方法的实现,并在此调用了init的重载方法。tomcat在调用init方法时，会读取配置信息进入到一个ServletConfig对象并将该对象传入init方法\n\n\npublic void init() throws ServletException \n重载init方法,为了让我们自己定义初始化功能的方法\n\n\npublic void log(String msg) \npublic void log(String message, Throwable t)\n打印日志的方法及重载\n\n\npublic abstract void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; \n服务方法再次声明\n\n\npublic String getServletName() \n获取ServletName的方法\n\n\n\n\n\n5.3 HttpServlet 抽象类\n\n\n\n\n\n\n\n\n源码\n\n通过idea查看: 此处略\n\n\n\n\n\n\n\n\n\n\n解释\n\nabstract class HttpServlet extends GenericServlet  HttpServlet抽象类,除了基本的实现以外,增加了更多的基础功能。HttpServlet 抽象类，侧重service方法的处理。\nprivate static final String METHOD_DELETE = &quot;DELETE&quot;;\nprivate static final String METHOD_HEAD = &quot;HEAD&quot;;\nprivate static final String METHOD_GET = &quot;GET&quot;;\nprivate static final String METHOD_OPTIONS = &quot;OPTIONS&quot;;\nprivate static final String METHOD_POST = &quot;POST&quot;;\nprivate static final String METHOD_PUT = &quot;PUT&quot;;\nprivate static final String METHOD_TRACE = &quot;TRACE&quot;;\n上述属性用于定义常见请求方式名常量值\n\n\npublic HttpServlet() &#123;&#125;\n构造器,用于处理继承\n\n\npublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException\n对服务方法的实现\n在该方法中,将请求和响应对象转换成对应HTTP协议的HttpServletRequest HttpServletResponse对象\n调用重载的service方法\n\n\npublic void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException\n重载的service方法,被重写的service方法所调用\n在该方法中,通过请求方式判断,调用具体的do***方法完成请求的处理\n\n\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\nprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\nprotected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\nprotected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\nprotected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\nprotected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\nprotected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException\n对应不同请求方式的处理方法\n除了doOptions和doTrace方法,其他的do*** 方法都在故意响应错误信息\n\n\n\n\n\n5.4 自定义Servlet\n\n\n\n\n\n\n\n\n继承关系图解\n\n自定义Servlet中,必须要对处理请求的方法进行重写\n\n要么重写service方法\n要么重写doGet&#x2F;doPost方法\n\n\n六 ServletConfig和ServletContext6.1  ServletConfig的使用\n\n\n\n\n\n\n\n\nServletConfig是什么\n\n为Servlet提供初始配置参数的一种对象,每个Servlet都有自己独立唯一的ServletConfig对象\n容器会为每个Servlet实例化一个ServletConfig对象,并通过Servlet生命周期的init方法传入给Servlet作为属性\n\n\n\n\n\n\n\n\n\n\n\nServletConfig是一个接口,定义了如下API\njavapackage jakarta.servlet;\nimport java.util.Enumeration;\npublic interface ServletConfig &#123;\n    String getServletName();\n    ServletContext getServletContext();\n    String getInitParameter(String var1);\n    Enumeration&lt;String&gt; getInitParameterNames();\n&#125;\n\n\n方法名\n作用\n\n\n\ngetServletName()\n获取&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;定义的Servlet名称\n\n\ngetServletContext()\n获取ServletContext对象\n\n\ngetInitParameter()\n获取配置Servlet时设置的『初始化参数』，根据名字获取值\n\n\ngetInitParameterNames()\n获取所有初始化参数名组成的Enumeration对象\n\n\n\n\n\n\n\n\n\n\n\nServletConfig怎么用,测试代码如下\n\n定义Servlet\n\njavapublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        ServletConfig servletConfig = this.getServletConfig();\n        // 根据参数名获取单个参数\n        String value = servletConfig.getInitParameter(&quot;param1&quot;);\n        System.out.println(&quot;param1:&quot;+value);\n        // 获取所有参数名\n        Enumeration&lt;String&gt; parameterNames = servletConfig.getInitParameterNames();\n        // 迭代并获取参数名\n        while (parameterNames.hasMoreElements()) &#123;\n            String paramaterName = parameterNames.nextElement();\n            System.out.println(paramaterName+&quot;:&quot;+servletConfig.getInitParameter(paramaterName));\n        &#125;\n    &#125;\n&#125;\n\n\n\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        ServletConfig servletConfig = this.getServletConfig();\n        // 根据参数名获取单个参数\n        String value = servletConfig.getInitParameter(&quot;param1&quot;);\n        System.out.println(&quot;param1:&quot;+value);\n        // 获取所有参数名\n        Enumeration&lt;String&gt; parameterNames = servletConfig.getInitParameterNames();\n        // 迭代并获取参数名\n        while (parameterNames.hasMoreElements()) &#123;\n            String paramaterName = parameterNames.nextElement();\n            System.out.println(paramaterName+&quot;:&quot;+servletConfig.getInitParameter(paramaterName));\n        &#125;\n    &#125;\n&#125;\n配置Servlet\n\nxml  &lt;servlet&gt;\n       &lt;servlet-name&gt;ServletA&lt;/servlet-name&gt;\n       &lt;servlet-class&gt;com.atguigu.servlet.ServletA&lt;/servlet-class&gt;\n       &lt;!--配置ServletA的初始参数--&gt;\n       &lt;init-param&gt;\n           &lt;param-name&gt;param1&lt;/param-name&gt;\n           &lt;param-value&gt;value1&lt;/param-value&gt;\n       &lt;/init-param&gt;\n       &lt;init-param&gt;\n           &lt;param-name&gt;param2&lt;/param-name&gt;\n           &lt;param-value&gt;value2&lt;/param-value&gt;\n       &lt;/init-param&gt;\n   &lt;/servlet&gt;\n\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;ServletB&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.atguigu.servlet.ServletB&lt;/servlet-class&gt;\n        &lt;!--配置ServletB的初始参数--&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;param3&lt;/param-name&gt;\n            &lt;param-value&gt;value3&lt;/param-value&gt;\n        &lt;/init-param&gt;\n        &lt;init-param&gt;\n            &lt;param-name&gt;param4&lt;/param-name&gt;\n            &lt;param-value&gt;value4&lt;/param-value&gt;\n        &lt;/init-param&gt;\n    &lt;/servlet&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;ServletA&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/servletA&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;ServletB&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/servletB&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n请求Servlet测试\n\n部署到tomcat上之后，访问代码即可查看结果\n\n6.2 ServletContext的使用\n\n\n\n\n\n\n\n\nServletContext是什么\n\nServletContext对象有称呼为上下文对象,或者叫应用域对象(后面统一讲解域对象)\n容器会为每个app创建一个独立的唯一的ServletContext对象\nServletContext对象为所有的Servlet所共享\nServletContext可以为所有的Servlet提供初始配置参数\n\n\n\n\n\n\n\n\n\n\n\nServletContext怎么用\n\n配置ServletContext参数\n\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;\n         version=&quot;5.0&quot;&gt;\n\n    &lt;context-param&gt;\n        &lt;param-name&gt;paramA&lt;/param-name&gt;\n        &lt;param-value&gt;valueA&lt;/param-value&gt;\n    &lt;/context-param&gt;\n    &lt;context-param&gt;\n        &lt;param-name&gt;paramB&lt;/param-name&gt;\n        &lt;param-value&gt;valueB&lt;/param-value&gt;\n    &lt;/context-param&gt;\n&lt;/web-app&gt;\n在Servlet中获取ServletContext并获取参数\n\njavapackage com.atguigu.servlet;\n\nimport jakarta.servlet.ServletConfig;\nimport jakarta.servlet.ServletContext;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport java.io.IOException;\nimport java.util.Enumeration;\n\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n       \n        // 从ServletContext中获取为所有的Servlet准备的参数\n        ServletContext servletContext = this.getServletContext();\n        String valueA = servletContext.getInitParameter(&quot;paramA&quot;);\n        System.out.println(&quot;paramA:&quot;+valueA);\n        // 获取所有参数名\n        Enumeration&lt;String&gt; initParameterNames = servletContext.getInitParameterNames();\n        // 迭代并获取参数名\n        while (initParameterNames.hasMoreElements()) &#123;\n            String paramaterName = initParameterNames.nextElement();\n            System.out.println(paramaterName+&quot;:&quot;+servletContext.getInitParameter(paramaterName));\n        &#125;\n    &#125;\n&#125;6.3 ServletContext其他重要API\n\n\n\n\n\n\n\n\n获取资源的真实路径\njavaString realPath = servletContext.getRealPath(&quot;资源在web目录中的路径&quot;);\n例如我们的目标是需要获取项目中某个静态资源的路径，不是工程目录中的路径，而是部署目录中的路径；我们如果直接拷贝其在我们电脑中的完整路径的话其实是有问题的，因为如果该项目以后部署到公司服务器上的话，路径肯定是会发生改变的，所以我们需要使用代码动态获取资源的真实路径.  只要使用了servletContext动态获取资源的真实路径，那么无论项目的部署路径发生什么变化，都会动态获取项目运行时候的实际路径，所以就不会发生由于写死真实路径而导致项目部署位置改变引发的路径错误问题\n\n举例演示\n\n\n\n\n\n\n\n\n\n\n获取项目的上下文路径\njavaString contextPath = servletContext.getContextPath();\n项目的部署名称,也叫项目的上下文路径,在部署进入tomcat时所使用的路径,该路径是可能发生变化的,通过该API动态获取项目真实的上下文路径,可以帮助我们解决一些后端页面渲染技术或者请求转发和响应重定向中的路径问题\n\n举例演示\n\n\n\n\n\n\n\n\n\n\n 域对象的相关API\n\n域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同\nServletContext代表应用,所以ServletContext域也叫作应用域,是webapp中最大的域,可以在本应用内实现数据的共享和传递\nwebapp中的三大域对象,分别是应用域,会话域,请求域\n后续我们会将三大域对象统一进行讲解和演示,三大域对象都具有的API如下\n\n\n\n\nAPI\n功能解释\n\n\n\nvoid setAttribute(String key,Object value);\n向域中存储&#x2F;修改数据\n\n\nObject getAttribute(String key);\n获得域中的数据\n\n\nvoid removeAttribute(String key);\n移除域中的数据\n\n\n举例演示\n在servlet1中向域中存储数据，然后在servlet2中获取数据以便查看。如果先访问servlet2，因为还没向域中存储数据，所以会返回null，如果先访问了servlet1再访问servlet2的话，可以从域中获取数据。\nServlet1代码\n\nServlet2代码\n\n\n七 HttpServletRequest7.1 HttpServletRequest简介\n\n\n\n\n\n\n\n\nHttpServletRequest是什么\n\nHttpServletRequest是一个接口,其父接口是ServletRequest\nHttpServletRequest是Tomcat将请求报文转换封装而来的对象,在Tomcat调用service方法时传入\nHttpServletRequest代表客户端发来的请求,所有请求中的信息都可以通过该对象获得\n\n\n7.2 HttpServletRequest常见API\n\n\n\n\n\n\n\n\nHttpServletRequest怎么用\n\n获取请求行信息相关(方式,请求的url,协议及版本)\n\n\n\n\nAPI\n功能解释\n\n\n\nStringBuffer getRequestURL();\n获取客户端请求的url\n\n\nString getRequestURI();\n获取客户端请求项目中的具体资源\n\n\nint getServerPort();\n获取客户端发送请求时的端口\n\n\nint getLocalPort();\n获取本应用在所在容器的端口\n\n\nint getRemotePort();\n获取客户端程序的端口\n\n\nString getScheme();\n获取请求协议\n\n\nString getProtocol();\n获取请求协议及版本号\n\n\nString getMethod();\n获取请求方式\n\n\nURL和URI的关系\n\n\n\nURI\n统一资源标识符\ninterface URI{}\n资源定位的要求和规范\n动物类\n&#x2F;demo3&#x2F;a.html\n\n\n\nURL\n统一资源定位符\nclass URL implements URI{}\n一个具体的资源路径\n哺乳动物类\nh ttp:&#x2F;&#x2F;ip:port&#x2F;demo3&#x2F;a.html\n\n\n\n获得请求头信息相关\n\n\n\n\nAPI\n功能解释\n\n\n\nString getHeader(String headerName);\n根据头名称获取请求头\n\n\nEnumeration getHeaderNames();\n获取所有的请求头名字\n\n\nString getContentType();\n获取content-type请求头\n\n\n\n获得请求参数相关\n\n\n\n\nAPI\n功能解释\n\n\n\nString getParameter(String parameterName);\n根据请求参数名获取请求单个参数值\n\n\nString[] getParameterValues(String parameterName);\n根据请求参数名获取请求多个参数值数组\n\n\nEnumeration getParameterNames();\n获取所有请求参数名\n\n\nMap&lt;String, String[]&gt; getParameterMap();\n获取所有请求参数的键值对集合\n\n\nBufferedReader getReader() throws IOException;\n获取读取请求体的字符输入流\n\n\nServletInputStream getInputStream() throws IOException;\n获取读取请求体的字节输入流\n\n\nint getContentLength();\n获得请求体长度的字节数\n\n\n\n其他API\n\n\n\n\nAPI\n功能解释\n\n\n\nString getServletPath();\n获取请求的Servlet的映射路径\n\n\nServletContext getServletContext();\n获取ServletContext对象\n\n\nCookie[] getCookies();\n获取请求中的所有cookie\n\n\nHttpSession getSession();\n获取Session对象\n\n\nvoid setCharacterEncoding(String encoding) ;\n设置请求体字符集\n\n\n举例演示\n\n\n\n\n\n\n\n\n\n行相关和头相关的API演示\n\n\n输出结果\n\n\n\n\n\n\n\n\n\n\n获得请求参数相关API\n\n下面展示的API专门用于获取key&#x3D;value形式的参数，无论这些参数是在url后还是在请求体中。\nform表单标签提交GET请求时，参数以键值对形式放在url后，不放在请求体里，GET方式的请求也是可以有请求体。\n\nindex代码部分\n使用get/post方式发请求都能够拿到信息\n\nServlet代码部分\n\n\n输出结果\n\n\n八 HttpServletResponse8.1 HttpServletResponse简介\n\n\n\n\n\n\n\n\nHttpServletResponse是什么\n\nHttpServletResponse是一个接口,其父接口是ServletResponse\nHttpServletResponse是Tomcat预先创建的,在Tomcat调用service方法时传入\nHttpServletResponse代表对客户端的响应,该对象会被转换成响应的报文发送给客户端,通过该对象我们可以设置响应信息\n\n\n8.2 HttpServletResponse的常见API\n\n\n\n\n\n\n\n\nHttpServletRequest怎么用\n\n设置响应行相关\n\n\n\n\nAPI\n功能解释\n\n\n\nvoid setStatus(int  code);\n设置响应状态码\n\n\n\n设置响应头相关\n\n\n\n\nAPI\n功能解释\n\n\n\nvoid setHeader(String headerName, String headerValue);\n设置&#x2F;修改响应头键值对\n\n\nvoid setContentType(String contentType);\n设置content-type响应头及响应字符集(设置MIME类型)\n\n\n\n设置响应体相关\n\n\n\n\nAPI\n功能解释\n\n\n\nPrintWriter getWriter() throws IOException;\n获得向响应体放入信息的字符输出流\n\n\nServletOutputStream getOutputStream() throws IOException;\n获得向响应体放入信息的字节输出流\n\n\nvoid setContentLength(int length);\n设置响应体的字节长度,其实就是在设置content-length响应头\n\n\n\n其他API\n\n\n\n\nAPI\n功能解释\n\n\n\nvoid sendError(int code, String message) throws IOException;\n向客户端响应错误信息的方法,需要指定响应码和响应信息\n\n\nvoid addCookie(Cookie cookie);\n向响应体中增加cookie\n\n\nvoid setCharacterEncoding(String encoding);\n设置响应体字符集\n\n\n\n\n\n\n\n\n\n\n\nMIME类型\n\nMIME类型,可以理解为文档类型,用户表示传递的数据是属于什么类型的文档\n浏览器可以根据MIME类型决定该用什么样的方式解析接收到的响应体数据\n可以这样理解: 前后端交互数据时,告诉对方发给对方的是 html&#x2F;css&#x2F;js&#x2F;图片&#x2F;声音&#x2F;视频&#x2F;… …\ntomcat&#x2F;conf&#x2F;web.xml中配置了常见文件的拓展名和MIMIE类型的对应关系\n常见的MIME类型举例如下\n\n\n\n\n文件拓展名\nMIME类型\n\n\n\n.html\ntext&#x2F;html\n\n\n.css\ntext&#x2F;css\n\n\n.js\napplication&#x2F;javascript\n\n\n.png &#x2F;.jpeg&#x2F;.jpg&#x2F;… …\nimage&#x2F;jpeg\n\n\n.mp3&#x2F;.mpe&#x2F;.mpeg&#x2F; … …\naudio&#x2F;mpeg\n\n\n.mp4\nvideo&#x2F;mp4\n\n\n.m1v&#x2F;.m1v&#x2F;.m2v&#x2F;.mpe&#x2F;… …\nvideo&#x2F;mpeg\n\n\n举例演示\nServlet代码\n\n访问网页响应体内容如下\n\n\n九 请求转发和响应重定向9.1 概述\n\n\n\n\n\n\n\n\n什么是请求转发和响应重定向\n\n请求转发和响应重定向是web应用中间接访问项目资源的两种手段,也是Servlet控制页面跳转的两种手段\n\n请求转发通过HttpServletRequest实现,响应重定向通过HttpServletResponse实现\n\n请求转发生活举例: 张三找李四借钱,李四没有,李四找王五,让王五借给张三\n\n响应重定向生活举例:张三找李四借钱,李四没有,李四让张三去找王五,张三自己再去找王五借钱\n\n\n重点：同样能够实现页面跳转，优先使用响应重定向。\n9.2 请求转发\n\n\n\n\n\n\n\n\n请求转发运行逻辑图\n\n\n\n\n\n\n\n\n\n\n请求转发特点(背诵)\n\n请求转发通过HttpServletRequest对象获取请求转发器实现\n请求转发是服务器内部的行为,对客户端是屏蔽的\n客户端只发送了一次请求,客户端地址栏不变\n服务端只产生了一对请求(request)和响应(response)对象,这一对请求和响应对象会继续传递给下一个资源\n因为全程只有一个HttpServletRequset对象,所以请求参数可以传递,请求域中的数据也可以传递\n请求转发可以转发给其他Servlet动态资源,也可以转发给一些html静态资源以实现页面跳转\n请求转发可以转发给WEB-INF下受保护的资源，该方式也是WEB-INF下的资源的唯一访问方式\n请求转发不能转发到本项目以外的外部资源\n\n\n\n\n\n\n\n\n\n\n请求转发测试代码\n\n\nServletA\n\njava@WebServlet(&quot;/servletA&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //  获取请求转发器\n        //  转发给servlet  ok\n        RequestDispatcher  requestDispatcher = req.getRequestDispatcher(&quot;servletB&quot;);\n        //  转发给一个视图资源 ok\n        //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;welcome.html&quot;);\n        //  转发给WEB-INF下的资源  ok\n        //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/views/view1.html&quot;);\n        //  转发给外部资源   no\n        //RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;http://www.atguigu.com&quot;);\n        //  获取请求参数\n        String username = req.getParameter(&quot;username&quot;);\n        System.out.println(username);\n        //  向请求域中添加数据\n        req.setAttribute(&quot;reqKey&quot;,&quot;requestMessage&quot;);\n        //  做出转发动作\n        requestDispatcher.forward(req,resp);\n    &#125;\n&#125;\nServletB\n\njava@WebServlet(&quot;/servletB&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 获取请求参数\n        String username = req.getParameter(&quot;username&quot;);\n        System.out.println(username);\n        // 获取请求域中的数据\n        String reqMessage = (String)req.getAttribute(&quot;reqKey&quot;);\n        System.out.println(reqMessage);\n        // 做出响应\n        resp.getWriter().write(&quot;servletB response&quot;);        \n     &#125;\n&#125;\n打开浏览器,输入以下url测试\n\nhttphttp://localhost:8080/web03_war_exploded/servletA?username=atguigu9.3 响应重定向\n\n\n\n\n\n\n\n\n响应重定向运行逻辑图\n\n\n\n\n\n\n\n\n\n\n响应重定向特点(背诵)\n\n响应重定向通过HttpServletResponse对象的sendRedirect方法实现\n响应重定向是服务端通过302响应码和路径,告诉客户端自己去找其他资源,是在服务端提示下的,客户端的行为\n客户端至少发送了两次请求,客户端地址栏是要变化的\n服务端产生了多对请求和响应对象,且请求和响应对象不会传递给下一个资源\n因为全程产生了多个HttpServletRequset对象,所以请求参数不可以传递,请求域中的数据也不可以传递\n重定向可以是其他Servlet动态资源,也可以是一些静态资源以实现页面跳转\n重定向不可以到WEB-INF下受保护的资源\n重定向可以到本项目以外的外部资源\n\n\n\n\n\n\n\n\n\n\n响应重定向测试代码\n\n\nServletA\n\njava@WebServlet(&quot;/servletA&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //  获取请求参数\n        String username = req.getParameter(&quot;username&quot;);\n        System.out.println(username);\n        //  向请求域中添加数据\n        req.setAttribute(&quot;reqKey&quot;,&quot;requestMessage&quot;);\n        //  响应重定向\n        // 重定向到servlet动态资源 OK\n        resp.sendRedirect(&quot;servletB&quot;);\n        // 重定向到视图静态资源 OK\n        //resp.sendRedirect(&quot;welcome.html&quot;);\n        // 重定向到WEB-INF下的资源 NO\n        //resp.sendRedirect(&quot;WEB-INF/views/view1&quot;);\n        // 重定向到外部资源\n        //resp.sendRedirect(&quot;http://www.atguigu.com&quot;);\n    &#125;\n&#125;\nServletB\n\njava@WebServlet(&quot;/servletB&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 获取请求参数\n        String username = req.getParameter(&quot;username&quot;);\n        System.out.println(username);\n        // 获取请求域中的数据\n        String reqMessage = (String)req.getAttribute(&quot;reqKey&quot;);\n        System.out.println(reqMessage);\n        // 做出响应\n        resp.getWriter().write(&quot;servletB response&quot;);\n\n    &#125;\n&#125;\n打开浏览器,输入以下url测试\n\nhttphttp://localhost:8080/web03_war_exploded/servletA?username=atguigu访问servlet1时，会重定向到servlet2\n代码部分\n\n\n结果演示\n\n\n十 web乱码和路径问题总结10.1 乱码问题\n\n\n\n\n\n\n\n\n乱码问题产生的根本原因是什么\n\n数据的编码和解码使用的不是同一个字符集\n使用了不支持某个语言文字的字符集\n\n\n\n\n\n\n\n\n\n\n各个字符集的兼容性\n\n\n由上图得知,上述字符集都兼容了ASCII\nASCII中有什么? 英文字母和一些通常使用的符号,所以这些东西无论使用什么字符集都不会乱码\n\n10.1.1 HTML乱码问题\n\n\n\n\n\n\n\n\n设置项目文件的字符集要使用一个支持中文的字符集\n\n查看当前文件的字符集\n\n\n\n查看项目字符集 配置,将Global Encoding 全局字符集,Project Encoding 项目字符集, Properties Files 属性配置文件字符集设置为UTF-8\n\n\n\n\n\n\n\n\n\n\n\n当前视图文件的字符集通过 来告知浏览器通过什么字符集来解析当前文件\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    中文\n&lt;/body&gt;\n&lt;/html&gt;10.1.2 Tomcat控制台乱码\n\n\n\n\n\n\n\n\n在tomcat10.1.7这个版本中,修改 tomcat&#x2F;conf&#x2F;logging.properties中,所有的UTF-8为GBK即可\n\n修改前\n\n\n\n修改后\n\n\n\n重启测试\n\n\n\n\n\n\n\n\n\n\n\n\nsout乱码问题,设置JVM加载.class文件时使用UTF-8字符集\n\n设置虚拟机加载.class文件的字符集和编译时使用的字符集一致\n\n\n10.1.3 请求乱码问题10.1.3.1 GET请求乱码\n\n\n\n\n\n\n\n\nGET请求方式乱码分析\n\nGET方式提交参数的方式是将参数放到URL后面,如果使用的不是UTF-8,那么会对参数进行URL编码处理\nHTML中的  影响了GET方式提交参数的URL编码\ntomcat10.1.7的URI编码默认为 UTF-8\n当GET方式提交的参数URL编码和tomcat10.1.7默认的URI编码不一致时,就会出现乱码\n\n\n\n\n\n\n\n\n\n\n\nGET请求方式乱码演示\n\n浏览器解析的文档的\n\n\n\n\nGET方式提交时,会对数据进行URL编码处理 ,是将GBK 转码为 “百分号码”\n\n\n\n\ntomcat10.1.7 默认使用UTF-8对URI进行解析,造成前后端使用的字符集不一致,出现乱码\n\n\n\n\n\n\n\n\n\n\n\n\nGET请求方式乱码解决\n\n方式1 ：设置GET方式提交的编码和Tomcat10.1.7的URI默认解析编码一致即可 (推荐)\n\n\n\n\n\n\n\n\n方式2 : 设置Tomcat10.1.7的URI解析字符集和GET请求发送时所使用URL转码时的字符集一致即可,修改conf&#x2F;server.xml中 Connecter 添加 URIEncoding&#x3D;”GBK”  (不推荐)\n\n\n\n\n\n10.1.3.2 POST方式请求乱码\n\n\n\n\n\n\n\n\nPOST请求方式乱码分析\n\nPOST请求将参数放在请求体中进行发送\n请求体使用的字符集受到了 的影响\nTomcat10.1.7 默认使用UTF-8字符集对请求体进行解析\n如果请求体的URL转码和Tomcat的请求体解析编码不一致,就容易出现乱码\n\n\n\n\n\n\n\n\n\n\nPOST方式乱码演示\n\nPOST请求请求体受到了 的影响\n\n\n\n\n请求体中,将GBK数据进行 URL编码\n\n\n\n\n后端默认使用UTF-8解析请求体,出现字符集不一致,导致乱码\n\n\n\n\n\n\n\n\n\n\n\n\nPOST请求方式乱码解决\n\n方式1 : 请求时,使用UTF-8字符集提交请求体 (推荐)\n\n\n\n\n\n\n方式2 : 后端在获取参数前,设置解析请求体使用的字符集和请求发送时使用的字符集一致 (不推荐)\n\n\n\n总结GET和POST方式\n\n10.1.3 响应乱码问题\n\n\n\n\n\n\n\n\n响应乱码分析\n\n在Tomcat10.1.7中,向响应体中放入的数据默认使用了工程编码 UTF-8\n浏览器在接收响应信息时,使用了不同的字符集或者是不支持中文的字符集就会出现乱码\n\n\n\n\n\n\n\n\n\n\n响应乱码演示\n\n服务端通过response对象向响应体添加数据\n\n\n\n\n浏览器接收数据解析乱码\n\n\n\n\n\n\n\n\n\n\n\n\n响应乱码解决\n方式1 ：手动设定浏览器对本次响应体解析时使用的字符集(不推荐)\n\nedge和 chrome浏览器没有提供直接的比较方便的入口,不方便\n\n方式2：后端通过设置响应体的字符集和浏览器解析响应体的默认字符集一致(不推荐)\n\n\n\n\n方式3： 通过设置content-type响应头,告诉浏览器以指定的字符集解析响应体(推荐)。\n\n注意：要明确响应体的编码(配合方式2中可以一起设置，保持两者一致)\n\n\n\n\n\n\n\n10.2  路径问题\n\n\n\n\n\n\n\n\n相对路径和绝对路径\n\n相对路径\n\n相对路径的规则是： 以当前资源所在的路径为出发点去寻找目标资源\n相对路径不以 / 开头\n在file协议下,使用的是磁盘路径\n在http协议下,使用的是url路径\n相对路径中可以使用 ./表示当前资源所在路径,可以省略不写\n相对路径中可以使用../表示当前资源所在路径的上一层路径,需要时要手动添加\n\n\n绝对路径\n\n绝对路径的规则是：使用以一个固定的路径做出出发点去寻找目标资源,和当前资源所在的路径没有关系\n绝对路径要以/ 开头\n绝对路径的写法中,不以当前资源的所在路径为出发点,所以不会出现  ./ 和../\n不同的项目和不同的协议下,绝对路径的基础位置可能不同,要通过测试确定\n绝对路径的好处就是：无论当前资源位置在哪,寻找目标资源路径的写法都一致\n\n\n应用场景\n\n前端代码中,href src action 等属性\n请求转发和重定向中的路径\n\n\n\n10.2.1 前端路径问题\n\n\n\n\n\n\n\n\n前端项目结构\n\n10.2.1.1  相对路径情况分析\n\n\n\n\n\n\n\n\n相对路径情况1：web&#x2F;index.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png\n\n访问index.html的url为   :  http://localhost:8080/web03_war_exploded/index.html\n当前资源为                      :  index.html\n当前资源的所在路径为  : http://localhost:8080/web03_war_exploded/\n要获取的目标资源url为 :  http://localhost:8080/web03_war_exploded/static/img/logo.png\nindex.html中定义的了    : &lt;img src=&quot;static/img/logo.png&quot;/&gt;\n寻找方式就是在当前资源所在路径(http://localhost:8080/web03_war_exploded/)后拼接src属性值(static/img/logo.png),正好是目标资源正常获取的url(http://localhost:8080/web03_war_exploded/static/img/logo.png)\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    \n    &lt;img src=&quot;static/img/logo.png&quot;&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n相对路径情况2：web&#x2F;a&#x2F;b&#x2F;c&#x2F;test.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png\n\n访问test.html的url为      :  http://localhost:8080/web03_war_exploded/a/b/c/test.html\n当前资源为                      :  test.html\n当前资源的所在路径为  : http://localhost:8080/web03_war_exploded/a/b/c/\n要获取的目标资源url为 :  http://localhost:8080/web03_war_exploded/static/img/logo.png\ntest.html中定义的了       : &lt;img src=&quot;../../../static/img/logo.png&quot;/&gt;\n寻找方式就是在当前资源所在路径(http://localhost:8080/web03_war_exploded/a/b/c/)后拼接src属性值(../../../static/img/logo.png),其中 ../可以抵消一层路径,正好是目标资源正常获取的url(http://localhost:8080/web03_war_exploded/static/img/logo.png)\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- ../代表上一层路径 --&gt;\n    &lt;img src=&quot;../../../static/img/logo.png&quot;&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n相对路径情况3：web&#x2F;WEB-INF&#x2F;views&#x2F;view1.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png\n\nview1.html在WEB-INF下,需要通过Servlet请求转发获得\n\njava@WebServlet(&quot;/view1Servlet&quot;)\npublic class View1Servlet extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/views/view1.html&quot;);\n        requestDispatcher.forward(req,resp);\n    &#125;\n&#125;\n访问view1.html的url为   :  http://localhost:8080/web03_war_exploded/view1Servlet\n当前资源为                      :  view1Servlet\n当前资源的所在路径为  : http://localhost:8080/web03_war_exploded/\n要获取的目标资源url为 :  http://localhost:8080/web03_war_exploded/static/img/logo.png\nview1.html中定义的了    : &lt;img src=&quot;static/img/logo.png&quot;/&gt;\n寻找方式就是在当前资源所在路径(http://localhost:8080/web03_war_exploded/)后拼接src属性值(static/img/logo.png),正好是目标资源正常获取的url(http://localhost:8080/web03_war_exploded/static/img/logo.png)\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;img src=&quot;static/img/logo.png&quot;&gt;\n&lt;/body&gt;\n&lt;/html&gt;10.2.1.2 绝对路径情况分析\n\n\n\n\n\n\n\n\n绝对路径情况1：web&#x2F;index.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png\n\n访问index.html的url为   :  http://localhost:8080/web03_war_exploded/index.html\n绝对路径的基准路径为  :  http://localhost:8080\n要获取的目标资源url为 : http://localhost:8080/web03_war_exploded/static/img/logo.png\nindex.html中定义的了    : &lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;/&gt;\n寻找方式就是在基准路径(http://localhost:8080)后面拼接src属性值(/web03_war_exploded/static/img/logo.png),得到的正是目标资源访问的正确路径\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- 绝对路径写法 --&gt;\n    &lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n绝对路径情况2：web&#x2F;a&#x2F;b&#x2F;c&#x2F;test.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png\n\n访问test.html的url为   :  http://localhost:8080/web03_war_exploded/a/b/c/test.html\n绝对路径的基准路径为  :  http://localhost:8080\n要获取的目标资源url为 :  http://localhost:8080/web03_war_exploded/static/img/logo.png\ntest.html中定义的了    : &lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;/&gt;\n寻找方式就是在基准路径(http://localhost:8080)后面拼接src属性值(/web03_war_exploded/static/img/logo.png),得到的正是目标资源访问的正确路径\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- 绝对路径写法 --&gt;\n    &lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n绝对路径情况3：web&#x2F;WEB-INF&#x2F;views&#x2F;view1.html中引入web&#x2F;static&#x2F;img&#x2F;logo.png\n\nview1.html在WEB-INF下,需要通过Servlet请求转发获得\n\njava@WebServlet(&quot;/view1Servlet&quot;)\npublic class View1Servlet extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/views/view1.html&quot;);\n        requestDispatcher.forward(req,resp);\n    &#125;\n&#125;\n访问view1.html的url为   :  http://localhost:8080/web03_war_exploded/view1Servlet\n绝对路径的基准路径为  :  http://localhost:8080\n要获取的目标资源url为 :  http://localhost:8080/web03_war_exploded/static/img/logo.png\nview1.html中定义的了    : &lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;/&gt;\n寻找方式就是在基准路径(http://localhost:8080)后面拼接src属性值(/static/img/logo.png),得到的正是目标资源访问的正确路径\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;img src=&quot;/web03_war_exploded/static/img/logo.png&quot;&gt;\n&lt;/body&gt;\n&lt;/html&gt;10.2.1.3 base标签的使用\n\n\n\n\n\n\n\n\nbase标签定义页面相对路径公共前缀\n\nbase 标签定义在head标签中,用于定义相对路径的公共前缀\nbase 标签定义的公共前缀只在相对路径上有效,绝对路径中无效\n如果相对路径开头有 ./ 或者../修饰,则base标签对该路径同样无效\n\n\n\n\n\n\n\n\n\n\nindex.html 和a&#x2F;b&#x2F;c&#x2F;test.html 以及view1Servlet 中的路径处理\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;!--定义相对路径的公共前缀,将相对路径转化成了绝对路径--&gt;\n    &lt;base href=&quot;/web03_war_exploded/&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;img src=&quot;static/img/logo.png&quot;&gt;\n&lt;/body&gt;\n&lt;/html&gt;10.2.1.4 缺省项目上下文路径\n\n\n\n\n\n\n\n\n项目上下文路径变化问题\n\n通过 base标签虽然解决了相对路径转绝对路径问题,但是base中定义的是项目的上下文路径\n项目的上下文路径是可以随意变化的\n一旦项目的上下文路径发生变化,所有base标签中的路径都需要改\n\n\n\n\n\n\n\n\n\n\n解决方案\n\n将项目的上下文路径进行缺省设置,设置为 &#x2F;,所有的绝对路径中就不必填写项目的上下文了,直接就是&#x2F;开头即可\n\n10.2.2 重定向中的路径问题\n\n\n\n\n\n\n\n\n目标 :由&#x2F;x&#x2F;y&#x2F;z&#x2F;servletA重定向到a&#x2F;b&#x2F;c&#x2F;test.html\njava@WebServlet(&quot;/x/y/z/servletA&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        \n    &#125;\n&#125;\n10.2.2.1相对路径写法\n访问ServletA的url为   :  http://localhost:8080/web03_war_exploded/x/y/z/servletA\n当前资源为                      :  servletA\n当前资源的所在路径为  : http://localhost:8080/web03_war_exploded/x/x/z/\n要获取的目标资源url为 :  http://localhost:8080/web03_war_exploded/a/b/c/test.html\nServletA重定向的路径    :  ../../../a/b/c/test/html\n寻找方式就是在当前资源所在路径(http://localhost:8080/web03_war_exploded/x/y/z/)后拼接(../../../a/b/c/test/html),形成(http://localhost:8080/web03_war_exploded/x/y/z/../../../a/b/c/test/html)每个..&#x2F;抵消一层目录,正好是目标资源正常获取的url(http://localhost:8080/web03_war_exploded/a/b/c/test/html)\n\njava@WebServlet(&quot;/x/y/z/servletA&quot;)\npublic class ServletA extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        // 相对路径重定向到test.html\n        resp.sendRedirect(&quot;../../../a/b/c/test.html&quot;);\n    &#125;\n&#125;10.2.2.2绝对路径写法\n访问ServletA的url为   :  http://localhost:8080/web03_war_exploded/x/y/z/servletA\n\n绝对路径的基准路径为  :  http://localhost:8080\n\n要获取的目标资源url为 :  http://localhost:8080/web03_war_exploded/a/b/c/test.html\n\nServletA重定向的路径    : /web03_war_exploded/a/b/c/test.html\n\n寻找方式就是在基准路径(http://localhost:8080)后面拼接(/web03_war_exploded/a/b/c/test.html),得到( http://localhost:8080/web03_war_exploded/a/b/c/test.html)正是目标资源访问的正确路径\n\n绝对路径中需要填写项目上下文路径,但是上下文路径是变换的\n\n可以通过 ServletContext的getContextPath()获取上下文路径\n可以将项目上下文路径定义为 &#x2F; 缺省路径,那么路径中直接以&#x2F;开头即可\n\njava//绝对路径中,要写项目上下文路径\n//resp.sendRedirect(&quot;/web03_war_exploded/a/b/c/test.html&quot;);\n// 通过ServletContext对象动态获取项目上下文路径\n//resp.sendRedirect(getServletContext().getContextPath()+&quot;/a/b/c/test.html&quot;);\n// 缺省项目上下文路径时,直接以/开头即可\nresp.sendRedirect(&quot;/a/b/c/test.html&quot;);\n\n10.2.3 请求转发中的路径问题\n\n\n\n\n\n\n\n\n目标 :由x&#x2F;y&#x2F;servletB请求转发到a&#x2F;b&#x2F;c&#x2F;test.html\njava@WebServlet(&quot;/x/y/servletB&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n\n    &#125;\n&#125;10.2.3.1 相对路径写法\n访问ServletB的url为       :  http://localhost:8080/web03_war_exploded/x/y/servletB\n\n当前资源为                      :  servletB\n\n当前资源的所在路径为  :http://localhost:8080/web03_war_exploded/x/x/\n\n要获取的目标资源url为 :  http://localhost:8080/web03_war_exploded/a/b/c/test.html\n\nServletA请求转发路径    :  ../../a/b/c/test/html\n\n寻找方式就是在当前资源所在路径(http://localhost:8080/web03_war_exploded/x/y/)后拼接(../../a/b/c/test/html),形成(http://localhost:8080/web03_war_exploded/x/y/../../a/b/c/test/html)每个..&#x2F;抵消一层目录,正好是目标资源正常获取的url(http://localhost:8080/web03_war_exploded/a/b/c/test/html)\njava@WebServlet(&quot;/x/y/servletB&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;../../a/b/c/test.html&quot;);\n        requestDispatcher.forward(req,resp);\n    &#125;\n&#125;\n\n\n\n10.2.3.2绝对路径写法\n请求转发只能转发到项目内部的资源,其绝对路径无需添加项目上下文路径\n\n请求转发绝对路径的基准路径相当于http://localhost:8080/web03_war_exploded\n\n在项目上下文路径为缺省值时,也无需改变,直接以&#x2F;开头即可\njava@WebServlet(&quot;/x/y/servletB&quot;)\npublic class ServletB extends HttpServlet &#123;\n    @Override\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/a/b/c/test.html&quot;);\n        requestDispatcher.forward(req,resp);\n    &#125;\n&#125;\n\n10.2.3.3目标资源内相对路径处理\n此时需要注意,请求转发是服务器行为,浏览器不知道,地址栏不变化,相当于我们访问test.html的路径为http://localhost:8080/web03_war_exploded/x/y/servletB\n\n那么此时 test.html资源的所在路径就是http://localhost:8080/web03_war_exploded/x/y/所以test.html中相对路径要基于该路径编写,如果使用绝对路径则不用考虑\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!--\n        当前资源路径是     http://localhost:8080/web03_war_exploded/x/y/servletB\n        当前资源所在路径是  http://localhost:8080/web03_war_exploded/x/y/\n        目标资源路径=所在资源路径+src属性值 \n        http://localhost:8080/web03_war_exploded/x/y/../../static/img/logo.png\n        http://localhost:8080/web03_war_exploded/static/img/logo.png\n        得到目标路径正是目标资源的访问路径\t\n    --&gt;\n&lt;img src=&quot;../../static/img/logo.png&quot;&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n十一 MVC架构模式\n\n\n\n\n\n\n\n\n MVC（Model View Controller）是软件工程中的一种**软件架构模式，它把软件系统分为模型、视图和控制器**三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。\n\nM：Model 模型层,具体功能如下\n\n存放和数据库对象的实体类以及一些用于存储非数据库表完整相关的VO对象\n存放一些对数据进行逻辑运算操作的的一些业务处理代码\n\n\nV：View 视图层,具体功能如下\n\n存放一些视图文件相关的代码 html css js等\n在前后端分离的项目中,后端已经没有视图文件,该层次已经衍化成独立的前端项目\n\n\nC：Controller 控制层,具体功能如下\n\n接收客户端请求,获得请求数据\n将准备好的数据响应给客户端\n\n\n\n\n\n\n\n\n\n\n\n\nMVC模式下,项目中的常见包\n\nM:\n\n实体类包(pojo &#x2F;entity &#x2F;bean) 专门存放和数据库对应的实体类和一些VO对象\n数据库访问包(dao&#x2F;mapper)  专门存放对数据库不同表格CURD方法封装的一些类\n服务包(service)                       专门存放对数据进行业务逻辑运算的一些类\n\n\nC:\n\n控制层包(controller)\n\n\nV:\n\nweb目录下的视图资源 html css js img 等\n前端工程化后,在后端项目中已经不存在了\n\n\n\n非前后端分离的MVC\n\n前后端分离的MVC\n\n实例演示MVC架构模式\n\n","slug":"Javaweb_Servlet","date":"2024-01-18T07:50:00.000Z","categories_index":"Javaweb","tags_index":"Javaweb","author_index":"白"},{"id":"b89f3d80974010c9e57f9b57b62ba2a8","title":"XML_Tomcat10_HTTP笔记","content":"第三章 XML_Tomcat10_HTTP一、XML\n\n\n\n\n\n\n\n\nXML是EXtensible Markup Language的缩写，翻译过来就是可扩展标记语言。所以很明显，XML和HTML一样都是标记语言，也就是说它们的基本语法都是标签。\n\n可扩展 三个字表面上的意思是XML允许自定义格式。但这不代表你可以随便写。\n在XML基本语法规范的基础上，你使用的那些第三方应用程序、框架会通过XML约束的方式强制规定配置文件中可以写什么和怎么写\nXML基本语法这个知识点的定位是：我们不需要从零开始，从头到尾的一行一行编写XML文档，而是在第三方应用程序、框架已提供的配置文件的基础上修改。要改成什么样取决于你的需求，而怎么改取决XML基本语法和具体的XML约束。\n\n1.1 常见配置文件类型\nproperties文件,例如druid连接池就是使用properties文件作为配置文件\nXML文件,例如Tomcat就是使用XML文件作为配置文件\nYAML文件,例如SpringBoot就是使用YAML作为配置文件\njson文件,通常用来做文件传输，也可以用来做前端或者移动端的配置文件\n等等…\n\n1.1.1 properties配置文件示例\npropertiesatguigu.jdbc.url=jdbc:mysql://localhost:3306/atguigu\natguigu.jdbc.driver=com.mysql.cj.jdbc.Driver\natguigu.jdbc.username=root\natguigu.jdbc.password=root语法规范\n\n由键值对组成\n键和值之间的符号是等号\n每一行都必须顶格写，前面不能有空格之类的其他符号\n\n1.1.2 xml配置文件示例\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;students&gt;\n    &lt;student&gt;\n        &lt;name&gt;张三&lt;/name&gt;\n        &lt;age&gt;18&lt;/age&gt;\n    &lt;/student&gt;\n    &lt;student&gt;\n        &lt;name&gt;李四&lt;/name&gt;\n        &lt;age&gt;20&lt;/age&gt;\n    &lt;/student&gt;\n&lt;/students&gt;XML的基本语法\n\nXML的基本语法和HTML的基本语法简直如出一辙。其实这不是偶然的，XML基本语法+HTML约束&#x3D;HTML语法。在逻辑上HTML确实是XML的子集。\n\n\nXML文档声明 这部分基本上就是固定格式，要注意的是文档声明一定要从第一行第一列开始写\n\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n根标签\n&#x20;根标签有且只能有一个。\n\n\n标签关闭\n双标签：开始标签和结束标签必须成对出现。\n单标签：单标签在标签内关闭。\n\n\n标签嵌套\n可以嵌套，但是不能交叉嵌套。\n\n\n注释不能嵌套\n标签名、属性名建议使用小写字母\n属性\n属性必须有值\n属性值必须加引号，单双都行\n\n\n\n\n\n\n\n\n\n\n\n\nXML的约束(稍微了解)\n将来我们主要就是根据XML约束中的规定来编写XML配置文件，而且会在我们编写XML的时候根据约束来提示我们编写, 而XML约束主要包括DTD和Schema两种。\n\nDTD\nSchema\n\nSchema约束要求我们一个XML文档中，所有标签，所有属性都必须在约束中有明确的定义。\n下面我们以web.xml的约束声明为例来做个说明：\nxml&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;\n         version=&quot;4.0&quot;&gt;1.2 DOM4J进行XML解析1.2.1 DOM4J的使用步骤\n导入jar包 dom4j.jar\n创建解析器对象(SAXReader)\n解析xml 获得Document对象\n获取根节点RootElement\n获取根节点下的子节点\n\n1.2.2 DOM4J的API介绍1.创建SAXReader对象\njavaSAXReader saxReader = new SAXReader();&#x20;2. 解析XML获取Document对象: 需要传入要解析的XML文件的字节输入流\njavaDocument document = reader.read(inputStream);&#x20;3. 获取文档的根标签\njavaElement rootElement = documen.getRootElement()&#x20;4. 获取标签的子标签\njava//获取所有子标签\nList&lt;Element&gt; sonElementList = rootElement.elements();\n//获取指定标签名的子标签\nList&lt;Element&gt; sonElementList = rootElement.elements(&quot;标签名&quot;);&#x20;5. 获取标签体内的文本\njavaString text = element.getText();&#x20;6. 获取标签的某个属性的值\njavaString value = element.attributeValue(&quot;属性名&quot;);\n二、Tomcat102.1 WEB服务器\n\n\n\n\n\n\n\n\nWeb服务器通常由硬件和软件共同构成。\n\n硬件：电脑，提供服务供其它客户电脑访问\n软件：电脑上安装的服务器软件，安装后能提供服务给网络中的其他计算机，将本地文件映射成一个虚拟的url地址供网络中的其他人访问。\n\n\n\n\n\n\n\n\n\n\n\n常见的JavaWeb服务器：\n\nTomcat（Apache）：当前应用最广的JavaWeb服务器\nJetty:更轻量级、更灵活的servlet容器\nJBoss（Redhat红帽）：支持JavaEE，应用比较广EJB容器 –&gt; SSH轻量级的框架代替\nGlassFish（Orcale）：Oracle开发JavaWeb服务器，应用不是很广\nResin（Caucho）：支持JavaEE，应用越来越广\nWeblogic（Orcale）：要钱的！支持JavaEE，适合大型项目\nWebsphere（IBM）：要钱的！支持JavaEE，适合大型项目\n\n2.2 Tomcat服务器2.2.1 简介\n\n\n\n\n\n\n\n\n\nTomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。\n2.2.2 安装\n\n\n\n\n\n\n\n\n下载\n\nTomcat官方网站：http://tomcat.apache.org/\n安装版：需要安装，一般不考虑使用。\n解压版: 直接解压缩使用，我们使用的版本。\n\n\n\n\n\n\n\n\n\n\n\n安装\n1、正确安装JDK并配置JAVA_HOME(以JDK17为例 https://injdk.cn中可以下载各种版本的JDK)\n\n2、解压tomcat到非中文无空格目录\n\n3、点击bin&#x2F;startup.bat启动\n\n\n4、打开浏览器输入 http://localhost:8080访问测试\n\n5、直接关闭窗口或者运行 bin&#x2F;shutdown.bat关闭tomcat\n\n6、处理dos窗口日志中文乱码问题: 修改conf&#x2F;logging.properties,将所有的UTF-8修改为GBK\n\n\n修改前\n\n\n\n修改后\n\n\n\n重启测试\n\n\n2.3 Tomcat目录及测试\n\n\n\n\n\n\n\n\nC:\\Program4java\\apache-tomcat-10.1.7 这个目录下直接包含Tomcat的bin目录，conf目录等，我们称之为Tomcat的安装目录或根目录。\nbin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat10.exe、tomcat10w.exe，前者是在控制台下启动Tomcat，后者是弹出GUI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要先配置JAVA_HOME环境变量才能启动，shutdawn.bat用来停止Tomcat；\nconf：这是一个非常非常重要的目录，这个目录下有四个最为重要的文件：\n​\t1、server.xml：配置整个服务器信息。例如修改端口号。默认HTTP请求的端口号是：8080\n​\t2、tomcat-users.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了；\nhtml&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot;\n              xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n              xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;\n              version=&quot;1.0&quot;&gt;\t\n    &lt;role rolename=&quot;admin-gui&quot;/&gt;\n    &lt;role rolename=&quot;admin-script&quot;/&gt;\n    &lt;role rolename=&quot;manager-gui&quot;/&gt;\n    &lt;role rolename=&quot;manager-script&quot;/&gt;\n    &lt;role rolename=&quot;manager-jmx&quot;/&gt;\n    &lt;role rolename=&quot;manager-status&quot;/&gt;\n    &lt;user \tusername=&quot;admin&quot; \n            password=&quot;admin&quot; \n            roles=&quot;admin-gui,admin-script,manager-gui,manager-script,manager-jmx,manager-status&quot;\n    /&gt;\n&lt;/tomcat-users&gt;​\t3、web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text&#x2F;html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME就是用来说明文档的内容是什么类型的！\ncontext.xml：对所有应用的统一配置，通常我们不会去配置它。\nlib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的jar包了，所以建议只把Tomcat需要的jar包放到这个目录下；\nlogs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中。\ntemp：存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！\nwebapps：存放web项目的目录，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中访问：http://127.0.0.1:8080，没有给出项目目录时，对应的就是ROOT项目.http://localhost:8080/examples，进入示例项目。其中examples&quot;就是项目名，即文件夹的名字。\nwork：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。\nLICENSE：许可证。\nNOTICE：说明文件。\n2.4 WEB项目的标准结构\n\n\n\n\n\n\n\n\n一个标准的可以用于发布的WEB项目标准结构如下\n\n\napp ：本应用根目录\nstatic ：非必要目录,约定俗成的名字,一般在此处放静态资源 ( css  js  img)\nWEB-INF： 必要目录,必须叫WEB-INF,受保护的资源目录,浏览器通过url不可以直接访问的目录\nclasses ：必要目录,src下源代码,配置文件,编译后会在该目录下,web项目中如果没有源码,则该目录不会出现\nlib ：必要目录,项目依赖的jar编译后会出现在该目录下,web项目要是没有依赖任何jar,则该目录不会出现\nweb.xml：必要文件,web项目的基本配置文件. 较新的版本中可以没有该文件,但是学习过程中还是需要该文件\n\n\nindex.html：非必要文件,index.html&#x2F;index.htm&#x2F;index.jsp为默认的欢迎页\n\n\n\n\n\n\n\n\n\n\n\n\nurl的组成部分和项目中资源的对应关系\n\n2.5 WEB项目部署的方式\n\n\n\n\n\n\n\n\n方式1   直接将编译好的项目放在webapps目录下  (已经演示)\n\n\n\n\n\n\n\n\n\n方式2   将编译好的项目打成war包放在webapps目录下,tomcat启动后会自动解压war包(其实和第一种一样)\n\n\n\n\n\n\n\n\n\n方式3   可以将项目放在非webapps的其他目录下,在tomcat中通过配置文件指向app的实际磁盘路径\n\n在磁盘的自定义目录上准备一个app\n\n\n\n在tomcat的conf下创建Catalina&#x2F;localhost目录,并在该目录下准备一个app.xml文件\n\nxml&lt;!-- \n    path: 项目的访问路径,也是项目的上下文路径,就是在浏览器中,输入的项目名称\n    docBase: 项目在磁盘中的实际路径\n --&gt;\n&lt;Context path=&quot;/app&quot; docBase=&quot;D:\\mywebapps\\app&quot; /&gt;\n启动tomcat访问测试即可\n\n2.6 IDEA中开发并部署运行WEB项目2.6.1 IDEA关联本地Tomcat\n\n\n\n\n\n\n\n\n可以在创建项目前设置本地tomcat,也可以在打开某个项目的状态下找到settings\n\n\n\n\n\n\n\n\n\n\n找到 Build,Execution,Eeployment下的Application Servers ,找到+号\n\n\n\n\n\n\n\n\n\n\n选择Tomcat Server\n\n\n\n\n\n\n\n\n\n\n选择tomcat的安装目录\n\n\n\n\n\n\n\n\n\n\n点击ok\n\n\n\n\n\n\n\n\n\n\n关联完毕\n\n2.6.2 IDEA创建web工程\n\n\n\n\n\n\n\n\n推荐先创建一个空项目,这样可以在一个空项目下同时存在多个modules,不用后续来回切换之前的项目,当然也可以忽略此步直接创建web项目\n\n\n\n\n\n\n\n\n\n\n\n检查项目的SDK,语法版本,以及项目编译后的输出目录\n\n\n\n\n\n\n\n\n\n\n\n先创建一个普通的JAVA项目\n\n\n\n\n\n\n\n\n\n\n检查各项信息是否填写有误\n\n\n\n\n\n\n\n\n\n\n创建完毕后,为项目添加Tomcat依赖\n\n\n\n\n\n\n\n\n\n\n\n\n选择modules,添加  framework support\n\n\n\n\n\n\n\n\n\n\n选择Web Application 注意Version,勾选  Create web.xml\n\n\n\n\n\n\n\n\n\n\n删除index.jsp ,替换为 index.html\n\n\n\n\n\n\n\n\n\n\n\n处理配置文件\n\n在工程下创建resources目录,专门用于存放配置文件(都放在src下也行,单独存放可以尽量避免文件集中存放造成的混乱)\n标记目录为资源目录,不标记的话则该目录不参与编译\n\n\n\n标记完成后,显示效果如下\n\n\n\n\n\n\n\n\n\n\n\n处理依赖jar包问题\n\n在WEB-INF下创建lib目录\n必须在WEB-INF下,且目录名必须叫lib!!!\n复制jar文件进入lib目录\n\n\n\n将lib目录添加为当前项目的依赖,后续可以用maven统一解决\n\n\n\n\n环境级别推荐选择module 级别,降低对其他项目的影响,name可以空着不写\n\n\n\n查看当前项目有那些环境依赖\n\n\n\n\n在此位置,可以通过-号解除依赖\n\n\n2.6.3 IDEA部署-运行web项目\n\n\n\n\n\n\n\n\n检查idea是否识别modules为web项目并存在将项目构建成发布结构的配置\n\n就是检查工程目录下,web目录有没有特殊的识别标记\n\n\n\n以及artifacts下,有没有对应 _war_exploded,如果没有,就点击+号添加\n\n\n\n\n\n\n\n\n\n\n\n点击向下箭头,出现 Edit Configurations选项\n\n\n\n\n\n\n\n\n\n\n出现运行配置界面\n\n\n\n\n\n\n\n\n\n\n点击+号,添加本地tomcat服务器\n\n\n\n\n\n\n\n\n\n\n因为IDEA 只关联了一个Tomcat,红色部分就只有一个Tomcat可选\n\n\n\n\n\n\n\n\n\n\n选择Deployment,通过+添加要部署到Tomcat中的artifact\n\n\n\n\n\n\n\n\n\n\napplicationContext中是默认的项目上下文路径,也就是url中需要输入的路径,这里可以自己定义,可以和工程名称不一样,也可以不写,但是要保留&#x2F;,我们这里暂时就用默认的\n\n\n\n\n\n\n\n\n\n\n点击apply 应用后,回到Server部分. After Launch是配置启动成功后,是否默认自动打开浏览器并输入URL中的地址,HTTP port是Http连接器目前占用的端口号\n\n\n\n\n\n\n\n\n\n\n点击OK后,启动项目,访问测试\n\n绿色箭头是正常运行模式\n“小虫子”是debug运行模式\n\n\n\n点击后,查看日志状态是否有异常\n\n\n\n浏览器自动打开并自动访问了index.html欢迎页\n\n\n\n\n\n\n\n\n\n\n\n工程结构和可以发布的项目结构之间的目录对应关系\n\n\n\n\n\n\n\n\n\n\nIDEA部署并运行项目的原理\n\nidea并没有直接进将编译好的项目放入tomcat的webapps中\nidea根据关联的tomcat,创建了一个tomcat副本,将项目部署到了这个副本中\nidea的tomcat副本在C:\\用户\\当前用户\\AppData\\Local\\JetBrains\\IntelliJIdea2022.2\\tomcat\\中\nidea的tomcat副本并不是一个完整的tomcat,副本里只是准备了和当前项目相关的配置文件而已\nidea启动tomcat时,是让本地tomcat程序按照tomcat副本里的配置文件运行\nidea的tomcat副本部署项目的模式是通过conf&#x2F;Catalina&#x2F;localhost&#x2F;*.xml配置文件的形式实现项目部署的\n\n\n\n2.7 对Tomcat补充使用Tomcat服务器打开项目后，所对应的文件如下\n\n部署到tomcat&#x2F;webapps中的标准app目录结构如下\n\n在IDEA中配置tomcat项目视图\n\n在IDEA开发工程前的准备步骤\n\nIDEA中构建后展示如下，分为工程和可以发布的APP\n\n\n三 HTTP协议3.1 HTTP简介\n\n\n\n\n\n\n\n\nHTTP 超文本传输协议 (HTTP-Hyper Text transfer protocol)，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过十几年的使用与发展，得到不断地完善和扩展。它是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。客户端与服务端通信时传输的内容我们称之为报文。HTTP协议就是规定报文的格式。HTTP就是一个通信规则，这个规则规定了客户端发送给服务器的报文格式，也规定了服务器发送给客户端的报文格式。实际我们要学习的就是这两种报文。客户端发送给服务器的称为”请求报文“，**服务器发送给客户端的称为”响应报文”**。\n\n3.1.1 发展历程\n\n\n\n\n\n\n\n\nHTTP&#x2F;0.9 \n\n蒂姆伯纳斯李是一位英国计算机科学家，也是万维网的发明者。他在 1989 年创建了单行 HTTP 协议。它只是返回一个网页。这个协议在 1991 年被命名为 HTTP&#x2F;0.9。\n\n\n\n\n\n\n\n\n\n\n HTTP&#x2F;1.0\n\n1996 年，HTTP&#x2F;1.0 发布。该规范是显著扩大，并且支持三种请求方法：GET，Head，和POST。 \nHTTP&#x2F;1.0 相对于 HTTP&#x2F;0.9 的改进如下：\n每个请求都附加了 HTTP 版本。\n在响应开始时发送状态代码。\n请求和响应都包含 HTTP 报文头。\n内容类型能够传输 HTML 文件以外的文档。\n\n\n但是，HTTP&#x2F;1.0 不是官方标准。\n\n\n\n\n\n\n\n\n\n\nHTTP&#x2F;1.1\n\nHTTP 的第一个标准化版本 HTTP&#x2F;1.1 ( RFC 2068 ) 于 1997 年初发布，支持七种请求方法：OPTIONS，GET，HEAD，POST，PUT，DELETE，和TRACE 。\n\nHTTP&#x2F;1.1 是 HTTP 1.0 的增强：\n\n虚拟主机允许从单个 IP 地址提供多个域。\n\n持久连接和流水线连接允许 Web 浏览器通过单个持久连接发送多个请求。\n\n缓存支持节省了带宽并使响应速度更快。\n\n\n\nHTTP&#x2F;1.1 在接下来的 15 年左右将非常稳定。 \n\n在此期间，出现了 HTTPS（安全超文本传输协议）。它是使用 SSL&#x2F;TLS 进行安全加密通信的 HTTP 的安全版本。\n\n\n\n\n\n\n\n\n\n\n\nHTTP&#x2F;2\n\n由IETF在2015年发布。HTTP&#x2F;2旨在提高Web性能，减少延迟，增加安全性，使Web应用更加快速、高效和可靠。\n\n\n多路复用：HTTP&#x2F;2 允许同时发送多个请求和响应，而不是像 HTTP&#x2F;1.1 一样只能一个一个地处理。这样可以减少延迟，提高效率，提高网络吞吐量。\n二进制传输：HTTP&#x2F;2 使用二进制协议，与 HTTP&#x2F;1.1 使用的文本协议不同。二进制协议可以更快地解析，更有效地传输数据，减少了传输过程中的开销和延迟。\n头部压缩：HTTP&#x2F;2 使用 HPACK 算法对 HTTP 头部进行压缩，减少了头部传输的数据量，从而减少了网络延迟。\n服务器推送：HTTP&#x2F;2 支持服务器推送，允许服务器在客户端请求之前推送资源，以提高性能。\n改进的安全性：HTTP&#x2F;2 默认使用 TLS（Transport Layer Security）加密传输数据，提高了安全性。\n兼容 HTTP&#x2F;1.1：HTTP&#x2F;2 可以与 HTTP&#x2F;1.1 共存，服务器可以同时支持 HTTP&#x2F;1.1 和 HTTP&#x2F;2。如果客户端不支持 HTTP&#x2F;2，服务器可以回退到 HTTP&#x2F;1.1。\n\n\n\n\n\n\n\n\n\n\nHTTP&#x2F;3\n\n于 2021 年 5 月 27 日发布 , HTTP&#x2F;3 是一种新的、快速、可靠且安全的协议，适用于所有形式的设备。 HTTP&#x2F;3 没有使用 TCP，而是使用谷歌在 2012 年开发的新协议 QUIC 。\n\nHTTP&#x2F;3 是继 HTTP&#x2F;1.1 和 HTTP&#x2F;2之后的第三次重大修订。 \n\nHTTP&#x2F;3 带来了革命性的变化，以提高 Web 性能和安全性。设置 HTTP&#x2F;3 网站需要服务器和浏览器支持。\n\n目前，谷歌云、Cloudflare和Fastly支持 HTTP&#x2F;3。Chrome、Firefox、Edge、Opera 和一些移动浏览器支持 HTTP&#x2F;3。\n\n\n3.1.2 HTTP协议的会话方式\n\n\n\n\n\n\n\n\n浏览器与服务器之间的通信过程要经历四个步骤\n\n\n浏览器与WEB服务器的连接过程是短暂的，每次连接只处理一个请求和响应。对每一个页面的访问，浏览器与WEB服务器都要建立一次单独的连接。\n浏览器到WEB服务器之间的所有通讯都是完全独立分开的请求和响应对。\n\n3.1.3 HTTP1.0和HTTP1.1的区别\n\n\n\n\n\n\n\n\n在HTTP1.0版本中，浏览器请求一个带有图片的网页，会由于下载图片而与服务器之间开启一个新的连接；但在HTTP1.1版本中，允许浏览器在拿到当前请求对应的全部资源后再断开连接，提高了效率。\n\n3.1.4 在浏览器中通过F12工具抓取请求响应报文包\n\n\n\n\n\n\n\n\n几乎所有的PC端浏览器都支持了F12开发者工具,只不过不同的浏览器工具显示的窗口有差异\n\n3.2 请求和响应报文\n3.2.1 报文的格式\n\n\n\n\n\n\n\n\n主体上分为报文首部和报文主体,中间空行隔开\n\n\n\n\n\n\n\n\n\n\n报文部首可以继续细分为  “行” 和 “头”\n\n3.2.2 请求报文\n\n\n\n\n\n\n\n\n客户端发给服务端的报文\n\n请求报文格式\n请求首行（请求行）；    GET&#x2F;POST   资源路径?参数   HTTP&#x2F;1.1\n请求头信息（请求头）；\n空行；\n请求体；POST请求才有请求体\n\n\n\n\n\n\n\n\n\n\n\n\n浏览器 f12 网络下查看请求数据包\n\n\n\n\n\n\n\n\n\n\nform表单发送GET请求特点\n\n由于请求参数在请求首行中已经携带了，所以没有请求体，也没有请求空行\n请求参数拼接在url地址中，地址栏可见[url?name1&#x3D;value1&amp;name2&#x3D;value2]，不安全\n由于参数在地址栏中携带，所以由大小限制[地址栏数据大小一般限制为4k]，只能携带纯文本\nget请求参数只能上传文本数据\n没有请求体。所以封装和解析都快，效率高， 浏览器默认提交的请求都是get请求比如：地址栏输入回车,超链接,表单默认的提交方式\n\n\n\n\n\n\n\n\n\n\n查看GET请求行,请求头,请求体\n\n请求行组成部分\n请求方式  GET\n访问服务器的资源路径?参数1&#x3D;值1&amp;参数2&#x3D;值2 … …\n协议及版本 HTTP&#x2F;1.1\n\n\n\nhttpGET /05_web_tomcat/login_success.html?username=admin&amp;password=123213 HTTP/1.1\n请求头\n\nhttp-主机虚拟地址\nHost: localhost:8080   \n-长连接\nConnection: keep-alive \n-请求协议的自动升级[http的请求，服务器却是https的，浏览器自动会将请求协议升级为https的]\nUpgrade-Insecure-Requests: 1  \n- 用户系统信息\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Safari/537.36\n- 浏览器支持的文件类型\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\n- 当前页面的上一个页面的路径[当前页面通过哪个页面跳转过来的]：   可以通过此路径跳转回上一个页面， 广告计费，防止盗链\nReferer: http://localhost:8080/05_web_tomcat/login.html\n- 浏览器支持的压缩格式\nAccept-Encoding: gzip, deflate, br\n- 浏览器支持的语言\nAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\n请求空行\n\n请求体\n\nGET请求数据不放在请求体\n\n\n\n\n\n\n\n\n\n\n\n\nform表单发送post请求特点\n\nPOST请求有请求体，而GET请求没有请求体。\n\npost请求数据在请求体中携带，请求体数据大小没有限制，可以用来上传所有内容[文件、文本]\n\n只能使用post请求上传文件\n\npost请求报文多了和请求体相关的配置[请求头]\n\n地址栏参数不可见，相对安全\n\npost效率比get低\n\n\n\nPOST请求要求将form标签的method的属性设置为post\n\n\n\n\n\n\n\n\n\n\n\n查看post的请求行 请求头 请求体\n\n请求行组成部分\n请求方式 POST\n访问服务器的资源路径?参数1&#x3D;值1&amp;参数2&#x3D;值2 … …\n协议及版本 HTTP&#x2F;1.1\n\n\n\nhttpPOST /05_web_tomcat/login_success.html HTTP/1.1\n请求头\n\nhttpHost: localhost:8080\nConnection: keep-alive\nContent-Length: 31     -请求体内容的长度\nCache-Control: max-age=0  -无缓存\nOrigin: http://localhost:8080\nUpgrade-Insecure-Requests: 1  -协议的自动升级\nContent-Type: application/x-www-form-urlencoded   -请求体内容类型[服务器根据类型解析请求体参数]\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Safari/537.36\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nReferer: http://localhost:8080/05_web_tomcat/login.html\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\nCookie:JSESSIONID-\n请求空行\n\n请求体:浏览器提交给服务器的数据\n\n\nhttpusername=admin&amp;password=12321313.2.3 响应报文\n\n\n\n\n\n\n\n\n响应报文格式\n\n响应首行（响应行）； 协议&#x2F;版本  状态码    状态码描述\n响应头信息（响应头）；\n空行；\n响应体；\n\n\n\n\n响应行组成部分\n协议及版本 HTTP&#x2F;1.1\n响应状态码 200\n状态描述   OK  (缺省)\n\n\n\nhttpHTTP/1.1 200 OK\n说明：响应协议为HTTP1.1，响应状态码为200，表示请求成功； \n响应头\n\nhttpServer: Apache-Coyote/1.1   服务器的版本信息\nAccept-Ranges: bytes\nETag: W/&quot;157-1534126125811&quot;\nLast-Modified: Mon, 13 Aug 2018 02:08:45 GMT\nContent-Type: text/html    响应体数据的类型[浏览器根据类型解析响应体数据]\nContent-Length: 157   响应体内容的字节数\nDate: Mon, 13 Aug 2018 02:47:57 GMT  响应的时间，这可能会有8小时的时区差\n响应体\n\nhtml&lt;!--需要浏览器解析使用的内容[如果响应的是html页面，最终响应体内容会被浏览器显示到页面中]--&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Insert title here&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    恭喜你，登录成功了...\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n响应状态码:响应码对浏览器来说很重要，它告诉浏览器响应的结果。比较有代表性的响应码如下：\n\n200： 请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中；\n302： 重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location指定新请求的URL地址；\n304： 使用了本地缓存\n404： 请求的资源没有找到，说明客户端错误的请求了不存在的资源；\n405： 请求的方式不允许\n500： 请求资源找到了，但服务器内部出现了错误；\n\n\n\n\n\n\n\n\n\n\n更多的响应状态码\n\n\n\n状态码\n状态码英文描述\n中文含义\n\n\n\n1**\n\n\n\n\n100\nContinue\n继续。客户端应继续其请求\n\n\n101\nSwitching Protocols\n切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议\n\n\n2**\n\n\n\n\n200\nOK\n请求成功。一般用于GET与POST请求\n\n\n201\nCreated\n已创建。成功请求并创建了新的资源\n\n\n202\nAccepted\n已接受。已经接受请求，但未处理完成\n\n\n203\nNon-Authoritative Information\n非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本\n\n\n204\nNo Content\n无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档\n\n\n205\nReset Content\n重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域\n\n\n206\nPartial Content\n部分内容。服务器成功处理了部分GET请求\n\n\n3**\n\n\n\n\n300\nMultiple Choices\n多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择\n\n\n301\nMoved Permanently\n永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替\n\n\n302\nFound\n临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI\n\n\n303\nSee Other\n查看其它地址。与301类似。使用GET和POST请求查看\n\n\n304\nNot Modified\n未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n\n\n305\nUse Proxy\n使用代理。所请求的资源必须通过代理访问\n\n\n306\nUnused\n已经被废弃的HTTP状态码\n\n\n307\nTemporary Redirect\n临时重定向。与302类似。使用GET请求重定向\n\n\n4**\n\n\n\n\n400\nBad Request\n客户端请求的语法错误，服务器无法理解\n\n\n401\nUnauthorized\n请求要求用户的身份认证\n\n\n402\nPayment Required\n保留，将来使用\n\n\n403\nForbidden\n服务器理解请求客户端的请求，但是拒绝执行此请求\n\n\n404\nNot Found\n服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面\n\n\n405\nMethod Not Allowed\n客户端请求中的方法被禁止\n\n\n406\nNot Acceptable\n服务器无法根据客户端请求的内容特性完成请求\n\n\n407\nProxy Authentication Required\n请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权\n\n\n408\nRequest Time-out\n服务器等待客户端发送的请求时间过长，超时\n\n\n409\nConflict\n服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突\n\n\n410\nGone\n客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置\n\n\n411\nLength Required\n服务器无法处理客户端发送的不带Content-Length的请求信息\n\n\n412\nPrecondition Failed\n客户端请求信息的先决条件错误\n\n\n413\nRequest Entity Too Large\n由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息\n\n\n414\nRequest-URI Too Large\n请求的URI过长（URI通常为网址），服务器无法处理\n\n\n415\nUnsupported Media Type\n服务器无法处理请求附带的媒体格式\n\n\n416\nRequested range not satisfiable\n客户端请求的范围无效\n\n\n417\nExpectation Failed\n服务器无法满足Expect的请求头信息\n\n\n5**\n\n\n\n\n500\nInternal Server Error\n服务器内部错误，无法完成请求\n\n\n501\nNot Implemented\n服务器不支持请求的功能，无法完成请求\n\n\n502\nBad Gateway\n作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应\n\n\n503\nService Unavailable\n由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中\n\n\n504\nGateway Time-out\n充当网关或代理的服务器，未及时从远端服务器获取请求\n\n\n505\nHTTP Version not supported\n服务器不支持请求的HTTP协议的版本，无法完成处理\n\n\n","slug":"Javaweb_XML_Tomcat10_HTTP","date":"2023-12-14T09:24:00.000Z","categories_index":"Javaweb","tags_index":"Javaweb","author_index":"白"},{"id":"c6f5b318c219a3ccc41a24b6ac6ea297","title":"JavaScript笔记","content":"第二章 JavaScript笔记一、JS简介1.1 JS特点\n脚本语言\nJavaScript是一种解释型的脚本语言。不同于C、C++、Java等语言先编译后执行,\tJavaScript不会产生编译出来的字节码文件，而是在程序的运行过程中对源文件逐行进行解释。\n\n\n基于对象\nJavaScript能够实现封装，可以模拟继承，不支持多态，所以它不是一门面向对象的编程语言。\n\n\n弱类型\nJavaScript中也有明确的数据类型，但是声明一个变量后它可以接收任何类型的数据，并且会在程序执行过程中根据上下文自动转换类型。\n\n\n事件驱动\nJavaScript是一种采用事件驱动的脚本语言，它不需要经过Web服务器就可以对用户的输入做出响应。\n\n\n跨平台性\nJavaScript脚本语言不依赖于操作系统，仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用，前提是机器上的浏览器支持JavaScript脚本语言。目前JavaScript已被大多数的浏览器所支持。\n\n\n\n1.2 JS组成部分\nBOM编程\n\n\n\n\n\n\n\n\n\n\nBOM是Browser Object Model的简写，即浏览器对象模型。\n\nBOM有一系列对象组成，是访问、控制、修改浏览器的属性和方法\n\nBOM没有统一的标准(每种客户端都可以自定标准)。\n\nBOM编程是将浏览器窗口的各个组成部分抽象成各个对象,通过各个对象的API操作组件行为的一种编程\n\nBOM编程的对象结构如下\n\nwindow 顶级对象,代表整个浏览器窗口\nlocation对象        window对象的属性之一,代表浏览器的地址栏\nhistory对象          window对象的属性之一,代表浏览器的访问历史\nscreen对象           window对象的属性之一,代表屏幕\nnavigator对象      window对象的属性之一,代表浏览器软件本身\ndocument对象     window对象的属性之一,代表浏览器窗口目前解析的html文档\n\n\n\n\n\n\nDOM编程\n\n\n\n\n\n\n\n\n\n\n简单来说:DOM编程就是使用document对象的API完成对网页HTML文档进行动态修改,以实现网页数据和样式动态变化效果的编程。\ndocument对象代表整个html文档，可用来访问页面中的所有元素，是最复杂的一个dom对象，可以说是学习好dom编程的关键所在。\n根据HTML代码结构特点,document对象本身是一种树形结构的文档对象。\n\n\n\n上面的代码生成的树如下\n\n\n\nDOM编程其实就是用window对象的document属性的相关API完成对页面元素的控制的编程\n\n\n1.3 JS的引入方式方式一：内嵌式\t&#x3D;》\t在head中通过一对script标签定义脚本代码\n\n在页面中,通过一对script标签引入JS代码\nscript代码放置位置具备一定的随意性,一般放在head标签中居多\n\n方式二：引入外部脚本文件\t&#x3D;》\t在head中通过一对script标签引入外部JS文件\n\n内部脚本仅能在当前页面上使用,代码复用度不高\n可以将脚本放在独立的JS文件中,通过script标签引入外部脚本文件\n一对script标签要么用于定义内部脚本,要么用于引入外部js文件,不能混用！\n一个html文档中,可以有多个script标签\n\n演示两种方式\n方式一：内嵌式\n\n代码\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n        &lt;title&gt;小标题&lt;/title&gt;\n        &lt;style&gt;\n            /* 通过选择器确定样式的作用范围 */\n            .btn1 &#123;\n                display: block;\n                width: 150px; \n                height: 40px; \n                background-color: rgb(245, 241, 129); \n                color: rgb(238, 31, 31);\n                border: 3px solid rgb(238, 23, 66);\n                font-size: 22px;\n                font-family: &#39;隶书&#39;;\n                line-height: 30px;\n                border-radius: 5px;\n            &#125;\n        &lt;/style&gt;\n        &lt;script&gt;\n            function suprise()&#123;\n                alert(&quot;Hello,我是惊喜&quot;)\n            &#125;\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;button class=&quot;btn1&quot; onclick=&quot;suprise()&quot;&gt;点我有惊喜&lt;/button&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n效果\n\n\n方式二：引入外部脚本文件\n\n抽取脚本代码到独立的js文件中\n\n\n\n在html文件中,通过script标签引入外部脚本文件\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n        &lt;title&gt;小标题&lt;/title&gt;\n        &lt;style&gt;\n            /* 通过选择器确定样式的作用范围 */\n            .btn1 &#123;\n                display: block;\n                width: 150px; \n                height: 40px; \n                background-color: rgb(245, 241, 129); \n                color: rgb(238, 31, 31);\n                border: 3px solid rgb(238, 23, 66);\n                font-size: 22px;\n                font-family: &#39;隶书&#39;;\n                line-height: 30px;\n                border-radius: 5px;\n            &#125;\n        &lt;/style&gt;\n        &lt;script src=&quot;js/button.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        &lt;button class=&quot;btn1&quot; onclick=&quot;suprise()&quot;&gt;点我有惊喜&lt;/button&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n二、JS的数据类型和运算符2.1 JS的数据类型JS是弱类型的，不是没有类型，是变量在声明时不指定类型，赋值时才确定类型，JS中的变量的声明，统统使用var。\ntxtJava: int i = 10\t\t\t\tJS:\tvar i = 10\n     String str = &quot;asdf&quot;\t\t\tvar str = &quot;asdf&quot;数值类型-number：数值类型统一为 number,不区分整数和浮点数。\n字符串类型-string：字符串类型为 string 和JAVA中的String相似,JS中不严格区分单双引号,都可以用于表示字符串\n布尔类型-boolean：布尔类型为boolean 和Java中的boolean相似,但是在JS的if语句中,非空字符串会被转换为’真’,非零数字也会被认为是’真’\n引用数据类型-Object：引用数据类型对象是Object类型, 各种对象和数组在JS中都是Object类型\nfunction类型-function：JS中的各种函数属于function数据类型\n命名未赋值-undefined：js为弱类型语言,统一使用 var声明对象和变量,在赋值时才确定真正的数据类型,变量如果只声明没有赋值的话,数据类型为undefined\n赋予NULL值-Object：在JS中,如果给一个变量赋值为null,其数据类型是Object, 可以通过typeof关键字判断数据类型\n2.2 JS的变量JS中的变量具有如下特征\n\n\n\n\n\n\n\n\n\n\n1、弱类型变量,可以统一声明成var\n2、var声明的变量可以再次声明\n3、变量可以使用不同的数据类型多次赋值\n4、JS的语句可以以; 结尾,也可以不用;结尾\n5、变量标识符严格区分大小写\n6、标识符的命名规则参照JAVA\n7、如果使用了 一个没有声明的变量,那么运行时会报uncaught ReferenceError: *** is not defined   at index.html:行号:列号\n8、如果一个变量只声明,没赋值,那么值是undefined\n\n2.3 JS的运算符\n算数运算符  + - * /  %\n其中需要注意的是 / 和 % \n/在除0时,结果是Infinity ,而不是报错\n%在模0时,结果是NaN,意思为 not a number ,而不是报错\n\n\n复合算数运算符 ++ --  += -= *= /= %=\n符合算数运算符基本和JAVA一致,同样需要注意 /=和%=\n在/=0时,结果是Infinity,而不是报错\n在%=0时,结果是NaN,意思为 not a number ,而不是报错\n\n\n关系运算符  &gt;   &lt;  &gt;= &lt;= == === !=\n需要注意的是 == 和 === 差别\n== 符号,如果两端的数据类型不一致,会尝试将两端的数据转换成number,再对比number大小\n&#39;123&#39; -&gt; 123\ntrue -&gt; 1 \nfalse -&gt;0\n\n\n===  符号,如果两端数据类型不一致,直接返回false,数据类型一致在比较是否相同\n\n\n逻辑运算符  || &amp;&amp;    \n几乎和JAVA中的一样,需要注意的是,这里直接就是短路逻辑运算符,单个的 |   和 &amp;  以及 ^ 是位运算符\n\n\n条件运算符 条件? 值1  : 值2\n几乎和JAVA中的一样\n\n\n位运算符  |  &amp;  ^  &lt;&lt;  &gt;&gt;  &gt;&gt;&gt;\n和 java中的类似(了解)\n\n\n\n代码举例演示\njsconsole.log(&#39;算数运算符&#39;)\nconsole.log(10/2)\nconsole.log(10/4)\nconsole.log(10/0)\nconsole.log(10%0)\nconsole.log(&#39;复合算数运算&#39;)\nvar i = 10\nconsole.log(i /= 0)\nconsole.log(&#39;关系运算符&#39;)\nconsole.log(1 == 1)\nconsole.log(1 == &#39;1&#39;)\nconsole.log(1 == true)效果\n在网页按F12打开控制台查看\n\n\n三、JS的流程控制和函数3.1 JS分支结构if结构\n\n这里的if结构几乎和JAVA中的一样,需要注意的是\nif()中的非空字符串会被认为是true\nif()中的非空对象会被判断为true\nif()中的非零数字会被认为是true\n\n\n\n代码\njavascriptif(&#39;false&#39;)&#123;// 非空字符串 if判断为true\n    console.log(true)\n&#125;else&#123;\n    console.log(false)\n&#125;\nif(new Object())&#123; //非空对象\n    console.log(true)\n&#125;else&#123;\n    console.log(false)\n&#125;\nif(&#39;&#39;)&#123;// 长度为0字符串 if判断为false\n    console.log(true)\n&#125;else&#123;\n    console.log(false)\n&#125;\nif(1)&#123;// 非零数字 if判断为true\n    console.log(true)\n&#125;else&#123;\n    console.log(false)\n&#125;\nif(0)&#123;\n    console.log(true)\n&#125;else&#123;\n    console.log(false)\n&#125;效果\n\nswitch结构\n\n几乎和JAVA的语法一致\n\n代码\njavascriptvar monthStr=prompt(&quot;请输入月份&quot;,&quot;例如:10 &quot;);\nvar month= Number.parseInt(monthStr)\nswitch(month)&#123;\n    case 3:\n    case 4:\n    case 5:\n        console.log(&quot;春季&quot;);\n        break;\n    case 6:\n    case 7:\n    case 8:\n        console.log(&quot;夏季&quot;);\n        break;\n    case 9:\n    case 10:\n    case 11:\n        console.log(&quot;秋季&quot;);\n        break;\n    case 1:\n    case 2:\n    case 12:\n        console.log(&quot;冬季&quot;);\n        break;\n    default :\n        console.log(&quot;月份有误&quot;)\n&#125;效果\n\n3.2 JS循环结构while结构\n\n几乎和JAVA一致\n\n代码\ndocument.write在浏览器的窗口上打印。\njavascript/* 打印99 乘法表 */\nvar i = 1;\nwhile(i &lt;= 9)&#123;\n    var j = 1;\n    while(j &lt;= i)&#123;\n        document.write(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);\n        j++;\n    &#125;\n    document.write(&quot;&lt;hr/&gt;&quot;);\n    i++;\n&#125;效果\n\nfor循环\n\n几乎和JAVA一致\n\n代码\njavascript/* 打印99 乘法表 */\nfor(  var i = 1;i &lt;= 9; i++)&#123;\n    for(var j = 1;j &lt;= i;j++)&#123;\n        document.write(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);\n    &#125;\n    document.write(&quot;&lt;hr/&gt;&quot;);\n&#125;效果\n\nforeach循环\n\n迭代数组时,和java不一样\n括号中的临时变量表示的是元素的索引,不是元素的值,\n()中也不再使用: 分隔,而是使用 in 关键字\n\n\n\n代码\njavascriptvar cities =[&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;,&quot;武汉&quot;,&quot;西安&quot;,&quot;成都&quot;]\ndocument.write(&quot;&lt;ul&gt;&quot;)\nfor(var index in  cities)&#123;\n    document.write(&quot;&lt;li&gt;&quot;+cities[index]+&quot;&lt;/li&gt;&quot;)\n&#125;\ndocument.write(&quot;&lt;/ul&gt;&quot;)效果\n\n3.3 JS函数声明JS中的方法,多称为函数,函数的声明语法和JAVA中有较大区别\n函数说明\n\n函数没有访问修饰符\n不用声明函数的返回值类型,需要返回在函数体中直接return即可,也无需void关键字\n参数列表中,无需数据类型\n调用函数时,实参和形参的个数可以不一致，在方法内部可以通过arguments(是个数组)获得调用时的实参\n声明函数时需要用function关键字\nJS函数没有异常列表\n函数也可以作为参数传递给另一个方法\n\n函数声明的语法\njs方式一： function 函数名(参数列表) &#123;函数体&#125;\n方式二： var 函数名 = function (参数列表) &#123;函数体&#125;代码\njavascript/* \n语法1 \n    function 函数名 (参数列表)&#123;函数体&#125;\n            */\nfunction sum(a, b)&#123;\n    return a+b;\n&#125;\nvar result =sum(10,20);\nconsole.log(result)\n\n/* \n语法2\n    var 函数名 = function (参数列表)&#123;函数体&#125;\n            */\nvar add = function(a, b)&#123;\n    return a+b;\n&#125;\nvar result = add(1,2);\nconsole.log(result);效果演示\n\n\n四、JS的对象和JSON4.1 JS声明对象的语法创建对象的语法\n方式一： new Object()\n方式二：&#123;属性名:属性值, ... ..., 函数名:function()&#123;&#125;&#125;\n代码演示\n语法1：通过new Object()直接创建对象\n注意：如果没有name属性，则添加一个name属性。\n\n代码\n\njavascriptvar person =new Object();\n// 给对象添加属性并赋值\nperson.name=&quot;张小明&quot;;\nperson.age=10;\nperson.foods=[&quot;苹果&quot;,&quot;橘子&quot;,&quot;香蕉&quot;,&quot;葡萄&quot;];\n// 给对象添加功能函数\nperson.eat= function ()&#123;\n    console.log(this.age+&quot;岁的&quot;+this.name+&quot;喜欢吃:&quot;)\n    for(var i = 0;i&lt;this.foods.length;i++)&#123;\n        console.log(this.foods[i])\n    &#125; \n&#125;\n//获得对象属性值\nconsole.log(person.name)\nconsole.log(person.age)\n//调用对象方法\nperson.eat();\n效果\n\n\n语法2：通过 &#123;&#125;形式创建对象\n语法为：var person =&#123;&quot;属性名&quot;:&quot;属性值&quot;,&quot;属性名&quot;,&quot;属性值&quot;,&quot;函数名&quot;:函数&#125;\n\n代码\n\njavascriptvar person =&#123;\n    &quot;name&quot;:&quot;张小明&quot;,\n    &quot;age&quot;:10,\n    &quot;foods&quot;:[&quot;苹果&quot;,&quot;香蕉&quot;,&quot;橘子&quot;,&quot;葡萄&quot;],\n    &quot;eat&quot;:function ()&#123;\n        console.log(this.age+&quot;岁的&quot;+this.name+&quot;喜欢吃:&quot;)\n        for(var i = 0;i&lt;this.foods.length;i++)&#123;\n            console.log(this.foods[i])\n        &#125; \n    &#125;\n&#125;\n//获得对象属性值\nconsole.log(person.name)\nconsole.log(person.age)\n//调用对象方法\nperson.eat();\n效果\n\n\n4.2 JSON格式\n\n\n\n\n\n\n\n\n JSON（JavaScript Object Notation, JS对象简谱）是一种轻量级的数据交换格式。它基于ECMAScript（European Computer Manufacturers Association, 欧洲计算机协会的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率 简单来说,JSON 就是一种字符串格式,这种格式无论是在前端还是在后端,都可以很容易的转换成对象,所以常用于前后端数据传递\n说明\n\nJSON的语法：var obj=&quot;&#123;&#39;属性名&#39;:&#39;属性值&#39;,&#39;属性名&#39;:&#123;&#39;属性名&#39;:&#39;属性值&#39;&#125;,&#39;属性名&#39;:[&#39;值1&#39;,&#39;值1&#39;,&#39;值3&#39;]&#125;&quot;\n\nJSON字符串一般用于传递数据,所以字符串中的函数就显得没有意义,在此不做研究\n\n通过JSON.parse()方法可以将一个JSON串转换成对象\n\n通过JSON.stringify()方法可以将一个对象转换成一个JSON格式的字符串\n\n\nJSON在客户端的使用\n\n代码\n\njavascript/* 定义一个JSON串 */\nvar personStr =&#39;&#123;&quot;name&quot;:&quot;张小明&quot;,&quot;age&quot;:20,&quot;girlFriend&quot;:&#123;&quot;name&quot;:&quot;铁铃&quot;,&quot;age&quot;:23&#125;,&quot;foods&quot;:[&quot;苹果&quot;,&quot;香蕉&quot;,&quot;橘子&quot;,&quot;葡萄&quot;],&quot;pets&quot;:[&#123;&quot;petName&quot;:&quot;大黄&quot;,&quot;petType&quot;:&quot;dog&quot;&#125;,&#123;&quot;petName&quot;:&quot;小花&quot;,&quot;petType&quot;:&quot;cat&quot;&#125;]&#125;&#39;\nconsole.log(personStr)\nconsole.log(typeof personStr)\n/* 将一个JSON串转换为对象 */\nvar person =JSON.parse(personStr);\nconsole.log(person)\nconsole.log(typeof person)\n/* 获取对象属性值 */\nconsole.log(person.name)\nconsole.log(person.age)\nconsole.log(person.girlFriend.name)\nconsole.log(person.foods[1])\nconsole.log(person.pets[1].petName)\nconsole.log(person.pets[1].petType)javascript/* 定义一个对象 */\nvar person=&#123;\n    &#39;name&#39;:&#39;张小明&#39;,\n    &#39;age&#39;:20,\n    &#39;girlFriend&#39;:&#123;\n        &#39;name&#39;:&#39;铁铃&#39;,\n        &#39;age&#39;:23\n    &#125;,\n    &#39;foods&#39;:[&#39;苹果&#39;,&#39;香蕉&#39;,&#39;橘子&#39;,&#39;葡萄&#39;],\n    &#39;pets&#39;:[\n        &#123;\n            &#39;petName&#39;:&#39;大黄&#39;,\n            &#39;petType&#39;:&#39;dog&#39;\n        &#125;,\n        &#123;\n            &#39;petName&#39;:&#39;小花&#39;,\n            &#39;petType&#39;:&#39;cat&#39;\n        &#125;\n    ]\n&#125;\n\n/* 获取对象属性值 */\nconsole.log(person.name)\nconsole.log(person.age)\nconsole.log(person.girlFriend.name)\nconsole.log(person.foods[1])\nconsole.log(person.pets[1].petName)\nconsole.log(person.pets[1].petType)\n/* 将对象转换成JSON字符串 */\nvar personStr =JSON.stringify(person)\nconsole.log(personStr)\nconsole.log(typeof personStr)JSON在服务端的使用\njavapublic void testWriteJson() throws JsonProcessingException &#123;\n    //实例化Person对象，将Person对象转换成JSON串\n    Dog dog = new Dog(&quot;小黄&quot;);\n    Person person = new Person(&quot;张三&quot;, 10, dog);\n\n    //将Person对象转换成一个字符串 Gson Jackson Fastjson\n    ObjectMapper objectMapper = new ObjectMapper();\n    String personStr = objectMapper.writeValueAsString(person);\n    System.out.println(personStr); \n    //输出结果: &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:10,&quot;dog&quot;:&#123;&quot;name&quot;:&quot;小黄&quot;&#125;&#125;\n&#125;\npublic void testReadJson() throws JsonProcessingException &#123;\n    String personStr = &quot;&#123;\\&quot;name\\&quot;:\\&quot;张三\\&quot;,\\&quot;age\\&quot;:10,\\&quot;dog\\&quot;:&#123;\\&quot;name\\&quot;:\\&quot;小黄\\&quot;&#125;&#125;&quot;;\n    ObjectMapper objectMapper = new ObjectMapper();\n    Person person = objectMapper.readValue(personStr, Person.class);\n    System.out.println(person); //可设置断点查看person的值\n&#125;JSON和Map_List_Array之间的转换\n\nmap\n\njavapublic void testMapToJson() throws JsonProcessingException &#123;\n    Map data = new HashMap&lt;&gt;();\n    data.put(&quot;a&quot;, &quot;valuea&quot;);\n    data.put(&quot;b&quot;, &quot;valueb&quot;);\n\n    ObjectMapper objectMapper = new ObjectMapper();\n    String s = objectMapper.writeValueAsString(data);\n    System.out.println(s);\n&#125;\n输出结果： &#123;&quot;a&quot;:&quot;valuea&quot;,&quot;b&quot;:&quot;valueb&quot;&#125;\nlist &#x2F; array\n\nlist和array打印的值是一样的，因此前端可能收到此类的值有两种情况。\njavapublic void testListToJson() throws JsonProcessingException &#123;\n//1、     List data = new ArrayList&lt;&gt;();\n//        data.add(&quot;a&quot;);\n//        data.add(&quot;b&quot;);\n//        data.add(&quot;c&quot;);\n//2、     String[] data = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;\n//3、\n    Dog dog = new Dog(&quot;小黄&quot;);\n    Person person = new Person(&quot;张三&quot;, 10, dog);\n    List data = new ArrayList&lt;&gt;();\n    data.add(person);\n\n    ObjectMapper objectMapper = new ObjectMapper();\n    String s = objectMapper.writeValueAsString(data);\n    System.out.println(s);\n&#125;\n输出结果：\n    1：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n    2：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n    3：[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:10,&quot;dog&quot;:&#123;&quot;name&quot;:&quot;小黄&quot;&#125;&#125;]前后端传递数据\n\n4.3 JS常见对象4.3.1 数组\n\n\n\n\n\n\n\n\n创建数组的四种方式\n\nnew Array()                                                   创建空数组\nnew Array(5)                                                 创建数组时给定长度\nnew Array(ele1,ele2,ele3,... ... ,elen);          创建数组时指定元素值\n[ele1,ele2,ele3,... ... ,elen];                           相当于第三种语法的简写\n\n\n\n\n\n\n\n\n\n\n数组的常见API\n\n在JS中,数组属于Object类型,其长度是可以变化的,更像JAVA中的集合\n\n\n\n\n方法\n描述\n\n\n\nconcat()\n连接两个或更多的数组，并返回结果。\n\n\ncopyWithin()\n从数组的指定位置拷贝元素到数组的另一个指定位置中。\n\n\nentries()\n返回数组的可迭代对象。\n\n\nevery()\n检测数值元素的每个元素是否都符合条件。\n\n\nfill()\n使用一个固定值来填充数组。\n\n\nfilter()\n检测数值元素，并返回符合条件所有元素的数组。\n\n\nfind()\n返回符合传入测试（函数）条件的数组元素。\n\n\nfindIndex()\n返回符合传入测试（函数）条件的数组元素索引。\n\n\nforEach()\n数组每个元素都执行一次回调函数。\n\n\nfrom()\n通过给定的对象中创建一个数组。\n\n\nincludes()\n判断一个数组是否包含一个指定的值。\n\n\nindexOf()\n搜索数组中的元素，并返回它所在的位置。\n\n\nisArray()\n判断对象是否为数组。\n\n\njoin()\n把数组的所有元素放入一个字符串。\n\n\nkeys()\n返回数组的可迭代对象，包含原始数组的键(key)。\n\n\nlastIndexOf()\n搜索数组中的元素，并返回它最后出现的位置。\n\n\nmap()\n通过指定函数处理数组的每个元素，并返回处理后的数组。\n\n\npop()\n删除数组的最后一个元素并返回删除的元素。\n\n\npush()\n向数组的末尾添加一个或更多元素，并返回新的长度。\n\n\nreduce()\n将数组元素计算为一个值（从左到右）。\n\n\nreduceRight()\n将数组元素计算为一个值（从右到左）。\n\n\nreverse()\n反转数组的元素顺序。\n\n\nshift()\n删除并返回数组的第一个元素。\n\n\nslice()\n选取数组的一部分，并返回一个新数组。\n\n\nsome()\n检测数组元素中是否有元素符合指定条件。\n\n\nsort()\n对数组的元素进行排序。\n\n\nsplice()\n从数组中添加或删除元素。\n\n\ntoString()\n把数组转换为字符串，并返回结果。\n\n\nunshift()\n向数组的开头添加一个或更多元素，并返回新的长度。\n\n\nvalueOf()\n返回数组对象的原始值。\n\n\nArray.of()\n将一组值转换为数组。\n\n\nArray.at()\n用于接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。\n\n\nArray.flat()\n创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。\n\n\nArray.flatMap()\n使用映射函数映射每个元素，然后将结果压缩成一个新数组。\n\n\n4.3.2 Boolean对象\n\n\n\n\n\n\n\n\nboolean对象的方法比较简单\n\n\n\n方法\n描述\n\n\n\ntoString()\n把布尔值转换为字符串，并返回结果。\n\n\nvalueOf()\n返回 Boolean 对象的原始值。\n\n\n4.3.3 Date对象\n\n\n\n\n\n\n\n\n和JAVA中的Date类比较类似\n\n\n\n方法\n描述\n\n\n\ngetDate()\n从 Date 对象返回一个月中的某一天 (1 ~ 31)。\n\n\ngetDay()\n从 Date 对象返回一周中的某一天 (0 ~ 6)。\n\n\ngetFullYear()\n从 Date 对象以四位数字返回年份。\n\n\ngetHours()\n返回 Date 对象的小时 (0 ~ 23)。\n\n\ngetMilliseconds()\n返回 Date 对象的毫秒(0 ~ 999)。\n\n\ngetMinutes()\n返回 Date 对象的分钟 (0 ~ 59)。\n\n\ngetMonth()\n从 Date 对象返回月份 (0 ~ 11)。\n\n\ngetSeconds()\n返回 Date 对象的秒数 (0 ~ 59)。\n\n\ngetTime()\n返回 1970 年 1 月 1 日至今的毫秒数。\n\n\ngetTimezoneOffset()\n返回本地时间与格林威治标准时间 (GMT) 的分钟差。\n\n\ngetUTCDate()\n根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。\n\n\ngetUTCDay()\n根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。\n\n\ngetUTCFullYear()\n根据世界时从 Date 对象返回四位数的年份。\n\n\ngetUTCHours()\n根据世界时返回 Date 对象的小时 (0 ~ 23)。\n\n\ngetUTCMilliseconds()\n根据世界时返回 Date 对象的毫秒(0 ~ 999)。\n\n\ngetUTCMinutes()\n根据世界时返回 Date 对象的分钟 (0 ~ 59)。\n\n\ngetUTCMonth()\n根据世界时从 Date 对象返回月份 (0 ~ 11)。\n\n\ngetUTCSeconds()\n根据世界时返回 Date 对象的秒钟 (0 ~ 59)。\n\n\ngetYear()\n已废弃。 请使用 getFullYear() 方法代替。\n\n\nparse()\n返回1970年1月1日午夜到指定日期（字符串）的毫秒数。\n\n\nsetDate()\n设置 Date 对象中月的某一天 (1 ~ 31)。\n\n\nsetFullYear()\n设置 Date 对象中的年份（四位数字）。\n\n\nsetHours()\n设置 Date 对象中的小时 (0 ~ 23)。\n\n\nsetMilliseconds()\n设置 Date 对象中的毫秒 (0 ~ 999)。\n\n\nsetMinutes()\n设置 Date 对象中的分钟 (0 ~ 59)。\n\n\nsetMonth()\n设置 Date 对象中月份 (0 ~ 11)。\n\n\nsetSeconds()\n设置 Date 对象中的秒钟 (0 ~ 59)。\n\n\nsetTime()\nsetTime() 方法以毫秒设置 Date 对象。\n\n\nsetUTCDate()\n根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。\n\n\nsetUTCFullYear()\n根据世界时设置 Date 对象中的年份（四位数字）。\n\n\nsetUTCHours()\n根据世界时设置 Date 对象中的小时 (0 ~ 23)。\n\n\nsetUTCMilliseconds()\n根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。\n\n\nsetUTCMinutes()\n根据世界时设置 Date 对象中的分钟 (0 ~ 59)。\n\n\nsetUTCMonth()\n根据世界时设置 Date 对象中的月份 (0 ~ 11)。\n\n\nsetUTCSeconds()\nsetUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段。\n\n\nsetYear()\n已废弃。请使用 setFullYear() 方法代替。\n\n\ntoDateString()\n把 Date 对象的日期部分转换为字符串。\n\n\ntoGMTString()\n已废弃。请使用 toUTCString() 方法代替。\n\n\ntoISOString()\n使用 ISO 标准返回字符串的日期格式。\n\n\ntoJSON()\n以 JSON 数据格式返回日期字符串。\n\n\ntoLocaleDateString()\n根据本地时间格式，把 Date 对象的日期部分转换为字符串。\n\n\ntoLocaleTimeString()\n根据本地时间格式，把 Date 对象的时间部分转换为字符串。\n\n\ntoLocaleString()\n根据本地时间格式，把 Date 对象转换为字符串。\n\n\ntoString()\n把 Date 对象转换为字符串。\n\n\ntoTimeString()\n把 Date 对象的时间部分转换为字符串。\n\n\ntoUTCString()\n根据世界时，把 Date 对象转换为字符串。实例：var today = new Date(); var UTCstring = today.toUTCString();\n\n\nUTC()\n根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。\n\n\nvalueOf()\n返回 Date 对象的原始值。\n\n\n4.3.4 Math\n\n\n\n\n\n\n\n\n 和JAVA中的Math类比较类似\n\n\n\n方法\n描述\n\n\n\nabs(x)\n返回 x 的绝对值。\n\n\nacos(x)\n返回 x 的反余弦值。\n\n\nasin(x)\n返回 x 的反正弦值。\n\n\natan(x)\n以介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间的数值来返回 x 的反正切值。\n\n\natan2(y,x)\n返回从 x 轴到点 (x,y) 的角度（介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间）。\n\n\nceil(x)\n对数进行上舍入。\n\n\ncos(x)\n返回数的余弦。\n\n\nexp(x)\n返回 Ex 的指数。\n\n\nfloor(x)\n对 x 进行下舍入。\n\n\nlog(x)\n返回数的自然对数（底为e）。\n\n\nmax(x,y,z,…,n)\n返回 x,y,z,…,n 中的最高值。\n\n\nmin(x,y,z,…,n)\n返回 x,y,z,…,n中的最低值。\n\n\npow(x,y)\n返回 x 的 y 次幂。\n\n\nrandom()\n返回 0 ~ 1 之间的随机数。\n\n\nround(x)\n四舍五入。\n\n\nsin(x)\n返回数的正弦。\n\n\nsqrt(x)\n返回数的平方根。\n\n\ntan(x)\n返回角的正切。\n\n\ntanh(x)\n返回一个数的双曲正切函数值。\n\n\ntrunc(x)\n将数字的小数部分去掉，只保留整数部分。\n\n\n4.3.5 Number\n\n\n\n\n\n\n\n\nNumber中准备了一些基础的数据处理函数\n\n\n\n方法\n描述\n\n\n\nisFinite\n检测指定参数是否为无穷大。\n\n\nisInteger\n检测指定参数是否为整数。\n\n\nisNaN\n检测指定参数是否为 NaN。\n\n\nisSafeInteger\n检测指定参数是否为安全整数。\n\n\ntoExponential(x)\n把对象的值转换为指数计数法。\n\n\ntoFixed(x)\n把数字转换为字符串，结果的小数点后有指定位数的数字。\n\n\ntoLocaleString(locales, options)\n返回数字在特定语言环境下的表示字符串。\n\n\ntoPrecision(x)\n把数字格式化为指定的长度。\n\n\ntoString()\n把数字转换为字符串，使用指定的基数。\n\n\nvalueOf()\n返回一个 Number 对象的基本数字值。\n\n\n4.3.6 String\n\n\n\n\n\n\n\n\n和JAVA中的String类似\n\n\n\n方法\n描述\n\n\n\ncharAt()\n返回在指定位置的字符。\n\n\ncharCodeAt()\n返回在指定的位置的字符的 Unicode 编码。\n\n\nconcat()\n连接两个或更多字符串，并返回新的字符串。\n\n\nendsWith()\n判断当前字符串是否是以指定的子字符串结尾的（区分大小写）。\n\n\nfromCharCode()\n将 Unicode 编码转为字符。\n\n\nindexOf()\n返回某个指定的字符串值在字符串中首次出现的位置。\n\n\nincludes()\n查找字符串中是否包含指定的子字符串。\n\n\nlastIndexOf()\n从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。\n\n\nmatch()\n查找找到一个或多个正则表达式的匹配。\n\n\nrepeat()\n复制字符串指定次数，并将它们连接在一起返回。\n\n\nreplace()\n在字符串中查找匹配的子串，并替换与正则表达式匹配的子串。\n\n\nreplaceAll()\n在字符串中查找匹配的子串，并替换与正则表达式匹配的所有子串。\n\n\nsearch()\n查找与正则表达式相匹配的值。\n\n\nslice()\n提取字符串的片断，并在新的字符串中返回被提取的部分。\n\n\nsplit()\n把字符串分割为字符串数组。\n\n\nstartsWith()\n查看字符串是否以指定的子字符串开头。\n\n\nsubstr()\n从起始索引号提取字符串中指定数目的字符。\n\n\nsubstring()\n提取字符串中两个指定的索引号之间的字符。\n\n\ntoLowerCase()\n把字符串转换为小写。\n\n\ntoUpperCase()\n把字符串转换为大写。\n\n\ntrim()\n去除字符串两边的空白。\n\n\ntoLocaleLowerCase()\n根据本地主机的语言环境把字符串转换为小写。\n\n\ntoLocaleUpperCase()\n根据本地主机的语言环境把字符串转换为大写。\n\n\nvalueOf()\n返回某个字符串对象的原始值。\n\n\ntoString()\n返回一个字符串。\n\n\n\n五、事件的绑定(重要)5.1 什么是事件\n\n\n\n\n\n\n\n\n HTML 事件可以是浏览器行为，也可以是用户行为。 当这些一些行为发生时,可以自动触发对应的JS函数的运行,我们称之为事件发生.JS的事件驱动指的就是行为触发代码运行的这种特点\n5.2 常见事件\n\n\n\n\n\n\n\n\n鼠标事件\n\n\n\n属性\n描述\n\n\n\nonclick\n当用户点击某个对象时调用的事件句柄。\n\n\noncontextmenu\n在用户点击鼠标右键打开上下文菜单时触发\n\n\nondblclick\n当用户双击某个对象时调用的事件句柄。\n\n\nonmousedown\n鼠标按钮被按下。\n\n\nonmouseenter\n当鼠标指针移动到元素上时触发。\n\n\nonmouseleave\n当鼠标指针移出元素时触发\n\n\nonmousemove\n鼠标被移动。\n\n\nonmouseover\n鼠标移到某元素之上。\n\n\nonmouseout\n鼠标从某元素移开。\n\n\nonmouseup\n鼠标按键被松开。\n\n\n\n\n\n\n\n\n\n\n\n键盘事件\n\n\n\n属性\n描述\n\n\n\nonkeydown\n某个键盘按键被按下。\n\n\nonkeypress\n某个键盘按键被按下并松开。\n\n\nonkeyup\n某个键盘按键被松开。\n\n\n\n\n\n\n\n\n\n\n\n表单事件\n\n\n\n属性\n描述\n\n\n\nonblur\n元素失去焦点时触发\n\n\nonchange\n该事件在表单元素的内容改变时触发( &lt;input&gt;, &lt;keygen&gt;, &lt;select&gt;, 和 &lt;textarea&gt;)\n\n\nonfocus\n元素获取焦点时触发\n\n\nonfocusin\n元素即将获取焦点时触发\n\n\nonfocusout\n元素即将失去焦点时触发\n\n\noninput\n元素获取用户输入时触发\n\n\nonreset\n表单重置时触发\n\n\nonsearch\n用户向搜索域输入文本时触发 ( &lt;input&#x3D;”search”&gt;)\n\n\nonselect\n用户选取文本时触发 ( &lt;input&gt; 和 &lt;textarea&gt;)\n\n\nonsubmit\n表单提交时触发\n\n\n5.3 事件的绑定事件的绑定方式\n\n\n\n\n\n\n\n\n\n1、通过元素的属性绑定\ton***\n\n通过事件属性绑定函数,在行为发生时会自动执行函数\n\n一个事件可以同时绑定多个函数\n\n一个元素可以同时绑定多个事件\n\n方法中可以传入 this对象,代表当前元素\n\n\n2、通过DOM编程动态绑定\n弹窗的三种方式\n\nalert()：信息提示框\nprompt：信息输入框\nconfirm：信息确认框\n\n常见的事件(演示内容)\n\n鼠标事件：onclick鼠标单击，ondbclick鼠标双击，onmouseover鼠标悬停，onmousemove鼠标移动，onmouseleave鼠标离开\n键盘事件：onkeydown键盘按下，onkeyup键盘松开\n表单事件：onreset表单提交，onsubmit表单重置\n页面加载事件：onload针对浏览器页面加载\n\n代码实现\n\n\n\n\n\n\n\n\n\n1、通过元素的属性绑定\n&lt;head&gt;标签部分\n\nevent.preventDefault() ：可以阻止组件的默认行为。\n也可以通过confirm获取提交表单的信息，通过返回的信息trueorfalse来决定是否阻止提交表单的行为。需要注意在&lt;form&gt;表单标签内对应的函数位置写上return。\n\nhtml&lt;script&gt;\n        function fun1()&#123;\n            console.log(&quot;按钮被点击了&quot;)\n        &#125;\n        function fun2()&#123;\n            console.log(&quot;鼠标单击了&quot;)\n        &#125;\n        function fun3()&#123;\n            console.log(&quot;鼠标双击了&quot;)\n        &#125;\n        function fun4()&#123;\n            console.log(&quot;鼠标悬停&quot;)\n        &#125;\n        function fun5()&#123;\n            console.log(&quot;鼠标移动&quot;)\n        &#125;\n        function fun6()&#123;\n            console.log(&quot;鼠标离开&quot;)\n        &#125;\n        function fun7()&#123;\n            console.log(&quot;按键按下&quot;)\n        &#125;\n        function fun8()&#123;\n            console.log(&quot;按键抬起&quot;)\n        &#125;\n        function testFoucs()&#123;\n            console.log(&quot;获得焦点&quot;)\n        &#125;\n        function testBlur()&#123;\n            console.log(&quot;失去焦点&quot;)\n        &#125;\n        function testChange(value)&#123;\n            console.log(&quot;内容改变为:&quot;+value)\n        &#125;\n        function testChange2(value)&#123;\n            console.log(&quot;选项改变为:&quot;+value)\n        &#125;\n        function testSubmit()&#123;\n            //alert(&quot;表单发生了提交&quot;)\n            //在这里可以阻止表单的提交\n            //event.preventDefault() //阻止组件的默认行为\n            var flag = confirm(&quot;你确定要提交吗?&quot;)\n            if(!flag)&#123;\n                return false\n            &#125;\n            return true\n        &#125;\n        function testReset()&#123;\n            alert(&quot;表单发生了重置&quot;)\n        &#125;\n&lt;/script&gt;&lt;body&gt;标签部分\nhtml&lt;body&gt;\n    &lt;form action=&quot;01JS的引入方式.html&quot; method=&quot;get&quot; onreset=&quot;testReset()&quot; onsubmit=&quot;return testSubmit()&quot;&gt;\n        用户昵称:&lt;input \n            type=&quot;text&quot; \n            name=&quot;realName&quot; \n            onfocus=&quot;testFoucs()&quot;\n            onblur=&quot;testBlur()&quot;\n            onchange=&quot;testChange(this.value)&quot;\n            &gt; &lt;br&gt;\n        登录账号:&lt;input type=&quot;text&quot; name=&quot;loginName&quot;&gt; &lt;br&gt;\n        选择籍贯:\n            &lt;select onchange=&quot;testChange2(this.value)&quot;&gt;\n                &lt;option value=&quot;1&quot;&gt;湖北&lt;/option&gt;\n                &lt;option value=&quot;2&quot;&gt;湖南&lt;/option&gt;\n                &lt;option value=&quot;3&quot;&gt;广东&lt;/option&gt;\n            &lt;/select&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;\n        &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;\n    &lt;/form&gt;\n    \n    &lt;input \n        type=&quot;button&quot; \n        value=&quot;按钮&quot; \n        onclick = &quot;fun1(),fun2()&quot;\n        ondblclick=&quot;fun3()&quot;\n    &gt; \n    &lt;input type=&quot;text&quot; onkeydown=&quot;fun7()&quot; onkeyup=&quot;fun8()&quot;&gt;\n    &lt;br&gt;\n    \n    &lt;img src=&quot;img/logo.png&quot; onmouseover=&quot;fun4()&quot; onmousemove=&quot;fun5()&quot; onmouseleave=&quot;fun6()&quot; &gt;\n&lt;/body&gt;效果\n\n\n\n\n\n\n\n\n\n\n2、通过DOM编程绑定\n因为程序是从上往下执行的，当执行script中的var btn = document.getElementById(&quot;btn1&quot;)时，btn得到的值为NULL。因此需要用到页面加载事件，在函数设置页面加载就能够解决问题。\n代码实现\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script&gt;\n        window.onload=function()&#123;\n            //通过dom获得要操作的元素\n            var btn = document.getElementById(&quot;btn1&quot;);\n            btn.onclick=function()&#123;\n                alert(&quot;你点击了按钮&quot;);\n            &#125;\n        &#125;\n    &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id = &quot;d1&quot; class=&quot;div1&quot;&gt;&lt;/div&gt;\n\n    &lt;button id = &quot;btn1&quot;&gt;按钮&lt;/button&gt;\n&lt;/body&gt;\n&lt;/html&gt;效果\n\n5.4 事件的触发\n\n\n\n\n\n\n\n\n\n行为触发：事件绑定中已有演示。略\nDOM编程触发\n\n通过DOM编程,用代码触发,执行某些代码相当于发生了某些行为\n代码实现\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script&gt;\n        window.onload=function()&#123;\n            //为div1绑定单击事件\n            var div1 = document.getElementById(&quot;d1&quot;);\n            div1.onclick=function()&#123;\n                div1.style.backgroundColor=&quot;red&quot;;\n            &#125;\n\n            //通过dom获得要操作的元素\n            var btn = document.getElementById(&quot;btn1&quot;);\n            btn.onclick=function()&#123;\n                alert(&quot;你点击了按钮&quot;);\n                //通过DOM编程触发div的单击事件\n                div1.onclick()\n            &#125;\n        &#125;\n    &lt;/script&gt;\n    &lt;style&gt;\n        .div1&#123;\n            width: 50px;\n            height: 50px;\n            background-color: yellow;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id = &quot;d1&quot; class=&quot;div1&quot;&gt;&lt;/div&gt;\n\n    &lt;button id = &quot;btn1&quot;&gt;按钮&lt;/button&gt;\n&lt;/body&gt;\n&lt;/html&gt;效果\n点击前为黄色，点击后触发事件，改变div块颜色。\n\n\n六、BOM编程6.1 什么是BOM\n\n\n\n\n\n\n\n\n\nBOM是Browser Object Model的简写，即浏览器对象模型。\nBOM由一系列对象组成，是访问、控制、修改浏览器的属性和方法(通过window对象及属性的一系列方法 控制浏览器行为的一种编程)。\nBOM没有统一的标准(每种客户端都可以自定标准)。\nBOM编程是将浏览器窗口的各个组成部分抽象成各个对象,通过各个对象的API操作组件行为的一种编程。\n\nBOM编程的对象结构如下\nwindow 顶级对象,代表整个浏览器窗口\n\nlocation对象：代表浏览器的地址栏\nhistory对象：代表浏览器的访问历史\nscreen对象：代表屏幕\nnavigator对象：代表浏览器软件本身\ndocument对象：代表浏览器窗口目前解析的html文档\nconsole对象：代表浏览器开发者工具的控制台\nlocalStorage对象：代表浏览器的本地数据持久化存储\nsessionStorage对象：代表浏览器的本地数据会话级存储\n\n\n6.2 window对象的常见属性(了解)\n\n\n属性\n描述\n\n\n\nclosed\n返回窗口是否已被关闭。\n\n\ndefaultStatus\n设置或返回窗口状态栏中的默认文本。\n\n\ndocument\n对 Document 对象的只读引用。(请参阅对象)\n\n\nframes\n返回窗口中所有命名的框架。该集合是 Window 对象的数组，每个 Window 对象在窗口中含有一个框架。\n\n\nhistory\n对 History 对象的只读引用。请参数 History 对象。\n\n\ninnerHeight\n返回窗口的文档显示区的高度。\n\n\ninnerWidth\n返回窗口的文档显示区的宽度。\n\n\nlocalStorage\n在浏览器中存储 key&#x2F;value 对。没有过期时间。\n\n\nlength\n设置或返回窗口中的框架数量。\n\n\nlocation\n用于窗口或框架的 Location 对象。请参阅 Location 对象。\n\n\nname\n设置或返回窗口的名称。\n\n\nnavigator\n对 Navigator 对象的只读引用。请参数 Navigator 对象。\n\n\nopener\n返回对创建此窗口的窗口的引用。\n\n\nouterHeight\n返回窗口的外部高度，包含工具条与滚动条。\n\n\nouterWidth\n返回窗口的外部宽度，包含工具条与滚动条。\n\n\npageXOffset\n设置或返回当前页面相对于窗口显示区左上角的 X 位置。\n\n\npageYOffset\n设置或返回当前页面相对于窗口显示区左上角的 Y 位置。\n\n\nparent\n返回父窗口。\n\n\nscreen\n对 Screen 对象的只读引用。请参数 Screen 对象。\n\n\nscreenLeft\n返回相对于屏幕窗口的x坐标\n\n\nscreenTop\n返回相对于屏幕窗口的y坐标\n\n\nscreenX\n返回相对于屏幕窗口的x坐标\n\n\nsessionStorage\n在浏览器中存储 key&#x2F;value 对。 在关闭窗口或标签页之后将会删除这些数据。\n\n\nscreenY\n返回相对于屏幕窗口的y坐标\n\n\nself\n返回对当前窗口的引用。等价于 Window 属性。\n\n\nstatus\n设置窗口状态栏的文本。\n\n\ntop\n返回最顶层的父窗口。\n\n\n6.3 window对象的常见方法(了解)\n\n\n方法\n描述\n\n\n\nalert()\n显示带有一段消息和一个确认按钮的警告框。\n\n\natob()\n解码一个 base-64 编码的字符串。\n\n\nbtoa()\n创建一个 base-64 编码的字符串。\n\n\nblur()\n把键盘焦点从顶层窗口移开。\n\n\nclearInterval()\n取消由 setInterval() 设置的 timeout。\n\n\nclearTimeout()\n取消由 setTimeout() 方法设置的 timeout。\n\n\nclose()\n关闭浏览器窗口。\n\n\nconfirm()\n显示带有一段消息以及确认按钮和取消按钮的对话框。\n\n\ncreatePopup()\n创建一个 pop-up 窗口。\n\n\nfocus()\n把键盘焦点给予一个窗口。\n\n\ngetSelection()\n返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置。\n\n\ngetComputedStyle()\n获取指定元素的 CSS 样式。\n\n\nmatchMedia()\n该方法用来检查 media query 语句，它返回一个 MediaQueryList对象。\n\n\nmoveBy()\n可相对窗口的当前坐标把它移动指定的像素。\n\n\nmoveTo()\n把窗口的左上角移动到一个指定的坐标。\n\n\nopen()\n打开一个新的浏览器窗口或查找一个已命名的窗口。\n\n\nprint()\n打印当前窗口的内容。\n\n\nprompt()\n显示可提示用户输入的对话框。\n\n\nresizeBy()\n按照指定的像素调整窗口的大小。\n\n\nresizeTo()\n把窗口的大小调整到指定的宽度和高度。\n\n\nscroll()\n已废弃。 该方法已经使用了 scrollTo() 方法来替代。\n\n\nscrollBy()\n按照指定的像素值来滚动内容。\n\n\nscrollTo()\n把内容滚动到指定的坐标。\n\n\nsetInterval()\n按照指定的周期（以毫秒计）来调用函数或计算表达式。\n\n\nsetTimeout()\n在指定的毫秒数后调用函数或计算表达式。\n\n\nstop()\n停止页面载入。\n\n\npostMessage()\n安全地实现跨源通信。\n\n\n6.4 通过BOM编程控制浏览器行为演示\n\n\n\n\n\n\n\n\n三种弹窗方式\n**alert()**：信息提示框prompt：信息输入框confirm：信息确认框\n代码实现\n&lt;html&gt;标签内容\nhtml&lt;script&gt;\n    function fun1()&#123;\n        window.alert(&#39;信息提示框&#39;)\n    &#125;\n    function fun2()&#123;\n        var name = window.prompt(&#39;请输入你的名字&#39;)\n        console.log(name)\n    &#125;\n    function fun3()&#123;\n        var res = prompt(&#39;确定要删除吗？&#39;)\n        console.log(res)\n    &#125;\n&lt;/script&gt;&lt;body&gt;标签内容\nhtml&lt;body&gt;\t\n    &lt;button onclick=&quot;fun1()&quot;&gt;信息提示框&lt;/button&gt;\n    &lt;button onclick=&quot;fun2()&quot;&gt;信息输入框&lt;/button&gt;\n    &lt;button onclick=&quot;fun3()&quot;&gt;信息确认框&lt;/button&gt;\n&lt;/body&gt;效果演示\n\n\n\n\n\n\n\n\n\n\n\n页面跳转\n代码实现\n&lt;html&gt;标签内容\nhtml&lt;script&gt;\t\t\n    function funA()&#123;\n        //向前翻页\n        window.history.back()\n    &#125;\n    function funB()&#123;\n        //向后翻页\n        window.history.forward()\n    &#125;\n    function funC()&#123;\n        //跳转到指定页面\n        window.location.href = &#39;https://www.w3school.com.cn/&#39;\n    &#125;\n&lt;/script&gt;&lt;body&gt;标签内容\nhtml&lt;body&gt;\n    &lt;button onclick=&quot;funA()&quot;&gt;上一页&lt;/button&gt;\n    &lt;button onclick=&quot;funB()&quot;&gt;下一页&lt;/button&gt;\n    &lt;a href=&quot;https://www.w3school.com.cn/&quot;&gt;w3school&lt;/a&gt;\n    &lt;button onclick=&quot;funC()&quot;&gt;演示location跳转&lt;/button&gt;\n&lt;/body&gt;效果演示\n\n6.5 通过BOM编程实现会话级和持久级数据存储\n会话级数据 : 内存型数据,是浏览器在内存上临时存储的数据,浏览器关闭后,数据失去,通过window的sessionStorge属性实现。\n持久级数据 : 磁盘型数据,是浏览器在磁盘上持久存储的数据,浏览器关闭后,数据仍在,通过window的localStorge实现。\n可以用于将来存储一些服务端响应回来的数据,比如:token令牌,或者一些其他功能数据,根据数据的业务范围我们可以选择数据存储的会话&#x2F;持久 级别。\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script&gt;\n        function saveItem()&#123;\n            // 让浏览器存储一些会话级数据\n            window.sessionStorage.setItem(&quot;sessionMsg&quot;,&quot;sessionValue&quot;)\n            // 让浏览器存储一些持久级数据\n            window.localStorage.setItem(&quot;localMsg&quot;,&quot;localValue&quot;)\n\n            console.log(&quot;haha&quot;)\n        &#125;\n\n        function removeItem()&#123;\n            // 删除数据\n            sessionStorage.removeItem(&quot;sessionMsg&quot;)\n            localStorage.removeItem(&quot;localMsg&quot;)\n        &#125;\n\n        function readItem()&#123;\n            console.log(&quot;read&quot;)\n            // 读取数据\n            console.log(&quot;session:&quot;+sessionStorage.getItem(&quot;sessionMsg&quot;))\n            console.log(&quot;local:&quot;+localStorage.getItem(&quot;localMsg&quot;))\n        &#125;\n    &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;button onclick=&quot;saveItem()&quot;&gt;存储数据&lt;/button&gt;\n    &lt;button onclick=&quot;removeItem()&quot;&gt;删除数据&lt;/button&gt;\n    &lt;button onclick=&quot;readItem()&quot;&gt;读取数据&lt;/button&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n测试,存储数据后,再读取数据,然后关闭浏览器,获取数据,发现sessionStorge的数据没有了,localStorge的数据还在\n通过removeItem可以将这些数据直接删除\n在F12开发者工具的应用程序栏,可以查看数据的状态\n\n\n\n七、DOM编程7.1 什么是DOM编程\n\n\n\n\n\n\n\n\n简单来说:DOM(Document Object Model)编程就是使用document对象的API完成对网页HTML文档进行动态修改,以实现网页数据和样式动态变化效果的编程.\n\ndocument对象代表整个html文档，可用来访问页面中的所有元素，是最复杂的一个dom对象，可以说是学习好dom编程的关键所在。\n根据HTML代码结构特点,document对象本身是一种树形结构的文档对象。\n\n\n\n上面的代码生成的树如下\n\n\n\nDOM编程其实就是用window对象的document属性的相关API完成对页面元素的控制的编程\n\n\n\ndom树中节点的类型\nnode  节点,所有结点的父类型\nelement  元素节点：node的子类型之一,代表一个完整标签\nattribute  属性节点：node的子类型之一,代表元素的属性\ntext         文本节点：node的子类型之一,代表双标签中间的文本\n\n\n\n\n\nDOM编程流程\n\n\n\n\n\n\n\n\n\n\n获得document，dom树\nwindow.document\n\n\n从document中获取要操作的元素(两种方式)\n直接获取\n间接获取\n\n\n对元素进行操作\n操作元素的属性\n操作元素的样式\n操作元素的文本\n增删元素\n\n\n\n7.2 获取页面元素的几种方式\n\n\n\n\n\n\n\n\n直接获取方式（API）\n7.2.1 在整个文档范围内查找元素结点\n\n\n功能\nAPI\n返回值\n\n\n\n根据id值查询\ndocument.getElementById(“id值”)\n一个具体的元素节\n\n\n根据标签名查询\ndocument.getElementsByTagName(“标签名”)\n元素节点数组\n\n\n根据name属性值查询\ndocument.getElementsByName(“name值”)\n元素节点数组\n\n\n根据类名查询\ndocument.getElementsByClassName(&quot;类名&quot;)\n元素节点数组\n\n\n\n\n\n\n\n\n\n\n\n间接获取方式（API）\n7.2.2 在具体元素节点范围内查找子节点\n\n\n功能\nAPI\n返回值\n\n\n\n查找子标签\nelement.children\n返回子标签数组\n\n\n查找第一个子标签\nelement.firstElementChild\n标签对象\n\n\n查找最后一个子标签\nelement.lastElementChild\n节点对象\n\n\n7.2.3 查找指定子元素节点的父节点\n\n\n功能\nAPI\n返回值\n\n\n\n查找指定元素节点的父标签\nelement.parentElement\n标签对象\n\n\n7.2.4  查找指定元素节点的兄弟节点\n\n\n功能\nAPI\n返回值\n\n\n\n查找前一个兄弟标签\nnode.previousElementSibling\n标签对象\n\n\n查找后一个兄弟标签\nnode.nextElementSibling\n标签对象\n\n\n代码实现\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n   &lt;script&gt;\n    /* \n    1 获得document  dom树\n        window.document\n    2 从document中获取要操作的元素\n        1. 直接获取\n            var el1 =document.getElementById(&quot;username&quot;) // 根据元素的id值获取页面上唯一的一个元素\n            var els =document.getElementsByTagName(&quot;input&quot;) // 根据元素的标签名获取多个同名元素\n            var els =document.getElementsByName(&quot;aaa&quot;) // 根据元素的name属性值获得多个元素\n            var els =document.getElementsByClassName(&quot;a&quot;) // 根据元素的class属性值获得多个元素\n        2. 间接获取\n            var cs=div01.children // 通过父元素获取全部的子元素\n            var firstChild =div01.firstElementChild  // 通过父元素获取第一个子元素\n            var lastChild = div01.lastElementChild   // 通过父元素获取最后一个子元素\n            var parent = pinput.parentElement  // 通过子元素获取父元素\n            var pElement = pinput.previousElementSibling // 获取前面的第一个元素\n            var nElement = pinput.nextElementSibling // 获取后面的第一个元素\n    3 对元素进行操作\n        1. 操作元素的属性\n        2. 操作元素的样式\n        3. 操作元素的文本\n        4. 增删元素   \n    */\n   function fun1()&#123;\n        //1 获得document\n        //2 通过document获得元素\n        var el1 =document.getElementById(&quot;username&quot;) // 根据元素的id值获取页面上唯一的一个元素\n        console.log(el1)\n   &#125;\n   function fun2()&#123;\n        var els =document.getElementsByTagName(&quot;input&quot;) // 根据元素的标签名获取多个同名元素\n        for(var i = 0 ;i&lt;els.length;i++)&#123;\n            console.log(els[i])\n        &#125;\n   &#125;\n   function fun3()&#123;\n        var els =document.getElementsByName(&quot;aaa&quot;) // 根据元素的name属性值获得多个元素\n        console.log(els)\n        for(var i =0;i&lt; els.length;i++)&#123;\n            console.log(els[i])\n        &#125;\n   &#125;\n\n   function fun4()&#123;\n    var els =document.getElementsByClassName(&quot;a&quot;) // 根据元素的class属性值获得多个元素\n    for(var i =0;i&lt; els.length;i++)&#123;\n            console.log(els[i])\n        &#125;\n   &#125;\n\n   function fun5()&#123;\n    // 先获取父元素\n     var div01 = document.getElementById(&quot;div01&quot;)\n     // 获取所有子元素\n     var cs=div01.children // 通过父元素获取全部的子元素\n     for(var i =0;i&lt; cs.length;i++)&#123;\n            console.log(cs[i])\n     &#125;\n\n     console.log(div01.firstElementChild)  // 通过父元素获取第一个子元素\n     console.log(div01.lastElementChild)   // 通过父元素获取最后一个子元素\n   &#125;\n\n   function fun6()&#123;\n        // 获取子元素\n        var pinput =document.getElementById(&quot;password&quot;)\n        console.log(pinput.parentElement) // 通过子元素获取父元素\n   &#125;\n\n   function fun7()&#123;\n        // 获取子元素\n        var pinput =document.getElementById(&quot;password&quot;)\n        console.log(pinput.previousElementSibling) // 获取前面的第一个元素\n        console.log(pinput.nextElementSibling) // 获取后面的第一个元素\n   &#125;\n   &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;div01&quot;&gt;\n        &lt;input type=&quot;text&quot; class=&quot;a&quot; id=&quot;username&quot; name=&quot;aaa&quot;/&gt;\n        &lt;input type=&quot;text&quot; class=&quot;b&quot; id=&quot;password&quot; name=&quot;aaa&quot;/&gt;\n        &lt;input type=&quot;text&quot; class=&quot;a&quot; id=&quot;email&quot;/&gt;\n        &lt;input type=&quot;text&quot; class=&quot;b&quot; id=&quot;address&quot;/&gt;\n    &lt;/div&gt;\n    &lt;input type=&quot;text&quot; class=&quot;a&quot;/&gt;&lt;br&gt;\n\n    &lt;hr&gt;\n    &lt;input type=&quot;button&quot; value=&quot;通过父元素获取子元素&quot; onclick=&quot;fun5()&quot; id=&quot;btn05&quot;/&gt;\n    &lt;input type=&quot;button&quot; value=&quot;通过子元素获取父元素&quot; onclick=&quot;fun6()&quot; id=&quot;btn06&quot;/&gt;\n    &lt;input type=&quot;button&quot; value=&quot;通过当前元素获取兄弟元素&quot; onclick=&quot;fun7()&quot; id=&quot;btn07&quot;/&gt;\n    &lt;hr&gt;\n\n    &lt;input type=&quot;button&quot; value=&quot;根据id获取指定元素&quot; onclick=&quot;fun1()&quot; id=&quot;btn01&quot;/&gt;\n    &lt;input type=&quot;button&quot; value=&quot;根据标签名获取多个元素&quot; onclick=&quot;fun2()&quot; id=&quot;btn02&quot;/&gt;\n    &lt;input type=&quot;button&quot; value=&quot;根据name属性值获取多个元素&quot; onclick=&quot;fun3()&quot; id=&quot;btn03&quot;/&gt;\n    &lt;input type=&quot;button&quot; value=&quot;根据class属性值获得多个元素&quot; onclick=&quot;fun4()&quot; id=&quot;btn04&quot;/&gt;\n    \n&lt;/body&gt;\n&lt;/html&gt;7.3 操作元素属性值快速理解\n\n\n\n\n\n\n\n\n\n\n操作元素的属性：元素名.属性名=&quot;&quot;\n操作元素的样式：元素名.style.样式名=&quot;&quot; 注意：样式名&quot;-&quot;要进行驼峰转换\n操作元素的文本：①元素名.innerText只识别文本 ②元素名.innerHTML同时可以识别html代码\n\n7.3.1 属性操作\n\n\n需求\n操作方式\n\n\n\n读取属性值\n元素对象.属性名\n\n\n修改属性值\n元素对象.属性名=新的属性值\n\n\n7.3.2 内部文本操作\n\n\n需求\n操作方式\n\n\n\n获取或者设置标签体的文本内容\nelement.innerText\n\n\n获取或者设置标签体的内容\nelement.innerHTML\n\n\n代码实现\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n   &lt;script&gt;\n    /* \n    1 获得document  dom树\n        window.document\n    2 从document中获取要操作的元素\n        1. 直接获取\n            var el1 =document.getElementById(&quot;username&quot;) // 根据元素的id值获取页面上唯一的一个元素\n            var els =document.getElementsByTagName(&quot;input&quot;) // 根据元素的标签名获取多个同名元素\n            var els =document.getElementsByName(&quot;aaa&quot;) // 根据元素的name属性值获得多个元素\n            var els =document.getElementsByClassName(&quot;a&quot;) // 根据元素的class属性值获得多个元素\n        2. 间接获取\n            var cs=div01.children // 通过父元素获取全部的子元素\n            var firstChild =div01.firstElementChild  // 通过父元素获取第一个子元素\n            var lastChild = div01.lastElementChild   // 通过父元素获取最后一个子元素\n            var parent = pinput.parentElement  // 通过子元素获取父元素\n            var pElement = pinput.previousElementSibling // 获取前面的第一个元素\n            var nElement = pinput.nextElementSibling // 获取后面的第一个元素\n    3 对元素进行操作\n        1. 操作元素的属性   元素名.属性名=&quot;&quot;\n        2. 操作元素的样式   元素名.style.样式名=&quot;&quot;  样式名&quot;-&quot; 要进行驼峰转换\n        3. 操作元素的文本   元素名.innerText   只识别文本\n                           元素名.innerHTML   同时可以识别html代码 \n        4. 增删元素   \n    */\n   function changeAttribute()&#123;\n        var in1 =document.getElementById(&quot;in1&quot;)\n        // 语法 元素.属性名=&quot;&quot;\n        // 获得属性值\n        console.log(in1.type)\n        console.log(in1.value)\n        // 修改属性值\n        in1.type=&quot;button&quot;\n        in1.value=&quot;嗨&quot;\n   &#125;\n   function changeStyle()&#123;\n        var in1 =document.getElementById(&quot;in1&quot;)\n        // 语法  元素.style.样式名=&quot;&quot;   原始样式名中的&quot;-&quot;符号 要转换驼峰式  background-color &gt; backgroundColor\n        in1.style.color=&quot;green&quot;\n        in1.style.borderRadius=&quot;5px&quot;\n        \n   &#125;\n   function changeText()&#123;\n        var div01 =document.getElementById(&quot;div01&quot;)\n        /* \n        语法  元素名.innerText   只识别文本\n              元素名.innerHTML   同时可以识别html代码\n        */\n        console.log(div01.innerText)\n        div01.innerHTML=&quot;&lt;h1&gt;嗨&lt;/h1&gt;&quot;\n   &#125;\n\n   &lt;/script&gt;\n   &lt;style&gt;\n    #in1&#123;\n        color: red;\n    &#125;\n   &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input id=&quot;in1&quot; type=&quot;text&quot; value=&quot;hello&quot;&gt;\n    &lt;div id=&quot;div01&quot;&gt;\n        hello\n    &lt;/div&gt;\n\n    &lt;hr&gt;\n    &lt;button onclick=&quot;changeAttribute()&quot;&gt;操作属性&lt;/button&gt;\n    &lt;button onclick=&quot;changeStyle()&quot;&gt;操作样式&lt;/button&gt;\n    &lt;button onclick=&quot;changeText()&quot;&gt;操作文本&lt;/button&gt;\n    \n&lt;/body&gt;\n&lt;/html&gt;7.4 增删元素快速理解\n\n\n\n\n\n\n\n\n\n创建元素：var element = document.createElement(&quot;元素名&quot;)\n在父元素中追加子元素：父元素.appendChild(子元素)\n在某个元素前增加元素：父元素.insertBefore(新元素,参照元素)\n用新的元素替换某个子元素：父元素.replaceChild(新元素,被替换的元素)\n删除当前元素：元素.remove()\n7.4.1 对页面的元素进行增删操作\n\n\nAPI\n功能\n\n\n\ndocument.createElement(&quot;标签名&quot;)\n创建元素节点并返回，但不会自动添加到文档中\n\n\ndocument.createTextNode(“文本值”)\n创建文本节点并返回，但不会自动添加到文档中\n\n\nelement.appendChild(ele)\n将ele添加到element所有子节点后面\n\n\nparentEle.insertBefore(newEle,targetEle)\n将newEle插入到targetEle前面\n\n\nparentEle.replaceChild(newEle, oldEle)\n用新节点替换原有的旧子节点\n\n\nelement.remove()\n删除某个标签\n\n\n代码实现\n!!!注意：\n\n如果使用cityul.remove()删除的是整个&lt;ul&gt;&lt;/ul&gt;\n使用cityul.innerHTML=&quot;&quot;可以使&lt;ul&gt;&lt;/ul&gt;中文本的内容变为空，并不会删除&lt;ul&gt;标签\n使用var fc = cityul.firstChild删除列表第一个也不会删除&lt;ul&gt;标签\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n   &lt;script&gt;\n    /* \n    1 获得document  dom树\n        window.document\n    2 从document中获取要操作的元素\n        1. 直接获取\n            var el1 =document.getElementById(&quot;username&quot;) // 根据元素的id值获取页面上唯一的一个元素\n            var els =document.getElementsByTagName(&quot;input&quot;) // 根据元素的标签名获取多个同名元素\n            var els =document.getElementsByName(&quot;aaa&quot;) // 根据元素的name属性值获得多个元素\n            var els =document.getElementsByClassName(&quot;a&quot;) // 根据元素的class属性值获得多个元素\n        2. 间接获取\n            var cs=div01.children // 通过父元素获取全部的子元素\n            var firstChild =div01.firstElementChild  // 通过父元素获取第一个子元素\n            var lastChild = div01.lastElementChild   // 通过父元素获取最后一个子元素\n            var parent = pinput.parentElement  // 通过子元素获取父元素\n            var pElement = pinput.previousElementSibling // 获取前面的第一个元素\n            var nElement = pinput.nextElementSibling // 获取后面的第一个元素\n    3 对元素进行操作\n        1. 操作元素的属性   元素名.属性名=&quot;&quot;\n        2. 操作元素的样式   元素名.style.样式名=&quot;&quot;  样式名&quot;-&quot; 要进行驼峰转换\n        3. 操作元素的文本   元素名.innerText   只识别文本\n                           元素名.innerHTML   同时可以识别html代码 \n        4. 增删元素\n            var element =document.createElement(&quot;元素名&quot;) // 创建元素\n            父元素.appendChild(子元素)               // 在父元素中追加子元素\n            父元素.insertBefore(新元素,参照元素)     // 在某个元素前增加元素\n            父元素.replaceChild(新元素,被替换的元素) // 用新的元素替换某个子子元素\n            元素.remove()                            // 删除当前元素\n    */\n   function addCs()&#123;\n        // 创建一个新的元素\n        // 创建元素\n        var csli =document.createElement(&quot;li&quot;) // &lt;li&gt;&lt;/li&gt;\n        // 设置子元素的属性和文本 &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt;\n        csli.id=&quot;cs&quot;\n        csli.innerText=&quot;长沙&quot;\n        // 将子元素放入父元素中\n        var cityul =document.getElementById(&quot;city&quot;)\n        // 在父元素中追加子元素\n        cityul.appendChild(csli)\n   &#125;\n   function addCsBeforeSz()&#123;\n        // 创建一个新的元素\n        // 创建元素\n        var csli =document.createElement(&quot;li&quot;) // &lt;li&gt;&lt;/li&gt;\n        // 设置子元素的属性和文本 &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt;\n        csli.id=&quot;cs&quot;\n        csli.innerText=&quot;长沙&quot;\n        // 将子元素放入父元素中\n        var cityul =document.getElementById(&quot;city&quot;)\n        // 在父元素中追加子元素\n        //cityul.insertBefore(新元素,参照元素)\n        var szli =document.getElementById(&quot;sz&quot;)\n        cityul.insertBefore(csli,szli)\n   &#125;\n\n   function replaceSz()&#123;\n        // 创建一个新的元素\n        // 创建元素\n        var csli =document.createElement(&quot;li&quot;) // &lt;li&gt;&lt;/li&gt;\n        // 设置子元素的属性和文本 &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt;\n        csli.id=&quot;cs&quot;\n        csli.innerText=&quot;长沙&quot;\n        // 将子元素放入父元素中\n        var cityul =document.getElementById(&quot;city&quot;)\n        // 在父元素中追加子元素\n        //cityul.replaceChild(新元素,被替换的元素)\n        var szli =document.getElementById(&quot;sz&quot;)\n        cityul.replaceChild(csli,szli)\n   &#125;\n\n   function removeSz()&#123;\n        var szli =document.getElementById(&quot;sz&quot;)\n        // 哪个元素调用了remove该元素就会从dom树中移除\n        szli.remove()\n   &#125;\n\n   function clearCity()&#123;\n        \n        var cityul =document.getElementById(&quot;city&quot;)\n\n        /* var fc =cityul.firstChild\n        while(fc != null )&#123;\n            fc.remove()\n            fc =cityul.firstChild\n        &#125; */\n        cityul.innerHTML=&quot;&quot;\n        //cityul.remove()\n        \n   &#125;\n   \n   &lt;/script&gt;\n   \n&lt;/head&gt;\n&lt;body&gt;\n    &lt;ul id=&quot;city&quot;&gt;\n        &lt;li id=&quot;bj&quot;&gt;北京&lt;/li&gt;\n        &lt;li id=&quot;sh&quot;&gt;上海&lt;/li&gt;\n        &lt;li id=&quot;sz&quot;&gt;深圳&lt;/li&gt;\n        &lt;li id=&quot;gz&quot;&gt;广州&lt;/li&gt;\n    &lt;/ul&gt;\n\n    &lt;hr&gt;\n    &lt;!-- 目标1 在城市列表的最后添加一个子标签  &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt;  --&gt;\n    &lt;button onclick=&quot;addCs()&quot;&gt;增加长沙&lt;/button&gt;\n    &lt;!-- 目标2 在城市列表的深圳前添加一个子标签  &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt;  --&gt;\n    &lt;button onclick=&quot;addCsBeforeSz()&quot;&gt;在深圳前插入长沙&lt;/button&gt;\n    &lt;!-- 目标3  将城市列表的深圳替换为  &lt;li id=&quot;cs&quot;&gt;长沙&lt;/li&gt;  --&gt;\n    &lt;button onclick=&quot;replaceSz()&quot;&gt;替换深圳&lt;/button&gt;\n    &lt;!-- 目标4  将城市列表删除深圳  --&gt;\n    &lt;button onclick=&quot;removeSz()&quot;&gt;删除深圳&lt;/button&gt;\n    &lt;!-- 目标5  清空城市列表  --&gt;\n    &lt;button onclick=&quot;clearCity()&quot;&gt;清空&lt;/button&gt;\n    \n&lt;/body&gt;\n&lt;/html&gt;\n八、正则表达式8.1 正则表达式简介\n\n\n\n\n\n\n\n\n正则表达式是描述字符模式的对象。正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。\n\n语法\n\njavascriptvar patt=new RegExp(pattern,modifiers);\n或者更简单的方式:\nvar patt=/pattern/modifiers; \n\n\n\n\n\n\n\n\n修饰符\n\n\n\n修饰符\n描述\n\n\n\ni\n执行对大小写不敏感的匹配。\n\n\ng\n执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。\n\n\nm\n执行多行匹配。\n\n\n\n\n\n\n\n\n\n\n\n方括号\n\n\n\n表达式\n描述\n\n\n\n[abc]\n查找方括号之间的任何字符。\n\n\n[^abc]\n查找任何不在方括号之间的字符。\n\n\n[0-9]\n查找任何从 0 至 9 的数字。\n\n\n[a-z]\n查找任何从小写 a 到小写 z 的字符。\n\n\n[A-Z]\n查找任何从大写 A 到大写 Z 的字符。\n\n\n[A-z]\n查找任何从大写 A 到小写 z 的字符。\n\n\n[adgk]\n查找给定集合内的任何字符。\n\n\n[^adgk]\n查找给定集合外的任何字符。\n\n\n(red|blue|green)\n查找任何指定的选项。\n\n\n\n\n\n\n\n\n\n\n\n元字符\n\n\n\n元字符\n描述\n\n\n\n.\n查找单个字符，除了换行和行结束符。\n\n\n\\w\n查找数字、字母及下划线。\n\n\n\\W\n查找非单词字符。\n\n\n\\d\n查找数字。\n\n\n\\D\n查找非数字字符。\n\n\n\\s\n查找空白字符。\n\n\n\\S\n查找非空白字符。\n\n\n\\b\n匹配单词边界。\n\n\n\\B\n匹配非单词边界。\n\n\n\\0\n查找 NULL 字符。\n\n\n\\n\n查找换行符。\n\n\n\\f\n查找换页符。\n\n\n\\r\n查找回车符。\n\n\n\\t\n查找制表符。\n\n\n\\v\n查找垂直制表符。\n\n\n\\xxx\n查找以八进制数 xxx 规定的字符。\n\n\n\\xdd\n查找以十六进制数 dd 规定的字符。\n\n\n\\uxxxx\n查找以十六进制数 xxxx 规定的 Unicode 字符。\n\n\n\n\n\n\n\n\n\n\n\n量词\n\n\n\n量词\n描述\n\n\n\nn+\n匹配任何包含至少一个 n 的字符串。例如，&#x2F;a+&#x2F; 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。\n\n\nn*\n匹配任何包含零个或多个 n 的字符串。例如，&#x2F;bo*&#x2F; 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。\n\n\nn?\n匹配任何包含零个或一个 n 的字符串。例如，&#x2F;e?le?&#x2F; 匹配 “angel” 中的 “el”，”angle” 中的 “le”。\n\n\nn{X}\n匹配包含 X 个 n 的序列的字符串。例如，&#x2F;a{2}&#x2F; 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。\n\n\nn{X,}\nX 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，&#x2F;a{2,}&#x2F; 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。\n\n\nn{X,Y}\nX 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，&#x2F;a{1,3}&#x2F; 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。\n\n\nn$\n匹配任何结尾为 n 的字符串。\n\n\n^n\n匹配任何开头为 n 的字符串。\n\n\n?&#x3D;n\n匹配任何其后紧接指定字符串 n 的字符串。\n\n\n?!n\n匹配任何其后没有紧接指定字符串 n 的字符串。\n\n\n\n\n\n\n\n\n\n\n\nRegExp对象方法\n\n\n\n方法\n描述\n\n\n\ncompile\n在 1.5 版本中已废弃。 编译正则表达式。\n\n\nexec\n检索字符串中指定的值。返回找到的值，并确定其位置。\n\n\ntest\n检索字符串中指定的值。返回 true 或 false。\n\n\ntoString\n返回正则表达式的字符串。\n\n\n\n\n\n\n\n\n\n\n\n支持正则的String的方法\n\n\n\n方法\n描述\n\n\n\nsearch\n检索与正则表达式相匹配的值。\n\n\nmatch\n找到一个或多个正则表达式的匹配。\n\n\nreplace\n替换与正则表达式匹配的子串。\n\n\nsplit\n把字符串分割为字符串数组。\n\n\n8.2 正则表达式体验8.2.1 验证注意：这里是使用正则表达式对象来调用方法。\njavascript// 创建一个最简单的正则表达式对象\nvar reg = /o/;\n// 创建一个字符串对象作为目标字符串\nvar str = &#39;Hello World!&#39;;\n// 调用正则表达式对象的test()方法验证目标字符串是否满足我们指定的这个模式，返回结果true\nconsole.log(&quot;/o/.test(&#39;Hello World!&#39;)=&quot;+reg.test(str));8.2.2 匹配注意：这里使用的是字符串对象来调用方法\njavascript// 创建一个最简单的正则表达式对象\nvar reg = /o/;\n// 创建一个字符串对象作为目标字符串\nvar str = &#39;Hello World!&#39;;\n// 在目标字符串中查找匹配的字符，返回匹配结果组成的数组\nvar resultArr = str.match(reg);\n// 数组长度为1\nconsole.log(&quot;resultArr.length=&quot;+resultArr.length);\n\n// 数组内容是o\nconsole.log(&quot;resultArr[0]=&quot;+resultArr[0]);8.2.3 替换注意：这里是使用字符串对象来调用方法。\njavascript// 创建一个最简单的正则表达式对象\nvar reg = /o/;\n// 创建一个字符串对象作为目标字符串\nvar str = &#39;Hello World!&#39;;\nvar newStr = str.replace(reg,&#39;@&#39;);\n// 只有第一个o被替换了，说明我们这个正则表达式只能匹配第一个满足的字符串\nconsole.log(&quot;str.replace(reg)=&quot;+newStr);//Hell@ World!\n\n// 原字符串并没有变化，只是返回了一个新字符串\nconsole.log(&quot;str=&quot;+str);//str=Hello World!8.2.4  全文查找如果不使用g对正则表达式对象进行修饰，则使用正则表达式进行查找时，仅返回第一个匹配；使用g后，返回所有匹配。\njavascript// 目标字符串\nvar targetStr = &#39;Hello World!&#39;;\n\n// 没有使用全局匹配的正则表达式\nvar reg = /[A-Z]/;\n// 获取全部匹配\nvar resultArr = targetStr.match(reg);\n// 数组长度为1\nconsole.log(&quot;resultArr.length=&quot;+resultArr.length);\n// 遍历数组，发现只能得到&#39;H&#39;\nfor(var i = 0; i &lt; resultArr.length; i++)&#123;\n  console.log(&quot;resultArr[&quot;+i+&quot;]=&quot;+resultArr[i]);\n&#125;对比\njavascript// 目标字符串\nvar targetStr = &#39;Hello World!&#39;;\n// 使用了全局匹配的正则表达式\nvar reg = /[A-Z]/g;\n// 获取全部匹配\nvar resultArr = targetStr.match(reg);\n// 数组长度为2\nconsole.log(&quot;resultArr.length=&quot;+resultArr.length);\n// 遍历数组，发现可以获取到“H”和“W”\nfor(var i = 0; i &lt; resultArr.length; i++)&#123;\n  console.log(&quot;resultArr[&quot;+i+&quot;]=&quot;+resultArr[i]);\n&#125;8.2.5 忽略大小写javascript//目标字符串\nvar targetStr = &#39;Hello WORLD!&#39;;\n\n//没有使用忽略大小写的正则表达式\nvar reg = /o/g;\n//获取全部匹配\nvar resultArr = targetStr.match(reg);\n//数组长度为1\nconsole.log(&quot;resultArr.length=&quot;+resultArr.length);\n//遍历数组，仅得到&#39;o&#39;\nfor(var i = 0; i &lt; resultArr.length; i++)&#123;\n  console.log(&quot;resultArr[&quot;+i+&quot;]=&quot;+resultArr[i]);\n&#125;对比\njavascript//目标字符串\nvar targetStr = &#39;Hello WORLD!&#39;;\n//使用了忽略大小写的正则表达式\nvar reg = /o/gi;\n//获取全部匹配\nvar resultArr = targetStr.match(reg);\n//数组长度为2\nconsole.log(&quot;resultArr.length=&quot;+resultArr.length);\n//遍历数组，得到&#39;o&#39;和&#39;O&#39;\nfor(var i = 0; i &lt; resultArr.length; i++)&#123;\n  console.log(&quot;resultArr[&quot;+i+&quot;]=&quot;+resultArr[i]);\n&#125;8.2.6 元字符使用javascriptvar str01 = &#39;I love Java&#39;;\nvar str02 = &#39;Java love me&#39;;\n// 匹配以Java开头\nvar reg = /^Java/g;\nconsole.log(&#39;reg.test(str01)=&#39;+reg.test(str01)); // false\nconsole.log(&quot;&lt;br /&gt;&quot;);\nconsole.log(&#39;reg.test(str02)=&#39;+reg.test(str02)); // truejavascriptvar str01 = &#39;I love Java&#39;;\nvar str02 = &#39;Java love me&#39;;\n// 匹配以Java结尾\nvar reg = /Java$/g;\nconsole.log(&#39;reg.test(str01)=&#39;+reg.test(str01)); // true\nconsole.log(&quot;&lt;br /&gt;&quot;);\nconsole.log(&#39;reg.test(str02)=&#39;+reg.test(str02)); // false8.2.7 字符集合的使用javascript//n位数字的正则\nvar targetStr=&quot;123456789&quot;;\nvar reg=/^[0-9]&#123;0,&#125;$/;\n//或者 ： var reg=/^\\d*$/;\nvar b = reg.test(targetStr);//truejavascript//数字+字母+下划线，6-16位\nvar targetStr=&quot;HelloWorld&quot;;\nvar reg=/^[a-z0-9A-Z_]&#123;6,16&#125;$/;\nvar b = reg.test(targetStr);//true8.2.8  常用正则表达式\n\n\n需求\n正则表达式\n\n\n\n用户名\n&#x2F;^[a-zA-Z ][a-zA-Z-0-9]{5,9}$&#x2F;\n\n\n密码\n&#x2F;^[a-zA-Z0-9 _-@#&amp; *]{6,12}$&#x2F;\n\n\n前后空格\n&#x2F;^\\s+|\\s+$&#x2F;g\n\n\n电子邮箱\n&#x2F;^[a-zA-Z0-9 _.-]+@([a-zA-Z0-9-]+[.]{1})+[a-zA-Z]+$&#x2F;\n\n\n","slug":"Javaweb_JavaScript","date":"2023-12-05T16:32:00.000Z","categories_index":"Javaweb","tags_index":"Javaweb","author_index":"白"},{"id":"8b3d229c812de5f72244620edb5f9588","title":"算法学习_链表篇","content":"算法学习_链表篇学习至：代码随想录 (programmercarl.com)\n链表的类型单链表链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。\n链表的入口节点称为链表的头结点也就是head。\n\n双链表单链表中的指针域只能指向节点的下一个节点。\n双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。\n双链表 既可以向前查询也可以向后查询。 \n\n循环链表循环链表，顾名思义，就是链表首尾相连。\n循环链表可以用来解决约瑟夫环问题。\n\n\n链表的操作删除节点删除D节点，如图所示：\n\n只要将C节点的next指针 指向E节点就可以了。\n添加节点如图所示：\n\n可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。\n但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。\n\n性能分析再把链表的特性和数组的特性进行一个对比，如图所示：\n\n\n\n\n插入删除（时间复杂度)\n查询（时间复杂度)\n适用场景\n\n\n\n数组\nO(n)\nO(1)\n数据量固定，频繁查询，较少增删\n\n\n链表\nO(1)\nO(n)\n数据量不固定，频繁增删，较少查询\n\n\nJava：\njavapublic class ListNode &#123;\n    // 结点的值\n    int val;\n\n    // 下一个结点\n    ListNode next;\n\n    // 节点的构造函数(无参)\n    public ListNode() &#123;\n    &#125;\n\n    // 节点的构造函数(有一个参数)\n    public ListNode(int val) &#123;\n        this.val = val;\n    &#125;\n\n    // 节点的构造函数(有两个参数)\n    public ListNode(int val, ListNode next) &#123;\n        this.val = val;\n        this.next = next;\n    &#125;\n&#125;\n移除链表元素题目\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n示例 1：\n\ntxt输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]示例 2：\ntxt输入：head = [], val = 1\n输出：[]示例 3：\ntxt输入：head = [7,7,7,7], val = 7\n输出：[]思路\n\n\n红色标记的prev，head表示链表开始时，head为遍历当前链表所在位置，prev为该结点的上一个结点。dummy指向头结点，返回结果为dummy-&gt;next。\n若当前的值满足head.val == val，则将prev移到head的下一个位置，如图第一条灰色线。执行prev.next = head.next，prev的下一位执行了2所在位置。\n若当前的值不满足head.val == val，则将prev移到当前位置。执行prev = head。\nwhile循环里遍历链表head = head.next。\n\n代码实现\njavapublic ListNode removeElements(ListNode head, int val) &#123;\n    //设置一个虚拟指向头结点的指针\n    ListNode dummy = new ListNode(0);\n    ListNode prev = new ListNode(0);\n    dummy.next = head;\n    //设置一个指向前一个结点的指针，方便移除链表元素\n    prev = dummy;\n    while (head != null) &#123;\n        //相等则移除\n        if (head.val == val) &#123;\n            prev.next = head.next;\n        &#125; else &#123;\n            //匹配失败把prev移到当前位置\n            prev = head;\n        &#125;\n        head = head.next;\n    &#125;\n    return dummy.next;\n&#125;\n设计链表 - 力扣题目\n你可以选择使用单链表或者双链表，设计并实现自己的链表。\n单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。\n如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\n实现 MyLinkedList 类：\n\nMyLinkedList() 初始化 MyLinkedList 对象。\nint get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\nvoid addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\nvoid addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\nvoid addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\nvoid deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\n\n 示例：\ntxt输入\n[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]\n[[], [1], [3], [1, 2], [1], [1], [1]]\n输出\n[null, null, null, null, 2, null, 3]\n\n解释\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3\nmyLinkedList.get(1);              // 返回 2\nmyLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3\nmyLinkedList.get(1);              // 返回 3思路\n\n每次对链表操作设置一个新的虚拟头结点current，不能直接对原链表头结点直接操作。\n如果有添加或者删除结点的操作时注意对size操作，并且需要设置prev指向上一个结点，current指向当前结点。\nsize表示链表长度，该链表下标由0开始，因此注意边界条件为(index &lt; 0 || index &gt;= size)\n\n该题难度不大，为了熟练对链表操作的掌握。\n代码实现\njavaclass MyLinkedList &#123;\n    //size存储链表元素的个数\n    int size;\n    //虚拟头结点\n    ListNode dummy;\n    public MyLinkedList() &#123;\n        size = 0;\n        dummy = new ListNode(0);\n    &#125;\n\n    public int get(int index) &#123;\n        //遍历链表获取链表中下标为index的节点的值\n        if(index &lt; 0 || index &gt;= size) &#123;\n            return -1; //下标无效\n        &#125;\n        //定义一个头结点\n        ListNode current = dummy;\n        for (int i = 0; i &lt; size; i++) &#123;\n            current = current.next;\n            if(i == index) &#123;\n                break;\n            &#125;\n        &#125;\n        return current.val;\n    &#125;\n    //插入到第一个元素之前\n    public void addAtHead(int val) &#123;\n        //新设一个头结点\n        ListNode current = dummy;\n        //需要插入的结点\n        ListNode newval  = new ListNode(val);\n        newval.next = current.next;\n        current.next = newval;\n        size++; //插入后链表长度发生变化\n    &#125;\n\n    //插入到最后一位\n    public void addAtTail(int val) &#123;\n        //新设一个头结点，遍历到链表最后一位\n        ListNode current = dummy;\n        for (int i = 0; i &lt; size; i++) &#123;\n            current = current.next;\n        &#125;\n        ListNode newval = new ListNode(val);\n        newval.next = null;\n        current.next = newval;\n        size++;\n    &#125;\n\n    public void addAtIndex(int index, int val) &#123;\n        if(index &gt; size) &#123;\n            return;\n        &#125;\n        //小于最小的结点则插入头\n        if(index &lt; 0) &#123;\n            addAtHead(val);\n        &#125; else if (index == size) &#123; //刚好等于链表长度,插入尾\n            addAtTail(val);\n        &#125; else &#123; //在链表中\n            //遍历链表的指针\n            ListNode current = dummy.next;\n            //前一个的指针\n            ListNode prev = dummy;\n            for (int i = 0; i &lt; size; i++) &#123;\n                if (i == index) &#123;\n                    //新数据\n                    ListNode node = new ListNode(val);\n                    node.next = current;\n                    prev.next = node;\n                    size++;\n                    break;\n                &#125;\n                prev = current;\n                if (current.next != null) &#123;\n                    current = current.next;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    public void deleteAtIndex(int index) &#123;\n        if (index &lt; 0 || index &gt; size) &#123;\n            return;\n        &#125;\n        //有效进行删除\n        ListNode prev = dummy;\n        ListNode current = dummy.next;\n        for (int i = 0; i &lt; size; i++) &#123;\n            if (i == index) &#123;\n                prev.next = current.next;\n                size--;\n                break;\n            &#125;\n            prev = current;\n            if (current.next != null) &#123;\n                current = current.next;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n反转链表 题目\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n\ntxt输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]示例 2：\ntxt输入：head = [1,2]\n输出：[2,1]示例 3：\ntxt输入：head = []\n输出：[]思路\n如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。\n其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。\n之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改变next指针的方向。\n\n动画应该是先移动pre，在移动cur\n\n首先定义一个cur指针，指向头结点，再定义一个prev指针，初始化为null。\n然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。\n为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向，将cur-&gt;next 指向prev ，此时已经反转了第一个节点了。\n反转过后应该遍历链表。循环条件：while(cur != null)，遍历链表：prev = cur，cur = temp。\n最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。\n\n\n代码实现\n双指针法\n时间复杂度: O(n)\n空间复杂度: O(1)\n\njavapublic ListNode reverseList(ListNode head) &#123;\n    //保存cur下一个结点\n    ListNode temp = new ListNode();\n    ListNode cur = head;\n    ListNode prev = null;\n    while (cur != null) &#123;\n        temp = cur.next; //临时存储下一个结点\n        cur.next = prev;\n        //移动prev和cur指针\n        prev = cur;\n        cur = temp;\n    &#125;\n    return prev;\n&#125;递归法\n时间复杂度: O(n), 要递归处理链表的每个节点\n空间复杂度: O(n), 递归调用了 n 层栈空间\n\njavapublic ListNode reverseList(ListNode head) &#123;\n        return reverse(null, head);\n&#125;\nprivate ListNode reverse(ListNode prev, ListNode cur) &#123;\n    if (cur == null) &#123;\n       return prev;\n    &#125;\n    ListNode temp = null;\n    temp = cur.next; //保存下一个结点\n    cur.next = prev; //反转\n    //更新prev和cur位置\n    //prev = cur;\n    //cur = temp;\n    return reverse(cur, temp);\n&#125;\n 两两交换链表中的节点 题目\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n示例 1：\n\ntxt输入：head = [1,2,3,4]\n输出：[2,1,4,3]示例 2：\ntxt输入：head = []\n输出：[]示例 3：\ntxt输入：head = [1]\n输出：[1]思路\n画图操作步骤如下，当temp存在的话就进行交换，因此条件为temp != null。\n\n代码实现\njavapublic ListNode swapPairs(ListNode head) &#123;\n    //设置虚拟头结点dummy用来返回\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    //前一个指针\n    ListNode prev = dummy;\n    while (head != null) &#123;\n        ListNode temp = head.next;\n        //如果后面的元素不为空则交换\n        if (temp != null) &#123;\n            prev.next = temp;\n            head.next = temp.next;\n            temp.next = head;\n        &#125;\n        prev = head;\n        head = head.next;\n    &#125;\n    return dummy.next;\n&#125;\n删除链表的倒数第N个结点 题目\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n 示例 1：\n\ntxt输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]示例 2：\ntxt输入：head = [1], n = 1\n输出：[]示例 3：\ntxt输入：head = [1,2], n = 1\n输出：[1]思路\n双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。\n但是需要注意一些细节\n\n定义fast指针和slow指针，初始值为虚拟头结点。\n\nfast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： \n\nfast和slow同时移动，直到fast指向末尾，如题： \n\n删除slow指向的下一个节点，如图： \n\n\n代码实现\njavapublic ListNode removeNthFromEnd(ListNode head, int n) &#123;\n    //设置一个虚拟头结点，用来返回\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    //设置快慢指针,快指针先走n+1步\n    ListNode fast = dummy;\n    ListNode slow = dummy;\n    //快指针先走n+1步\n    while (n-- &gt; 0 &amp;&amp; fast != null) &#123;\n        fast = fast.next;\n    &#125;\n    //再移动一次fast\n    fast = fast.next;\n    //同时移动快慢指针，当fast指针指向null停止\n    while (fast != null) &#123;\n        fast = fast.next;\n        slow = slow.next;\n    &#125;\n    //删除slow下一个结点\n    slow.next = slow.next.next;\n    return dummy.next;\n&#125;\n面试题 02.07. 链表相交题目\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1：\n\ntxt输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at &#39;8&#39;\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。示例 2：\n\ntxt输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at &#39;2&#39;\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。示例 3：\n\ntxt输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。思路\n简单来说，就是求两个链表交点节点的指针。 这里要注意，交点不是数值相等，而是指针相等。\n为了方便举例，假设节点元素数值相等，则节点指针相等。\n看如下两个链表，目前curA指向链表A的头结点，curB指向链表B的头结点：\n\n我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，如图：\n\n此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。\n否则循环退出返回空指针。\n代码实现\njavapublic ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\n    //设置两个指针，分别指向链表A和链表B的头结点\n    ListNode curA = headA;\n    ListNode curB = headB;\n    int lenA = 0;\n    int lenB = 0;\n    //计算链表A和链表B的长度\n    while (curA!= null) &#123;\n        lenA++;\n        curA = curA.next;\n    &#125;\n    while (curB!= null) &#123;\n        lenB++;\n        curB = curB.next;\n    &#125;\n    curA = headA;\n    curB = headB;\n    //比较两个链表的长度，将较长的链表的指针cur向后移动abs(curA-curB)个位置\n    if (lenA &gt; lenB) &#123;\n        for (int i = 0; i &lt; lenA - lenB; i++) &#123;\n            curA = curA.next;\n        &#125;\n    &#125; else &#123;\n        for (int i = 0; i &lt; lenB - lenA; i++) &#123;\n            curB = curB.next;\n        &#125;\n    &#125;\n    //同时遍历两个链表，找到指针指向的数值相同的则返回交点\n    while (curA!= null &amp;&amp; curB!= null) &#123;\n        if (curA == curB) &#123;\n            return curA;\n        &#125;\n        curA = curA.next;\n        curB = curB.next;\n    &#125;\n    return null;\n&#125;\n环形链表题目\n给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n示例 1：\n\ntxt输入：head = [3,2,0,-4], pos = 1\n输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。示例 2：\n\ntxt输入：head = [1,2], pos = 0\n输出：返回索引为 0 的链表节点\n解释：链表中有一个环，其尾部连接到第一个节点。示例 3：\n\ntxt输入：head = [1], pos = -1\n输出：返回 null\n解释：链表中没有环。思路\n注意：判断时是判断指针是否相等，而不是判断val值是否相等。\n考察两知识点：\n\n判断链表是否环\n如果有环，如何找到这个环的入口\n\n1、判断链表是否有环\n可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。\n为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢\n首先第一点：fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。\n那么来看一下，为什么fast指针和slow指针一定会相遇呢？\n可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。\n会发现最终都是这种情况， 如下图：\n\nfast和slow各自再走一步， fast和slow就相遇了\n这是因为fast是走两步，slow是走一步，其实相对于slow来说，fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合。\n动画如下：\n\n2、如果有环，如何找到这个环的入口\n此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。\n假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：\n\n那么相遇时： slow指针走过的节点数为: x + y， fast指针走过的节点数：x + y + n (y + z)，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。\n因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 &#x3D; slow指针走过的节点数 * 2：\ntxt(x + y) * 2 = x + y + n (y + z)两边消掉一个（x+y）: x + y = n (y + z)\n因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。\n所以要求x ，将x单独放在左面：x = n (y + z) - y ,\n再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。\n这个公式说明什么呢？\n先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。\n当 n为1的时候，公式就化解为 x = z，\n这就意味着，从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\n也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。\n让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。\n动画如下：\n\n那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。\n其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。\n代码实现\njavapublic ListNode detectCycle(ListNode head) &#123;\n    //定义快慢指针\n    ListNode fast = head;\n    ListNode slow = head;\n    //快指针每次走两格，慢指针每次走一格，相遇则为环\n    while (fast != null &amp;&amp; fast.next != null) &#123;\n        fast = fast.next.next;\n        slow = slow.next;\n        //找到则找index。\n        if (fast == slow) &#123;\n            ListNode index1 = fast;\n            ListNode index2 = head;\n            // 两个指针分别从头结点和相遇结点开始移动，直到相遇\n            while (index1 != index2) &#123;\n                index1 = index1.next;\n                index2 = index2.next;\n            &#125;\n            return index1;\n        &#125;\n    &#125;\n    //没有进入while说明fast为空，没有成环\n    return null;\n&#125;\n链表总结\n","slug":"算法-链表","date":"2023-12-05T11:33:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"白"},{"id":"f3f2df35f49c4b62e5dd8763403aa68d","title":"HTML&CSS笔记","content":"第一章 HTML&amp;CSS笔记一 HTML入门1.1 HTML&amp;CSS&amp;JavaScript的作用\nHTML 主要用于网页主体结构的搭建\nCSS 主要用于页面元素美化\t\nJavaScript 主要用于页面元素的动态处理\n\n1.2 HTML基础结构\n文档声明\n\nHTML文件中第一行的内容，用来告诉浏览器当前HTML文档的基本信息，其中最重要的就是当前HTML文档遵循的语法标准。这里我们只需要知道HTML有4和5这两个大的版本\nHTML4版本的文档类型声明是：\n\nhtml&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;\n&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\nHTML5版本的文档类型声明是：\n\nhtml&lt;!DOCTYPE html&gt;\n根标签\n\nhtml标签是整个文档的根标签，所有其他标签都必须放在html标签里面。\n\n\n头部元素\n\nhead标签用于定义文档的头部，其他头部元素都放在head标签里。头部元素包括title标签、script标签、style标签、link标签、meta标签等等。\n\n\n主体元素\n\nbody标签定义网页的主体内容，在浏览器窗口内显示的内容都定义到body标签内。\n\n\n注释\n\nHTML注释的写法是\n\ntxt&lt;!-- 注释内容 --&gt;\n\n基础结构演示\n\n1.3 HTML的入门程序代码实现\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;我的第一个html&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello VSCode 你好世界&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;结果演示\n\n1.4 HTML概念词汇解释\n标签\n代码中的一个 &lt;&gt; 叫做一个标签,有些标签成对出现,称之为双标签,有些标签单独出现,称之为单标签\n\n\n属性\n一般在开始标签中,用于定义标签的一些特征\n\n\n文本\n双标签中间的文字,包含空格换行等结构\n\n\n元素\n经过浏览器解析后,每一个完整的标签(标签+属性+文本)可以称之为一个元素\n\n\n\n1.5 HTML的语法规则\n根标签有且只能有一个\n\n无论是双标签还是单标签都需要正确关闭\n\n标签可以嵌套但不能交叉嵌套\n\n注释语法为  ,注意不能嵌套\n\n属性必须有值，值必须加引号,H5中属性名和值相同时可以省略属性值\n\nHTML中不严格区分字符串使用单双引号\n\nHTML标签不严格区分大小写,但是不能大小写混用\n\nHTML中不允许自定义标签名,强行自定义则无效\n\n\n1.6 在线帮助文档http://www.w3school.com.cn\n\n二 HTML常见标签2.1 标题标签标题标签一般用于在页面上定义一些标题性的内容,如新闻标题,文章标题等,有h1到h6六级标题。\n\n代码\n\nhtml&lt;body&gt;\n    &lt;h1&gt;一级标题&lt;/h1&gt;\n    &lt;h2&gt;二级标题&lt;/h2&gt;\n    &lt;h3&gt;三级标题&lt;/h3&gt;\n    &lt;h4&gt;四级标题&lt;/h4&gt;\n    &lt;h5&gt;五级标题&lt;/h5&gt;\n    &lt;h6&gt;六级标题&lt;/h6&gt;\n&lt;/body&gt;\n效果\n\n\n2.2 段落标签段落标签一般用于定义一些在页面上要显示的大段文字,多个段落标签之间实现自动分段的效果\n\n代码\n\nhtml&lt;body&gt;\n    &lt;p&gt;\n        记者从工信部了解到，近年来我国算力产业规模快速增长，年增长率近30%，算力规模排名全球第二。\n    &lt;/p&gt;\n    &lt;p&gt;\n        工信部统计显示，截至去年底，我国算力总规模达到180百亿亿次浮点运算/秒，存力总规模超过1000EB（1万亿GB）。\n        国家枢纽节点间的网络单向时延降低到20毫秒以内，算力核心产业规模达到1.8万亿元。中国信息通信研究院测算，\n        算力每投入1元，将带动3至4元的GDP经济增长。\n    &lt;/p&gt;\n    &lt;p&gt; \n        近年来，我国算力基础设施发展成效显著，梯次优化的算力供给体系初步构建，算力基础设施的综合能力显著提升。\n        当前，算力正朝智能敏捷、绿色低碳、安全可靠方向发展。\n    &lt;/p&gt;\n&lt;/body&gt;\n效果\n\n\n2.3 换行标签br ：实现换行。\nhr ：添加分割线。\n\n代码\n\nhtml&lt;body&gt;\n        工信部统计显示，截至去年底，我国算力总规模达到180百亿亿次浮点运算/秒，存力总规模超过1000EB（1万亿GB）。\n    &lt;br&gt;\n        国家枢纽节点间的网络单向时延降低到20毫秒以内，算力核心产业规模达到1.8万亿元。\n    &lt;hr&gt;\n        中国信息通信研究院测算，算力每投入1元，将带动3至4元的GDP经济增长。\n&lt;/body&gt;\n效果\n\n\n2.4 列表标签1、有序列表  ：分条列项展示数据的标签, 其每一项前面的符号带有顺序特征\n\n列表标签 ol\n列表项标签 li\n\n代码\nhtml&lt;ol&gt;\n    &lt;li&gt;JAVA&lt;/li&gt;\n    &lt;li&gt;前端&lt;/li&gt;\n    &lt;li&gt;大数据&lt;/li&gt;\n&lt;/ol&gt;效果\n\n2、无序列表  ：分条列项展示数据的标签, 其每一项前面的符号不带有顺序特征\n\n列表标签 ul\n列表项标签 li\n\n代码\nhtml&lt;ul&gt;\n    &lt;li&gt;JAVASE&lt;/li&gt;\n    &lt;li&gt;JAVAEE&lt;/li&gt;\n    &lt;li&gt;数据库&lt;/li&gt;\n&lt;/ul&gt;效果\n\n3、嵌套列表 ： 列表和列表之前可以签到,实现某一项内容详细展示\n\n代码\n\nhtml&lt;ol&gt;\n    &lt;li&gt;\n        JAVA\n        &lt;ul&gt;\n            &lt;li&gt;JAVASE&lt;/li&gt;\n            &lt;li&gt;JAVAEE&lt;/li&gt;\n            &lt;li&gt;数据库&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/li&gt;\n    &lt;li&gt;前端&lt;/li&gt;\n    &lt;li&gt;大数据&lt;/li&gt;\n&lt;/ol&gt;\n效果\n\n\n2.5 超链接标签点击后带有链接跳转的标签 ,也叫作a标签。\n\nhref 属性用于定义要跳转的目标资源的地址\n\n绝对路径：以/开头,始终以一个固定路径作为基准路径作为出发点\n无论当前资源在哪，使用以固定的位置作为出发点去找目标资源。以/开头。\n\n\n相对路径：不以/开头,以当前资源的所在路径为出发点去找目标资源。\n./ 表示当前资源的所在路径，可以省略不写的。\n../表示当前资源的上一层路径，需要时必须显示写出。\n\n\n完整的URL：https://www.w3school.com.cn/\n\n\ntarget 用于定义目标资源的打开方式\n\n_blank 在新窗口中打开目标资源\n_self  在当前窗口中打开目标资源\n\n\n代码\n\n\nhtml&lt;body&gt;\n   &lt;a href=&quot;01html的基本结构.html&quot; target=&quot;_blank&quot;&gt;相对路径本地资源连接&lt;/a&gt; &lt;br&gt;\n   &lt;a href=&quot;/day01-html/01html的基本结构.html&quot; target=&quot;_self&quot;&gt;绝对路径本地资源连接&lt;/a&gt; &lt;br&gt;\n   &lt;a href=&quot;https://www.w3school.com.cn&quot; target=&quot;_blank&quot;&gt;外部资源链接&lt;/a&gt; &lt;br&gt;  \n&lt;/body&gt;\n效果\n\n\n2.6 多媒体标签img(重点) ： 图片标签,用于在页面上引入图片\n\nsrc：用于定义图片的连接\ntitle：用于定义鼠标悬停时显示的文字\nalt：用于定义图片加载失败时显示的提示文字\n\n代码\nhtml&lt;img src=&quot;img/logo.png&quot;  title=&quot;w3school&quot; alt=&quot;w3schoollogo&quot; /&gt;效果\n\naudio： 用于在页面上引入一段声音\n\nsrc：用于定义目标声音资源\nautoplay：用于控制打开页面时是否自动播放\ncontrols： 用于控制是否展示控制面板\nloop：用于控制是否进行循环播放\n\n代码\nhtml&lt;body&gt;\n   &lt;audio src=&quot;img/music.mp3&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; /&gt;\n&lt;/body&gt;效果\n\nvideo： 用于在页面上引入一段视频\n\nsrc： 用于定义目标视频资源\nautoplay：用于控制打开页面时是否自动播放\ncontrols： 用于控制是否展示控制面板\nloop：用于控制是否进行循环播放\n\n代码\nhtml&lt;body&gt;\n   &lt;video src=&quot;img/movie.mp4&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; width=&quot;400px&quot; /&gt;\n&lt;/body&gt;效果\n\n2.7 表格标签(重点)常规表格\n\ntable标签： 代表表格\nthead标签： 代表表头 可以省略不写\ntbody标签： 代表表体 可以省略不写\ntfoot标签： 代表表尾  可以省略不写\ntr标签： 代表一行\ntd标签： 代表行内的一格\nth标签： 自带加粗和居中效果的td\n\n代码\nhtml    &lt;h3 style=&quot;text-align: center;&quot;&gt;员工技能竞赛评分表&lt;/h3&gt;\n    &lt;table  border=&quot;1px&quot; style=&quot;width: 400px; margin: 0px auto;&quot;&gt;\n        &lt;tr&gt;\n            &lt;th&gt;排名&lt;/th&gt;\n            &lt;th&gt;姓名&lt;/th&gt;\n            &lt;th&gt;分数&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;1&lt;/td&gt;\n            &lt;td&gt;张小明&lt;/td&gt;\n            &lt;td&gt;100&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;2&lt;/td&gt;\n            &lt;td&gt;李小东&lt;/td&gt;&lt;/td&gt;\n            &lt;td&gt;99&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;3&lt;/td&gt;\n            &lt;td&gt;王小虎&lt;/td&gt;\n            &lt;td&gt;98&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;效果\n\n单元格跨行\n通过td的rowspan属性实现上下跨行\n\n代码\n\nhtml    &lt;h3 style=&quot;text-align: center;&quot;&gt;员工技能竞赛评分表&lt;/h3&gt;\n    &lt;table  border=&quot;1px&quot; style=&quot;width: 400px; margin: 0px auto;&quot;&gt;\n        &lt;tr&gt;\n            &lt;th&gt;排名&lt;/th&gt;\n            &lt;th&gt;姓名&lt;/th&gt;\n            &lt;th&gt;分数&lt;/th&gt;\n            &lt;th&gt;备注&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;1&lt;/td&gt;\n            &lt;td&gt;张小明&lt;/td&gt;\n            &lt;td&gt;100&lt;/td&gt;\n            &lt;td rowspan=&quot;3&quot;&gt;\n                前三名升职加薪\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;2&lt;/td&gt;\n            &lt;td&gt;李小东&lt;/td&gt;&lt;/td&gt;\n            &lt;td&gt;99&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;3&lt;/td&gt;\n            &lt;td&gt;王小虎&lt;/td&gt;\n            &lt;td&gt;98&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n效果\n\n\n单元格跨行\n通过td的colspan属性实现左右跨列\n\n代码\n\nhtml    &lt;h3 style=&quot;text-align: center;&quot;&gt;员工技能竞赛评分表&lt;/h3&gt;\n    &lt;table  border=&quot;1px&quot; style=&quot;width: 400px; margin: 0px auto;&quot;&gt;\n        &lt;tr&gt;\n            &lt;th&gt;排名&lt;/th&gt;\n            &lt;th&gt;姓名&lt;/th&gt;\n            &lt;th&gt;分数&lt;/th&gt;\n            &lt;th&gt;备注&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;1&lt;/td&gt;\n            &lt;td&gt;张小明&lt;/td&gt;\n            &lt;td&gt;100&lt;/td&gt;\n            &lt;td rowspan=&quot;6&quot;&gt;\n                前三名升职加薪\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;2&lt;/td&gt;\n            &lt;td&gt;李小东&lt;/td&gt;&lt;/td&gt;\n            &lt;td&gt;99&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;3&lt;/td&gt;\n            &lt;td&gt;王小虎&lt;/td&gt;\n            &lt;td&gt;98&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;总人数&lt;/td&gt;\n            &lt;td colspan=&quot;2&quot;&gt;2000&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;平均分&lt;/td&gt;\n            &lt;td colspan=&quot;2&quot;&gt;90&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;及格率&lt;/td&gt;\n            &lt;td colspan=&quot;2&quot;&gt;80%&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n效果\n\n\n2.8 表单标签(重点)表单标签：可以实现让用户在界面上输入各种信息并提交的一种标签. 是向服务端发送数据主要的方式之一\n\nform标签：表单标签,其内部用于定义可以让用户输入信息的表单项标签\n\ntarget：from标签的属性之一，设置要跳转的新地址打开位置；值_self、_blank\naction：form标签的属性之一,用于定义信息提交的服务器的地址\nmethod：form标签的属性之一,用于定义信息的提交方式\nget方式：数据会缀到url后,以?作为参数开始的标识,多个参数用&amp;隔开\turl?key=value&amp;key=value&amp;key=value\n数据直接暴露在地址栏上，相对不安全\n地址栏长度有限制，所以提交的数据量不大\n地址栏上，只能是字符，不能提交文件\n相比于post效率高一些\n\n\npost方式：数据会通过请求体发送,不会在缀到url后\n参数默认不放到url后\n数据不会直接暴露在地址栏上，相对安全\n数据是单独打包通过请求体发送，提交的数据量比较大\n请求体中，可以是字符，也可以字节数据，可以提交文件\n相比于get效率略低一些\n\n\n\n\n\n\ninput标签：主要的表单项标签,可以用于定义表单项\n\nname：input标签的属性之一,用于定义提交的参数名\ntype：input标签的属性之一,用于定义表单项类型\ntext：文本框\npassword：密码框\nbutton：普通按钮，需要通过JavaScript绑定单击响应函数\nsubmit：提交按钮\nreset：重置按钮\nradio：单选框，多个选项选其一，多个单选框使用相同的name属性值，则就会有互斥效果\ncheckbox：复选框 ，多个选项选多个\nhidden：隐藏域 ，不显示在页面上，提交时会携带\nfile：文件上传框\n\n\n\n\n\n代码\nhtml   &lt;form action=&quot;http://www.atguigu.com&quot; method=&quot;get&quot;&gt;\n        用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br&gt;\n        密&amp;nbsp;&amp;nbsp;&amp;nbsp;码 &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;br&gt;\n        &lt;input type=&quot;submit&quot;  value=&quot;登录&quot; /&gt;\n        &lt;input type=&quot;reset&quot;  value=&quot;重置&quot; /&gt;\n   &lt;/form&gt;效果\n\nreadonly：只读，提交时携带\ndisabled：不可用提交时，不携带\nhtml&lt;input type=&quot;hidden&quot;name=&quot;id&quot;value=&quot;123&quot;&gt;\n&lt;input type=&quot;text&quot;name=&quot;pid&quot;value=&quot;456&quot;readonly&gt;&lt;br&gt;\n&lt;input type=&quot;text&quot;name=&quot;tid&quot;value=&quot;789&quot;disabled&gt;&lt;br&gt;2.9 常见表单项标签(重点)1、单行文本框\n\n代码\n\nhtml个性签名：&lt;input type=&quot;text&quot; name=&quot;signal&quot;/&gt;&lt;br/&gt;\n效果\n\n\n2、密码框\n\n代码\n\nhtml密码：&lt;input type=&quot;password&quot; name=&quot;secret&quot;/&gt;&lt;br/&gt;\n效果\n\n\n3、单选框\n简要说明\n\nname属性相同的radio为一组，组内互斥\n当用户选择了一个radio并提交表单，这个radio的name属性和value属性组成一个键值对发送给服务器\n设置checked=&quot;checked&quot;属性设置默认被选中的radio\n如果属性名和属性值一样的话，可以省略属性值，只写checked即可\n\n代码\nhtml你的性别是：\n&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;spring&quot; /&gt;男\n&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;summer&quot; checked=&quot;checked&quot; /&gt;女效果\n\n4、复选框\n设置checked=&quot;checked&quot;属性设置默认被选中的checkbox\n\n代码\n\nhtml你喜欢的球队是：\n&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;Brazil&quot;/&gt;巴西\n&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;German&quot; checked/&gt;德国\n&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;France&quot;/&gt;法国\n&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;China&quot; checked=&quot;checked&quot;/&gt;中国\n&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;Italian&quot;/&gt;意大利\n效果\n\n\n5、下拉框\n简要说明\n\n下拉列表用到了两种标签，其中select标签用来定义下拉列表，而option标签设置列表项。\nname属性在select标签中设置,value属性在option标签中设置。\noption标签的标签体是显示出来给用户看的，提交到服务器的是value属性的值。\n通过在option标签中设置selected=&quot;selected&quot;属性实现默认选中的效果。\n\n代码\nhtml你喜欢的运动是：\n&lt;select name=&quot;interesting&quot;&gt;\n    &lt;option value=&quot;swimming&quot;&gt;游泳&lt;/option&gt;\n    &lt;option value=&quot;running&quot;&gt;跑步&lt;/option&gt;\n    &lt;option value=&quot;shooting&quot; selected=&quot;selected&quot;&gt;射击&lt;/option&gt;\n    &lt;option value=&quot;skating&quot;&gt;溜冰&lt;/option&gt;\n&lt;/select&gt;效果\n\n6、按钮\n简要说明\n\n普通按钮: 点击后无效果，需要通过JavaScript绑定单击响应函数\n重置按钮: 点击后将表单内的所有表单项都恢复为默认值\n提交按钮: 点击后提交表单\n\n代码\nhtml&lt;button type=&quot;button&quot;&gt;普通按钮&lt;/button&gt;或&lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;/&gt;\n&lt;button type=&quot;reset&quot;&gt;重置按钮&lt;/button&gt;或&lt;input type=&quot;reset&quot; value=&quot;重置按钮&quot;/&gt;\n&lt;button type=&quot;submit&quot;&gt;提交按钮&lt;/button&gt;或&lt;input type=&quot;submit&quot; value=&quot;提交按钮&quot;/&gt;效果\n\n7、隐藏域\n简要说明\n\n通过表单隐藏域设置的表单项不会显示到页面上，用户看不到。但是提交表单时会一起被提交。用来设置一些需要和表单一起提交但是不希望用户看到的数据，例如：用户id等等。\n\n代码\nhtml&lt;input type=&quot;hidden&quot; name=&quot;userId&quot; value=&quot;2233&quot;/&gt;8、多行文本框\n简要说明\n\ntextarea没有value属性，如果要设置默认值需要写在开始和结束标签之间。\n\n代码\nhtml自我介绍：&lt;textarea name=&quot;desc&quot;&gt;&lt;/textarea&gt;效果\n\n9、文件标签\n简要说明\n\n不同浏览器显示的样式有微小差异\n\n代码\nhtml头像:&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;效果\n\n2.10 布局相关标签div标签：  俗称”块”,主要用于划分页面结构,做页面布局。块元素的CSS样式的宽，高等等往往都是生效的。\nspan标签： 俗称”层”,主要用于划分元素范围,配合CSS做页面元素样式的修饰。行内的CSS样式的宽，高等待很多都是不生效的。\n\n代码\n\nhtml    &lt;div style=&quot;width: 500px; height: 400px;background-color: cadetblue;&quot;&gt;\n        &lt;div style=&quot;width: 400px; height: 100px;background-color: beige;margin: 10px auto;&quot;&gt;\n            &lt;span style=&quot;color: blueviolet;&quot;&gt;页面开头部分&lt;/span&gt;\n        &lt;/div&gt; \n        &lt;div style=&quot;width: 400px; height: 100px;background-color: blanchedalmond;margin: 10px auto;&quot;&gt;\n            &lt;span style=&quot;color: blueviolet;&quot;&gt;页面中间部分&lt;/span&gt;\n        &lt;/div&gt; \n        &lt;div style=&quot;width: 400px; height: 100px;background-color: burlywood;margin: 10px auto;&quot;&gt;\n            &lt;span style=&quot;color: blueviolet;&quot;&gt;页面结尾部分&lt;/span&gt;\n        &lt;/div&gt; \n    &lt;/div&gt;\n展示效果\n\n\n2.11 特殊字符Html特殊字符表 - 在线工具 (tool.lu)\n常见字符实体总结：\n\n\n代码\n\nhtml&amp;lt;span&amp;gt;  &lt;br&gt;    \n&amp;lt;a href=&quot;https://www.w3school.com.cn/index.html&quot;&amp;gt;特殊&amp;nbsp;字&amp;nbsp;符&amp;lt;/a&amp;gt; &lt;br&gt;\n&amp;amp;amp;\n效果\n\n\n\n三 CSS的使用CSS  层叠样式表(英文全称：(Cascading Style Sheets)   能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力 ,简单来说,美化页面。\n3.1 CSS引入方式方式一：行内式\n\n通过元素开始标签的style属性引入。\n语法：style=&quot;样式名:样式值;样式名:样式值;... ....&quot;\n缺点：1、代码复用度低，不利于维护。 2、css样式代码和html结构代码交织在一起，影响文件大小，影响性能。\n\n方式二：内嵌式\n\n内嵌式样式需要在head标签中,通过一对style标签定义CSS样式\nCSS样式的作用范围控制要依赖选择器\nCSS的样式代码中注释的方式为 /*   */\n内嵌式虽然对样式代码做了抽取,但是CSS代码仍然在html文件中\n内嵌样式仅仅能作用于当前文件,代码复用度还是不够,不利于网站风格统一\n\n方式三：外部样式表\n\n将css代码单独放入一个.css文件中，哪个html需要这些代码就在head中通过link标签引入\n&lt;link href=&quot;css/btn.css&quot; rel=&quot;stylesheet&quot;&gt;\n\n如下图所示\n\n代码演示\n1、方式一：行内式\n\n代码\n\nhtml&lt;input \n    type=&quot;button&quot; \n    value=&quot;按钮&quot;\n    style=&quot;\n        display: block;\n        width: 60px; \n        height: 40px; \n        background-color: rgb(140, 235, 100); \n        color: white;\n        border: 3px solid green;\n        font-size: 22px;\n        font-family: &#39;隶书&#39;;\n        line-height: 30px;\n        border-radius: 5px;\n&quot;/&gt; \n效果\n\n\n2、方式二：内嵌式\n\n代码\n\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;style&gt;\n        /* 通过选择器确定样式的作用范围 */\n        input &#123;\n            display: block;\n            width: 80px; \n            height: 40px; \n            background-color: rgb(140, 235, 100); \n            color: white;\n            border: 3px solid green;\n            font-size: 22px;\n            font-family: &#39;隶书&#39;;\n            line-height: 30px;\n            border-radius: 5px;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; \n&lt;/body&gt;\n效果\n\n\n3、方式三：外部样式表\n\n代码\n\nbuttons.css\ncssinput &#123;\n    display: block;\n    width: 80px; \n    height: 40px; \n    background-color: rgb(140, 235, 100); \n    color: white;\n    border: 3px solid green;\n    font-size: 22px;\n    font-family: &#39;隶书&#39;;\n    line-height: 30px;\n    border-radius: 5px;\n&#125;html\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;link href=&quot;css/buttons.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; \n&lt;/body&gt;\n效果\n\n\n3.2 CSS选择器\n元素选择器\n根据标签名确定样式的作用范围\n语法：元素名 &#123;&#125;\n样式只能作用到同名标签上,其他标签不可用\n相同的标签未必需要相同的样式,会造成样式的作用范围太大\n\n\nid选择器\n根据元素id属性的值确定样式的作用范围\n语法：#id值 &#123;&#125;\nid属性的值在页面上具有唯一性,所有id选择器也只能影响一个元素的样式\n因为id属性值不够灵活,所以使用该选择器的情况较少\n\n\nclass选择器\n根据元素class属性的值确定样式的作用范围\n语法： .class值 &#123;&#125;\nclass属性值可以有一个,也可以有多个,多个不同的标签也可以是使用相同的class值\n多个选择器的样式可以在同一个元素上进行叠加\n因为class选择器非常灵活,所以在CSS中,使用该选择器的情况较多\n\n\n\n代码演示\n1、元素选择器\n\n代码\n\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n   &lt;style&gt;\n    input &#123;\n        display: block;\n        width: 80px; \n        height: 40px; \n        background-color: rgb(140, 235, 100); \n        color: white;\n        border: 3px solid green;\n        font-size: 22px;\n        font-family: &#39;隶书&#39;;\n        line-height: 30px;\n        border-radius: 5px;\n    &#125;\n   &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; \n    &lt;button&gt;按钮5&lt;/button&gt;\n&lt;/body&gt;\n效果\n\n\n2、id选择器\n\n代码\n\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n   &lt;style&gt;\n    #btn1 &#123;\n        display: block;\n        width: 80px; \n        height: 40px; \n        background-color: rgb(140, 235, 100); \n        color: white;\n        border: 3px solid green;\n        font-size: 22px;\n        font-family: &#39;隶书&#39;;\n        line-height: 30px;\n        border-radius: 5px;\n    &#125;\n   &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; \n    &lt;input id=&quot;btn2&quot; type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; \n    &lt;input id=&quot;btn3&quot; type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; \n    &lt;input id=&quot;btn4&quot; type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; \n    &lt;button id=&quot;btn5&quot;&gt;按钮5&lt;/button&gt;\n&lt;/body&gt;\n效果\n\n\n3、class选择器\n\n代码\n\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n   &lt;style&gt;\n    .shapeClass &#123;\n        display: block;\n        width: 80px; \n        height: 40px; \n        border-radius: 5px;\n    &#125;\n    .colorClass&#123;\n        background-color: rgb(140, 235, 100); \n        color: white;\n        border: 3px solid green;\n    &#125;\n    .fontClass &#123;\n        font-size: 22px;\n        font-family: &#39;隶书&#39;;\n        line-height: 30px;\n    &#125;\n\n   &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input  class =&quot;shapeClass colorClass fontClass&quot;type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; \n    &lt;input  class =&quot;shapeClass colorClass&quot; type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; \n    &lt;input  class =&quot;colorClass fontClass&quot; type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; \n    &lt;input  class =&quot;fontClass&quot; type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; \n    &lt;button class=&quot;shapeClass colorClass fontClass&quot; &gt;按钮5&lt;/button&gt;\n&lt;/body&gt;\n效果\n\n\n3.3 CSS浮动CSS 的 Float（浮动）使元素脱离文档流，按照指定的方向（左或右发生移动），直到它的外边缘碰到包含框或另一个浮动框的边框为止。\n\n浮动设计的初衷为了解决文字环绕图片问题，浮动后一定不会将文字挡住，这是设计初衷。\n文档流是是文档中可显示对象在排列时所占用的位置&#x2F;空间，而脱离文档流就是在页面中不占位置了。\n\n浮动原理\n向右浮动：当把框 1 向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘\n\n\n\n向左浮动：当框 1 向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。如果把所有三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。\n\n\n\n如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”\n\n\n浮动的样式名:float\n\n\n\n值\n描述\n\n\n\nleft\n元素向左浮动。\n\n\nright\n元素向右浮动。\n\n\nnone\n默认值。元素不浮动，并会显示在其文本中出现的位置。\n\n\n代码\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n   &lt;style&gt;\n    .outerDiv &#123;\n        width: 500px;\n        height: 300px;\n        border: 1px solid green;\n        background-color: rgb(230, 224, 224);\n    &#125;\n    .innerDiv&#123;\n        width: 100px;\n        height: 100px;\n        border: 1px solid blue;\n        float: left;\n    &#125;\n    .d1&#123;\n        background-color: greenyellow;\n       /*  float: right; */\n    &#125;\n    .d2&#123;\n        background-color: rgb(79, 230, 124);\n    &#125;\n    .d3&#123;\n        background-color: rgb(26, 165, 208);\n    &#125;\n   &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n   &lt;div class=&quot;outerDiv&quot;&gt;\n        &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n   &lt;/div&gt; \n&lt;/body&gt;效果\n\n3.4 CSS定位position 属性指定了元素的定位类型。\n\n这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。\n元素可以使用的顶部，底部，左侧和右侧属性定位。然而，这些属性无法工作，除非是先设定position属性。他们也有不同的工作方式，这取决于定位方法。\n\n\n\n\n值\n描述\n\n\n\nabsolute\n生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。元素的位置通过left,top,right以及bottom属性进行规定。\n\n\nfixed\n生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过left,top,right以及bottom属性进行规定，\n\n\nrelative\n生成相对定位的元素，相对于其正常位置进行定位。因此，left:20会向元素的LEFT位置添加20像素。\n\n\nstatic\n默认值。没有定位，元素出现在正常的流中（忽路top,bottom,left,right或者Z-index声明）\n\n\n1、静态定位\n说明\n\n不设置的时候的默认值就是static，静态定位，没有定位，元素出现在该出现的位置，块级元素垂直排列，行内元素水平排列\n\n代码\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;style&gt;\n        .innerDiv&#123;\n                width: 100px;\n                height: 100px;\n        &#125;\n        .d1&#123;\n            background-color: rgb(166, 247, 46);\n            position: static;\n        &#125;\n        .d2&#123;\n            background-color: rgb(79, 230, 124);\n        &#125;\n        .d3&#123;\n            background-color: rgb(26, 165, 208);\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n&lt;/body&gt;效果\n\n2、绝对定位 \n说明\n\nabsolute 通过 top， left， right， bottom 指定元素在页面上的固定位置\n定位后元素会让出原来位置,其他元素可以占用\n\n代码\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;style&gt;\n        .innerDiv&#123;\n                width: 100px;\n                height: 100px;\n        &#125;\n        .d1&#123;\n            background-color: rgb(166, 247, 46);\n            position: absolute;\n            left: 300px;\n            top: 100px;\n        &#125;\n        .d2&#123;\n            background-color: rgb(79, 230, 124);\n        &#125;\n        .d3&#123;\n            background-color: rgb(26, 165, 208);\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n&lt;/body&gt;效果\n\n3、相对定位\n说明\n\nrelative 相对于自己原来的位置进行地位\n定位后保留原来的站位,其他元素不会移动到该位置\n\n代码\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;style&gt;\n        .innerDiv&#123;\n                width: 100px;\n                height: 100px;\n        &#125;\n        .d1&#123;\n            background-color: rgb(166, 247, 46);\n            position: relative;\n            left: 30px;\n            top: 30px;\n        &#125;\n        .d2&#123;\n            background-color: rgb(79, 230, 124);\n        &#125;\n        .d3&#123;\n            background-color: rgb(26, 165, 208);\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n&lt;/body&gt;效果\n\n4、固定定位\n说明\n\nfixed 定位在浏览器窗口固定位置,不会随着页面的上下移动而移动\n元素定位后会让出原来的位置,其他元素可以占用\n\n代码\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;style&gt;\n        .innerDiv&#123;\n                width: 100px;\n                height: 100px;\n        &#125;\n        .d1&#123;\n            background-color: rgb(166, 247, 46);\n            position: fixed;\n            right: 30px;\n            top: 30px;\n        &#125;\n        .d2&#123;\n            background-color: rgb(79, 230, 124);\n        &#125;\n        .d3&#123;\n            background-color: rgb(26, 165, 208);\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n        br*100+tab\n&lt;/body&gt;效果\n\n3.5 CSS盒子模型所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。\n\nCSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin），边框（border），填充（padding），和实际内容（content）。\n\n\n盒子模型介绍\n\nMargin(外边距) - 清除边框外的区域，外边距是透明的。\nBorder(边框) - 围绕在内边距和内容外的边框。\nPadding(内边距) - 清除内容周围的区域，内边距是透明的。\nContent(内容) - 盒子的内容，显示文本和图像。\n\n\n代码\nhtml    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n       &lt;style&gt;\n        .outerDiv &#123;\n            width: 800px;\n            height: 300px;\n            border: 1px solid green;\n            background-color: rgb(230, 224, 224);\n            margin: 0px auto;\n        &#125;\n        .innerDiv&#123;\n            width: 100px;\n            height: 100px;\n            border: 1px solid blue;\n            float: left;\n            /* margin-top: 10px;\n            margin-right: 20px;\n            margin-bottom: 30px;\n            margin-left: 40px; */\n            margin: 10px 20px 30px 40px;\n           \n        &#125;\n        .d1&#123;\n            background-color: greenyellow;\n            /* padding-top: 10px;\n            padding-right: 20px;\n            padding-bottom: 30px;\n            padding-left: 40px; */\n            padding: 10px 20px 30px 40px;\n        &#125;\n        .d2&#123;\n            background-color: rgb(79, 230, 124);\n        &#125;\n        .d3&#123;\n            background-color: rgb(26, 165, 208);\n        &#125;\n       &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n       &lt;div class=&quot;outerDiv&quot;&gt;\n            &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n            &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n            &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n       &lt;/div&gt; \n    &lt;/body&gt;效果\n\n在浏览器上,通过F12工具查看盒子模型状态\n\n","slug":"Javaweb_HTML&CSS","date":"2023-12-04T16:32:00.000Z","categories_index":"Javaweb","tags_index":"Javaweb","author_index":"白"},{"id":"1451337e2cd8330994910442b8a41dbc","title":"Java学习笔记","content":"Java笔记\n第 2 章 Java 概述Java 技术体系平台\nJava 重要特点\nJava 语言是面向对象的(oop)\nJava 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证\nJava 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]\nJava 语言是解释型的[了解]\n\n\n解释性语言：javascript,PHP, java 编译性语言: c &#x2F; c++\n区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可\n以直接被机器执行, c &#x2F;c++\n\nJava运行机制及运行过程\nJava核心机制Java 虚拟机 [JVM java virtual machine]\n基本介绍\nJVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在\n\nJDK 中. \n\n对于不同的平台，有不同的虚拟机。\nJava 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行” [说明]\n\n示意图\n什么是 JDK，JREJDK基本介绍\nJDK 的全称(Java Development Kit Java 开发工具包)\n\n​\tJDK &#x3D; JRE + java 的开发工具 [java, javac,javadoc,javap 等]\n\nJDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了\n\nJRE 基本介绍\nJRE(Java Runtime Environment Java 运行环境)\n\nJRE &#x3D; JVM + Java 的核心类库[类]\n\n包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。\n\nJDK、JRE 和 JVM 的包含关系\nJDK &#x3D; JRE + 开发工具集（例如 Javac,java 编译工具等)\nJRE &#x3D; JVM + Java SE 标准类库（java 核心类库）\n如果只想运行开发好的 .class 文件 只需要 JRE\n\nJava开发注意事项和细节说明\nJava转义字符Java常用的转义字符\n在控制台，输入 tab 键，可以实现命令补全\n\\t ：一个制表位，实现对齐的功能\n\\n ：换行符\n\\\\ ：一个\\\n\\&quot; :一个&quot;\n\\&#39; ：一个&#39; \n\\r :一个回车\n注释(comment)Java中的注释类型\n单行注释 //\n多行注释 /*  */\n文档注释 /**  */\n\n单行注释格式： &#x2F;&#x2F;注释文字\n多行注释格式： &#x2F;* 注释文字 *&#x2F;\n使用细节\n被注释的文字，不会被 JVM（java 虚拟机）解释执行\n多行注释里面不允许有多行注释嵌套\n\nDOS命令DOS介绍Dos： Disk Operating System 磁盘操作系统。\n原理图\n相对路径，绝对路径\n常用的dos命令DOS内部命令\ndir—-显示指定路径下所有文件和目录的信息\ncd—-进入指定目录\nmd—-创建指定目录\ncd&gt;—-创建指定文件\nrd—-删除指定空目录\ndel—-删除指定文件\ncopy—-复制文件\nren—-改名\nver—-显示当前DOS系统版本号\ntype—-在命令行窗口打开文件\ncls—-清空DOS命令窗口\nchkdsk—-检查磁盘使用情况\ntime—-显示和设置DOS的系统时间\ndate—-显示和设置DOS的系统日期\nsys—-传递系统文件命令\nexit—-退出cmd.exe程序\n\n常用DOS外部命令\nxcopy—-批量复制\ncertmgr—-证书管理\ncalc—-计算器\ncleanmgr—-垃圾整理\ncliconfg—-SQL SERVER客户端网络使用程序\ncompmgmt—-管理\ndevmgmt—-设备管理器\neventvwr—-事件查看器\nexplorer—-资源管理器\ngpedit—-组策略\nlusrmgr—-用户组\nmspaint—-画图板\nmstsc—-桌面远程连接\nnotepad—-记事本\nregedit—-注册表\nsfc—-系统文件检查器\nsfc&#x2F;scannow—-文件保护\ntaskmgr—-任务管理器\nwrite—-写字板\nipconfig—-查看电脑的IP地址\nping—-网络诊断\n\n\n第 3 章 变量3.1 数据类型\n3.2 整数类型整型的类型\n\n\n类型\n占用存储空间\n范围\n\n\n\nbyte[字节]\n1字节\n-128 ~ 127为啥存放的范围是这个&#x3D;&gt;二进制\n\n\nshort[短整型]\n2字节\n-(2^15) ~ 2^15 - 1-32768 ~ 32767\n\n\nint[整型]\n4字节\n-2^31 ~ 2^31 - 1-2147483648 - 2147483647\n\n\nIong[长整型]\n8字节\n-2^63 ~ 2^63 - 1\n\n\n整型的使用细节\nJva各整数类型有固定的范围和字段长度，不受具体OS[操作系统]的影响，以保证java程序的可移植性。\nJava的整型常量（具体值）默认为int型，声明long型常量须后加&#39;I&#39;或&#39;L&#39; \njava程序中变量常声明为int型，除非不足以表示大数，才使用long \nbit:计算机中的最小存储单位。byte:计算机中基本存储单元，1byte&#x3D;8bit。\n\n3.3 浮点类型浮点型的分类\n\n\n类型\n占用存储空间\n范围\n\n\n\n单精度float\n4字节\n-3.403E38 ~ 3.403E38\n\n\n双精度double\n8字节\n-1.798E308 ~ 1.798E308\n\n\n\n关于浮点数在机器中存放形式的简单说明,浮点数&#x3D;符号位+指数位+尾数位\n尾数部分可能丢失，造成精度损失(小数都是近似值)。\n\n浮点型使用细节\n与整数类型类以，Java浮点类型也有固定的范围和字段长度，不受具体OS的影响。[float  4个字节\tdouble是8个字节] \nJava的浮点型常量（具体值）默认为doublei型，声明float型常量，须后加 &#39;f&#39;或&#39;F&#39; \n浮点型常量有两种表示形式\n\n\n十进制数形式：如：5.12   512.0f    .512(必须有小数点)\n科学计数法形式：如：5.12e2 [5.12*10的2次方]  5.12E-2  [5.12&#x2F;10的2次方]\n\n\n通常情况下，应该使用doublei型，因为它比float?型更精确。[举例说明]\n\n\ndouble num9 &#x3D; 2.1234567851；\nfloat num10 &#x3D; 2.1234567851F；\n\n\n浮点数使用陷阱：2.7和8.1&#x2F;3比较\n\njavadouble num7 2.7;\ndouble num8 =8.1/3;\nif(Math.abs(num7-num8)&lt;0.00001)&#123; \n    Svstem.out.println(&quot;相等~~~&quot;);3.4 Java API文档\nAPI (Application Programming Interface, 应用程序编程接口) 是 Java提供的基本编程接口 (java提供的类还有相关的方法)。中文在线文档： https://www.matools.com \nJava语言提供了大量的基础类，因此Oracle公司也为这些基础类提供了相应的API文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。 \nJava类的组织形式。\n\n\n3. 5 字符类型字符类型使用细节\n字符常量是用单引号( &#39; &#39; )括起来的单个字符。例如： char c1 &#x3D; ‘a’ ；char c2 &#x3D; ‘中’ ；char c3 &#x3D; ‘9’；\nJava中还允许使用转义字符&#39;\\&#39;来将其后的字符转变为特殊字符型常量。例如：char c3 &#x3D; ‘n’；’\\n’表示换行符 \n在java中，char的本质是一个整数，在输出时，是 unicode码对应的字符。 http://tool.chinaz.com/Tools/Unicode.aspx \n可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出 [97-&gt; a]\ncha类型是可以进行运算的，相当于一个整数，因为它都对应有Unicodet码.\n\n3.6 ASCII &#x2F; Unicode &#x2F; UTF-8 编码介绍ASCII码\n\nASCII码：上个世纪60年代，美国制定了一套字符编码（使用一个字节），对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。ASCII码一共规定了128个学符的编被，只占用了二个学节的后面7位，最前面的1位统一规定为0。特别提示：一个字节可以表示256个字符，ASCII码只用了128个学符。\n缺点：不能表示所有字符。\n\nUnicode编码\n\nUnicode的好处：一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用Unicode没有乱码的问题。 \nUnicode的缺点：一个英文字母和一个汉字都占用2个字节，这对于存储空间来说是浪费。 \n2的16次方是65536，所以最多编码是65536个字符。 \n编码0-127的字符是与ASCIIE的编码一样。比如 ‘a’ 在ASCII码是 0x61，在unicode码是 ox0061，都对应97。因此Unicode码兼容ASCII码。\n\nUTF-8编码\n\nUTF-8是在互联网上使用最广的一种 Unicode的实现方式（改进）\nUTF-8是一种变长的编码方式。它可以使用1-6个字节表示一个符号，根据不同的符号而变化字节长度。\n使用 大小可变的编码 字母占1个字节，汉字占3个字节\n\n3.7 布尔类型：boolean\n布尔类型也叫boolean类型，booolean类型数据只允许取值true和false，无 null \nboolean类型占1个字节。\nboolean类型适于逻辑运算，一般用于程序流程控制。\n\n3.8 基本数据类型转换自动类型转换当ava程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型这个就是自动类型转换。\n数据类型按精度(容量)大小排序如图\n\n自动类型转换注意和细节\n\n有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。\n当我们把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错，反之就会进行自动类型转换。 \n(byte,short) 和 char之间不会相互自动转换。 当把具体数赋给 byte 时，(1)先判断该数是否在 byte 范围内，如果是就可以。\nbyte，short，char 他们三者可以计算，在计算时首先转换为int类型。\nboolean不参与转换\n自动提升原则：表达式结果的类型自动提升为操作数中最大的类型\n\n代码例题演示①\njavaint n1 = 10;\t/ok\n\nfloat d1 = n1 + 1.1;\t/错误 n1 + 1.1 =&gt; 结果类型是 double\n\ndouble d1 = n1 + 1.1;\t/对 n1 + 1.1 =&gt; 结果类型是 double\n\nfloat d1 = n1 + 1.1F;\t/对 n1 + 1.1 =&gt; 结果类型是 float②\njavaint n2 = 1.1;\t/错误 double -&gt; int③\njavabyte b1 = 10;\t/对 , -128-127\n\nint n2 = 1;\t\t/n2 是 int\n\nbyte b2 = n2; \t/错误，原因： 如果是变量赋值，判断类型\n\nchar c1 = b1; \t/错误， 原因 byte 不能自动转成 char④\njavabyte b2 = 1;\nbyte b3 = 2;\nshort s1 = 1;\n\nshort s2 = b2 + s1;\t/错, b2 + s1 =&gt; int\n\nint s2 = b2 + s1;\t/对, b2 + s1 =&gt; int\n\nbyte b4 = b2 + b3; \t/错误: b2 + b3 =&gt; int ⑤\njavaboolean pass = true;\n\nint num100 = pass;\t/boolean 不参与类型的自动转换⑥\njavabyte b4 = 1;\nshort s3 = 100;\nint num200 = 1;\nfloat num300 = 1.1F;\n\ndouble num500 = b4 + s3 + num200 + num300; /float -&gt; double强制类型转换自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成精度降低或溢出,格外要注意。\n强制类型转换细节说明\n\n\n\n\n\n\n\n\n\n1、当进行数据的大小从大——》小，就需要使用到强制转换强转换\n2、强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级\n3、char类型可以保存int的常量值，但不能保存int的变量值，需要强转 \n4、byte和short,char类型在进行运算时，当做int类型处理。\n代码演示\n强制转换\njava//int x=(int)10*3.5+6*1.5;\nint y=(int)(10*3.5+6*1.5);\nSystem.out.println(y);  转换细节\njavachar c1 100; \t/ok \nint m 100; \t/ok \nchar c2=m; \t/错误 \nchar c3 =(char)m; \t/ok \nSystem.out.println(c3); \t/100对应的字符\t练习题java1. short s = 12;\t/ok\n   s = s - 9;\t/错误 int-&gt;short\n2. byte b = 10;\t\t/ok\n   b = b + 11;\t\t/错误 int-&gt;byte\n   b = (byte)(b+1);\t\t/正确 使用强转\n3. char c = &#39;a&#39;;\t/ok \n   int i = 16;\t\t/ok\n   float d = .314F;\t/ok\n   double result = c + i + d;\t/ok float-&gt;double\n4. byte b = 16;\t\t/ok\n   short s = 14;\t/ok\n   short t = s + b;\t\t/错误 int-&gt;short3.9 基本数据类型和String类型的转换3.9.1 介绍和使用介绍\n在程序开发中，我们经常需要将基本数据类型转成String类型。或者将String类型转成基本数据类型。\n\n基本类型转String类型\n语法：将基本类型的值+&quot;&quot;即可\n\n\nString类型转基本数据类型\n语法：通过基本类型的包装类调用parseXX方法即可\n\n\n\n使用\n基本数据类型-&gt;String\njavaint n1 = 100;\nfloat f1 = 1.1F;\ndouble d1 = 4.5;\nboolean b1 = true;\nString s1 = n1 + &quot;&quot;;\nString s2 = f1 + &quot;&quot;;\nString s3 = d1 + &quot;&quot;;\nString s4 = b1 + &quot;&quot;;\nSystem.out.println(s1 + &quot; &quot; + s2 + &quot; &quot; + s3 + &quot; &quot; + s4);String-&gt;对应的基本数据类型\n(使用 基本数据类型对应的包装类，的相应方法，得到基本数据类型)\njavaString s5 = &quot;123&quot;;\nint num1 = Integer.parseInt(s5);\ndouble num2 = Double.parseDouble(s5);\nfloat num3 = Float.parseFloat(s5);\nlong num4 = Long.parseLong(s5);\nbyte num5 = Byte.parseByte(s5);\nboolean b = Boolean.parseBoolean(&quot;true&quot;);\nshort num6 = Short.parseShort(s5);\nSystem.out.println(&quot;===================&quot;);\nSystem.out.println(num1);\t/123\nSystem.out.println(num2);\t/123.0\nSystem.out.println(num3);\t/123.0\nSystem.out.println(num4);\t/123\nSystem.out.println(num5);\t/123\nSystem.out.println(num6);\t/123\nSystem.out.println(b);\t\t/true\n    \n//怎么把字符串转成字符 char -&gt; 含义是指 把字符串的第一个字符得到\n//解读 s5.charAt(0) 得到 s5 字符串的第一个字符 &#39;1&#39; \nSystem.out.println(s5.charAt(0));3.9.2 注意事项\n在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据，比如可以把”123”，转成一个整数，但不能把”hello”转成一个整数。\n如果格式不正确，就会抛出异常，程序就会终止。\n\n\n第 4 章 运算符4.1 运算符介绍运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。\n\n算术运算符\n赋值运算符\n关系运算符 [比较运算符]\n逻辑运算符\n位运算符 [需要二进制基础]\n三元运算符\n\n4.2 算术运算符介绍算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多。\n算术运算符一览\n\n细节说明\n\n对于除号&quot;/&quot;，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。例如：intx&#x3D;10&#x2F;3,结果是3 \n当对一个数取模时，可以等价a%b=a-a/b*b,这样我们可以看到取模的一个本质运算。\n当自增当做一个独立语言使用时，不管是++i还是i++都是一样的，等价。\n\n4.3 关系运算符介绍\n\n关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false\n关系表达式 经常用在 if 结构的条件中或循环结构的条件中\n\n关系运算符一览\n\n细节说明\n\n关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。\n关系运算符组成的表达式，我们称为关系表达式。 例如a &gt; b\n比较运算符&quot;==&quot;不能误写成&quot;=&quot;\n\n4.4 逻辑运算符介绍\n用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值。\n逻辑运算符一览\n\n短路与 &amp;&amp; ， 短路或 ||，取反 !\n逻辑与 &amp;，逻辑或 |，逻辑异或 ^\n\n\n逻辑运算规则\n\na&amp;b : &amp; 叫逻辑与：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false\na&amp;&amp;b : &amp;&amp; 叫短路与：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false\na|b : | 叫逻辑或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false\na||b : || 叫短路或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false\n!a : 叫取反，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true\na^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false\n\n4.4.1 &amp;&amp; 和 &amp; 基本规则\n\n\n名称\n语法\n特点\n\n\n\n短路与 &amp;&amp;\n条件 1&amp;&amp;条件 2\n两个条件都为 true，结果为 true,否则 false\n\n\n逻辑与 &amp;\n条件 1&amp;条件 2\n两个条件都为 true，结果为 true,否则 false\n\n\n&amp;&amp; 和 &amp; 使用区别\n\n&amp;&amp;短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高\n&amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低\n\n4.4.2 || 和 | 基本规则\n\n\n名称\n语法\n特点\n\n\n\n短路或 ||\n条件 1||条件 2\n两个条件中只要有一个成立，结果为 true,否则为 false\n\n\n逻辑或 |\n条件 1 | 条件2\n只要有一个条件成立，结果为 true,否则为 false\n\n\n|| 和 | 使用区别\n\n|| 短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高\n| 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低\n\n4.4.3 ! 取反 基本规则\n\n\n名称\n语法\n特点\n\n\n\n! 非（取反）\n!条件\n如果条件本身成立，结果为 false，否则为 true\n\n\n4.4.4 ^ 逻辑异或a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false\n4.5 赋值运算符赋值运算符的分类\n基本赋值运算符 &#x3D; \tint a &#x3D; 10;\n复合赋值运算符\n+= ，-= ，*=， /= ，%= 等 \na +&#x3D; b; \t[等价 a &#x3D; a + b; ]\na -&#x3D; b; \t[等价 a &#x3D; a - b; ]\n赋值运算符特点\n\n运算顺序从右往左 \tint num = a + b + c;\n赋值运算符的左边 只能是变量,右边 可以是变量、表达式、常量值\tint num = 20; int num2= 78 * 34 - 10; int num3 = a;\n复合赋值运算符等价于下面的效果\t比如：a+&#x3D;3;等价于 a&#x3D;a+3; 其他类推\n复合赋值运算符会进行类型转换。\tbyte b = 2; b+=3; b++;\n\n4.6 三元运算符基本语法\n条件表达式 ? 表达式 1: 表达式 2;\n运算规则\n\n如果条件表达式为 true，运算后的结果是表达式 1；\n如果条件表达式为 false，运算后的结果是表达式 2；\n\n使用细节\n\n表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)\n三元运算符可以转成 if–else 语句\n\njavaint res = a &gt; b ? a++ : --b;\n\nif ( a &gt; b) res = a++;\n\nelse res = --b;java//编写一个 main 方法\npublic static void main(String[] args) &#123;\n    //表达式 1 和表达式 2 要为可以赋给接收变量的类型\n    //(或可以自动转换/或者强制转换)\n    int a = 3;\n    int b = 8;\n    int c = a &gt; b ? (int)1.1 : (int)3.4;//可以的\n    double d = a &gt; b ? a : b + 3;//可以的，满足 int -&gt; double\n&#125;4.7 运算符优先级\n运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。\n只有单目运算符、赋值运算符是从右向左运算的。\n一览表, 不要背，使用多了，就熟悉了。\n\n\n4.8 标识符的命名规则和规范标识符概念\n\nJava对各种变量、方法和类等命名时使用的字符序列称为标识符\n凡是自己可以起名字的地方都叫标识符int num1&#x3D;90;\n\n4.8.1 标识符的命名规则（必须遵守）\n由26个英文字母大小写，0-9，_或$组成\n数字不可以开头。int 3ab &#x3D; 1;   &#x2F;&#x2F;错误\n不可以使用关键字和保留字，但能包含关键字和保留字。\nJava中严格区分大小写，长度无限制。int totalNum = 10;int n = 90;\n标识符不能包含空格。int a b = 90;\n\n判断下面变量名是否正确\njavalsp \t/ok\nlsp12 \t/ok\n1hsp \t/错误, 数字不能开头\nh-s \t/ 错误 , 不能有 - x h // 错误， 有空格\nh$4 \t/ ok\nclass \t/错误，class 关键字\nint \t/ 错误 ,int 是关键字\ndouble \t/错误 ,double 是关键字\npublic \t/错误 ,public 是关键字\nstatic \t/错误 ,static 是关键字\ngoto \t/错误, goto 是保留字\nstu_name \t/ok4.8.2 标识符命名规范\n包名：多单词组成时所有字母都小写：aaa.bbb.ccc \t比如 com.hsp.crm\n类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰]        比如： TankShotGame\n变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小驼峰， 简称 驼峰法]比如： tankShotGame\n常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ       比如 ：定义一个所得税率 TAX_RATE\n\n4.9 位运算符7 个位运算(&amp;、|、 ^ 、~、&gt;&gt;、&lt;&lt;和 &gt;&gt;&gt;)\n分别是按位与&amp;、按位或| 按位异或∧，按位取反~，它们的运算规则是：\n\n按位与&amp;\t：\t两位全为1，结果为1，否则为0\n按位或|\t：\t两位有一个为1，结果为1，否则为0\n按位异或^\t：\t两位一个为0，一个为1，结果为1，否则为0\n按位取反~ \t：\t0-&gt;1,1-&gt;0\n\n3 个位运算符 &gt;&gt;、&lt;&lt; 和 &gt;&gt;&gt; , 运算规则是：\n\n算术右移 &gt;&gt;：低位溢出,符号位不变,并用符号位补溢出的高位\n算术左移 &lt;&lt;: 符号位不变,低位补 0\n逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0\n特别说明：没有 &lt;&lt;&lt; 符号\n\n应用案例\n\nint a&#x3D;1&gt;&gt;2; &#x2F;&#x2F;1 &#x3D;&gt; 00000001 &#x3D;&gt; 00000000 本质 1 &#x2F; 2 &#x2F; 2 &#x3D;0\nint c&#x3D;1&lt;&lt;2; &#x2F;&#x2F;1 &#x3D;&gt; 00000001 &#x3D;&gt; 00000100 本质 1 * 2 * 2 &#x3D; 4\n\n本章作业1、计算下列表达式的结果 \njava10/3=3；10/5=2; 10%2=0；\n-10.5%3=?;\n/a%b当a是小数时，公式=a-(int)a/b*b\n/-10.5%3 = -10.5-(-10)/3*3 = -10.5 + 9 = -1.5注意：有小数运算，得到结果是近似以值\n2、试说出下面代码的结果\njavaint i = 66;\nSystem.out.println(++i+i);\t/执行 i=i+1 =&gt; i= 67 =&gt; 1343、在Java中，以下赋值语句正确的是(CD)。\njavaA) int num1=(int)&quot;18&quot;;\t/错误\t应该Integer.parselnt(&quot;18&quot;); \nB) int num2=18.0;\t\t/错误\tdouble-&gt;int \nC) double num3=3d;\t/ok \nD) double num4=8;\t/ok\tint-&gt;double \nE) inti=48;\tchar ch=i+1;\t/错误\tint-&gt;char \nF) byte b=19;short s=b+2;\t\t/错误\tint-&gt;short4、试写出将String转换成double类型的语句，以及将char类型转换成String的语句，举例说明即可，写简单代码\njavaString str = &quot;18.8&quot;;\t/注意\t字符串要可以被转成double \ndouble d1 = Double.parseDouble(str);\nchar c1 = &#39;韩&#39;； \nString str2 = c1 + &quot;&quot;;\n第 6 章 数组、排序和查找6.1 数组介绍数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。\n6.2 数组的使用使用方式1-动态初始化\n数据类型 数组名[] = new 数据类型[大小]\n举例：int a[] = new int[5]，创建一个数组，名字a，存放5个int\n使用方式 2-动态初始化\n数据类型 数组名[]; 或者 数据类型[] 数组名;\n举例：int a[]或者int[] a，a = new int[10];\n使用方式 3-静态初始化\n数据类型 数组名[] = &#123;元素值,元素值...&#125;\n举例：double hens[] = &#123;3, 5, 1, 3.4, 2, 50&#125;;\n6.3 数组使用注意事项和细节\n数组是多个相同类型数据的组合，实现对这些数据的统一管理\n数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。\n数组创建后，如果没有赋值，有默认值int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000，boolean false，String null\n使用数组的步骤 1、 声明数组并开辟空间 2、给数组各个元素赋值 3、使用数组\n数组的下标是从 0 开始的。\n数组下标必须在指定范围内使用，否则报：下标越界异常，比如 int [] arr=new int[5]; 则有效下标为 0-4\n数组属引用类型，数组型数据是对象(object)\n\n6.4 数组应用案例1、创建一个 char 类型的 26 个元素的数组，分别 放置’A’-‘Z’。使用 for 循环访问所有元素并打印出来。\njava//编写一个 main 方法\npublic static void main(String[] args) &#123;\n    /*\n    创建一个 char 类型的 26 个元素的数组，分别 放置&#39;A&#39;-&#39;Z&#39;。\n    使用 for 循环访问所有元素并打印出来。\n    提示：char 类型数据运算 &#39;A&#39;+1 -&gt; &#39;B&#39; 思路分析\n    1. 定义一个 数组 char[] chars = new char[26]\n    2. 因为 &#39;A&#39; + 1 = &#39;B&#39; 类推，所以老师使用 for 来赋值\n    3. 使用 for 循环访问所有元素\n    */\n    char[] chars = new char[26];\n    for( int i = 0; i &lt; chars.length; i++) &#123;//循环 26 次\n        //chars 是 char[]\n        //chars[i] 是 char\n        chars[i] = (char)(&#39;A&#39; + i); //&#39;A&#39; + i 是 int , 需要强制转换\n    &#125;\n    //循环输出\n    System.out.println(&quot;===chars 数组===&quot;);\n    for( int i = 0; i &lt; chars.length; i++) &#123;//循环 26 次\n        System.out.print(chars[i] + &quot; &quot;);\n    &#125;\n&#125;\t2、请求出一个数组 int[]的最大值 {4,-1,9, 10,23}，并得到对应的下标。\njavapublic static void main(String[] args) &#123;\n    //请求出一个数组 int[]的最大值 &#123;4,-1,9, 10,23&#125;，并得到对应的下标\n    //思路分析\n    //1. 定义一个 int 数组 int[] arr = &#123;4,-1,9, 10,23&#125;;\n    //2. 假定 max = arr[0] 是最大值 , maxIndex=0;\n    //3. 从下标 1 开始遍历 arr， 如果 max &lt; 当前元素，说明 max 不是真正的\n    // 最大值, 我们就 max=当前元素; maxIndex=当前元素下标\n    //4. 当我们遍历这个数组 arr 后 , max 就是真正的最大值，maxIndex 最大值\n    // 对应的下标\n    int[] arr = &#123;4,-1,9,10,23&#125;;\n    int max = arr[0];//假定第一个元素就是最大值\n    int maxIndex = 0; //\n    for(int i = 1; i &lt; arr.length; i++) &#123;//从下标 1 开始遍历 arr\n        if(max &lt; arr[i]) &#123;//如果 max &lt; 当前元素\n        max = arr[i]; //把 max 设置成 当前元素\n        maxIndex = i;\n        &#125;\n    &#125;\n    //当我们遍历这个数组 arr 后 , max 就是真正的最大值，maxIndex 最大值下标\n    System.out.println(&quot;max=&quot; + max + &quot; maxIndex=&quot; + maxIndex);\n&#125;6.5 数组赋值机制\n基本数据类型赋值，这个值就是具体的数据，而且相互不影响。int n1 = 2; int n2 = n1;\n数组在默认情况下是引用传递，赋的值是地址。看一个案例，并分析数组赋值的内存图(重点, 难点)。\n\njavaint[] arr1 = &#123;1,2,3&#125;;\nint[] arr2 = arr1;\n6.6 数组拷贝将 int[] arr1 &#x3D; {10,20,30}; 拷贝到 arr2 数组, 要求数据空间是独立的.\njavapublic static void main(String[] args) &#123;\n    //将 int[] arr1 = &#123;10,20,30&#125;; 拷贝到 arr2 数组, //要求数据空间是独立的. int[] arr1 = &#123;10,20,30&#125;;\n    //创建一个新的数组 arr2,开辟新的数据空间\n    //大小 arr1.length;\n    int[] arr2 = new int[arr1.length];\n    //遍历 arr1 ，把每个元素拷贝到 arr2 对应的元素位置\n    for(int i = 0; i &lt; arr1.length; i++) &#123;\n        arr2[i] = arr1[i];\n    &#125;\n    //修改 arr2， 不会对 arr1 有影响. arr2[0] = 100;\n    //输出 arr1\n    System.out.println(&quot;====arr1 的元素====&quot;);\n    for(int i = 0; i &lt; arr1.length; i++) &#123;\n        System.out.println(arr1[i]);//10,20,30\n    &#125;\n    //\n    System.out.println(&quot;====arr2 的元素====&quot;);\n    for(int i = 0; i &lt; arr2.length; i++) &#123;\n        System.out.println(arr2[i]);//\n    &#125;\n&#125;6.7 数组反转把数组的元素内容反转。arr {11,22,33,44,55,66} \t\t{66, 55,44,33,22,11}\n方式 1：通过找规律反转\njavapublic static void main(String[] args) &#123;\n    //定义数组\n    int[] arr = &#123;11, 22, 33, 44, 55, 66&#125;;\n    //规律\n    //1. 把 arr[0] 和 arr[5] 进行交换 &#123;66,22,33,44,55,11&#125;\n    //2. 把 arr[1] 和 arr[4] 进行交换 &#123;66,55,33,44,22,11&#125;\n    //3. 把 arr[2] 和 arr[3] 进行交换 &#123;66,55,44,33,22,11&#125;\n    //4. 一共要交换 3 次 = arr.length / 2\n    //5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]\n    //代码\n    //优化\n    int temp = 0;\n    int len = arr.length; //计算数组的长度\n    for( int i = 0; i &lt; len / 2; i++) &#123;\n        temp = arr[len - 1 - i];//保存\n        arr[len - 1 - i] = arr[i];\n        arr[i] = temp;\n    &#125;\n    System.out.println(&quot;===翻转后数组===&quot;);\n    for(int i = 0; i &lt; arr.length; i++) &#123;\n        System.out.print(arr[i] + &quot;\\t&quot;);//66,55,44,33,22,11\n    &#125;\n&#125;方式 2：使用逆序赋值方式\njavapublic static void main(String[] args) &#123;\n    //定义数组\n    int[] arr = &#123;11, 22, 33, 44, 55, 66&#125;;\n    //使用逆序赋值方式\n    //1. 先创建一个新的数组 arr2 ,大小 arr.length\n    //2. 逆序遍历 arr ,将 每个元素拷贝到 arr2 的元素中(顺序拷贝)\n    //3. 建议增加一个循环变量 j -&gt; 0 -&gt; 5\n    int[] arr2 = new int[arr.length];\n    //逆序遍历 arr\n    for(int i = arr.length - 1, j = 0; i &gt;= 0; i--, j++) &#123;\n        arr2[j] = arr[i];\n    &#125;\n    //4. 当 for 循环结束，arr2 就是一个逆序的数组 &#123;66, 55, 44,33, 22, 11&#125;\n    //5. 让 arr 指向 arr2 数据空间, 此时 arr 原来的数据空间就没有变量引用\n    // 会被当做垃圾，销毁\n    arr = arr2;\n    System.out.println(&quot;====arr 的元素情况=====&quot;);\n    //6. 输出 arr 看看\n    for(int i = 0; i &lt; arr.length; i++) &#123;\n        System.out.print(arr[i] + &quot;\\t&quot;);\n    &#125;\n&#125;6.8 数组添加&#x2F;扩容要求：实现动态的给数组添加元素效果，实现对数组扩容。\n\n原始数组使用静态分配 int[] arr = &#123;1,2,3&#125;\n增加的元素 4，直接放在数组的最后 arr = &#123;1,2,3,4&#125;\n用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y&#x2F;n\n\njava//编写一个 main 方法\npublic static void main(String[] args) &#123;\n    /*\n    要求：实现动态的给数组添加元素效果，实现对数组扩容。ArrayAdd.java\n    1.原始数组使用静态分配 int[] arr = &#123;1,2,3&#125;\n    2.增加的元素 4，直接放在数组的最后 arr = &#123;1,2,3,4&#125;\n    3.用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n\n    思路分析\n    1. 定义初始数组 int[] arr = &#123;1,2,3&#125;//下标 0-2\n    2. 定义一个新的数组 int[] arrNew = new int[arr.length+1];\n    3. 遍历 arr 数组，依次将 arr 的元素拷贝到 arrNew 数组\n    4. 将 4 赋给 arrNew[arrNew.length - 1] = 4;把 4 赋给 arrNew 最后一个元素\n    5. 让 arr 指向 arrNew ; arr = arrNew; 那么 原来 arr 数组就被销毁\n    6. 创建一个 Scanner 可以接受用户输入\n    7. 因为用户什么时候退出，不确定，使用 do-while + break 来控制\n    */\n    Scanner myScanner = new Scanner(System.in);\n    //初始化数组\n    int[] arr = &#123;1,2,3&#125;;\n    do &#123;\n        int[] arrNew = new int[arr.length + 1];\n        //遍历 arr 数组，依次将 arr 的元素拷贝到 arrNew 数组\n        for(int i = 0; i &lt; arr.length; i++) &#123;\n            arrNew[i] = arr[i];\n        &#125;\n        System.out.println(&quot;请输入你要添加的元素&quot;);\n        int addNum = myScanner.nextInt();\n        //把 addNum 赋给 arrNew 最后一个元素\n        arrNew[arrNew.length - 1] = addNum;\n        //让 arr 指向 arrNew, arr = arrNew;\n        //输出 arr 看看效果\n        System.out.println(&quot;====arr 扩容后元素情况====&quot;);\n        for(int i = 0; i &lt; arr.length; i++) &#123;\n            System.out.print(arr[i] + &quot;\\t&quot;);\n        &#125;\n        //问用户是否继续\n        System.out.println(&quot;是否继续添加 y/n&quot;);\n        char key = myScanner.next().charAt(0);\n        if( key == &#39;n&#39;) &#123; //如果输入 n ,就结束\n            break;\n        &#125;\n    &#125;while(true);\n    System.out.println(&quot;你退出了添加...&quot;);\n&#125;\t6.9 排序的介绍内部排序\n指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择式排序法和插入式排序法)；\n外部排序法\n数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法)。\n6.10 冒泡排序法介绍\n冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。\n例题\n将五个无序：24,69,80,57,13 使用冒泡排序法将其排成一个从小到大的有序数列。\n\n代码\njavapublic static void main(String[] args) &#123;\n    /*\n    数组 [24,69,80,57,13]\n    第 1 轮排序: 目标把最大数放在最后\n    第 1 次比较[24,69,80,57,13]\n    第 2 次比较[24,69,80,57,13]\n    第 3 次比较[24,69,57,80,13]\n    第 4 次比较[24,69,57,13,80]\n    */\n    int[] arr = &#123;24, 69, 80, 57, 13, -1, 30, 200, -110&#125;;\n    int temp = 0; //用于辅助交换的变量\n    //将多轮排序使用外层循环包括起来即可\n    //先死后活 =》 4 就是 arr.length - 1\n    for( int i = 0; i &lt; arr.length - 1; i++) &#123;//外层循环是 4 次\n        for( int j = 0; j &lt; arr.length - 1 - i; j++) &#123;//4 次比较-3 次-2 次-1 次\n            //如果前面的数&gt;后面的数，就交换\n            if(arr[j] &gt; arr[j + 1]) &#123;\n                temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            &#125;\n        &#125;\n        System.out.println(&quot;\\n==第&quot;+(i+1)+&quot;轮==&quot;);\n        for(int j = 0; j &lt; arr.length; j++) &#123;\n            System.out.print(arr[j] + &quot;\\t&quot;);\n        &#125;\t\n    &#125;\n&#125;6.11 查找\n顺序查找\n二分查找\n\n举例\n有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏：从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值。\njavapublic static void main(String[] args) &#123;\n    /*\n    有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏：\n    从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】\n    要求: 如果找到了，就提示找到，并给出下标值\n    思路分析\n    1. 定义一个字符串数组\n    2. 接收用户输入, 遍历数组，逐一比较，如果有，则提示信息，并退出\n    */\n    //定义一个字符串数组\n    String[] names = &#123;&quot;白眉鹰王&quot;, &quot;金毛狮王&quot;, &quot;紫衫龙王&quot;, &quot;青翼蝠王&quot;&#125;;\n    Scanner myScanner = new Scanner(System.in);\n    System.out.println(&quot;请输入名字&quot;);\n    String findName = myScanner.next();\n    //遍历数组，逐一比较，如果有，则提示信息，并退出\n    int index = -1;\n    for(int i = 0; i &lt; names.length; i++) &#123;\n        //比较 字符串比较 equals, 如果要找到名字就是当前元素\n        if(findName.equals(names[i])) &#123;\n            System.out.println(&quot;恭喜你找到 &quot; + findName);\n            System.out.println(&quot;下标为= &quot; + i);\n            //把 i 保存到 index\n            index = i;\n            break;//退出\n        &#125;\n    &#125;\n    if(index == -1) &#123; //没有找到\n        System.out.println(&quot;sorry ,没有找到 &quot; + findName);\n    &#125;\n&#125;\t6.12 多维数组-二维数组使用方式 1: 动态初始化\n语法: 类型[][] 数组名&#x3D;new 类型[大小][大小]\n比如: int a[][]&#x3D;new int[2][3]\n二维数组在内存的存在形式\n\n内存的存在形式\n\n代码演示\njavapublic static void main(String[] args) &#123;\n    //int arr[][] = new int[2][3];\n    int arr[][]; //声明二维数组\n    arr = new int[2][3];//再开空间\n    arr[1][1] = 8;\n    //遍历 arr 数组\n    for(int i = 0; i &lt; arr.length; i++) &#123;\n        for(int j = 0; j &lt; arr[i].length; j++) &#123;//对每个一维数组遍历\n            System.out.print(arr[i][j] +&quot; &quot;);\n        &#125;\n        System.out.println();//换行\n    &#125;\n&#125;使用方式 2: 动态初始化\n先声明：类型 数组名[][]; TwoDimensionalArray02.java\n再定义(开辟空间) 数组名 &#x3D; new 类型[大小][大小]\n赋值(有默认值，比如 int 类型的就是 0)\n\n使用方式 3: 动态初始化-列数不确定\n代码演示\njavapublic static void main(String[] args) &#123;\n    //看一个需求：动态创建下面二维数组，并输出\n    //i = 0: 1\n    //i = 1: 2 2\n    //i = 2: 3 3 3 一个有三个一维数组, 每个一维数组的元素是不一样的\n    //创建 二维数组，一个有 3 个一维数组，但是每个一维数组还没有开数据空间\n    int[][] arr = new int[3][];\n    for(int i = 0; i &lt; arr.length; i++) &#123;//遍历 arr 每个一维数组\n        //给每个一维数组开空间 new\n        //如果没有给一维数组 new ,那么 arr[i]就是 null\n        arr[i] = new int[i + 1];\n        //遍历一维数组，并给一维数组的每个元素赋值\n        for(int j = 0; j &lt; arr[i].length; j++) &#123;\n               arr[i][j] = i + 1;//赋值\n        &#125;\n    &#125;\n    System.out.println(&quot;=====arr 元素=====&quot;);\n    //遍历 arr 输出\n    for(int i = 0; i &lt; arr.length; i++) &#123;\n        //输出 arr 的每个一维数组\n        for(int j = 0; j &lt; arr[i].length; j++) &#123;\n            System.out.print(arr[i][j] + &quot; &quot;);\n        &#125;\n        System.out.println();//换行\n    &#125;\n&#125;使用方式 4: 静态初始化定义 类型 数组名[][] &#x3D; &#123;&#123;值 1,值 2..&#125;,&#123;值 1,值 2..&#125;,&#123;值 1,值 2..&#125;&#125;，使用即可 [ 固定方式访问 ]。\n比如:int[][] arr = &#123;&#123;1,1,1&#125;, &#123;8,8,9&#125;, &#123;100&#125;&#125;;\n解读\n\n定义了一个二维数组 arr\narr 有三个元素(每个元素都是一维数组)\n第一个一维数组有 3 个元素 , 第二个一维数组有 3 个元素, 第三个一维数组有 1 个元素\n\n举例\nint arr[][]=&#123;&#123;4,6&#125;,&#123;1,4,5,7&#125;,&#123;-2&#125;&#125;; 遍历该二维数组，并得到和\njavapublic static void main(String[] args) &#123;\n    /*\n    int arr[][]=&#123;&#123;4,6&#125;,&#123;1,4,5,7&#125;,&#123;-2&#125;&#125;; 遍历该二维数组，并得到和\n    思路\n    1. 遍历二维数组，并将各个值累计到 int sum\n    */\n    int arr[][]= &lt;!--swig￼4--&gt;;\n    int sum = 0;\n    for(int i = 0; i &lt; arr.length; i++) &#123;\n        //遍历每个一维数组\n        for(int j = 0; j &lt; arr[i].length; j++) &#123;\n            sum += arr[i][j];\n        &#125;\n    &#125;\n    System.out.println(&quot;sum=&quot; + sum);\n&#125;二维数组使用细节和注意事项\n一维数组的声明方式有:int[] x 或者 int x[]\n二维数组的声明方式有:int[][] y 或者int[] y[]或者 int y[][]\n二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。比如： map[][] 是一个二维数组int map [][] = &#123;&#123;1,2&#125;,&#123;3,4,5&#125;&#125;由 map[0] 是一个含有两个元素的一维数组 ，map[1] 是一个含有三个元素的一维数组构成，我们也称为列数不等的二维数组\n\n举例\n声明：int[] x,y[]:以下选项允许通过编译的是(b e)：\n说明：x是int类型一维数组，y是int类型的二维数组 \njavaa)\tx[0]=y;\t/错误 int[][]-&gt;int \nb)\ty[0]=x;\t/正确 int[][]-&gt;int[] \nc)\ty[0][0]=x;\t/错误 int[]-&gt;int \nd)\tx[O][O]=y;\t/错误 x[O][O]是错误 \ne)\ty[0][0]=x[0]:\t/正确 int-&gt;int \nf)\tx=y;\t/错误 int[们[]-&gt;int[]\n第 7 章 面向对象编程(基础部分)7.1 类与对象类与对象的关系示意图\n\n类和对象的区别和联系\n\n类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型. \n对象是具体的，实际的，代表一个具体事物, 即 是实例. \n类是对象的模板，对象是类的一个个体，对应一个实例\n\n对象在内存中存在形式(重要的)必须搞清楚。\n\n属性&#x2F;成员变量&#x2F;字段\n基本介绍\n\n从概念或叫法上看： 成员变量 &#x3D; 属性 &#x3D; field(字段) （即 成员变量是用来表示属性的）\n属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。比如：定义猫类 的 int age 就是属性\n\n注意事项和细节说明\n\n属性的定义语法同变量，示例：访问修饰符 属性类型 属性名;\n属性的定义类型可以为任意类型，包含基本类型或引用类型\n属性如果不赋值，有默认值，规则和数组一致。具体说: int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000，boolean false，String null\n\n如何创建对象\n\n先声明再创建\n\njavaCat cat ; //声明对象 cat\ncat = new Cat(); //创建\n直接创建\n\njavaCat cat = new Cat();如何访问属性\n基本语法：对象名.属性名;\n类和对象的内存分配机制(重要)\n定义一个人类(Person)(包括 名字,年龄)。\njavaPerson p1 = new Person();\np1.age = 10;\np1.name = &quot;小明&quot;;\nPerson p2 = p1; //把p1赋给了p2,让p2指向p1\nSystem.out.println(p2.age);问题：p2.age究竟是多少？并画出内存图：\n\n类和对象的内存分配机制\n1、Java 内存的结构分析\n\n栈： 一般存放基本数据类型(局部变量)\n堆： 存放对象(Cat cat , 数组等)\n方法区：常量池(常量，比如字符串)， 类加载信息\n\n2、Java 创建对象的流程简单分析\njavaPerson p = new Person();\np.name = &quot;jack&quot;;\np.age = 10\n先加载 Person 类信息(属性和方法信息, 只会加载一次)\n在堆中分配空间, 进行默认初始化(看规则)\n把地址赋给 p , p 就指向对象\n进行指定初始化， 比如 p.name = &quot;jack&quot; p.age = 10\n\n3、练习题\n观察下面代码，分析并画出内存布局图\njavaPerson a = new Person();\na.age = 10;\na.name = &quot;小明&quot;;\nPerson b;\nb = a;\nSystem.out.println(b.name); //小明\nb.age = 200;\nb = null;\nSystem.out.println(a.age); //200\nSystem.out.println(b.age); //异常\n7.2 成员方法基本介绍\n在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用成员方法才能完成。现在要求对 Person 类完善。\n 方法的调用机制原理：(重要!-示意图!!!)\n\n成员方法的定义\njava访问修饰符 返回数据类型 方法名（形参列表..） &#123;//方法体\n    语句；\n    return 返回值;\n&#125;\n形参列表：表示成员方法输入 cal(int n) ， getSum(int num1, int num2)\n返回数据类型：表示成员方法输出, void 表示没有返回值\n方法主体：表示为了实现某一功能代码块\nreturn 语句不是必须的。\n\n注意事项和使用细节\n1、访问修饰符 (作用是控制 方法使用的范围)\n如果不写默认访问，[有四种: public, protected, 默认, private], 具体在后面说\n2、返回数据类型\n\n一个方法最多有一个返回值 [返回多个结果 -&gt; 返回数组 ]\n返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)\n如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的值类型一致或兼容\n如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return ;\n\n方法名\n遵循驼峰命名法，最好见名知义，表达出该功能的意思即可, 比如 得到两个数的和 getSum, 开发中按照规范\n形参列表\n\n一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如getSum(intn1,intn2)\n参数类型可以为任意类型，包含基本类型或引用类型，比如printArr(int[][] map) \n调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数！getSum \n方法定义时的参数称为形式参数，简称形参；方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致回或兼容、个数、顺序必须一致！\n\n方法体\n里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义。\n7.3 成员方法传参机制(非常重要)7.3.1 基本数据类型的传参机制分析代码结果\njavapublic class MethodParameter01 &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        int a = 10;\n        int b = 20;\n        //创建 AA 对象 名字 obj\n        AA obj = new AA();\n        obj.swap(a, b); //调用 swap\n        System.out.println(&quot;main 方法 a=&quot; + a + &quot; b=&quot; + b);//a=10 b=20\n    &#125;\n&#125;\nclass AA &#123;\n    public void swap(int a,int b)&#123;\n        System.out.println(&quot;\\na 和 b 交换前的值\\na=&quot; + a + &quot;\\tb=&quot; + b);//a=10 b=20\n        //完成了 a 和 b 的交换\n        int tmp = a;\n        a = b;\n        b = tmp;\n        System.out.println(&quot;\\na 和 b 交换后的值\\na=&quot; + a + &quot;\\tb=&quot; + b);//a=20 b=10\n    &#125;\n&#125;内存分析\n\n7.3.2 引用数据类型的传参机制分析代码结果\njavapublic class MethodParameter02 &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        //测试\n        B b = new B();\n        // int[] arr = &#123;1, 2, 3&#125;;\n        // b.test100(arr);//调用方法\n        // System.out.println(&quot; main 的 arr 数组 &quot;);\n        // //遍历数组\n        // for(int i = 0; i &lt; arr.length; i++) &#123;\n        // System.out.print(arr[i] + &quot;\\t&quot;);\n        // &#125;\n        // System.out.println();\n        \n        //测试\n        Person p = new Person();\n        p.name = &quot;jack&quot;;\n        p.age = 10;\n        b.test200(p);\n        //测试题, 如果 test200 执行的是 p = null ,下面的结果是 10\n        //测试题, 如果 test200 执行的是 p = new Person();..., 下面输出的是 10\n        System.out.println(&quot;main 的 p.age=&quot; + p.age);//10000\n    &#125;\n&#125;\nclass Person &#123;\n    String name;\n    int age;\n&#125;\nclass B &#123;\n    public void test200(Person p) &#123;\n        //p.age = 10000; //修改对象属性\n        //思考\n        p = new Person();\n        p.name = &quot;tom&quot;;\n        p.age = 99;\n        //思考\n        //p = null;\n    &#125;\n    //B 类中编写一个方法 test100，\n    //可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化\n    public void test100(int[] arr) &#123;\n        arr[0] = 200;//修改元素\n        //遍历数组\n        System.out.println(&quot; test100 的 arr 数组 &quot;);\n        for(int i = 0; i &lt; arr.length; i++) &#123;\n        System.out.print(arr[i] + &quot;\\t&quot;);\n        &#125;\n        System.out.println();\n    &#125;\n&#125;结论及示意图\n结论：引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！\n\np=null和 p = new Person(); 对应示意图\n\n7.3.3 成员方法返回类型是引用类型应用实例MethodExercise02.java\n\n编写类 MyTools 类，编写一个方法可以打印二维数组的数据。\n编写一个方法 copyPerson，可以复制一个 Person 对象，返回复制的对象。克隆对象， 注意要求得到新对象和原来的对象是两个独立的对象，只是他们的属性相同\n\n代码\njavapublic class MethodExercise02 &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n    Person p = new Person();\n    p.name = &quot;milan&quot;;\n    p.age = 100;\n    //创建 tools\n    MyTools tools = new MyTools();\n    Person p2 = tools.copyPerson(p);\n    //到此 p 和 p2 是 Person 对象，但是是两个独立的对象，属性相同\n    System.out.println(&quot;p 的属性 age=&quot; + p.age + &quot; 名字=&quot; + p.name);\n    System.out.println(&quot;p2 的属性 age=&quot; + p2.age + &quot; 名字=&quot; + p2.name);\n    //这里老师提示： 可以同 对象比较看看是否为同一个对象\n    System.out.println(p == p2);//false\n    &#125;\n&#125;\nclass Person &#123;\n    String name;\n    int age;\n&#125;\nclass MyTools &#123;\n    //编写一个方法 copyPerson，可以复制一个 Person 对象，返回复制的对象。克隆对象，\n    //注意要求得到新对象和原来的对象是两个独立的对象，只是他们的属性相同\n    //\n    //编写方法的思路\n    //1. 方法的返回类型 Person\n    //2. 方法的名字 copyPerson\n    //3. 方法的形参 (Person p)\n    //4. 方法体, 创建一个新对象，并复制属性，返回即可\n    public Person copyPerson(Person p) &#123;\n    //创建一个新的对象\n    Person p2 = new Person();\n    p2.name = p.name; //把原来对象的名字赋给 p2.name\n    p2.age = p.age; //把原来对象的年龄赋给 p2.age\n    return p2;\n    &#125;\n&#125;示意图\n\n7.4 方法递归调用递归举例\n列举两个小案例\n\n打印问题\n阶乘问题\n\n代码\njavapublic class Recursion01 &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        T t1 = new T();\n        t1.test(4);//输出什么？ n=2 n=3 n=4\n        int res = t1.factorial(5);\n        System.out.println(&quot;5 的阶乘 res =&quot; + res);\n    &#125;\n&#125;\nclass T &#123;\n    //分析\n    public void test(int n) &#123;\n        if (n &gt; 2) &#123;\n            test(n - 1);\n        &#125;\n        System.out.println(&quot;n=&quot; + n);\n    &#125;\n    //factorial 阶乘\n    public int factorial(int n) &#123;\n        if (n == 1) &#123;\n            return 1;\n        &#125; else &#123;\n            return factorial(n - 1) * n;\n        &#125;\n    &#125;\n&#125;分析示意图\n\n递归重要规则\n\n执行一个方法时，就创建一个新的受保护的独立空间（栈空间）\n方法的局部变量是独立的，不会相互影响，比如n变量\n如果方法中使用的是引用类型变量（比如数组，对象），就会共享该引用类型的数据.\n递归必须向退出递归的条件逼近，否则就是无限递归出现 StackOverflowError\n当一个方法执行完毕，或者遇到return,就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。\n\n练习题\n\n请使用递归的方式求出斐波那契数1,1,2,3,5,8,13.…给你一个整数n,求出它的值是多少\n猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！以后每天猴子都吃其中的一半，然后再多吃一个。当到第10天时，想再吃时（即还没吃）发现只有1个桃子了。问题：最初共多少个桃子？\n\n代码\njavapublic class RecursionExercise01 &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        T t1 = new T();\n        // int n = 7;\n        // int res = t1.fibonacci(n);\n        // if(res != -1) &#123;\n        // System.out.println(&quot;当 n=&quot;+ n +&quot; 对应的斐波那契数=&quot; + res);\n        // &#125;\n        //\n        //桃子问题\n        int day = 0;\n        int peachNum = t1.peach(day);\n        if(peachNum != -1) &#123;\n            System.out.println(&quot;第 &quot; + day + &quot;天有&quot; + peachNum + &quot;个桃子&quot;);\n        &#125;\t\n    &#125;\n&#125;\nclass T &#123;\n    /*\n    请使用递归的方式求出斐波那契数 1,1,2,3,5,8,13...给你一个整数 n，求出它的值是多\n    思路分析\n    1. 当 n = 1 斐波那契数 是 1\n    2. 当 n = 2 斐波那契数 是 1\n    3. 当 n &gt;= 3 斐波那契数 是前两个数的和\n    4. 这里就是一个递归的思路\n    */\n    public int fibonacci(int n) &#123;\n        if( n &gt;= 1) &#123;\n        if( n == 1 || n == 2) &#123;\n            return 1;\n        &#125; else &#123;\n            return fibonacci(n-1) + fibonacci(n-2);\n        &#125; else &#123;\n            System.out.println(&quot;要求输入的 n&gt;=1 的整数&quot;);\n            return -1;\n        &#125;\n    &#125;\n    /*\n    猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！\n    以后每天猴子都吃其中的一半，然后再多吃一个。当到第 10 天时，\n    想再吃时（即还没吃），发现只有 1 个桃子了。问题：最初共多少个桃子？\n    思路分析 逆推\n    1. day = 10 时 有 1 个桃子\n    2. day = 9 时 有 (day10 + 1) * 2 = 4\n    3. day = 8 时 有 (day9 + 1) * 2 = 10\n    4. 规律就是 前一天的桃子 = (后一天的桃子 + 1) *2//就是我们的能力\n    5. 递归\n    */\n    public int peach(int day) &#123;\n        if(day == 10) &#123;//第 10 天，只有 1 个桃\n            return 1;\n        &#125; else if ( day &gt;= 1 &amp;&amp; day &lt;=9 ) &#123;\n            return (peach(day + 1) + 1) * 2;//规则，自己要想\n        &#125; else &#123;\n            System.out.println(&quot;day 在 1-10&quot;);\n            return -1;\n        &#125;\n    &#125;\n&#125;递归调用应用实例-迷宫问题\n\n代码\njavapublic class MiGong &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        //思路\n        //1. 先创建迷宫，用二维数组表示 int[][] map = new int[8][7];\n        //2. 先规定 map 数组的元素值: 0 表示可以走 1 表示障碍物\n        int[][] map = new int[8][7];\n        //3. 将最上面的一行和最下面的一行，全部设置为 1\n        for(int i = 0; i &lt; 7; i++) &#123;\n            map[0][i] = 1;\n            map[7][i] = 1;\n        &#125;\n        //4.将最右面的一列和最左面的一列，全部设置为 1\n        for(int i = 0; i &lt; 8; i++) &#123;\n            map[i][0] = 1;\n            map[i][6] = 1;\n        &#125;\n        map[3][1] = 1;\n        map[3][2] = 1;\n        map[2][2] = 1; //测试回溯\n        // map[2][1] = 1;\n        // map[2][2] = 1;\n        // map[1][2] = 1;\n        //输出当前的地图\n        System.out.println(&quot;=====当前地图情况======&quot;);\n        for(int i = 0; i &lt; map.length; i++) &#123;\n            for(int j = 0; j &lt; map[i].length; j++) &#123;\n                System.out.print(map[i][j] + &quot; &quot;);//输出一行\n            &#125;\n            System.out.println();\n        &#125;\n        //使用 findWay 给老鼠找路\n        T t1 = new T();\n        //下右上左\n        t1.findWay(map, 1, 1);\n        System.out.println(&quot;\\n====找路的情况如下=====&quot;);\n        for(int i = 0; i &lt; map.length; i++) &#123;\n            for(int j = 0; j &lt; map[i].length; j++) &#123;\n                System.out.print(map[i][j] + &quot; &quot;);//输出一行\n            &#125;\n        System.out.println();\n        &#125;\n    &#125;\n&#125;\nclass T &#123;\n    //使用递归回溯的思想来解决老鼠出迷宫\n    //1. findWay 方法就是专门来找出迷宫的路径\n    //2. 如果找到，就返回 true ,否则返回 false\n    //3. map 就是二维数组，即表示迷宫\n    //4. i,j 就是老鼠的位置，初始化的位置为(1,1)\n    //5. 因为我们是递归的找路，所以我先规定 map 数组的各个值的含义\n    // 0 表示可以走 1 表示障碍物 2 表示可以走 3 表示走过，但是走不通是死路\n    //6. 当 map[6][5] =2 就说明找到通路,就可以结束，否则就继续找. //7. 先确定老鼠找路策略 下-&gt;右-&gt;上-&gt;左\n    public boolean findWay(int[][] map , int i, int j) &#123;\n        if(map[6][5] == 2) &#123;//说明已经找到\n            return true;\n        &#125; else &#123;\n            if(map[i][j] == 0) &#123;//当前这个位置 0,说明表示可以走\n            //我们假定可以走通\n            map[i][j] = 2;\n            //使用找路策略，来确定该位置是否真的可以走通\n            //下-&gt;右-&gt;上-&gt;左\n            if(findWay(map, i + 1, j)) &#123;//先走下\n                return true;\n            &#125; else if(findWay(map, i, j + 1))&#123;//右\n                return true;\n            &#125; else if(findWay(map, i-1, j)) &#123;//上\n                return true;\n            &#125; else if(findWay(map, i, j-1))&#123;//左\n                return true;\n            &#125; else &#123;\n                map[i][j] = 3;\n                return false;\n            &#125;\n         &#125; else &#123; //map[i][j] = 1 , 2, 3\n                return false;\n            &#125;\n        &#125;\n    &#125;\n&#125;递归调用应用实例-汉诺塔\n\n代码\njavapublic class HanoiTower &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        Tower tower = new Tower();\n        tower.move(64, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);\n    &#125;\n&#125;\nclass Tower &#123;\n    //方法\n    //num 表示要移动的个数, a, b, c 分别表示 A 塔，B 塔, C 塔\n    public void move(int num , char a, char b ,char c) &#123;\n        //如果只有一个盘 num = 1\n        if(num == 1) &#123;\n            System.out.println(a + &quot;-&gt;&quot; + c);\n        &#125; else &#123;\n            //如果有多个盘，可以看成两个 , 最下面的和上面的所有盘(num-1)\n            //(1)先移动上面所有的盘到 b, 借助 c\n            move(num - 1 , a, c, b);\n            //(2)把最下面的这个盘，移动到 c\n            System.out.println(a + &quot;-&gt;&quot; + c);\n            //(3)再把 b 塔的所有盘，移动到 c ,借助 a\n            move(num - 1, b, a, c);\n        &#125;\n    &#125;\n&#125;7.5 方法重载(OverLoad)基本介绍\njava 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！\n重载的好处\n\n减轻了起名的麻烦\n减轻了记名的麻烦\n\n注意事项和使用细节\n\n方法名：必须相同\n形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求\n返回类型：无要求\n\n练习题\n与void show(inta,char b,double c)构成重载的有：[b c d e] \na) void show(intx,char y,double z&#123;&#125;\t&#x2F;不是 \nb) int show(int a,double c,char b)&#123;&#125;\t&#x2F;是 \nc) void show(int a,double c,char b)&#123;&#125;\t&#x2F;是\nd) boolean show(int c,char b)&#123;&#125;\t&#x2F;是\ne) void show(double c)&#123;&#125;\t&#x2F;是\nf)double show(intx,char y,double z)&#123;&#125;\t&#x2F;不是 \ng) void shows()&#123;&#125;\t&#x2F;不是\n7.6 可变参数基本概念\njava 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。就可以通过可变参数实现\n基本语法\njava访问修饰符 返回类型 方法名(数据类型... 形参名) &#123;\n&#125;举例\n\nint… 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)\n使用可变参数时，可以当做数组来使用 即 nums 可以当做数组\n遍历 nums 求和即可\n\njavapublic int sum(int... nums) &#123;\n    //System.out.println(&quot;接收的参数个数=&quot; + nums.length);\n    int res = 0;\n    for(int i = 0; i &lt; nums.length; i++) &#123;\n        res += nums[i];\n    &#125;\n    return res;\n&#125;注意事项和使用细节\nVarParameterDetail.java \n\n可变参数的实参可以为0个或任意多个。 \n可变参数的实参可以为数组。 \n可变参数的本质就是数组. \n可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后 \n一个形参列表中只能出现一个可变参数\n\n代码\njavapublic class VarParameterDetail &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        //细节: 可变参数的实参可以为数组\n        int[] arr = &#123;1, 2, 3&#125;;\n        T t1 = new T();\n        t1.f1(arr);\n    &#125;\n&#125;\nclass T &#123;\n    public void f1(int... nums) &#123;\n        System.out.println(&quot;长度=&quot; + nums.length);\n    &#125;\n    //细节: 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后\n    public void f2(String str, double... nums) &#123;\n    &#125;\n    //细节: 一个形参列表中只能出现一个可变参数\n    //下面的写法是错的. \n    // public void f3(int... nums1, double... nums2) &#123;\n    // &#125;\n&#125;练习题\n有三个方法，分别实现返回姓名和两门课成绩（总分），返回姓名和三门课成绩（总分)，返回姓名和五门课成绩（总分）。封装成一个可变参数的方法。类名HspMethod，方法名showScore。\njavapublic class VarParameterExercise &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        HspMethod hm = new HspMethod();\n        System.out.println(hm.showScore(&quot;milan&quot; , 90.1, 80.0 ));\n        System.out.println(hm.showScore(&quot;terry&quot; , 90.1, 80.0,10,30.5,70 ));\n    &#125;\n&#125;\nclass HspMethod &#123;\n    /*\n    有三个方法，分别实现返回姓名和两门课成绩(总分)，\n    返回姓名和三门课成绩(总分)，返回姓名和五门课成绩（总分）。\n    封装成一个可变参数的方法\n    */\n    //分析 1. 方法名 showScore 2. 形参(String ,double... ) 3. 返回 String\n    public String showScore(String name ,double... scores ) &#123;\n        double totalScore = 0;\n        for(int i = 0; i &lt; scores.length; i++) &#123;\n            totalScore += scores[i];\n        &#125;\n        return name + &quot; 有 &quot; +scores.length + &quot;门课的成绩总分为=&quot; + totalScore;\n    &#125;\n&#125;7.7 作用域基本使用\n面向对象中，变量作用域是非常重要知识点。\n\n在java编程中，主要的变量就是属性（成员变量）和局部变量。\n我们说的局部变量一般是指在成员方法中定义的变量。【举例Cat类：cry】 \njava中作用域的分类：\n全局变量：也就是属性，作用域为整个类体Cat类：cry eat等方法使用属性【举例】\n局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中！\n\n\n全局变量（属性）可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。[举例]\n\n代码举例\njavaclass Cat &#123;\n    //全局变量：也就是属性，作用域为整个类体 Cat 类：cry eat 等方法使用属性\n    //属性在定义时，可以直接赋值\n    int age = 10; //指定的值是 10\n    //全局变量(属性)可以不赋值，直接使用，因为有默认值，\n    double weight; //默认值是 0.0\n    public void hi() &#123;\n        //局部变量必须赋值后，才能使用，因为没有默认值\n        int num = 1;\n        String address = &quot;北京的猫&quot;;\n        System.out.println(&quot;num=&quot; + num);\n        System.out.println(&quot;address=&quot; + address);\n        System.out.println(&quot;weight=&quot; + weight);//属性\n    &#125;\n    public void cry() &#123;\n        //1. 局部变量一般是指在成员方法中定义的变量\n        //2. n 和 name 就是局部变量\n        //3. n 和 name 的作用域在 cry 方法中\n        int n = 10;\n        String name = &quot;jack&quot;;\n        System.out.println(&quot;在 cry 中使用属性 age=&quot; + age);\n    &#125;\n    public void eat() &#123;\n        System.out.println(&quot;在 eat 中使用属性 age=&quot; + age);\n        //System.out.println(&quot;在 eat 中使用 cry 的变量 name=&quot; + name);//错误\n    &#125;\n&#125;注意事项和细节使用\n\n属性和局部变量可以重名，访问时遵循就近原则 \n在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。\n属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。\n作用域范围不同\n全局变量&#x2F;属性：可以被本类使用，或其他类使用（通过对象调用）\n局部变量：只能在本类中对应的方法中使用\n\n\n修饰符不同\n全局变量&#x2F;属性可以加修饰符\n局部变量不可以加修饰符\n\n\n\njavapublic class VarScopeDetail &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        Person p1 = new Person();\n        /*\n        属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。\n        局部变量，生命周期较短，伴随着它的代码块的执行而创建，\n        伴随着代码块的结束而销毁。即在一次方法调用过程中\n        */\n        //p1.say();//当执行 say 方法时，say 方法的局部变量比如 name,会创建，当 say 执行完毕后\n        //name 局部变量就销毁,但是属性(全局变量)仍然可以使用\n        //\n        T t1 = new T();\n        t1.test(); //第 1 种跨类访问对象属性的方式\n        t1.test2(p1);//第 2 种跨类访问对象属性的方式\n    &#125;\n&#125;\nclass T &#123;\n    //全局变量/属性：可以被本类使用，或其他类使用（通过对象调用)\n    public void test() &#123;\n        Person p1 = new Person();\n        System.out.println(p1.name);//jack\n    &#125;\n    public void test2(Person p) &#123;\n        System.out.println(p.name);//jack\n    &#125;\n&#125;\nclass Person &#123;\n    //细节: 属性可以加修饰符(public protected private..)\n    // 局部变量不能加修饰符\n    public int age = 20;\n    String name = &quot;jack&quot;;\n    public void say() &#123;\n        //细节 属性和局部变量可以重名，访问时遵循就近原则\n        String name = &quot;king&quot;;\n        System.out.println(&quot;say() name=&quot; + name);\n    &#125;\n    public void hi() &#123;\n        String address = &quot;北京&quot;;\n        //String address = &quot;上海&quot;;//错误,重复定义变量\n        String name = &quot;hsp&quot;;//可以\n    &#125;\n&#125;7.8 构造方法&#x2F;构造器基本语法\njava[修饰符] 方法名(形参列表)&#123;\n    方法体;\n&#125;\n构造器的修饰符可以默认， 也可以是 public protected private\n构造器没有返回值\n方法名 和类名字必须一样\n参数列表 和 成员方法一样的规则\n构造器的调用, 由系统完成\n\n基本介绍\n构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。它有几个特点：\n\n方法名和类名相同\n没有返回值\n在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。\n\n举例\njavapublic class Constructor01 &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        //当我们 new 一个对象时，直接通过构造器指定名字和年龄\n        Person p1 = new Person(&quot;smith&quot;, 80);\n        System.out.println(&quot;p1 的信息如下&quot;);\n        System.out.println(&quot;p1 对象 name=&quot; + p1.name);//smith\n        System.out.println(&quot;p1 对象 age=&quot; + p1.age);//80\n        &#125;\n&#125;\n//在创建人类的对象时，就直接指定这个对象的年龄和姓名\nclass Person &#123;\n    String name;\n    int age;\n    //构造器\n    //1. 构造器没有返回值, 也不能写 void\n    //2. 构造器的名称和类 Person 一样\n    //3. (String pName, int pAge) 是构造器形参列表，规则和成员方法一样\n    public Person(String pName, int pAge) &#123;\n        System.out.println(&quot;构造器被调用~~ 完成对象的属性初始化&quot;);\n        name = pName;\n        age = pAge;\n    &#125;\n&#125;注意事项和使用细节\n\n一个类可以定义多个不同的构造器，即构造器重载\n比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名不需要指定年龄\n\n\n构造器名和类名要相同 \n构造器没有返回值 \n构造器是完成对象的初始化，并不是创建对象 \n在创建对象时，系统自动的调用该类的构造方法 \n如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器)，比如Dog()&#123;&#125;,使用javap指令反编译看看\n一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下，即：Dog()&#123;&#125;写（重要）\n\njavapublic class ConstructorDetail &#123;\n    //编写一个 main 方法\n    public static void main(String[] args) &#123;\n        Person p1 = new Person(&quot;king&quot;, 40);//第 1 个构造器\n        Person p2 = new Person(&quot;tom&quot;);//第 2 个构造器\n        Dog dog1 = new Dog();//使用的是默认的无参构造器\n    &#125;\n&#125;\nclass Dog &#123;\n    //如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)\n    //使用 javap 指令 反编译看看\n    /*\n    默认构造器\n    Dog() &#123;\n    &#125;\n    */\n    //一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，\n    //除非显式的定义一下,即: Dog()&#123;&#125; 写 (这点很重要)\n    public Dog(String dName) &#123;\n    &#125;\n    Dog() &#123; //显式的定义一下 无参构造器\n    &#125;\n&#125;\nclass Person &#123;\n    String name;\n    int age;//默认 0\n    //第 1 个构造器\n    public Person(String pName, int pAge) &#123;\n        name = pName;\n        age = pAge;\n    &#125;\n    //第 2 个构造器, 只指定人名，不需要指定年龄\n    public Person(String pName) &#123;\n        name = pName;\n    &#125;\n&#125;7.9 对象创建的流程分析javaclass Person//Person \n    int age=90; \n    String name; \n    Person(String n,int a)&#123;//构造器 \t\n        name=n;\t//给属性赋值 \n        age=a;//..\n    &#125;\n&#125;\nPerson p = new Person(&quot;小倩, 20&quot;);流程分析（面试题)\n\n加载Person类信息(Person.class),只会加载一次 \n在堆中分配空间（地址） \n完成对象初始化 \n默认初始化age=0 name=null\n显式初始化 age=90 name=null\n构造器的初始化age=20,name=小倩\n\n\n在对象在堆中的地址，返回给p(p是对象名，也可以理解成是对象的引用)\n\n\n7.10 this 关键字分析this与示意图\nthis：简单的说，哪个对象调用，this就代表哪个对象。\n使用hashCode()查看对象的情况。\njavaclass Dog&#123;\n    public String name;\n    public int age;\n    public Dog(String name, int in_age)&#123;\n        this.name = name;\n        this.age = in_age;\n    &#125;\n    public void info()&#123;\n        System.out.println(this.name + &quot;\\t&quot; + this.age + &quot;\\t&quot; \n        + &quot;当前对象的hashCode是:&quot; + this.hashcode());\n    &#125;\n&#125;示意图\n\nthis 的注意事项和使用细节\n\nthis 关键字可以用来访问本类的属性、方法、构造器\nthis 用于区分当前类的属性和局部变量\n访问成员方法的语法：this.方法名(参数列表);\n访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一条语句)\nthis 不能在类定义的外部使用，只能在类定义的方法中使用。\n\n\n第 8 章 面向对象编程(中级部分)8.1 IDE（集成开发环境）-IDEAIDEA 常用快捷键\n\n删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d\n复制当前行, 自己配置 ctrl + alt + 向下光标\n补全代码 alt + /\n添加注释和取消注释 ctrl + / 【第一次是添加注释，第二次是取消注释】\n导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可\n快速格式化代码 ctrl + alt + L\n快速运行程序 自己定义 alt + R\n生成构造器等 alt + insert [提高开发效率]\n查看一个类的层级关系 ctrl + H [学习继承后，非常有用]\n将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用]\n自动的分配变量名 , 通过在后面加 .var\n还有很多其它的快捷键\n\n模板&#x2F;自定义模板\nfile-&gt; settings -&gt; editor -&gt; Live templates -&gt;\n查看有哪些模板快捷键&#x2F;可以自己增加模板\n模板可以高效的完成开发，提高速度\n8.2 包包的三大作用\n\n区分相同名字的类\n当类很多时，可以很好的管理类[看Java API文档] \n控制访问范围\n\n包基本语法\n\npackage关键字，表示打包 \ncom.edu:表示包名\n\n包的本质分析(原理)\n\n快速入门\n\n包的命名\n命名规则：只能包含数字、字母、下划线、小圆点。但不能用数字开头，不能是关键字或保留字\n举例：\njavademo.class.exec1 /错误 class是关键字\ndemo.12a \t/错误 12a是数字开头\ndemo.ab12.oa\t/对命名规范：一般是小写字母+小圆点\ncom.公司名.项目名.业务模块名\n比如：com.atguigu.oa.model; com.atguigu.oa.controller;\n举例：\njavacom.sina.crm.user /用户模块\ncom.sina.crm.order /订单模块\ncom.sina.crm.utils\t/工具类常用的包\n一个包下,包含很多的类,java 中常用的包有:\n\njava.lang.* ：lang 包是基本包，默认引入，不需要再引入. \njava.util.* ：util 包，系统提供的工具包, 工具类，使用 Scanner\njava.net.*  ：网络包，网络开发\njava.awt.*  ：是做 java 的界面开发，GUI\n\n注意事项和使用细节\n\npackage的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package\nimport指令位置放在package的下面，在类定义前面，可以有多句且没有顺序要求。\n\n8.3 访问修饰符基本介绍\njava 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）:\n\n公开级别：用 public 修饰，对外公开。\n受保护级别：用 protected 修饰，对子类和同一个包中的类公开。\n默认级别：没有修饰符号，向同一个包的类公开。\n私有级别：用 private 修饰,只有类本身可以访问，不对外公开。\n\n4 种访问修饰符的访问范围（重要，最好背）\n\n\n\n访问级别\n访问控制修饰符\n同类\n同包\n子类\n不同包\n\n\n\n公开\npublic\n√\n√\n√\n√\n\n\n受保护\nprotected\n√\n√\n√\n×\n\n\n默认\n没有修饰符\n√\n√\n×\n×\n\n\n私有\nprivate\n√\n×\n×\n×\n\n\n使用的注意事项\n\n修饰符可以用来修饰类中的属性，成员方法以及类\n只有默认的和public.才能修饰类！并且遵循上述访问权限的特点。\n因为没有学习继承，因此关于在子类中的访问权限，在子类中讲解\n成员方法的访问规则和属性完全一样。\n\n代码演示\njavapublic class A &#123;\n    //四个属性,分别使用不同的访问修饰符来修饰\n    public int n1 = 100;\n    protected int n2 = 200;\n    int n3 = 300;\n    private int n4 = 400;\n    public void m1() &#123;\n        //在同一类中，可以访问 public protected 默认 private 修饰属性和方法\n        System.out.println(&quot;n1=&quot; + n1 + &quot; n2=&quot; + n2 + &quot; n3=&quot; + n3 + &quot; n4=&quot; + n4);\n    &#125;\n    protected void m2() &#123; &#125;\n    void m3() &#123; &#125;\n    private void m4() &#123; &#125;\n    public void hi() &#123;\n        //在同一类中，可以访问 public protected 默认 private 修饰属性和方法\n        m1();\n        m2();\n        m3();\n        m4();\n    &#125;\n&#125;javapublic class B &#123;\n    public void say() &#123;\n        A a = new A();\n        //在同一个包下，可以访问 public , protected 和 默认修饰属性或方法,不能访问 private 属性或方法\n        System.out.println(&quot;n1=&quot; + a.n1 + &quot; n2=&quot; + a.n2 + &quot; n3=&quot; + a.n3 );\n        a.m1();\n        a.m2();\n        a.m3();\n        //a.m4(); 错误的\n    &#125;\n&#125;javapublic class Test &#123;\n    public static void main(String[] args) &#123;\n    A a = new A ();\n    a.m1();\n    B b = new B();\n    b.say();\n    &#125;\n&#125;\n//只有 默认和 public 可以修饰类\nclass Tiger&#123; &#125;8.4 面向对象编程三大特征基本介绍\n面向对象编程有三大特征：封装、继承和多态。\n封装介绍\n封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作[方法]，才能对数据进行操作。\n封装的理解和好处\n\n隐藏实现细节：方法（连接数据库）&lt;– 调用（传入参数）\n可以对数据进行验证，保证安全合理\n\njavaPerson &#123;name,age&#125;\nPerson p new Person();\np.name=&quot;jack”; \np.age=1200;封装的实现步骤 (三步)\n\n将属性进行私有化private【不能直接修改属性】 \n\n提供一个公共的(public)set方法，用于对属性判断并赋值 \n\njavapublic void setXxx(类型 参数名)&#123; //Xxx表示某个属性\n    //加入数据验证的业务逻辑\n    属性 = 参数名;\n&#125;\n\n\n提供一个公共的(public)get方法，用于获取属性的值 \n\njavapublic 数据类型 getXxx()&#123; //权限判断，Xx某个属性 \n    return xx;\n&#125;\n\n\n\n快速入门案例\n不能随便查看人的年龄，工资等隐私，并对设置的年龄进行合理的验证。年龄合理就设置，否则给默认年龄，必须在1-120，年龄，工资不能直接查看 name的长度在2-6字符之间\njavaclass Person &#123;\n    public String name; //名字公开\n    private int age; //age 私有化\n    private double salary; //.. \n    public void say(int n,String name) &#123;&#125;\n    //构造器 alt+insert\n    public Person() &#123;\n    &#125;\n    //有三个属性的构造器\n    public Person(String name, int age, double salary) &#123;\n        // this.name = name;\n        // this.age = age;\n        // this.salary = salary;\n        //我们可以将 set 方法写在构造器中，这样仍然可以验证\n        setName(name);\n        setAge(age);\n        setSalary(salary);\n    &#125;\n    //自己写 setXxx 和 getXxx 太慢，我们使用快捷键\n    //然后根据要求来完善我们的代码. \n    public String getName() &#123;\n        return name;\n    &#125;\n    \n    public void setName(String name) &#123;\n        //加入对数据的校验,相当于增加了业务逻辑\n        if(name.length() &gt;= 2 &amp;&amp; name.length() &lt;=6 ) &#123;\n            this.name = name;\n        &#125;else &#123;\n            System.out.println(&quot;名字的长度不对，需要(2-6)个字符，默认名字&quot;);\n        this.name = &quot;无名人&quot;;\n        &#125;\n    &#125;\n    \n    public int getAge() &#123;\n        return age;\n    &#125;\n    \n    public void setAge(int age) &#123;\n        //判断\n        if(age &gt;= 1 &amp;&amp; age &lt;= 120) &#123;//如果是合理范围\n            this.age = age;\n        &#125; else &#123;\n            System.out.println(&quot;你设置年龄不对，需要在 (1-120), 给默认年龄 18 &quot;);\n            this.age = 18;//给一个默认年龄\n        &#125;\n    &#125;\n    \n    public double getSalary() &#123;\n    //可以这里增加对当前对象的权限判断\n        return salary;\n    &#125;\n    \n    public void setSalary(double salary) &#123;\n        this.salary = salary;\n    &#125;\n    \n    //写一个方法，返回属性信息\n    public String info() &#123;\n        return &quot;信息为 name=&quot; + name + &quot; age=&quot; + age + &quot; 薪水=&quot; + salary;\n    &#125;\n&#125;将构造器和 setXxx 结合\njava//有三个属性的构造器\npublic Person(String name, int age, double salary) &#123;\n    // this.name = name;\n    // this.age = age;\n    // this.salary = salary;\n    //我们可以将 set 方法写在构造器中，这样仍然可以验证\n    setName(name);\n    setAge(age);\n    setSalary(salary);\n&#125;8.5 面向对象编程-继承继承基本介绍和示意图\n\n\n\n\n\n\n\n\n\n继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。画出继承的示意图\n\n继承的基本语法\njavaclass 子类 extends 父类&#123;\n&#125;\n子类就会自动拥有父类定义的属性和方法\n父类又叫超类，基类\n子类又叫派生类\n\n继承给编程带来的便利\n\n代码的复用性提高了\n代码的扩展性和维护性提高了\n\n继承的深入讨论&#x2F;细节问题\n\n子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问。\n子类必须调用父类的构造器， 完成父类的初始化。\n当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过。\n如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)\nsuper 在使用时，必须放在构造器第一行(super 只能在构造器中使用)\nsuper() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器\njava 所有类都是 Object 类的子类, Object 是所有类的基类. \n父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)\n子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。那么如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】\n不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系\n\n代码举例\njavapublic class ExtendsDetail &#123;\n    public static void main(String[] args) &#123;\n        // System.out.println(&quot;===第 1 个对象====&quot;);\n        // Sub sub = new Sub(); //创建了子类对象 sub\n        // System.out.println(&quot;===第 2 个对象====&quot;);\n        // Sub sub2 = new Sub(&quot;jack&quot;); //创建了子类对象 sub2\n        System.out.println(&quot;===第 3 对象====&quot;);\n        Sub sub3 = new Sub(&quot;king&quot;, 10); //创建了子类对象 sub2\n        //sub.sayOk();\n    &#125;\n&#125;javapublic class Base extends TopBase &#123; //父类\n    //4 个属性\n    public int n1 = 100;\n    protected int n2 = 200;\n    int n3 = 300;\n    private int n4 = 400;\n    \n    public Base() &#123; //无参构造器\n        System.out.println(&quot;父类 Base()构造器被调用....&quot;);\n    &#125;\n    \n    public Base(String name, int age) &#123;//有参构造器\n        //默认 super()\n        System.out.println(&quot;父类 Base(String name, int age)构造器被调用....&quot;);\n    &#125;\n    \n    public Base(String name) &#123;//有参构造器\n        System.out.println(&quot;父类 Base(String name)构造器被调用....&quot;);\n    &#125;\n    //父类提供一个 public 的方法,返回了 n4\n    public int getN4() &#123;\n        return n4;\n    &#125;\n    \n    public void test100() &#123;\n        System.out.println(&quot;test100&quot;);\n    &#125;\n    \n    protected void test200() &#123;\n        System.out.println(&quot;test200&quot;);\n    &#125;\n    \n    void test300() &#123;\n        System.out.println(&quot;test300&quot;);\n    &#125;\n    \n    private void test400() &#123;\n        System.out.println(&quot;test400&quot;);\n    &#125;\n    //call\n    public void callTest400() &#123;\n        test400();\n    &#125;\n&#125;javapublic class Sub extends Base &#123; //子类\n    public Sub(String name, int age) &#123;\n        //1. 调用父类的无参构造器, 如下或者 什么都不写,默认就是调用 super()\n        //super();//父类的无参构造器\n        //2. 调用父类的 Base(String name) 构造器\n        //super(&quot;lsp&quot;);\n        //3. 调用父类的 Base(String name, int age) 构造器\n        super(&quot;king&quot;, 20);\n        //细节： super 在使用时，必须放在构造器第一行\n        //细节: super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器\n        //this() 不能再使用了\n        System.out.println(&quot;子类 Sub(String name, int age)构造器被调用....&quot;);\n    &#125;\n    \n    public Sub() &#123;//无参构造器\n        //super(); //默认调用父类的无参构造器\n        super(&quot;smith&quot;, 10);\n        System.out.println(&quot;子类 Sub()构造器被调用....&quot;);\n    &#125;\n    \n    //当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器\n    public Sub(String name) &#123;\n        super(&quot;tom&quot;, 30);\n        //do nothing... System.out.println(&quot;子类 Sub(String name)构造器被调用....&quot;);\n    &#125;\n    \n    public void sayOk() &#123;//子类方法\n        //非私有的属性和方法可以在子类直接访问\n        //但是私有属性和方法不能在子类直接访问\n        System.out.println(n1 + &quot; &quot; + n2 + &quot; &quot; + n3);\n        test100();\n        test200();\n        test300();\n        //test400();错误\n        //要通过父类提供公共的方法去访问\n        System.out.println(&quot;n4=&quot; + getN4());\n        callTest400();//\n    &#125;\n&#125;javapublic class TopBase &#123; //父类是 Object\n    public TopBase() &#123;\n        //super(); Object 的无参构造器\n        System.out.println(&quot;构造器 TopBase() 被调用...&quot;);//1\n    &#125;\n&#125;继承的本质分析(重要)\n按照查找关系来返回信息\n\n首先看子类是否有该属性\n如果子类有这个属性，并且可以访问，则返回信息\n如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)\n如果父类没有就按照(3)的规则，继续找上级父类，直到 Object…\n\n代码举例\njavapublic class ExtendsTheory &#123;\n    public static void main(String[] args) &#123;\n        Son son = new Son();//内存的布局\n        //按照查找关系来返回信息\n        //(1) 首先看子类是否有该属性\n        //(2) 如果子类有这个属性，并且可以访问，则返回信息\n        //(3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)\n        //(4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object... \n        System.out.println(son.name);//返回就是大头儿子\n        //System.out.println(son.age);//返回的就是 39\n        //System.out.println(son.getAge());//返回的就是 39\n        System.out.println(son.hobby);//返回的就是旅游\n    &#125;\n&#125;\nclass GrandPa &#123; //爷类\n    String name = &quot;大头爷爷&quot;;\n    String hobby = &quot;旅游&quot;;\n&#125;\nclass Father extends GrandPa &#123;//父类\n    String name = &quot;大头爸爸&quot;;\n    private int age = 39;\n    public int getAge() &#123;\n        return age;\n    &#125;\n&#125;\nclass Son extends Father &#123; //子类\n    String name = &quot;大头儿子&quot;;\n&#125;子类创建的内存布局\n\n8.6 super关键字基本介绍\nsuper 代表父类的引用，用于访问父类的属性、方法、构造器\n基本语法\n\n访问父类的属性，但不能访问父类的private属性。super.属性名\n访问父类的方法，不能访问父类的private方法。super.方法名(参数列表);\n访问父类的构造器。super(参数列表);只能放在构造器的第一句，只能出现一句！\n\n代码举例\n1、希望调用父类-A 的 cal 方法这时，因为子类 B 没有 cal 方法，因此可以使用下面三种方式找 cal 方法时(cal() 和 this.cal())，顺序是:\n\n先找本类，如果有，则调用\n如果没有，则找父类(如果有，并可以调用，则调用)\n如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类\n\n提示：如果查找方法的过程中，找到了，但是不能访问， 则报错 cannot access           如果查找方法的过程中，没有找到，则提示方法不存在\n2、演示访问属性的规则\n找 cal 方法(super.call()) 的顺序是直接查找父类，其他的规则一样\nn1 和 this.n1 查找的规则是\n\n先找本类，如果有，则调用\n如果没有，则找父类(如果有，并可以调用，则调用)\n如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类\n\n提示：如果查找属性的过程中，找到了，但是不能访问， 则报错 cannot access           如果查找属性的过程中，没有找到，则提示属性不存在\njavapublic class B extends A &#123;\n    public int n1 = 888;\n    //编写测试方法\n    public void test() &#123;\n        //super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员；\n        // 如果多个基类(上级类)中都有同名的成员，使用 super 访问遵循就近原则。A-&gt;B-&gt;C\n        System.out.println(&quot;super.n1=&quot; + super.n1);\n        super.cal();\n    &#125;\n    //访问父类的属性 , 但不能访问父类的 private 属性 [案例]super.属性名\n    public void hi() &#123;\n        System.out.println(super.n1 + &quot; &quot; + super.n2 + &quot; &quot; + super.n3 );\n    &#125;\n    public void cal() &#123;\n        System.out.println(&quot;B 类的 cal() 方法...&quot;);\n    &#125;\n    public void sum() &#123;\n        System.out.println(&quot;B 类的 sum()&quot;);\n        //希望调用父类-A 的 cal 方法\n        //这时，因为子类 B 没有 cal 方法，因此可以使用下面三种方式\n        //找 cal 方法时(cal() 和 this.cal())，顺序是:\n        // (1)先找本类，如果有，则调用\n        // (2)如果没有，则找父类(如果有，并可以调用，则调用)\n        // (3)如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类\n        // 提示：如果查找方法的过程中，找到了，但是不能访问， 则报错, cannot access\n        // 如果查找方法的过程中，没有找到，则提示方法不存在\n        //cal();\n        this.cal(); //等价 cal\n        //找 cal 方法(super.call()) 的顺序是直接查找父类，其他的规则一样\n        //super.cal();\n        //演示访问属性的规则\n        //n1 和 this.n1 查找的规则是\n        //(1) 先找本类，如果有，则调用\n        //(2) 如果没有，则找父类(如果有，并可以调用，则调用)\n        //(3) 如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类\n        // 提示：如果查找属性的过程中，找到了，但是不能访问， 则报错, cannot access\n        // 如果查找属性的过程中，没有找到，则提示属性不存在\n        System.out.println(n1);\n        System.out.println(this.n1);\n        //找 n1 (super.n1) 的顺序是直接查找父类属性，其他的规则一样\n        System.out.println(super.n1);\n    &#125;\n    //访问父类的方法，不能访问父类的 private 方法 super.方法名(参数列表);\n    public void ok() &#123;\n        super.test100();\n        super.test200();\n        super.test300();\n        //super.test400();//不能访问父类 private 方法\n    &#125;\n    //访问父类的构造器(这点前面用过)：super(参数列表);只能放在构造器的第一句，只能出现一句！\n    public B() &#123;\n        //super();\n        //super(&quot;jack&quot;, 10);\n        super(&quot;jack&quot;);\n    &#125;\n&#125;super 给编程带来的便利&#x2F;细节\n\n调用父类的构造器的好处(分工明确，父类属性由父类初始化，子类的属性由子类初始化) \n当子类中有和父类中的成员 (属性和方法) 重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！\nsupe的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。A-&gt;B-&gt;C，当然也需要遵守访问权限的相关规则。\n\nsuper 和 this 的比较\n\n\n\n区别点\nthis\nsuper\n\n\n\n访问属性\n访问本类中的属性，如果本类没有此属性则从父类中继续查找\n从父类开始查找顺序\n\n\n调用方法\n访问本类中的方法，如果本类没有此方法则从父类继续查找\n从父类开始查找方法\n\n\n调用构造器\n调用本类构造器，必须放在构造器的首行\n调用父类构造器，必须放在子类构造器的首行\n\n\n特殊\n表示当前对象\n子类中访问父类对象\n\n\n8.7 方法重写&#x2F;覆盖(override)基本介绍\n简单的说：方法覆盖（重写）就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的方法。\n快速入门\njavapublic class Animal &#123;\n    public void cry() &#123;\n        System.out.println(&quot;动物叫唤..&quot;);\n    &#125;\n    public Object m1() &#123;\n        return null;\n    &#125;\n    public String m2() &#123;\n        return null;\n    &#125;\n    public AAA m3() &#123;\n        return null;\n    &#125;\n    protected void eat() &#123;\n    &#125;\n&#125;javapublic class Dog extends Animal&#123;\n    //1. 因为 Dog 是 Animal 子类\n    //2. Dog 的 cry 方法和 Animal 的 cry 定义形式一样(名称、返回类型、参数)\n    //3. 这时我们就说 Dog 的 cry 方法，重写了 Animal 的 cry 方法\n    public void cry() &#123;\n        System.out.println(&quot;小狗汪汪叫..&quot;);\n    &#125;\n    //细节: 子类方法的返回类型和父类方法返回类型一样，\n    // 或者是父类返回类型的子类\n    比如 父类 返回类型是 Object , // 子类方法返回类型是 String\n    public String m1() &#123;\n        return null;\n    &#125;\n    //这里 Object 不是 String 的子类，因此编译错误\n    // public Object m2() &#123;\n    // return null;\n    // &#125;\n    // public BBB m3() &#123;\n    // return null;\n    // &#125;\n    //细节: 子类方法不能缩小父类方法的访问权限 【演示】\n    //public &gt; protected &gt; 默认&gt;private\n    public void eat() &#123;\n    &#125;\n&#125;\nclass AAA &#123;\n&#125;\nclass BBB extends AAA &#123;\n&#125;注意事项和使用细节\n方法重写也叫方法覆盖，需要满足下面的条件\n\n子类的方法的形参列表方法名称，要和父类方法的形参列表，方法名称完全一样。\n子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类比如父类返回类型是Object,子类方法返回类型是String。举例： public Object getInfo()&#123;，public String getInfo()&#123;\n子类方法不能缩小父类方法的访问权限，权限大小顺序：public&gt;protected&gt;默认&gt;private 。举例：void sayok()&#123; ，public oid sayok()&#123;\n\n方法的重写和重载比较\n\n\n\n名称\n发生范围\n方法名\n形参列表\n返回类型\n修饰符\n\n\n\n重载(overload)\n本类\n必须一样\n类型，个数或者顺序至少有一个不同\n无要求\n无要求\n\n\n重写(override)\n父子类\n必须一样\n相同\n子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类\n子类方法不能缩小父类方法的访问范围\n\n\n8.8 面向对象编程-多态多[多种]态[状态]基本介绍\n方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。\n多态的具体体现\n重写和重载就体现多态 [案例说明：]\njavapublic class PloyMethod &#123;\n    public static void main(String[] args) &#123;\n        //方法重载体现多态\n        A a = new A();\n        //这里我们传入不同的参数，就会调用不同 sum 方法，就体现多态\n        System.out.println(a.sum(10, 20));\n        System.out.println(a.sum(10, 20, 30));\n        //方法重写体现多态\n        B b = new B();\n        a.say();\n        b.say();\n    &#125;\n&#125;\nclass B &#123; //父类\n    public void say() &#123;\n        System.out.println(&quot;B say() 方法被调用...&quot;);\n    &#125;\n&#125;\nclass A extends B &#123;//子类\n    public int sum(int n1, int n2)&#123;//和下面 sum 构成重载\n        return n1 + n2;\n    &#125;\n    public int sum(int n1, int n2, int n3)&#123;\n        return n1 + n2 + n3;\n    &#125;\n    public void say() &#123;\n        System.out.println(&quot;A say() 方法被调用...&quot;);\n    &#125;\n&#125;对象的多态 (核心，困难，重点)\n\n一个对象的编译类型和运行类型可以不一致\n编译类型在定义对象时，就确定了，不能改变\n运行类型是可以变化的\n编译类型是看定义时 &#x3D; 号的左边，运行类型看 &#x3D; 号的右边\n\n代码举例说明\njavapackage com.poly_.objectpoly_;\npublic class Animal &#123;\n    public void cry() &#123;\n        System.out.println(&quot;Animal cry() 动物在叫....&quot;);\n    &#125;\n&#125;\n\npackage com.poly_.objectpoly_;\npublic class Cat extends Animal &#123;\n    public void cry() &#123;\n    System.out.println(&quot;Cat cry() 小猫喵喵叫...&quot;);\n    &#125;\n&#125;\n\npackage com.objectpoly_;\npublic class Dog extends Animal &#123;\n    public void cry() &#123;\n        System.out.println(&quot;Dog cry() 小狗汪汪叫...&quot;);\n    &#125;\n&#125;javapublic class PolyObject &#123;\n    public static void main(String[] args) &#123;\n        //体验对象多态特点\n        //animal 编译类型就是 Animal , 运行类型 Dog\n        Animal animal = new Dog();\n        //因为运行时 , 执行到改行时，animal 运行类型是 Dog,所以 cry 就是 Dog 的 cry\n        animal.cry(); //小狗汪汪叫\n        //animal 编译类型 Animal,运行类型就是 Cat\n        animal = new Cat();\n        animal.cry(); //小猫喵喵叫\n    &#125;\n&#125;多态注意事项和细节讨论\n多态的前提是：两个对象(类)存在继承关系\n1、多态的向上转型\n\n本质：父类的引用指向了子类的对象\n语法：父类类型 引用名 = new 子类类型();\n特点：编译类型看左边，运行类型看右边。\n可以调用父类中的所有成员（需遵守访问权限）\n不能调用子类中特有成员\n最终运行效果看子类的具体实现\n\n\n\n2、多态向下转型\n\n语法：子类类型 引用名 = (子类类型) 父类引用;\n只能强转父类的引用，不能强转父类的对象\n要求父类的引用必须指向的是当前目标类型的对象\n当向下转型后，可以调用子类类型中所有的成员\n\n代码举例说明\njavapublic static void main(String[] args) &#123;\n    //向上转型: 父类的引用指向了子类的对象\n    //语法：父类类型引用名 = new 子类类型();\n    Animal animal = new Cat();\n    Object obj = new Cat();//可以吗? 可以 Object 也是 Cat 的父类\n    //向上转型调用方法的规则如下:\n    //(1)可以调用父类中的所有成员(需遵守访问权限)\n    //(2)但是不能调用子类的特有的成员\n    //(#)因为在编译阶段，能调用哪些成员,是由编译类型来决定的\n    //animal.catchMouse();错误\n    //(4)最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法\n    //，然后调用，规则我前面我们讲的方法调用规则一致。\n    animal.eat();//猫吃鱼.. animal.run();//跑\n    animal.show();//hello,你好\n    animal.sleep();//睡\n    //希望可以调用 Cat 的 catchMouse 方法\n    //多态的向下转型\n    //(1)语法：子类类型 引用名 =（子类类型）父类引用;\n    //问一个问题? cat 的编译类型 Cat,运行类型是 Cat\n    Cat cat = (Cat) animal;\n    cat.catchMouse();//猫抓老鼠\n    //(2)要求父类的引用必须指向的是当前目标类型的对象\n    Dog dog = (Dog) animal; //可以吗？\n    System.out.println(&quot;ok~~&quot;);\n    &#125;\n&#125;属性没有重写之说！属性的值看编译类型。代码举例说明\njavapublic class PolyDetail02 &#123;\n    public static void main(String[] args) &#123;\n        //属性没有重写之说！属性的值看编译类型\n        Base base = new Sub();//向上转型\n        System.out.println(base.count);// ？ 看编译类型 10\n        Sub sub = new Sub();\n        System.out.println(sub.count);//? 20\n    &#125;\n&#125;\nclass Base &#123; //父类\n    int count = 10;//属性\n&#125;\nclass Sub extends Base &#123;//子类\n    int count = 20;//属性\n&#125;instanceOf 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型。代码举例说明\njavapublic class PolyDetail03 &#123;\n    public static void main(String[] args) &#123;\n        BB bb = new BB();\n        System.out.println(bb instanceof BB);// true\n        System.out.println(bb instanceof AA);// true\n        //aa 编译类型 AA, 运行类型是 BB\n        //BB 是 AA 子类\n        AA aa = new BB();\n        System.out.println(aa instanceof AA);\n        System.out.println(aa instanceof BB);\n        Object obj = new Object();\n        System.out.println(obj instanceof AA);//false\n        String str = &quot;hello&quot;;\n        //System.out.println(str instanceof AA);\n        System.out.println(str instanceof Object);//true\n    &#125;\n&#125;\nclass AA &#123;&#125; //父类\nclass BB extends AA &#123;&#125;//子类java 的动态绑定机制(非常非常重要.)\n\n当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定。\n当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用。\n\n代码举例说明\njavapublic class DynamicBinding &#123;\n    public static void main(String[] args) &#123;\n        //a 的编译类型 A, 运行类型 B\n        A a = new B();//向上转型\n        System.out.println(a.sum());//?40 -&gt; 30\n        System.out.println(a.sum1());//?30-&gt; 20\n    &#125;\n&#125;\n\nclass A &#123;//父类\n    public int i = 10;\n    //动态绑定机制:\n    public int sum() &#123;//父类 sum()\n        return getI() + 10;//20 + 10\n    &#125;\n    public int sum1() &#123;//父类 sum1()\n        return i + 10;//10 + 10\n    &#125;\n    public int getI() &#123;//父类 getI\n        return i;\n    &#125;\n&#125;\n\nclass B extends A &#123;//子类\n    public int i = 20;\n    // public int sum() &#123;\n    // return i + 20;\n    // &#125;\n    public int getI() &#123;//子类 getI()\n        return i;\n    &#125;\n    // public int sum1() &#123;\n    // return i + 10;\n    // &#125;\n&#125;8.9 Object 类详解equals 方法\n&#x3D;&#x3D;和 equals 的对比 [面试题]\n==是一个比较运算符\n\n==：既可以判断基本类型，又可以判断引用类型\n==：如果判断基本类型，判断的是值是否相等。示例：int i = 10; double d = 10.0;\n==：如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象\nequals：是Object类中的方法，只能判断引用类型\n默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如Integer，String。（可以查看String和Intteger的equals源代码）【光标放在equals方法，按ctrl+b查看】\n\n如何重写 equals 方法\n代码举例说明\njava//如果两个 Person 对象的各个属性值都一样，则返回 true，反之 false\nclass Person&#123; //extends Object\n    private String name;\n    private int age;\n    private char gender;\n    //重写 Object 的 equals 方法\n    public boolean equals(Object obj) &#123;\n        //判断如果比较的两个对象是同一个对象，则直接返回 true\n        if(this == obj) &#123;\n            return true;\n        &#125;\n        //类型判断\n        if(obj instanceof Person) &#123;//是 Person，我们才比较\n            //进行 向下转型, 因为我需要得到 obj 的 各个属性\n            Person p = (Person)obj;\n            return this.name.equals(p.name) &amp;&amp; this.age == p.age &amp;&amp; this.gender == p.gender;\n        &#125;\n    //如果不是 Person ，则直接返回 false\n    return false;\n    &#125;\n&#125;hashCode 方法\n基本介绍\n返回该对象的哈希码值，支持此方法是为了提高哈希表的性能。实际上，由Object类定义的hashCode方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是Java编程语言不需要这种实现技巧。）\n\n提高具有哈希结构的容器的效率！\n两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！\n两个引用，如果指向的是不同对象，则哈希值是不一样的\n哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址。\n\n代码举例说明\njavapublic class HashCode_ &#123;\n    public static void main(String[] args) &#123;\n        AA aa = new AA();\n        AA aa2 = new AA();\n        AA aa3 = aa;\n        System.out.println(&quot;aa.hashCode()=&quot; + aa.hashCode());\n        System.out.println(&quot;aa2.hashCode()=&quot; + aa2.hashCode());\n        System.out.println(&quot;aa3.hashCode()=&quot; + aa3.hashCode());\n    &#125;\n&#125;\nclass AA &#123;&#125;toString 方法\n基本介绍\n\n默认返回：全类名+@+哈希值的十六进制，【查看 Object 的 toString 方法】\n子类往往重写 toString 方法，用于返回对象的属性信息\n重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式。\n当直接输出一个对象时，toString 方法会被默认的调用, 比如：System.out.println(monster)； 就会默认调用 monster.toString()。\n\n代码举例说明\njavaclass Monster &#123;\n    private String name;\n    private String job;\n    private double sal;\n    public Monster(String name, String job, double sal) &#123;\n        this.name = name;\n        this.job = job;\n        this.sal = sal;\n    &#125;\n    //重写 toString 方法, 输出对象的属性\n    //使用快捷键即可 alt+insert -&gt; toString\n    @Override\n    public String toString() &#123; //重写后，一般是把对象的属性值输出，当然程序员也可以自己定制\n        return &quot;Monster&#123;&quot; +\n        &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n        &quot;, job=&#39;&quot; + job + &#39;\\&#39;&#39; +\n        &quot;, sal=&quot; + sal +\n        &#39;&#125;&#39;;\n        &#125;\n&#125;finalize 方法\n基本介绍\n\n当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作\n什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法。\n垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制\n\n代码举例说明\njava//演示 Finalize 的用法\npublic class Finalize_ &#123;\n    public static void main(String[] args) &#123;\n        Car bmw = new Car(&quot;宝马&quot;);\n        //这时 car 对象就是一个垃圾,垃圾回收器就会回收(销毁)对象, 在销毁对象前，会调用该对象的 finalize 方法\n        //,程序员就可以在 finalize 中，写自己的业务逻辑代码(比如释放资源：数据库连接,或者打开文件..)\n        //,如果程序员不重写 finalize,那么就会调用 Object 类的 finalize, 即默认处理\n        //,如果程序员重写了 finalize, 就可以实现自己的逻辑\n        bmw = null;\n        System.gc();//主动调用垃圾回收器\n        System.out.println(&quot;程序退出了....&quot;);\n    &#125;\n&#125;\nclass Car &#123;\n    private String name;\n    //属性, 资源。。\n    public Car(String name) &#123;\n        this.name = name;\n    &#125;\n    //重写 finalize\n    @Override\n    protected void finalize() throws Throwable &#123;\n        System.out.println(&quot;我们销毁 汽车&quot; + name );\n        System.out.println(&quot;释放了某些资源...&quot;);\n    &#125;\n&#125;\n第 9 章 面向对象编程(高级部分)9.1 类变量和类方法类变量基本介绍类变量也叫静态变量&#x2F;静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。这个从前面的图也可看出来。\n类变量快速入门\njavaclass Child &#123; //类\n    private String name;\n    //定义一个变量 count ,是一个类变量(静态变量) static 静态\n    //该变量最大的特点就是会被 Child 类的所有的对象实例共享\n    public static int count = 0;\n    public Child(String name) &#123;\n        this.name = name;\n    &#125;\n    public void join() &#123;\n        System.out.println(name + &quot; 加入了游戏..&quot;);\n    &#125;\n&#125;类变量内存布局\nstatic变量是对象共享不管static变量在哪里\n\nstatic变量是同一个类所有对象共享。\nstatic类变量，在类加载的时候就生成了。\n\n\n如何定义类变量\njava访问修饰符 static 数据类型 变量名; [推荐]\nstatic 访问修饰符 数据类型 变量名;如何访问类变量\njava类名.类变量名\n对象名.类变量名 [静态变量的访问修饰符的访问权限和范围 和 普通属性是一样的。]\n推荐使用：类名.类变量名;代码举例说明\njavapublic class VisitStatic &#123;\n    public static void main(String[] args) &#123;\n        //类名.类变量名\n        //说明：类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问\n        System.out.println(A.name);\n        A a = new A();\n        //通过对象名.类变量名\n        System.out.println(&quot;a.name=&quot; + a.name);\n    &#125;\n&#125;\nclass A &#123;\n    //类变量\n    //类变量的访问，必须遵守 相关的访问权限. public static String name = &quot;韩顺平教育&quot;;\n    //普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量\n    private int num = 10;\n&#125;类变量使用注意事项和细节讨论\n\n什么时候需要用类变量\n当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量(静态变量)：比如：定义学生类，统计所有学生共交多少钱。Student (name, static fee)。\n\n\n类变量与实例变量(普通属性)区别\n加上static称为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量\n类变量可以通过 类名.类变量名 或者 对象名.类变量名 来访问。推荐类名.类变量名方式访问。[前提是满足访问修饰符的访问权限和范围]\n实例变量不能通过 类名.类变量名 方式访问。\n类变量是在类加载时就初始化了，也就是说，即使没有创建对象，只要类加载了，就可以使用类变量了。\n类变量的生命周期是随类的加载开始，随着类消亡而销毁。\n\n代码举例说明\njavapublic class StaticDetail &#123;\n    public static void main(String[] args) &#123;\n        B b = new B();\n        //System.out.println(B.n1);\n        System.out.println(B.n2);\n        //静态变量是类加载的时候，就创建了,所以我们没有创建对象实例\n        //也可以通过类名.类变量名来访问\n        System.out.println(C.address);\n    &#125;\n&#125;\nclass B &#123;\n    public int n1 = 100;\n    public static int n2 = 200;\n&#125;\nclass C &#123;\n    public static String address = &quot;北京&quot;;\n&#125;类方法基本介绍类方法也叫静态方法\njava访问修饰符 static 数据返回类型 方法名()&#123; &#125;\t【推荐】\nstatic 访问修饰符 数据返回类型 方法名()&#123; &#125;类方法的调用\n使用方式：类名.类方法名或者对象名.类方法名。前提是：满足访问修饰符的访问权限和范围。\n类方法应用案例\njavapublic class StaticMethod &#123;\n    public static void main(String[] args) &#123;\n        //创建 2 个学生对象，叫学费\n        Stu tom = new Stu(&quot;tom&quot;);\n        //tom.payFee(100);\n        Stu.payFee(100);//对不对?对\n        Stu mary = new Stu(&quot;mary&quot;);\n        //mary.payFee(200);\n        Stu.payFee(200);//对\n        //输出当前收到的总学费\n        Stu.showFee();//300\n        //如果我们希望不创建实例，也可以调用某个方法(即当做工具来使用)\n        //这时，把方法做成静态方法时非常合适\n        System.out.println(&quot;9 开平方的结果是=&quot; + Math.sqrt(9));\n        System.out.println(MyTools.calSum(10, 30));\n    &#125;\n&#125;\n//开发自己的工具类时，可以将方法做成静态的，方便调用\nclass MyTools &#123;\n    //求出两个数的和\n    public static double calSum(double n1, double n2) &#123;\n    return n1 + n2;\n&#125;\n//可以写出很多这样的工具方法... &#125;\nclass Stu &#123;\n    private String name;//普通成员\n    //定义一个静态变量，来累积学生的学费\n    private static double fee = 0;\n    public Stu(String name) &#123;\n        this.name = name;\n    &#125;\n    //说明\n    //1. 当方法使用了 static 修饰后，该方法就是静态方法\n    //2. 静态方法就可以访问静态属性/变量\n    public static void payFee(double fee) &#123;\n        Stu.fee += fee;//累积到\n    &#125;\n    public static void showFee() &#123;\n        System.out.println(&quot;总学费有:&quot; + Stu.fee);\n    &#125;\n&#125;类方法使用注意事项和细节讨论\n\n类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：\n类方法中无this的参数\n普通方法中隐含着this的参数\n\n\n类方法可以通过类名调用，也可以通过对象名调用。\n普通方法和对象有关，需要通过对象名调用，比如对象名方法名（参数），不能通过类名调用。\n类方法中不允许使用和对象有关的关键字，比如this和super。普通方法（成员方法）可以。\n类方法（静态方法）中只能访问静态变量或静态方法。\n普通成员方法，既可以访问非静态成员，也可以访问静态成员。\n\n小结：（1）静态方法，只能访问静态的成员。（2）非静态的方法，可以访问静态成员和非静态成员。（必须遵守访问权限）\n代码举例说明\njavapublic class StaticMethodDetail &#123;\n    public static void main(String[] args) &#123;\n        D.hi();//ok\n        //非静态方法，不能通过类名调用\n        //D.say();, 错误，需要先创建对象，再调用\n        new D().say();//可以\n    &#125;\n&#125;\nclass D &#123;\n    private int n1 = 100;\n    private static int n2 = 200;\n    public void say() &#123;//非静态方法,普通方法\n    &#125;\n    public static void hi() &#123;//静态方法,类方法\n        //类方法中不允许使用和对象有关的关键字，\n        //比如 this 和 super。普通方法(成员方法)可以。\n        //System.out.println(this.n1);\n    &#125;\n    //类方法(静态方法)中 只能访问 静态变量 或静态方法\n    //口诀:静态方法只能访问静态成员. \n    public static void hello() &#123;\n        System.out.println(n2);\n        System.out.println(D.n2);\n        //System.out.println(this.n2);不能使用\n        hi();//OK\n        //say();//错误\n    &#125;\n    //普通成员方法，既可以访问 非静态成员，也可以访问静态成员\n    //小结: 非静态方法可以访问 静态成员和非静态成员\n    public void ok() &#123;\n        //非静态成员\n        System.out.println(n1);\n        say();\n        //静态成员\n        System.out.println(n2);\n        hello();\n    &#125;\n&#125;9.2 理解 main 方法语法深入理解 main 方法\n解释main方法的形式：public static void main(String[] args)&#123;&#125;\n\nmain方法时虚以机调用 \njava虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public \njava虚拟机在执行main()方法时不必创建对象，所以该方法必须是static\n该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数\njava 执行的程序 参数1 参数2 参数3 [举例说明]\n\n\n特别提示\n\n在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。\n但是不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员\n\n代码举例说明\njavapublic class Main01 &#123;\n    //静态的变量/属性\n    private static String name = &quot;韩顺平教育&quot;;\n    //非静态的变量/属性\n    private int n1 = 10000;\n    //静态方法\n    public static void hi() &#123;\n        System.out.println(&quot;Main01 的 hi 方法&quot;);\n    &#125;\n    //非静态方法\n    public void cry() &#123;\n        System.out.println(&quot;Main01 的 cry 方法&quot;);\n    &#125;\n    public static void main(String[] args) &#123;\n        //可以直接使用 name\n        //1. 静态方法 main 可以访问本类的静态成员\n        System.out.println(&quot;name=&quot; + name);\n        hi();\n        //2. 静态方法 main 不可以访问本类的非静态成员\n        //System.out.println(&quot;n1=&quot; + n1);//错误\n        //cry();\n        //3. 静态方法 main 要访问本类的非静态成员，需要先创建对象 , 再调用即可\n        Main01 main01 = new Main01();\n        System.out.println(main01.n1);//ok\n        main01.cry();\n    &#125;\n&#125;9.3 代码块基本介绍\n代码化块又称为初始化块，属于类中的成员[即 是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过&#123;&#125;包围起来。但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。\n基本语法\njava[修饰符]&#123;\n    代码\n&#125;;说明注意：\n\n修饰符可选，要写的话，也只能写static\n代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块&#x2F;非静态代码块\n逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）\n;号可以写上，也可以省略。\n\n代码块的好处\n\n相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作\n场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性\n\n代码块案例演示\njavapublic class CodeBlock01 &#123;\n    public static void main(String[] args) &#123;\n        Movie movie = new Movie(&quot;你好，李焕英&quot;);\n        System.out.println(&quot;===============&quot;);\n        Movie movie2 = new Movie(&quot;唐探 3&quot;, 100, &quot;陈思诚&quot;);\n    &#125;\n&#125;\nclass Movie &#123;\n    private String name;\n    private double price;\n    private String director;\n    //3 个构造器-》重载\n    //(1) 下面的三个构造器都有相同的语句\n    //(2) 这样代码看起来比较冗余\n    //(3) 这时我们可以把相同的语句，放入到一个代码块中，即可\n    //(4) 这样当我们不管调用哪个构造器，创建对象，都会先调用代码块的内容\n    //(5) 代码块调用的顺序优先于构造器.. \n    &#123;\n        System.out.println(&quot;电影屏幕打开...&quot;);\n        System.out.println(&quot;广告开始...&quot;);\n        System.out.println(&quot;电影正是开始...&quot;);\n    &#125;;\n    \n    public Movie(String name) &#123;\n        System.out.println(&quot;Movie(String name) 被调用...&quot;);\n        this.name = name;\n    &#125;\n    \n    public Movie(String name, double price) &#123;\n        this.name = name;\n        this.price = price;\n    &#125;\n    \n    public Movie(String name, double price, String director) &#123;\n        System.out.println(&quot;Movie(String name, double price, String director) 被调用...&quot;);\n        this.name = name;\n        this.price = price;\n        this.director = director;\n    &#125;\n&#125;代码块使用注意事项和细节讨论\n\nstatic代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行。 \n\n类什么时候被加载[重要背！]\n\n① 创建对象实例时(new)\n② 创建子类对象实例，父类也会被加载\n③ 使用类的静态成员时（静态属性，静态方法）\n案例演示：A类extends B类的静态块\n\n\n普通的代码块，在创建对象实例时，会被隐式的调用。\n\n被创建一次，就会调用一次。\n如果只是使用类的静态成员时，普通代码块并不会执行。\n\n\n创建一个对象时，在一个类调用顺序是：【重点，难点】：\n\n调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)\n调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)\n调用构造方法。\n\n\n构造器 的最前面其实隐含了super()和调用普通代码块，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块执行的。\n\njavaclass A&#123;\n    public A()&#123; //构造器\n        //这里有隐藏的执行要求\n        //(1) super(); 在继承知识点有说明\n        //(2) 调用普通代码块的\n        System.out.println(&quot;ok&quot;);\n    &#125;\n&#125;\n\n\n创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：\n\n父类的静态代码块和静态属性（优先级一样，按定义顺序执行） \n子类的静态代码块和静态属性（优先级一样，按定义顺序执行） \n父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）\n父类的构造方法 \n子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）\n子类的构造方法    &#x2F;&#x2F;面试题\n\n\n静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员。\n\n\n小结：\n\nstatic代码块是类加载时，执行，只会执行一次 \n普通代码块是在创建对象时调用的，创建一次，调用一次 \n类加载的3种情况，需要记住\n\n代码举例说明\njavapublic class CodeBlockDetail01 &#123;\n    public static void main(String[] args) &#123;\n        //类被加载的情况举例\n        //1. 创建对象实例时(new)\n        // AA aa = new AA();\n        //2. 创建子类对象实例，父类也会被加载, 而且，父类先被加载，子类后被加载\n        // AA aa2 = new AA();\n        //3. 使用类的静态成员时(静态属性，静态方法)\n        // System.out.println(Cat.n1);\n        //static 代码块，是在类加载时，执行的，而且只会执行一次. // DD dd = new DD();\n        // DD dd1 = new DD();\n        //普通的代码块，在创建对象实例时，会被隐式的调用。\n        // 被创建一次，就会调用一次。\n        // 如果只是使用类的静态成员时，普通代码块并不会执行\n        System.out.println(DD.n1);//8888, 静态模块块一定会执行\n        &#125;\n    &#125;\nclass DD &#123;\n    public static int n1 = 8888;//静态属性\n    //静态代码块\n    static &#123;\n        System.out.println(&quot;DD 的静态代码 1 被执行...&quot;);//\n    &#125;\n    //普通代码块, 在 new 对象时，被调用，而且是每创建一个对象，就调用一次\n    //可以这样简单的，理解 普通代码块是构造器的补充\n    &#123;\n        System.out.println(&quot;DD 的普通代码块...&quot;);\n    &#125;\n&#125;\n\nclass Animal &#123;\n    //静态代码块\n    static &#123;\n        System.out.println(&quot;Animal 的静态代码 1 被执行...&quot;);//\n    &#125;\n&#125;\n\nclass Cat extends Animal &#123;\n    public static int n1 = 999;//静态属性\n    //静态代码块\n    static &#123;\n        System.out.println(&quot;Cat 的静态代码 1 被执行...&quot;);//\n    &#125;\n&#125;\n\nclass BB &#123;\n    //静态代码块\n    static &#123;\n        System.out.println(&quot;BB 的静态代码 1 被执行...&quot;);//1\n    &#125;\n&#125;\n\nclass AA extends BB &#123;\n    //静态代码块\n    static &#123;\n        System.out.println(&quot;AA 的静态代码 1 被执行...&quot;);//2\n    &#125;\n&#125;代码块使用注意事项和细节讨论第4点，代码举例说明\njavapublic class CodeBlockDetail02 &#123;\n    public static void main(String[] args) &#123;\n        A a = new A();// (1) A 静态代码块 01 (2) getN1 被调用...(3)A 普通代码块 01(4)getN2 被调用...(5)A() 构造器被调用\n    &#125;\n&#125;\n\nclass A &#123;\n    &#123; //普通代码块\n        System.out.println(&quot;A 普通代码块 01&quot;);\n    &#125;\n    private int n2 = getN2();//普通属性的初始化\n    static &#123; //静态代码块\n        System.out.println(&quot;A 静态代码块 01&quot;);\n    &#125;\n    //静态属性的初始化\n    private static int n1 = getN1();\n    public static int getN1() &#123;\n        System.out.println(&quot;getN1 被调用...&quot;);\n        return 100;\n    &#125;\n    \n    public int getN2() &#123; //普通方法/非静态方法\n        System.out.println(&quot;getN2 被调用...&quot;);\n        return 200;\n    &#125;\n    //无参构造器\n    public A() &#123;\n        System.out.println(&quot;A() 构造器被调用&quot;);\n    &#125;\n&#125;代码块使用注意事项和细节讨论第5点，代码举例说明\njavapublic class CodeBlockDetail03 &#123;\n    public static void main(String[] args) &#123;\n        new BBB();//(1)AAA 的普通代码块(2)AAA() 构造器被调用(3)BBB 的普通代码块(4)BBB() 构造器被调用\n    &#125;\n&#125;\nclass AAA &#123; //父类 Object\n    &#123;\n        System.out.println(&quot;AAA 的普通代码块&quot;);\n    &#125;\n    public AAA() &#123;\n        //(1)super()\n        //(2)调用本类的普通代码块\n        System.out.println(&quot;AAA() 构造器被调用....&quot;);\n    &#125;\n&#125;\nclass BBB extends AAA &#123;\n    &#123;\n        System.out.println(&quot;BBB 的普通代码块...&quot;);\n    &#125;\n    public BBB() &#123;\n        //(1)super()\n        //(2)调用本类的普通代码块\n        System.out.println(&quot;BBB() 构造器被调用....&quot;);\n    &#125;\n&#125;代码块使用注意事项和细节讨论第6点，代码举例说明\njavapublic class CodeBlockDetail04 &#123;\n    public static void main(String[] args) &#123;\n        //说明\n        //(1) 进行类的加载\n        //1.1 先加载 父类 A02 1.2 再加载 B02\n        //(2) 创建对象\n        //2.1 从子类的构造器开始\n        //new B02();//对象\n        new C02();\n    &#125;\n&#125;\nclass A02 &#123; //父类\n    private static int n1 = getVal01();\n    static &#123;\n        System.out.println(&quot;A02 的一个静态代码块..&quot;);//(2)\n    &#125;\n    &#123;\n        System.out.println(&quot;A02 的第一个普通代码块..&quot;);//(5)\n    &#125;\n    public int n3 = getVal02();//普通属性的初始化\n    public static int getVal01() &#123;\n        System.out.println(&quot;getVal01&quot;);//(1)\n        return 10;\n    &#125;\n    public int getVal02() &#123;\n        System.out.println(&quot;getVal02&quot;);//(6)\n        return 10;\n    &#125;\n    public A02() &#123;//构造器\n        //隐藏\n        //super()\n        //普通代码和普通属性的初始化...... System.out.println(&quot;A02 的构造器&quot;);//(7)\n    &#125;\n&#125;\nclass C02 &#123;\n    private int n1 = 100;\n    private static int n2 = 200;\n    private void m1() &#123;\n    &#125;\n    private static void m2() &#123;\n    &#125;\n    static &#123;\n        //静态代码块，只能调用静态成员\n        //System.out.println(n1);错误\n        System.out.println(n2);//ok\n        //m1();//错误\n        m2();\n    &#125;\n    &#123;\n        //普通代码块，可以使用任意成员\n        System.out.println(n1);\n        System.out.println(n2);//ok\n        m1();\n        m2();\n    &#125;\n&#125;\nclass B02 extends A02 &#123; //\n    private static int n3 = getVal03();\n    static &#123;\n        System.out.println(&quot;B02 的一个静态代码块..&quot;);//(4)\n    &#125;\n    public int n5 = getVal04();\n    &#123;\n        System.out.println(&quot;B02 的第一个普通代码块..&quot;);//(9)\n    &#125;\n    public static int getVal03() &#123;\n        System.out.println(&quot;getVal03&quot;);//(3)\n        return 10;\n    &#125;\n    public int getVal04() &#123;\n        System.out.println(&quot;getVal04&quot;);//(8)\n        return 10;\n    &#125;\n    //一定要慢慢的去品.. \n    public B02() &#123;//构造器\n        //隐藏了\n        //super()\n        //普通代码块和普通属性的初始化... System.out.println(&quot;B02 的构造器&quot;);//(10)\n        // TODO Auto-generated constructor stub\n    &#125;\n&#125;9.4 单例设计模式什么是设计模式\n\n静态方法和属性的经典使用\n设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格，以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。\n\n什么是单例模式\n\n所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法\n单例模式有两种方式：1)饿汉式2)懒汉式\n\n单例模式应用实例\n\n构造器私有化 &#x3D;》防止直接new\n类的内部创建对象\n向外暴露一个静态的公共方法。getlnstance\n\n代码举例说明\n单例模式-饿汉式\njavapublic class SingleTon01 &#123;\n    public static void main(String[] args) &#123;\n        // GirlFriend xh = new GirlFriend(&quot;小红&quot;);\n        // GirlFriend xb = new GirlFriend(&quot;小白&quot;);\n        //通过方法可以获取对象\n        GirlFriend instance = GirlFriend.getInstance();\n        System.out.println(instance);\n        GirlFriend instance2 = GirlFriend.getInstance();\n        System.out.println(instance2);\n        System.out.println(instance == instance2);//T\n        //System.out.println(GirlFriend.n1);\n        //... &#125;\n&#125;\n//有一个类， GirlFriend\n//只能有一个女朋友\nclass GirlFriend &#123;\n    private String name;\n    //public static int n1 = 100;\n    //为了能够在静态方法中，返回 gf 对象，需要将其修饰为 static\n    //對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用. private static GirlFriend gf = new GirlFriend(&quot;小红红&quot;);\n    //如何保障我们只能创建一个 GirlFriend 对象\n    //步骤[单例模式-饿汉式]\n    //1. 将构造器私有化\n    //2. 在类的内部直接创建对象(该对象是 static)\n    //3. 提供一个公共的 static 方法，返回 gf 对象\n    private GirlFriend(String name) &#123;\n        System.out.println(&quot;構造器被調用.&quot;);\n        this.name = name;\n    &#125;\n    public static GirlFriend getInstance() &#123;\n        return gf;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;GirlFriend&#123;&quot; +\n        &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n        &#39;&#125;&#39;;\n    &#125;\n&#125;   单例模式-懒汉式\njavapublic class SingleTon02 &#123;\n    public static void main(String[] args) &#123;\n        //new Cat(&quot;大黃&quot;);\n        //System.out.println(Cat.n1);\n        Cat instance = Cat.getInstance();\n        System.out.println(instance);\n        //再次調用 getInstance\n        Cat instance2 = Cat.getInstance();\n        System.out.println(instance2);\n        System.out.println(instance == instance2);//T\n    &#125;\n&#125;\n//希望在程序運行過程中，只能創建一個 Cat 對象\n//使用單例模式\nclass Cat &#123;\n    private String name;\n    public static int n1 = 999;\n    private static Cat cat ; //默認是 null\n    //步驟\n    //1.仍然構造器私有化\n    //2.定義一個 static 靜態屬性對象\n    //3.提供一個 public 的 static 方法，可以返回一個 Cat 對象\n    //4.懶漢式，只有當用戶使用 getInstance 時，才返回 cat 對象, 後面再次調用時，會返回上次創建的 cat 對象\n    // 從而保證了單例\n    private Cat(String name) &#123;\n        System.out.println(&quot;構造器調用...&quot;);\n        this.name = name;\n    &#125;\n    public static Cat getInstance() &#123;\n        if(cat == null) &#123;//如果還沒有創建 cat 對象\n        cat = new Cat(&quot;小可愛&quot;);\n        &#125;\n        return cat;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Cat&#123;&quot; +\n        &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n        &#39;&#125;&#39;;\n    &#125;\n&#125;饿汉式 VS 懒汉式\n\n二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。\n饿汉式不存在线程安全问题，懒汉式存在线程安全问题。\n饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。\n在javaSE标准类中，java.lang.Runtime就是经典的单例模式。\n\n9.5 final 关键字基本介绍\nfinal中文意思：最后的，最终的。\nfinal可以修饰类、属性、方法和局部变量。\n在某些情况下，程序员可能有以下需求，就会使用到final\n\n当不希望类被继承时，可以用final修饰.\n当不希望父类的某个方法被子类覆盖&#x2F;重写(override)时，可以用final关键字修饰。\n当不希望类的的某个属性的值被修改，可以用final修饰.\n当不希望某个局部变量被修改，可以使用final修饰\n\n代码举例说明\njavapublic class Final01 &#123;\n    public static void main(String[] args) &#123;\n        E e = new E();\n        //e.TAX_RATE = 0.09;\n    &#125;\n&#125;\n//如果我们要求 A 类不能被其他类继承\n//可以使用 final 修饰 A 类\nfinal class A &#123; &#125;\n//class B extends A &#123;&#125;\nclass C &#123;\n    //如果我们要求 hi 不能被子类重写\n    //可以使用 final 修饰 hi 方法\n    public final void hi() &#123;&#125;\n&#125;\nclass D extends C &#123;\n    // @Override\n    // public void hi() &#123;\n    // System.out.println(&quot;重写了 C 类的 hi 方法..&quot;);\n    // &#125;\n&#125;\n//当不希望类的的某个属性的值被修改,可以用 final 修饰\nclass E &#123;\n    public final double TAX_RATE = 0.08;//常量\n&#125;\n//当不希望某个局部变量被修改，可以使用 final 修饰\nclass F &#123;\n    public void cry() &#123;\n        //这时，NUM 也称为 局部常量\n        final double NUM = 0.01;\n        //NUM = 0.9;\n        System.out.println(&quot;NUM=&quot; + NUM);\n    &#125;\n&#125;final 使用注意事项和细节讨论\n\nfinal修饰的属性又叫常量，一般用XX_XX_XX来命名 \n\nfinal修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋初值即可】：\n\n定义时：如public final double TAX_RATE = 0.08;\n在构造器中\n在代码块中。\n\n\n如果final修饰的属性是静态的，则初始化的位置只能是\n\n定义时\n在静态代码块不能在构造器中赋值。\n\n\nfinal类不能继承，但是可以实例化对象。[A2类]\n\n如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。[A3类]\n\n一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法。 \n\nfinal不能修饰构造方法（即构造器） \n\nfinal和static往往搭配使用，效率更高，不会导致类加载.底层编译器做了优化处理。 \n\njavaclass Demo&#123; \n    public static final int i=16;\n    static&#123; \n        System.out.println(&quot;Java&quot;);\n    &#125;\n&#125;\n\n\n包装类(Integer,,Double,Float,Boolean等都是final)，String也是final类。\n\n\n代码举例说明\nfinal 使用注意事项和细节讨论前5点，代码举例\njavapublic class FinalDetail01 &#123;\n    public static void main(String[] args) &#123;\n        CC cc = new CC();\n        new EE().cal();\n    &#125;\n&#125;\nclass AA &#123;\n    /*\n    1. 定义时：如 public final double TAX_RATE=0.08;\n    2. 在构造器中\n    3. 在代码块中\n    */\n    public final double TAX_RATE = 0.08;//1.定义时赋值\n    public final double TAX_RATE2 ;\n    public final double TAX_RATE3 ;\n    public AA() &#123;//构造器中赋值\n        TAX_RATE2 = 1.1;\n    &#125;\n    &#123;//在代码块赋值\n        TAX_RATE3 = 8.8;\n    &#125;\n&#125;\nclass BB &#123;\n    /*\n    如果 final 修饰的属性是静态的，则初始化的位置只能是\n    1 定义时 2 在静态代码块 不能在构造器中赋值。\n    */\n    public static final double TAX_RATE = 99.9;\n    public static final double TAX_RATE2 ;\n    static &#123;\n        TAX_RATE2 = 3.3;\n    &#125;\n&#125;\n//final 类不能继承，但是可以实例化对象\nfinal class CC &#123; &#125;\n    //如果类不是 final 类，但是含有 final 方法，则该方法虽然不能重写，但是可以被继承\n    //即，仍然遵守继承的机制. class DD &#123;\n    public final void cal() &#123;\n        System.out.println(&quot;cal()方法&quot;);\n    &#125;\n&#125;\nclass EE extends DD &#123; &#125;final 使用注意事项和细节讨论6-9点，代码举例\njavapublic class FinalDetail02 &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(BBB.num);\n        //包装类,String 是 final 类，不能被继承\n    &#125;\n&#125;\n//final 和 static 往往搭配使用，效率更高，不会导致类加载.底层编译器做了优化处理\nclass BBB &#123;\n    public final static int num = 10000;\n    static &#123;\n        System.out.println(&quot;BBB 静态代码块被执行&quot;);\n    &#125;\n&#125;\nfinal class AAA&#123;\n    //一般来说，如果一个类已经是 final 类了，就没有必要再将方法修饰成 final 方法\n    //public final void cry() &#123;&#125;\n&#125;final 应用实例\n题1：请编写一个程序，能够计算圆形的面积。要求圆周率为3.14.赋值的位置3个方式都写一下\njavapublic class FinalExercise01 &#123;\n    public static void main(String[] args) &#123;\n        Circle circle = new Circle(5.0);\n        System.out.println(&quot;面积=&quot; + circle.calArea());\n    &#125;\n&#125;\nclass Circle &#123;\n    private double radius;\n    private final double PI;// = 3.14;\n    //构造器\n    public Circle(double radius) &#123;\n        this.radius = radius;\n        //PI = 3.14;\n    &#125;\n    &#123;\n        PI = 3.14;\n    &#125;\n    public double calArea() &#123;\n        return PI * radius * radius;\n    &#125;\n&#125;题2：下面的代码是否有误，为什么?\njavapublic int addOne(final int x) &#123; \n    ++x; //错误,原因是不能修改 final x 的值\n    return x + 1; //这里是可以. &#125;\n&#125;9.6 抽象类当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。\n抽象类的介绍\n\n用abstract关键字来修饰一个类时，这个类就叫抽象类\n\njava访问修饰符 abstract 类名&#123;&#125;\n\n\n用abstract关键字来修饰一个方法时，这个方法就是抽象方法\n\njava访问修饰符 abstract 返回类型 方法名(参数列表); //没有方法体\n\n\n抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()\n\n抽象类，是考官比较爱问的知识点，在框架和设计模式使用较多\n\n\n抽象类使用的注意事项和细节讨论\n\n抽象类不能被实例化\n抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法\n一旦类包含了abstract方法，则这个类必须声明为abstract\nabstract只能修饰类和方法，不能修饰属性和其它的\n抽象类可以有任意成员【抽象类本质还是类】比如：非抽象方法、构造器、静态属性等等。\n抽象方法不能有主体，即不能实现，如图所示\n\n\n\n如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。\n抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的。\n\n代码举例说明\n抽象类使用的注意事项和细节讨论1-4点，代码举例\njavapublic class AbstractDetail01 &#123;\n    public static void main(String[] args) &#123;\n        //抽象类，不能被实例化\n        //new A();\n    &#125;\n&#125;\n//抽象类不一定要包含 abstract 方法。也就是说,抽象类可以没有 abstract 方法\n//，还可以有实现的方法。\nabstract class A &#123;\n    public void hi() &#123;\n        System.out.println(&quot;hi&quot;);\n    &#125;\n&#125;\n//一旦类包含了 abstract 方法,则这个类必须声明为 abstract\nabstract class B &#123;\n    public abstract void hi();\n&#125;\n//abstract 只能修饰类和方法，不能修饰属性和其它的\nclass C &#123;\n    // public abstract int n1 = 1;\n&#125;抽象类使用的注意事项和细节讨论5-8点，代码举例\njavapublic class AbstractDetail02 &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;hello&quot;);\n    &#125;\n&#125;\n//抽象方法不能使用 private、final 和 static 来修饰，因为这些关键字都是和重写相违背的\nabstract class H &#123;\n    public abstract void hi();//抽象方法\n&#125;\n//如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为 abstract 类\nabstract class E &#123;\n    public abstract void hi();\n&#125;\nabstract class F extends E &#123;\n&#125;\nclass G extends E &#123;\n    @Override\n    public void hi() &#123; //这里相等于 G 子类实现了父类 E 的抽象方法，所谓实现方法，就是有方法体\n    &#125;\n&#125;\n//抽象类的本质还是类，所以可以有类的各种成员\nabstract class D &#123;\n    public int n1 = 10;\n    public static String name = &quot;白胖墩&quot;;\n    public void hi() &#123;\n        System.out.println(&quot;hi&quot;);\n    &#125;\n    public abstract void hello();\n    public static void ok() &#123;\n        System.out.println(&quot;ok&quot;);\n    &#125;\n&#125;9.7 接口接口快速入门\njavapackage com.interface_;\npublic interface UsbInterface &#123; //接口\n    //规定接口的相关方法,老师规定的.即规范... public void start();\n    public void stop();\n&#125;\n\npackage com.interface_;\npublic class Camera implements UsbInterface&#123;//实现接口,就是把接口方法实现\n    @Override\n    public void start() &#123;\n        System.out.println(&quot;相机开始工作...&quot;);\n    &#125;\n    @Override\n    public void stop() &#123;\n        System.out.println(&quot;相机停止工作....&quot;);\n    &#125;\n&#125;\n\npackage com.interface_;\n//Phone 类 实现 UsbInterface\n//解读 1. 即 Phone 类需要实现 UsbInterface 接口 规定/声明的方法\npublic class Phone implements UsbInterface &#123;\n    @Override\n    public void start() &#123;\n        System.out.println(&quot;手机开始工作...&quot;);\n    &#125;\n    @Override\n    public void stop() &#123;\n        System.out.println(&quot;手机停止工作.....&quot;);\n    &#125;\n&#125;\n\npackage com.interface_;\npublic class Interface01 &#123;\n    public static void main(String[] args) &#123;\n        //创建手机，相机对象\n        //Camera 实现了 UsbInterface\n        Camera camera = new Camera();\n        //Phone 实现了 UsbInterface\n        Phone phone = new Phone();\n        //创建计算机\n        Computer computer = new Computer();\n        computer.work(phone);//把手机接入到计算机\n        System.out.println(&quot;===============&quot;);\n        computer.work(camera);//把相机接入到计算机\n    &#125;\n&#125;基本介绍\n接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。\n语法： \njavainterface 接口名&#123;\n    //属性\n    //抽象方法\n&#125;\nclass 类名 implements 接口&#123;\n    自己属性;\n    自己方法;\n    必须实现的接口的抽象方法\n&#125;小结：接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体【jdk7.0】。接口体现了程序设计的多态和高内聚低偶合的设计思想。\n特别说明：Jdk8.0后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现。\n注意事项和细节\n\n接口不能被实例化 \n接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰。图示：\n\n\n\n一个普通类实现接口就必须将该接口的所有方法都实现。 \n抽象类实现接口，可以不用实现接口的方法。\n一个类同时可以实现多个接口\n接口中的属性，只能是final的，而且是public static final修饰符。比如： int a=1;实际上是public static final int a=1;(必须初始化)\n接口中属性的访问形式：接口名.属性名\n接口不能继承其它的类，但是可以继承多个别的接口。举例： interface A extends B,C&#123;&#125;\n接口的修饰符只能是public和默认，这点和类的修饰符是一样的。\n\n代码举例说明\n接口注意事项和细节1-4点，代码举例\njavapublic class InterfaceDetail01 &#123;\n    public static void main(String[] args) &#123;\n    //new IA();\n    &#125;\n&#125;\n//1.接口不能被实例化\n//2.接口中所有的方法是 public 方法, 接口中抽象方法，可以不用 abstract 修饰\n//3.一个普通类实现接口,就必须将该接口的所有方法都实现,可以使用 alt+enter 来解决\n//4.抽象类去实现接口时，可以不实现接口的抽象方法\ninterface IA &#123;\n    void say();//修饰符 public protected 默认 private\n    void hi();\n&#125;\nclass Cat implements IA&#123;\n    @Override\n    public void say() &#123;\n    &#125;\n    @Override\n    public void hi() &#123;\n    &#125;\n&#125;\nabstract class Tiger implements IA &#123;\n&#125;接口注意事项和细节5-9点，代码举例\njavapublic class InterfaceDetail02 &#123;\n    public static void main(String[] args) &#123;\n        //接口中的属性,是 public static final\n        System.out.println(IB.n1);//说明 n1 就是 static\n        //IB.n1 = 30; 说明 n1 是 final\n    &#125;\n&#125;\ninterface IB &#123;\n    //接口中的属性,只能是 final 的，而且是 public static final 修饰符\n    int n1 = 10; //等价 public static final int n1 = 10;\n    void hi();\n&#125;\ninterface IC &#123;\n    void say();\n&#125;\n//接口不能继承其它的类,但是可以继承多个别的接口\ninterface ID extends IB,IC &#123;\n&#125;\n//接口的修饰符 只能是 public 和默认，这点和类的修饰符是一样的\ninterface IE&#123;&#125;\n    //一个类同时可以实现多个接口\n    class Pig implements IB,IC &#123;\n    @Override\n    public void hi() &#123;\n    &#125;\n    @Override\n    public void say() &#123;\n    &#125;\n&#125;实现接口 vs 继承类\n\n当子类继承了父类，就自动的拥有父类的功能\n如果子类需要扩展功能，可以通过实现接口的方式扩展. \n可以理解 实现接口 是 对 java 单继承机制的一种补充.\n\n代码举例说明\njavapublic class ExtendsVsInterface &#123;\n    public static void main(String[] args) &#123;\n        LittleMonkey wuKong = new LittleMonkey(&quot;悟空&quot;);\n        wuKong.climbing();\n        wuKong.swimming();\n        wuKong.flying();\n    &#125;\n&#125;\n//猴子\nclass Monkey &#123;\n    private String name;\n    public Monkey(String name) &#123;\n        this.name = name;\n    &#125;\n    public void climbing() &#123;\n        System.out.println(name + &quot; 会爬树...&quot;);\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n&#125;\n//接口\ninterface Fishable &#123;\n    void swimming();\n&#125;\ninterface Birdable &#123;\n    void flying();\n&#125;\nclass LittleMonkey extends Monkey implements Fishable,Birdable &#123;\n    public LittleMonkey(String name) &#123;\n        super(name);\n    &#125;\n    @Override\n    public void swimming() &#123;\n        System.out.println(getName() + &quot; 通过学习，可以像鱼儿一样游泳...&quot;);\n    &#125;\n    @Override\n    public void flying() &#123;\n        System.out.println(getName() + &quot; 通过学习，可以像鸟儿一样飞翔...&quot;);\n    &#125;\n&#125;接口和继承解决的问题不同\n继承的价值主要在于：解决代码的复用性和可维护性。\n接口的价值主要在于：设计，设计好各种规范（方法），让其它类去实现这些方法。即更加的灵活…..\n接口比继承更加灵活\n接口比继承更加灵活，继承是满足is - a的关系，而接口只需满足like - a的关系。\n接口在一定程序上实现代码解耦 [即：接口规范性+动态绑定机制]\n接口的多态特性\n\n多态参数：在前面的Usb接口案例，Usblnterface usb,既可以接收手机对象，又可以接收相机对象，就体现了接口 多态（接口引用可以指向实现了接口的类的对象） \n多态数组：演示一个案例：给Usb数组中，存放Phone和相机对像，Phone类还有一个特有的方法cal()，请遍历Usb数组，如果是Phone对象，除了调用Usb接口定义的方法外，还需要调用 Phone特有方法call。\n接口存在多态传递现象。\n\n代码举例说明\njavapublic class InterfacePolyParameter &#123;\n    public static void main(String[] args) &#123;\n        //接口的多态体现\n        //接口类型的变量 if01 可以指向 实现了 IF 接口类的对象实例\n        IF if01 = new Monster();\n        if01 = new Car();\n        //继承体现的多态\n        //父类类型的变量 a 可以指向 继承 AAA 的子类的对象实例\n        AAA a = new BBB();\n        a = new CCC();\n    &#125;\n&#125;\ninterface IF &#123;&#125;\nclass Monster implements IF&#123;&#125;\nclass Car implements IF&#123;&#125;\nclass AAA &#123;\n&#125;\nclass BBB extends AAA &#123;&#125;\nclass CCC extends AAA &#123;&#125;javapublic class InterfacePolyArr &#123;\n    public static void main(String[] args) &#123;\n        //多态数组 -&gt; 接口类型数组\n        Usb[] usbs = new Usb[2];\n        usbs[0] = new Phone_();\n        usbs[1] = new Camera_();\n        /*\n        给 Usb 数组中，存放 Phone 和 相机对象，Phone 类还有一个特有的方法 call（），\n        请遍历 Usb 数组，如果是 Phone 对象，除了调用 Usb 接口定义的方法外，\n        还需要调用 Phone 特有方法 call\n        */\n        for(int i = 0; i &lt; usbs.length; i++) &#123;\n        usbs[i].work();//动态绑定.. //和前面一样，我们仍然需要进行类型的向下转型\n        if(usbs[i] instanceof Phone_) &#123;//判断他的运行类型是 Phone_\n            ((Phone_) usbs[i]).call();\n        &#125;\n    &#125;\n&#125;\ninterface Usb&#123;\n    void work();\n&#125;\nclass Phone_ implements Usb &#123;\n    public void call() &#123;\n        System.out.println(&quot;手机可以打电话...&quot;);\n    &#125;\n    @Override\n    public void work() &#123;\n        System.out.println(&quot;手机工作中...&quot;);\n    &#125;\n&#125;\nclass Camera_ implements Usb &#123;\n    @Override\n    public void work() &#123;\n        System.out.println(&quot;相机工作中...&quot;);\n    &#125;\n&#125;java/**\n* 演示多态传递现象\n*/\npublic class InterfacePolyPass &#123;\n    public static void main(String[] args) &#123;\n        //接口类型的变量可以指向，实现了该接口的类的对象实例\n        IG ig = new Teacher();\n        //如果 IG 继承了 IH 接口，而 Teacher 类实现了 IG 接口\n        //那么，实际上就相当于 Teacher 类也实现了 IH 接口. //这就是所谓的 接口多态传递现象. IH ih = new Teacher();\n        &#125;\n&#125;\ninterface IH &#123;\n    void hi();\n&#125;\ninterface IG extends IH&#123; &#125;\nclass Teacher implements IG &#123;\n    @Override\n    public void hi() &#123;\n    &#125;\n&#125;9.8 内部类如果定义类在局部位置(方法中&#x2F;代码块) ：(1) 局部内部类 (2) 匿名内部类\n定义在成员位置 (1) 成员内部类 (2) 静态内部类\n基本介绍\n个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员【思考：类的五大成员是哪些[属性、方法、构造器、代码块、内部类]】，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系，注意：内部类是学习的难点，同时也是重点，后面看底层源码时，有大量的内部类.\n基本语法\njavaclass Outer&#123;\t//外部类\n    class Inner&#123; //内部类\n    &#125;\n&#125;\nclass Other&#123;\t//外部其他类\n&#125;快速入门案例\njavapublic class InnerClass01 &#123; //外部其他类\n    public static void main(String[] args) &#123;\n    &#125;\n&#125;\nclass Outer &#123; //外部类\n    private int n1 = 100;//属性\n    public Outer(int n1) &#123;//构造器\n        this.n1 = n1;\n    &#125;\n    public void m1() &#123;//方法\n        System.out.println(&quot;m1()&quot;);\n    &#125;\n    &#123;//代码块\n        System.out.println(&quot;代码块...&quot;);\n    &#125;\n    \n    class Inner &#123; //内部类, 在 Outer 类的内部\n    &#125;\n&#125;内部类的分类\n定义在外部类局部位置上（比如方法内） \n\n局部内部类（有类名） \n匿名内部类（没有类名，重点!!!!）\n\n定义在外部类的成员位置上： \n\n成员内部类（没用static修饰） \n静态内部类  (使用static修饰)\n\n局部内部类的使用说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。 \n\n可以直接访问外部类的所有成员，包含私有的 \n不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final \n作用域：仅仅在定义它的方法或代码块中。 \n局部内部类–访问–&gt;外部类的成员 [访问方式：直接访问] \n外部类–访问–&gt;局部内部类的成员\n访问方式：创建对象，再访问（注意：必须在作用域内）\n\n\n外部其他类–不能访问—&gt;局部内部类（因为局部内部类地位是一个局部变量） \n如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.ths.成员）去访问\n演示：System.out.println(&quot;外部类的n2=&quot; + 外部类名.this.n2);\n\n\n\n记住：\n\n局部内部类定义在方法中&#x2F;代码块\n作用域在方法体或者代码块中\n本质仍然是一个类\n\n代码举例说明\njavapublic class LocalInnerClass &#123;//\n    public static void main(String[] args) &#123;\n        //演示一遍\n        Outer02 outer02 = new Outer02();\n        outer02.m1();\n        System.out.println(&quot;outer02 的 hashcode=&quot; + outer02);\n    &#125;\n&#125;\nclass Outer02 &#123;//外部类\n    private int n1 = 100;\n    private void m2() &#123;\n        System.out.println(&quot;Outer02 m2()&quot;);\n    &#125;//私有方法\n    public void m1() &#123;//方法\n        //1.局部内部类是定义在外部类的局部位置,通常在方法\n        //3.不能添加访问修饰符,但是可以使用 final 修饰\n        //4.作用域 : 仅仅在定义它的方法或代码块中\n        final class Inner02 &#123;//局部内部类(本质仍然是一个类)\n        //2.可以直接访问外部类的所有成员，包含私有的\n        private int n1 = 800;\n        public void f1() &#123;\n            //5. 局部内部类可以直接访问外部类的成员，比如下面 外部类 n1 和 m2()\n            //7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，\n            // 使用 外部类名.this.成员）去访问\n            // 老韩解读 Outer02.this 本质就是外部类的对象, 即哪个对象调用了 m1, Outer02.this 就是哪个对象\n            System.out.println(&quot;n1=&quot; + n1 + &quot; 外部类的 n1=&quot; + Outer02.this.n1);\n            System.out.println(&quot;Outer02.this hashcode=&quot; + Outer02.this);\n            m2();\n        &#125;\n    &#125;\n    //6. 外部类在方法中，可以创建 Inner02 对象，然后调用方法即可\n    Inner02 inner02 = new Inner02();\n    inner02.f1();\n    &#125;\n&#125;匿名内部类的使用(重要!!!!!!!)说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名\n\n本质是类\n内部类\n该类没有名字\n同时还是一个对象\n\n基本语法\njavanew 类或接口(参数列表)&#123;\n    类体\n&#125;;代码举例说明\njavapublic class AnonymousInnerClass &#123;\n    public static void main(String[] args) &#123;\n        Outer04 outer04 = new Outer04();\n        outer04.method();\n    &#125;\n&#125;\nclass Outer04 &#123; //外部类\n    private int n1 = 10;//属性\n    public void method() &#123;//方法\n    //基于接口的匿名内部类\n    //1.需求： 想使用 IA 接口,并创建对象\n    //2.传统方式，是写一个类，实现该接口，并创建对象\n    //3.需求是 Tiger/Dog 类只是使用一次，后面再不使用\n    //4. 可以使用匿名内部类来简化开发\n    //5. tiger 的编译类型 ? IA\n    //6. tiger 的运行类型 ? 就是匿名内部类 Outer04$1\n    /*\n    我们看底层 会分配 类名 Outer04$1\n    class Outer04$1 implements IA &#123;\n        @Override\n        public void cry() &#123;\n            System.out.println(&quot;老虎叫唤...&quot;);\n        &#125;\n    &#125;\n    */\n    //7. jdk 底层在创建匿名内部类 Outer04$1,立即马上就创建了 Outer04$1 实例，并且把地址\n    // 返回给 tiger\n    //8. 匿名内部类使用一次，就不能再使用\n    IA tiger = new IA() &#123;\n        @Override\n        public void cry() &#123;\n            System.out.println(&quot;老虎叫唤...&quot;);\n        &#125;\n    &#125;;\n    System.out.println(&quot;tiger 的运行类型=&quot; + tiger.getClass());\n    tiger.cry();\n    tiger.cry();\n    tiger.cry();\n    // IA tiger = new Tiger();\n    // tiger.cry();\n    //演示基于类的匿名内部类\n    //分析\n    //1. father 编译类型 Father\n    //2. father 运行类型 Outer04$2\n    //3. 底层会创建匿名内部类\n    //4. 同时也直接返回了 匿名内部类 Outer04$2 的对象\n    //5. 注意(&quot;jack&quot;) 参数列表会传递给 构造器\n    Father father = new Father(&quot;jack&quot;)&#123;\n        @Override\n        public void test() &#123;\n            System.out.println(&quot;匿名内部类重写了 test 方法&quot;);\n        &#125;\n    &#125;;\n    System.out.println(&quot;father 对象的运行类型=&quot; + father.getClass());//Outer04$2\n    father.test();\n    //基于抽象类的匿名内部类\n    Animal animal = new Animal()&#123;\n        @Override\n        void eat() &#123;\n            System.out.println(&quot;小狗吃骨头...&quot;);\n        &#125;\n    &#125;;\n    animal.eat();\n    &#125;\n&#125;\ninterface IA &#123;//接口\n    public void cry();\n&#125;匿名内部类说明\n\n匿名内部类的语法比较奇特，注意，因为匿名内部类既是一个类的定义同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法。\n可以直接访问外部类的所有成员，包含私有的\n不能添加访问修饰符，因为它的地位就是一个局部变量。\n作用域：仅仅在定义它的方法或代码块中。\n匿名内部类–访问–&gt;外部类成员\n外部其他类–不能访问–&gt;匿名内部类（因为匿名内部类地位是一个局部变量）\n如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问\n\n匿名内部类的最佳实践\njavapublic class InnerClassExercise01 &#123;\n    public static void main(String[] args) &#123;\n        //当做实参直接传递，简洁高效\n        f1(new IL() &#123;\n            @Override\n            public void show() &#123;\n                System.out.println(&quot;这是一副名画~~...&quot;);\n            &#125;\n        &#125;);\n        //传统方法\n        f1(new Picture());\n    &#125;\n    //静态方法,形参是接口类型\n    public static void f1(IL il) &#123;\n        il.show();\n    &#125;\n&#125;\n//接口\ninterface IL &#123;\n    void show();\n&#125;\n//类-&gt;实现 IL =&gt; 编程领域 (硬编码)\nclass Picture implements IL &#123;\n    @Override\n    public void show() &#123;\n        System.out.println(&quot;这是一副名画 XX...&quot;);\n    &#125;\n&#125;成员内部类的使用说明：成员内部类是定义在外部类的成员位置，并且没有static修饰。 \n\n可以直接访问外部类的所有成员，包含私有的 \n\njavaclass Outer01&#123; //外部类 \n    private int n1 10; \n    public String name =&quot;张三&quot;;\n    class Innter01&#123; \n        public void say()&#123; \n            System.out.printin(&quot;Outert01的n1=&quot; + n1 +&quot;outert01的name=&quot; + name);\n&#125;&#125;&#125;\n\n\n可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员。 \n\n作用域\n\n和外部类的其他成员一样，为整个类体比如前面案例，在外部类的成员方法中创建成员内部类对象，再调用方法.\n\n\n成员内部类–访问–&gt;外部类成员（比如：属性) [访问方式：直接访问] \n\n外部类-访问—&gt;成员内部类（说明) 访问方式：创建对象，再访问 \n\n外部其他类–访问–&gt;成员内部类 \n\n如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问\n\n\n代码举例说明\njavapublic static void main(String[] args) &#123;\n    Outer08 outer08 = new Outer08();\n    outer08.t1();\n    //外部其他类，使用成员内部类的三种方式\n    //解读\n    // 第一种方式\n    // outer08.new Inner08(); 相当于把 new Inner08()当做是 outer08 成员\n    // 这就是一个语法，不要特别的纠结. Outer08.Inner08 inner08 = outer08.new Inner08();\n    inner08.say();\n    // 第二方式 在外部类中，编写一个方法，可以返回 Inner08 对象\n    Outer08.Inner08 inner08Instance = outer08.getInner08Instance();\n    inner08Instance.say();\n&#125;\nclass Outer08 &#123; //外部类\n    private int n1 = 10;\n    public String name = &quot;张三&quot;;\n    private void hi() &#123;\n        System.out.println(&quot;hi()方法...&quot;);\n    &#125;\n    //1.注意: 成员内部类，是定义在外部内的成员位置上\n    //2.可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员\n    public class Inner08 &#123;//成员内部类\n        private double sal = 99.8;\n        private int n1 = 66;\n        public void say() &#123;\n            //可以直接访问外部类的所有成员，包含私有的\n            //如果成员内部类的成员和外部类的成员重名，会遵守就近原则. //，可以通过 外部类名.this.属性 来访问外部类的成员\n            System.out.println(&quot;n1 = &quot; + n1 + &quot; name = &quot; + name + &quot; 外部类的 n1=&quot; + Outer08.this.n1);\n            hi();\n        &#125;\n    &#125;\n    //方法，返回一个 Inner08 实例\n    public Inner08 getInner08Instance()&#123;\n        return new Inner08();\n    &#125;\n    //写方法\n    public void t1() &#123;\n        //使用成员内部类\n        //创建成员内部类的对象，然后使用相关的方法\n        Inner08 inner08 = new Inner08();\n        inner08.say();\n        System.out.println(inner08.sal);\n    &#125;\n&#125;静态内部类的使用说明：静态内部类是定义在外部类的成员位置，并且有static修饰 \n\n可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员 \n可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员。 \n作用域：同其他的成员，为整个类体 \n静态内部类–访问–&gt;外部类（比如：静态属性）[访问方式：直接访问所有静态成员] \n外部类–访问—&gt;静态内部类。\t访问方式：创建对象，再访问 \n外部其他类–访问—&gt;静态内部类 \n如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问\n\n代码举例说明\njavapublic static void main(String[] args) &#123;\n    Outer10 outer10 = new Outer10();\n    outer10.m1();\n    //外部其他类 使用静态内部类\n    //方式 1\n    //因为静态内部类，是可以通过类名直接访问(前提是满足访问权限)\n    Outer10.Inner10 inner10 = new Outer10.Inner10();\n    inner10.say();\n    //方式 2\n    //编写一个方法，可以返回静态内部类的对象实例. Outer10.Inner10 inner101 = outer10.getInner10();\n    System.out.println(&quot;============&quot;);\n    inner101.say();\n    Outer10.Inner10 inner10_ = Outer10.getInner10_();\n    System.out.println(&quot;************&quot;);\n    inner10_.say();\n&#125;\n\nclass Outer10 &#123; //外部类\n    private int n1 = 10;\n    private static String name = &quot;张三&quot;;\n    private static void cry() &#123;&#125;\n    //Inner10 就是静态内部类\n    //1. 放在外部类的成员位置\n    //2. 使用 static 修饰\n    //3. 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员\n    //4. 可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员\n    //5. 作用域 ：同其他的成员，为整个类体\n    static class Inner10 &#123;\n        private static String name = &quot;Java学习&quot;;\n        public void say() &#123;\n            //如果外部类和静态内部类的成员重名时，静态内部类访问的时，\n            //默认遵循就近原则，如果想访问外部类的成员，则可以使用 （外部类名.成员）\n            System.out.println(name + &quot; 外部类 name= &quot; + Outer10.name);\n            cry();\n        &#125;\n    &#125;\n    public void m1() &#123; //外部类---访问------&gt;静态内部类 访问方式：创建对象，再访问\n        Inner10 inner10 = new Inner10();\n        inner10.say();\n    &#125;\n    public Inner10 getInner10() &#123;\n        return new Inner10();\n    &#125;\n    public static Inner10 getInner10_() &#123;\n        return new Inner10();\n    &#125;\n&#125;\n第 10 章 枚举和注解10.1 枚举的二种实现方式\n自定义类实现枚举\n使用 enum 关键字实现枚举\n\n自定义类实现枚举-应用案例\n\n不需要提供setXxx方法，因为枚举对象值通常为只读。\n对枚举对象&#x2F;属性使用final+static 共同修饰，实现底层优化。\n枚举对象名通常使用全部大写，常量的命名规范。\n枚举对象根据需要，也可以有多个属性\n\n代码举例说明\njava//演示字定义枚举实现\nclass Season &#123;//类\n    private String name;\n    private String desc;//描述\n    //定义了四个对象, 固定. public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);\n    public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);\n    public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);\n    public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;);\n    //1. 将构造器私有化,目的防止 直接 new\n    //2. 去掉 setXxx 方法, 防止属性被修改\n    //3. 在 Season 内部，直接创建固定的对象\n    //4. 优化，可以加入 final 修饰符\n    private Season(String name, String desc) &#123;\n        this.name = name;\n        this.desc = desc;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public String getDesc() &#123;\n        return desc;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Season&#123;&quot; +\n        &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n        &quot;, desc=&#39;&quot; + desc + &#39;\\&#39;&#39; +\n        &#39;&#125;&#39;;\n    &#125;\n&#125;10.2 自定义类实现枚举特点自定义类实现枚举特点如下：\n\n构造器私有化\n本类内部创建一组对象[四个 春夏秋冬]\n对外暴露对象（通过为对象添加 public final static 修饰符）\n可以提供 get 方法，但是不要提供 set\n\n10.3 enum 关键字实现枚举快速入门\njava//演示使用 enum 关键字来实现枚举类\nenum Season2 &#123;//类\n    //定义了四个对象, 固定. // public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);\n    // public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);\n    // public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);\n    // public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;);\n    //如果使用了 enum 来实现枚举类\n    //1. 使用关键字 enum 替代 class\n    //2. public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;) 直接使用\n    // SPRING(&quot;春天&quot;, &quot;温暖&quot;) 解读 常量名(实参列表)\n    //3. 如果有多个常量(对象)， 使用 ,号间隔即可\n    //4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面\n    //5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()\n    SPRING(&quot;春天&quot;, &quot;温暖&quot;), WINTER(&quot;冬天&quot;, &quot;寒冷&quot;), AUTUMN(&quot;秋天&quot;, &quot;凉爽&quot;), SUMMER(&quot;夏天&quot;, &quot;炎热&quot;)/*, What()*/;\n    private String name;\n    private String desc;//描述\n    private Season2() &#123;//无参构造器\n    &#125;\n    private Season2(String name, String desc) &#123;\n        this.name = name;\n        this.desc = desc;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public String getDesc() &#123;\n        return desc;\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;Season&#123;&quot; +\n        &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n        &quot;, desc=&#39;&quot; + desc + &#39;\\&#39;&#39; +\n        &#39;&#125;&#39;;\n    &#125;\n&#125;10.4 enum 关键字实现枚举注意事项\n当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类, 而且是一个 final 类\n传统的 public static final Season2 SPRING = new Season2(&quot;春天&quot;, &quot;温暖&quot;); 简化成 SPRING(&quot;春天&quot;, &quot;温暖&quot;)， 这里必须知道，它调用的是哪个构造器. \n如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略\n当有多个枚举对象时，使用,间隔，最后有一个分号结尾\n枚举对象必须放在枚举类的行首\n\n案例练习\n下面代码是否正确, 并说明表示的含义?\njavaenum Gender&#123; //1min\n    BOY , GIRL; \n    //这里其实就是调用 Gender 类的无参构造器\n&#125;回答如下：\n\n上面语法是 ok\n有一个枚举类 Gender， 没有属性。\n有两个枚举对象 BOY, GIRL, 使用的无参构造器创建.\n\n10.5 enum 常用方法\ntoString:Enum 类已经重写过了，返回的是当前对象名,子类可以重写该方法，用于返回对象的属性信息\nname：返回当前对象名（常量名），子类中不能重写\nordinal：返回当前对象的位置号，默认从 0 开始\nvalues：返回当前枚举类中所有的常量\nvalueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常！\ncompareTo：比较两个枚举常量，比较的就是编号！\n\n应用案例\nSeason2类在上面有\njavapublic class EnumMethod &#123;\n    public static void main(String[] args) &#123;\n        //使用 Season2 枚举类，来演示各种方法\n        Season2 autumn = Season2.AUTUMN;\n        //输出枚举对象的名字\n        System.out.println(autumn.name());\n        //ordinal() 输出的是该枚举对象的次序/编号，从 0 开始编号\n        //AUTUMN 枚举对象是第三个，因此输出 2\n        System.out.println(autumn.ordinal());\n        //从反编译可以看出 values 方法，返回 Season2[]\n        //含有定义的所有枚举对象\n        Season2[] values = Season2.values();\n        System.out.println(&quot;===遍历取出枚举对象(增强 for)====&quot;);\n        for (Season2 season: values) &#123;//增强 for 循环\n            System.out.println(season);\n        &#125;\n        //valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常\n        //执行流程\n        //1. 根据你输入的 &quot;AUTUMN&quot; 到 Season2 的枚举对象去查找\n        //2. 如果找到了，就返回，如果没有找到，就报错\n        Season2 autumn1 = Season2.valueOf(&quot;AUTUMN&quot;);\n        System.out.println(&quot;autumn1=&quot; + autumn1);\n        System.out.println(autumn == autumn1);\n        //compareTo：比较两个枚举常量，比较的就是编号\n        //1. 就是把 Season2.AUTUMN 枚举对象的编号 和 Season2.SUMMER 枚举对象的编号比较\n        //2. 看看结果\n        /*\n        public final int compareTo(E o) &#123;\n        return self.ordinal - other.ordinal;\n        &#125;\n        Season2.AUTUMN 的编号[2] - Season2.SUMMER 的编号[3]\n        */\n        System.out.println(Season2.AUTUMN.compareTo(Season2.SUMMER));\n    &#125;\n&#125;10.6 enum 实现接口\n使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。\n枚举类和普通类一样，可以实现接口。形式：enum 类名 implements 接口 1，接口 2&#123;&#125;\n\n代码举例说明\njavapublic class EnumDetail &#123;\n    public static void main(String[] args) &#123;\n        Music.CLASSICMUSIC.playing();\n    &#125;\n&#125;\nclass A &#123;\n&#125;\n//1.使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制\n//enum Season3 extends A &#123;\n//\n//&#125;\n//2.enum 实现的枚举类，仍然是一个类，所以还是可以实现接口的. interface IPlaying &#123;\npublic void playing();\n&#125;\nenum Music implements IPlaying &#123;\n    CLASSICMUSIC;\n    @Override\n    public void playing() &#123;\n        System.out.println(&quot;播放好听的音乐...&quot;);\n    &#125;\n&#125;10.7 注解的理解\n注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。\n和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。\n在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。\n\n10.8 基本的 Annotation 介绍使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素\n三个基本的 Annotation:\n\n@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法\n@Deprecated: 用于表示某个程序元素(类, 方法等)已过时\n@SuppressWarnings: 抑制编译器警告\n\n@Override注解Override使用说明\n\n@Override表示指定重与父类的方法（从编泽层面验证），如果父类没有fIy方法，则会报错。\n如果不写@Override注解，而父类仍有public void fly()&#123;&#125;，仍然构成重写。\n@Override只能修饰方法，不能修饰其它类，包，属性等等。\n查看@Override注解源码为@Target(ElementType.METHOD)，说明只能修饰方法。\n@Target是修饰注解的注解，称为元注解，记住这个概念。\n\n代码举例说明\njavaclass Son extends Father &#123;//子类\n    //1. @Override 注解放在 fly 方法上，表示子类的 fly 方法时重写了父类的 fly\n    //2. 这里如果没有写 @Override 还是重写了父类 fly\n    //3. 如果你写了@Override 注解，编译器就会去检查该方法是否真的重写了父类的\n    // 方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误\n    //4. 看看 @Override 的定义\n    // 解读： 如果发现 @interface 表示一个 注解类\n    /*\n    @Target(ElementType.METHOD)\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface Override &#123;\n    &#125;\n    */\n    @Override //说明\n    public void fly() &#123;\n        System.out.println(&quot;Son fly....&quot;);\n    &#125;\n    @Override\n    public void say() &#123;&#125;\n&#125;@Deprecated注解@Deprecated说明\n\n用于表示某个程序元素（类，方法等）已过时\n可以修饰方法，类，字段，包，参数等等\n@Target(value&#x3D;{CONSTRUCTOR,FIELD,LOCAL VARIABLE,METHOD, PACKAGE,PARAMETER,TYPE})\n@Deprecated的作用可以做到新旧版本的兼容和过渡\n\n代码举例说明\njavapublic class Deprecated_ &#123;\n    public static void main(String[] args) &#123;\n        A a = new A();\n        a.hi();\n        System.out.println(a.n1);\n    &#125;\n&#125;\n//1. @Deprecated 修饰某个元素, 表示该元素已经过时\n//2. 即不在推荐使用，但是仍然可以使用\n//3. 查看 @Deprecated 注解类的源码\n//4. 可以修饰方法，类，字段, 包, 参数 等等\n//5. @Deprecated 可以做版本升级过渡使用\n/*\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)\npublic @interface Deprecated &#123;\n&#125;\n*/\n@Deprecated\nclass A &#123;\n    @Deprecated\n    public int n1 = 10;\n    @Deprecated\n    public void hi()&#123;\n    &#125;\n&#125;@SuppressWarnings注解@SuppressWarnings说明各种值\n\nunchecked是忽略没有检查的警告 \nrawtypes是忽略没有指定泛型的警告（传参时没有指定泛型的警告错误） \nunused是忽略没有使用某个变量的警告错误\n@SuppressWarnings可以修饰的程序元素为，查看@Target\n生成@SupperssWarnings时，不用背，直接点击左侧的黄色提示，就可以选择（注意可以指定生成的位置）\n\n代码举例说明\njava@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;unused&quot;&#125;)\npublic class SuppressWarnings_ &#123;\n    //1. 当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息\n    //2. 在&#123;&quot;&quot;&#125; 中，可以写入你希望抑制(不显示)警告信息\n    //3. 可以指定的警告类型有\n    // all，抑制所有警告\n    // boxing，抑制与封装/拆装作业相关的警告\n    // //cast，抑制与强制转型作业相关的警告\n    // //dep-ann，抑制与淘汰注释相关的警告\n    // //deprecation，抑制与淘汰的相关警告\n    // //fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告\n    // //finally，抑制与未传回 finally 区块相关的警告\n    // //hiding，抑制与隐藏变数的区域变数相关的警告\n    // //incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告\n    // //javadoc，抑制与 javadoc 相关的警告\n    // //nls，抑制与非 nls 字串文字相关的警告\n    // //null，抑制与空值分析相关的警告\n    // //rawtypes，抑制与使用 raw 类型相关的警告\n    // //resource，抑制与使用 Closeable 类型的资源相关的警告\n    // //restriction，抑制与使用不建议或禁止参照相关的警告\n    // //serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告\n    // //static-access，抑制与静态存取不正确相关的警告\n    // //static-method，抑制与可能宣告为 static 的方法相关的警告\n    // //super，抑制与置换方法相关但不含 super 呼叫的警告\n    // //synthetic-access，抑制与内部类别的存取未最佳化相关的警告\n    // //sync-override，抑制因为置换同步方法而遗漏同步化的警告\n    // //unchecked，抑制与未检查的作业相关的警告\n    // //unqualified-field-access，抑制与栏位存取不合格相关的警告\n    // //unused，抑制与未用的程式码及停用的程式码相关的警告\n    //4. 关于 SuppressWarnings 作用范围是和你放置的位置相关\n    // 比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main\n    // 通常我们可以放置具体的语句, 方法, 类. //5. 看看 @SuppressWarnings 源码\n    //(1) 放置的位置就是 TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE\n    //(2) 该注解类有数组 String[] values() 设置一个数组比如 &#123;&quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;unused&quot;&#125;\n    /*\n    @Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface SuppressWarnings &#123;\n    String[] value();\n    &#125;\n    */\n    public static void main(String[] args) &#123;\n        List list = new ArrayList();\n        list.add(&quot;jack&quot;);\n        list.add(&quot;tom&quot;);\n        list.add(&quot;mary&quot;);\n        int i;\n        System.out.println(list.get(1));\n    &#125;\n    public void f1() &#123;\n        // @SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)\n        List list = new ArrayList();\n        list.add(&quot;jack&quot;);\n        list.add(&quot;tom&quot;);\n        list.add(&quot;mary&quot;);\n        // @SuppressWarnings(&#123;&quot;unused&quot;&#125;)\n        int i;\n        System.out.println(list.get(1));\n    &#125;\n&#125;\n第 11 章 异常-Exception11.1 异常介绍基本概念：Java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常)\n执行过程中所发生的异常事件可分为两大类 \n\nError(错误)：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError[栈溢出]和OOM(out of memory),Error是严重错误，程序会崩溃。 \nException：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception分为两大类：运行时异常程序运行时，发生的异常]和编译时异常[编程时，编译器检查出的异常]。\n\n11.2 异常体系图一览异常体系图\n\n异常体系图的小结\n\n异常分为两大类，运行时异常和编译时异常运行时异常。\n编译器检查不出来。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。\n对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。\n编译时异常，是编译器要求必须处置的异常。\n\n11.3 常见的运行时异常\nNullPointerException 空指针异常\nArithmeticException 数学运算异常\nArrayIndexOutOfBoundsException 数组下标越界异常\nClassCastException 类型转换异常\nNumberFormatException 数字格式不正确异常\n\n11.4 常见的运行时异常举例NullPointerException 空指针异常\njavapublic class NullPointerException_ &#123;\n    public static void main(String[] args) &#123;\n        String name = null;\n        System.out.println(name.length());\n    &#125;\n&#125;ArithmeticException 数学运算异常\njavapublic class NumberFormatException_ &#123;\n    public static void main(String[] args) &#123;\n        String name = &quot;教育&quot;;\n        //将 String 转成 int\n        int num = Integer.parseInt(name);//抛出 NumberFormatException\n        System.out.println(num);//1234\n    &#125;\n&#125;ArrayIndexOutOfBoundsException 数组下标越界异常\n用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引\njavapublic class ArrayIndexOutOfBoundsException_ &#123;\n    public static void main(String[] args) &#123;\n        int[] arr = &#123;1,2,4&#125;;\n        for (int i = 0; i &lt;= arr.length; i++) &#123;\n            System.out.println(arr[i]);\n        &#125;\n    &#125;\n&#125;ClassCastException 类型转换异常\n当试图将对象强制转换为不是实例的子类时，抛出该异常。\njavapublic class ClassCastException_ &#123;\n    public static void main(String[] args) &#123;\n        A b = new B(); //向上转型\n        B b2 = (B)b;//向下转型，这里是 OK\n        C c2 = (C)b;//这里抛出 ClassCastException\n    &#125;\n&#125;\nclass A &#123;&#125;\nclass B extends A &#123;&#125;\nclass C extends A &#123;&#125;NumberFormatException 数字格式不正确异常\n当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常 &#x3D;&gt; 使用异常。我们可以确保输入是满足条件数字。\njavapublic class NumberFormatException_ &#123;\n    public static void main(String[] args) &#123;\n        String name = &quot;韩顺平教育&quot;;\n        //将 String 转成 int\n        int num = Integer.parseInt(name);//抛出 NumberFormatException\n        System.out.println(num);//1234\n    &#125;\n&#125;11.5 编译异常基本介绍\n编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译。\n常见的编译异常\n\nSQLException：操作数据库时，查询表可能发生异常 \nIOException：操作文件时，发生的异常 \nFileNotFoundException：当操作一个不存在的文件时，发生异常 \nClassNotFoundException：加载类，而该类不存在时，异常 \nEOFException：操作文件，到文件末尾，发生异常 \nlllegalArguementException：参数异常\n\n案例说明\njavapublic class Exception02 &#123;\n    public static void main(String[] args) &#123;\n        try &#123;\n            FileInputStream fis;\n            fis = new FileInputStream(&quot;d:\\\\aa.jpg&quot;);\n            int len;\n            while ((len = fis.read()) != -1) &#123;\n                System.out.println(len);\n            &#125;\n            fis.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;11.6 异常处理基本介绍\n异常处理就是当异常发生时，对异常处理的方式。\n异常处理的方式\n\ntry-catch-finally：程序员在代码中捕获发生的异常，自行处理 \nthrows：将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM\n\n示意图\n\n\n11.7 try-catch 异常处理try-catch 方式处理异常说明\n\nJava提供try和catch块来处理异常。try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个try….catch块。 \n\n基本语法 \n\njavatry&#123;\n    //可疑代码\n    //将异常生成对应的异常对象，传递给catch:块\n&#125;catch(异常)&#123;\n    //对异常的处理\n&#125;\n//如果没有finally,语法是可以通过\n\n\n\ntry-catch 方式处理异常-快速入门\njavapublic static void main(String[] args) &#123;\n    int num1 = 10;\n    int num2 = 0;\n    try &#123;\n        int res = num1 / num2;\n    &#125; catch (Exception e) &#123;\n        System.out.println(e.getMessage());\n    &#125;\n&#125;try-catch 方式处理异常-注意事项\n\n如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块。\n如果异常没有发生，则顺序执行try的代码块，不会进入到catch。\n如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等）则使用如下代码 - finally{}\n可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，比如(Exception在后，NullPointerException在前，如果发生异常，只会匹配一个catch。\n可以进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉&#x2F;退出。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑\n\njavatry&#123;\n    //何疑代码\n&#125;catch(异常)&#123;\n    //....\n&#125;finally&#123;\n    //释放资源等.\n&#125;代码举例说明\ntry-catch注意事项1-3\njavapublic class TryCatchDetail &#123;\n    public static void main(String[] args) &#123;\n        //ctrl + atl + t\n        //1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到 catch 块\n        //2. 如果异常没有发生，则顺序执行 try 的代码块，不会进入到 catch\n        //3. 如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码- finally\n        try &#123;\n            String str = &quot;韩顺平&quot;;\n            int a = Integer.parseInt(str);\n            System.out.println(&quot;数字：&quot; + a);\n        &#125; catch (NumberFormatException e) &#123;\n            System.out.println(&quot;异常信息=&quot; + e.getMessage());\n        &#125; finally &#123;\n            System.out.println(&quot;finally 代码块被执行...&quot;);\n        &#125;\n        System.out.println(&quot;程序继续...&quot;);\n    &#125;\n&#125;try-catch注意事项4\njavapublic class TryCatchDetail02 &#123;\n    public static void main(String[] args) &#123;\n        //1.如果 try 代码块有可能有多个异常\n        //2.可以使用多个 catch 分别捕获不同的异常，相应处理\n        //3.要求子类异常写在前面，父类异常写在后面\n        try &#123;\n            Person person = new Person();\n            //person = null;\n            System.out.println(person.getName());//NullPointerException\n            int n1 = 10;\n            int n2 = 0;\n            int res = n1 / n2;//ArithmeticException\n        &#125; catch (NullPointerException e) &#123;\n            System.out.println(&quot;空指针异常=&quot; + e.getMessage());\n        &#125; catch (ArithmeticException e) &#123;\n            System.out.println(&quot;算术异常=&quot; + e.getMessage());\n        &#125; catch (Exception e) &#123;\n            System.out.println(e.getMessage());\n        &#125; finally &#123;\n        &#125;\n    &#125;\n&#125;\nclass Person &#123;\n    private String name = &quot;jack&quot;;\n    public String getName() &#123;\n        return name;\n    &#125;\n&#125;try-catch注意事项5\njavapublic class TryCatchDetail03 &#123;\n    public static void main(String[] args) &#123;\n        /*\n        可以进行 try-finally 配合使用, 这种用法相当于没有捕获异常，\n        因此程序会直接崩掉/退出。应用场景，就是执行一段代码，不管是否发生异常，\n        都必须执行某个业务逻辑\n        */\n        try&#123;\n            int n1 = 10;\n            int n2 = 0;\n            System.out.println(n1 / n2);\n        &#125;finally &#123;\n            System.out.println(&quot;执行了 finally..&quot;);\n        &#125;\n        System.out.println(&quot;程序继续执行..&quot;);\n    &#125;\n&#125;try-catch-finally 执行顺序小结\n\n如果没有出现异常，则执行try块中所有语句，不执行catch块中语句，如果有finally，最后还需要执行finally里面的语句\n如果出现异常，则ty块中异常发生后，try块剩下的语句不再执行。将执行catch:块中的语句，如果有finally,最后还需要执行finally里面的语句！\n\n11.8 throws 异常处理基本介绍\n\n如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。\n在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。\n\n注意事项和使用细节\n\n对于编译异常，程序中必须处理，比如 try-catch 或者 throws\n对于运行时异常，程序中如果没有处理，默认就是throws的方式处理\n子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型\n在throws过程中，如果有方法try-catch,就相当于处理异常，就可以不必 throws\n\n代码举例说明\njavapublic class ThrowsDetail &#123;\n    public static void main(String[] args) &#123;\n        f2();\n    &#125;\n    public static void f2() /*throws ArithmeticException*/ &#123;\n        //1.对于编译异常，程序中必须处理，比如 try-catch 或者 throws\n        //2.对于运行时异常，程序中如果没有处理，默认就是 throws 的方式处理\n        int n1 = 10;\n        int n2 = 0;\n        double res = n1 / n2;\n    &#125;\n    public static void f1() throws FileNotFoundException &#123;\n    //这里大家思考问题 调用 f3() 报错\n    //1. 因为 f3() 方法抛出的是一个编译异常\n    //2. 即这时，就要 f1() 必须处理这个编译异常\n    //3. 在 f1() 中，要么 try-catch-finally ,或者继续 throws 这个编译异常\n        f3(); // 抛出异常\n    &#125;\n    public static void f3() throws FileNotFoundException &#123;\n        FileInputStream fis = new FileInputStream(&quot;d://aa.txt&quot;);\n    &#125;\n    public static void f4() &#123;\n        //1. 在 f4()中调用方法 f5() 是 OK\n        //2. 原因是 f5() 抛出的是运行异常\n        //3. 而 java 中，并不要求程序员显示处理,因为有默认处理机制\n        f5();\n    &#125;\n    public static void f5() throws ArithmeticException &#123;\n    &#125;\n&#125;\nclass Father &#123; //父类\n    public void method() throws RuntimeException &#123;\n    &#125;\n&#125;\nclass Son extends Father &#123;//子类\n    //3. 子类重写父类的方法时，对抛出异常的规定:子类重写的方法，\n    // 所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常类型的子类型\n    //4. 在 throws 过程中，如果有方法 try-catch , 就相当于处理异常，就可以不必 throws\n    @Override\n    public void method() throws ArithmeticException &#123;\n    &#125;\n&#125;11.9 自定义异常基本概念\n当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。\n自定义异常的步骤\n\n定义类：自定义异常类名（程序员自己写）继承Exception或RuntimeException\n如果继承Exception，属于编译异常\n如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException)\n\n自定义异常的应用实例\njavapublic class CustomException &#123;\n    public static void main(String[] args) /*throws AgeException*/ &#123;\n        int age = 180;\n        //要求范围在 18 – 120 之间，否则抛出一个自定义异常\n        if(!(age &gt;= 18 &amp;&amp; age &lt;= 120)) &#123;\n            //这里我们可以通过构造器，设置信息\n            throw new AgeException(&quot;年龄需要在 18~120 之间&quot;);\n        &#125;\n        System.out.println(&quot;你的年龄范围正确.&quot;);\n    &#125;\n&#125;\nclass AgeException extends RuntimeException &#123;\n    public AgeException(String message) &#123;//构造器\n        super(message);\n    &#125;\n&#125;11.10 throw 和 throws 的区别\n\n\n\n意义\n位置\n后面跟的东西\n\n\n\nthrows\n异常处理的一种方式\n方法声明处\n异常类型\n\n\nthrow\n手动生成异常对象的关键字\n方法体中\n异常对象\n\n\n测试题\n\n\n第 12 章 常用类","slug":"Java学习笔记","date":"2023-12-04T13:29:00.000Z","categories_index":"Java","tags_index":"Java","author_index":"白"},{"id":"52a2a9bb6ef1e7b81577358c82fded8e","title":"Python初级入门","content":"Python初级入门爬虫的流程第一步：获取网页内容\nHTTP协议\nHTTP响应\n\nPython Requests\n第二步：解析网页内容\nHTML定义网页的结构和信息 \nCSs定义网页的样式 \nJavaScript定义用户和网页的交互逻辑\nhtml网页结构\nBeautiful Soup\n第三步：储存或分析数据\n","slug":"Python初级入门","date":"2023-12-02T06:50:00.000Z","categories_index":"Python","tags_index":"Python","author_index":"白"},{"id":"929904857381a43e5a2e7edb558ba72e","title":"算法学习_数组篇","content":"算法学习_数组篇学习至：代码随想录 (programmercarl.com)\n二分查找前提条件1、被搜索的序列必须是有序的，可以是升序或降序。\n2、数据集中的元素必须是可比较的。(因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。)\n使用二分查找不一定要求数组是有序的。只需要能够找到一个分割点，将序列分为两个类别即可，通常来说这个分割点用中点。\n二分查找类型(重要)写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。\n在java中设置int mid &#x3D; left + ( left + right )&#x2F;2是为了防止溢出。相当于 right + left &gt;&gt; 1;\n左闭右闭[left, right]因为定义target在[left, right]区间，所以有如下两点：\n\nwhile (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;\nif (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1\n\n例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：\n\n代码实现\n\n时间复杂度：O(log n)\n空间复杂度：O(1)\n\njavaclass Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        // 避免当 target 小于nums[0] 大于nums[nums.length - 1]时多次循环运算\n        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123;\n            return -1;\n        &#125;\n        int left = 0, right = nums.length - 1;\n        while (left &lt;= right) &#123;\n            int mid = left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] == target)\n                return mid;\n            else if (nums[mid] &lt; target)\n                left = mid + 1;\n            else if (nums[mid] &gt; target)\n                right = mid - 1;\n        &#125;\n        return -1;\n    &#125;\n&#125;左闭右开[left, right)如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。\n\nwhile (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的\nif (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]\n\n在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（注意和方法一的区别）\n\n代码实现\n\n时间复杂度：O(log n)\n空间复杂度：O(1)\n\njavaclass Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        int left = 0, right = nums.length;\n        while (left &lt; right) &#123;\n            int mid = left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] == target)\n                return mid;\n            else if (nums[mid] &lt; target)\n                left = mid + 1;\n            else if (nums[mid] &gt; target)\n                right = mid;\n        &#125;\n        return -1;\n    &#125;\n&#125;相关题目练习\n(35. 搜索插入位置 - 力扣（LeetCode）)\n(34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）)\n(69. x 的平方根 - 力扣（LeetCode）)\n(367. 有效的完全平方数 - 力扣（LeetCode）)\n\n35.搜索插入位置题目\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\n示例 1:\ntxt输入: nums = [1,3,5,6], target = 5\n输出: 2示例 2:\ntxt输入: nums = [1,3,5,6], target = 2\n输出: 1示例 3:\ntxt输入: nums = [1,3,5,6], target = 7\n输出: 4思路\n\n当target &#x3D; 2 &gt; nums[mid]的时候，l &#x3D; mid + 1，因此l就移动到3（索引为1）的位置，此刻left&gt;right不满足循环条件，因此退出循环。最后应当返回left所在位置为插入位置。\n\n\n代码实现\njavapublic int searchInsert(int[] nums, int target) &#123;\n    int left = 0, right = nums.length-1;\n    while(left &lt;= right) &#123; //左闭右闭\n        int mid = ((left + right) /2);\n        if(target &gt; nums[mid]) &#123;\n            left = mid + 1;\n        &#125; else if(target &lt; nums[mid]) &#123;\n            right = mid -1;\n        &#125; else &#123;\n            return mid;\n        &#125;\n    &#125;\n    return left;\n&#125;34.在排序数组中查找元素的第一个和最后一个位置题目\n给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：\ntxt输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]示例 2：\ntxt输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]示例 3：\ntxt输入：nums = [], target = 0\n输出：[-1,-1]思路\n\n代码实现\njavapublic int[] searchRange(int[] nums, int target) &#123;\n    int len = nums.length;\n    if(len == 0) &#123;\n        return new int[]&#123;-1,-1&#125;;\n    &#125;\n    int firstPosition = findFirstPosition(nums, target);\n    if(firstPosition == -1) &#123;\n        return new int[]&#123;-1, -1&#125;;\n    &#125;\n    int lastPosition = findLastPosition(nums, target);\n    return new int[]&#123;firstPosition, lastPosition&#125;;\n&#125;\n//返回第一个\npublic int findFirstPosition(int[] nums, int target) &#123;\n    int first = -1;\n    int left = 0, right = nums.length-1;\n    while(left &lt;= right) &#123; //左闭右闭\n        int mid = ((left + right) /2);\n        if(target &gt; nums[mid]) &#123;\n            left = mid + 1;\n        &#125; else if(target &lt; nums[mid]) &#123;\n            right = mid -1;\n        &#125; else &#123;\n            first = mid;\n            right = mid-1;\n        &#125;\n    &#125;\n    return first;\n&#125;\npublic int findLastPosition(int[] nums, int target) &#123;\n    int last = -1;\n    int left = 0, right = nums.length-1;\n    while(left &lt;= right) &#123; //左闭右闭\n        int mid = ((left + right) /2);\n        if(target &gt; nums[mid]) &#123;\n            left = mid + 1;\n        &#125; else if(target &lt; nums[mid]) &#123;\n            right = mid -1;\n        &#125; else &#123;\n            last = mid;\n            left = mid +1;\n        &#125;\n    &#125;\n    return last;\n&#125;69.x的平方根题目\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1：\ntxt输入：x = 4\n输出：2示例 2：\ntxt输入：x = 8\n输出：2\n解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。思路\nx设为right，通过二分法查找值，mid*mid &#x3D; x时则表示找到。为了防止溢出这里不能用 mid*mid&#x3D;x应该用 x&#x2F;mid&#x3D;mid。\n代码实现\njavapublic int mySqrt(int x) &#123;\n    if(x == 0 || x == 1)&#123;\n        return x;\n    &#125;\n    int left = 0;\n    int right = x;\n    while(left &lt;= right) &#123;\n        int mid = (left + right) / 2;\n        if(x/mid == mid) &#123;\n            return mid;\n        &#125;\n        if(x/mid &lt; mid) &#123;\n            right = mid - 1;\n        &#125; else if(x/mid &gt; mid) &#123;\n            left = mid + 1;\n        &#125;\n    &#125;\n    return right;\n&#125;367.有效的完全平方数题目\n给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。\n完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n不能使用任何内置的库函数，如 sqrt 。\n示例 1：\ntxt输入：num = 16\n输出：true\n解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。示例 2：\ntxt输入：num = 14\n输出：false\n解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。思路\n设置一个临时变量t存储num&#x2F;mid的值，再借此判断t与mid的关系。如果此时t &#x3D;&#x3D; mid，还要再判断余数，若余数为0则满足是完全平方数。\n代码实现\njavapublic boolean isPerfectSquare(int num) &#123;\n    int low = 1;\n    int high = num;\n    while (low &lt;= high) &#123;\n        int mid = low + (high-low)/2;\n        int t = num/mid; //求完全平方数\n        if(t == mid) &#123;\n            return num % mid == 0;\n        &#125; else if (t &lt; mid) &#123;\n            high = mid - 1;\n        &#125; else &#123;\n            low = mid + 1;\n        &#125;\n    &#125;\n    return  false;\n&#125;\n移除元素题目\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1：\ntxt输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。示例 2：\ntxt输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,3,0,4]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。双指针法双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。\n定义快慢指针\n\n快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组\n慢指针：指向更新 新数组下标的位置\n\n删除过程如下\n\n代码实现\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n设置快慢指针，快指针从头开始遍历数组，将符合条件的筛选出来。例如本题val=3的话，将val!=3的数据加入到数组中，在本题中就利用慢指针开始覆盖掉原数组内容，快指针遍历数组并进行筛选。\njavapublic int removeElement(int[] nums, int val) &#123;\n    int slowIndex = 0;\n    for (int flastIndex = 0; flastIndex &lt; nums.length; flastIndex++) &#123;\n        if(nums[flastIndex] != val) &#123;\n            nums[slowIndex++] = nums[flastIndex];\n        &#125;\n    &#125;\n    return slowIndex;\n&#125;相关题目练习\n26.删除排序数组中的重复项\n283.移动零\n844.比较含退格的字符串\n977.有序数组的平方\n\n26.删除有序数组中的重复项题目\n给你一个 非严格递增排列 的数组 nums ，请你  原地   删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。\n返回 k 。\n\n示例 1：\ntxt输入：nums = [1,1,2]\n输出：2, nums = [1,2,_]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。示例 2：\ntxt输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。思路\n设置双指针，lowindex和highindex都从0开始。highindex遍历数组，lowindex记录数据序号，当highindex查询到与当前lowindex所在位置数据相同时，跳过当前循环。如果查询到新数据，先将lowindex向后移一位，再把当前新数据存储到nums数组中，返回结果时注意lowindex+1。\njavapublic int removeDuplicates(int[] nums) &#123;\n    int lowindex = 0;\n    for (int highindex = 0; highindex &lt; nums.length; highindex++) &#123;\n        if(nums[highindex] == nums[lowindex]) &#123;\n            continue;\n        &#125;\n        nums[++lowindex] = nums[highindex];\n    &#125;\n    return ++lowindex;\n&#125;283.移动零题目\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\ntxt输入: nums = [0,1,0,3,12]\n输出: [1,3,12,0,0]示例 2:\ntxt输入: nums = [0]\n输出: [0]思路\n解法一：\n两次遍历创建两个指针i和j，i指针负责记录有多少个非0元素，i指针从头遍历数组，j指针负责找到非0的值，当找到非0元素直接赋值给i指针所在位置，i指针指向下一个。当j指针遍历到数组尾部时，i指针指向的下标就是最后一个非0元素的后一个位置。\n演示\nb从头遍历，当a指针找到非0的数据，直接覆盖掉b所在位置。然后b++，指向下一位，a指针找到非0的值直接覆盖。当a指针遍历完数组后，从b指针开始给数组其他位赋值0。\n\njavapublic void moveZeroes(int[] nums) &#123;\n    int lowindex = 0;\n    for (int highindex = 0; highindex &lt; nums.length; highindex++) &#123;\n        //highindex不为0直接赋值给lowindex，并且l递增\n        if(nums[highindex] != 0) &#123;\n            nums[lowindex++] = nums[highindex];\n        &#125;\n    &#125;\n    //当highindex遍历完数组时，应该为后面的填0\n    for (int i = lowindex; i &lt; nums.length; i++) &#123;\n        nums[i] = 0;\n    &#125;\n&#125;解法二：\n​\t这里参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点 x，然后把所有小于等于 x 的元素放到 x 的左边，大于 x 的元素放到其右边。这里我们可以用 0 当做这个中间点，把不等于 0(注意题目没说不能有负数)的放到中间点的左边，等于 0 的放到其右边。这的中间点就是 0 本身，所以实现起来比快速排序简单很多，我们使用两个指针 i 和 j，只要 nums[i]!=0，我们就交换 nums[i] 和 nums[j]，并且让i指针指向下一个数据。\n演示\na，b指针都从0开始遍历数组，b指针从头遍历，a指针找非0数据，当找到非0数据就与b交换，并且b++。\n\njavapublic void moveZeroes(int[] nums) &#123;\n    int left = 0;\n    int temp;\n    for (int right = 0; right &lt; nums.length; right++) &#123;\n        if(nums[right] != 0) &#123;\n            temp = nums[right];\n            nums[right] = nums[left];\n            nums[left++] = temp;\n            //left++;\n        &#125;\n    &#125;\n&#125;844.比较含退格的字符串题目\n给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n注意：如果对空文本输入退格字符，文本继续为空。\n示例 1：\ntxt输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;\n输出：true\n解释：s 和 t 都会变成 &quot;ac&quot;。示例 2：\ntxt输入：s = &quot;ab##&quot;, t = &quot;c#d#&quot;\n输出：true\n解释：s 和 t 都会变成 &quot;&quot;。示例 3：\ntxt输入：s = &quot;a#c&quot;, t = &quot;b&quot;\n输出：false\n解释：s 会变成 &quot;c&quot;，但 t 仍然是 &quot;b&quot;。思路\n由于#号会消除左边的一个字符，所以对右边字符无影响，所以我们选择从后往前遍历S，T字符串。\n步骤解析\n1、准备两个指针i,j分别指向 S，T 的末位字符，再准备两个变量skipS，skipT来分别存放 S，T 字符串中的 # 数量。\n2、从后往前遍历S，所遇到的情况有三个。\n\n2.1 若当前字符是#，则skipS自增1；\n2.2 若当前字符不是#，且skipS不为0，则skipS自减1；\n2.3 若当前字符不是#，且skipS为0，则代表当前字符不会被消除，这时我们就需要和T中的当前字符作比较。\n\n3、从后往前遍历T和2相同。\n4、若对比出现S、T当前字符不匹配，则遍历结束，返回false，若S、T都遍历结束，且都能一一匹配，则返回true。\njavapublic boolean backspaceCompare(String s, String t) &#123;\n    //设置两个指针位置，定义skip*为#个数\n    int i = s.length() - 1, j = t.length() - 1;\n    int skipS = 0,skipT = 0;\n    while (i &gt;= 0 || j &gt;= 0) &#123;\n        //该while循环找s字符串右边不被消除的字符\n        while (i &gt;= 0) &#123;\n            if (s.charAt(i) == &#39;#&#39;) &#123;\n                skipS++;\n                i--;\n            &#125; else if (skipS &gt; 0) &#123;\n                skipS--;\n                i--;\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n        //该while循环找t字符串右边不被消除的字符\n        while (j &gt;= 0) &#123;\n            if (t.charAt(j) == &#39;#&#39;) &#123;\n                skipT++;\n                j--;\n            &#125; else if (skipT &gt; 0) &#123;\n                skipT--;\n                j--;\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n        //如果i和j没越界，就看i，j指向的值是否相等\n        if(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;\n            //匹配当前最后一个字符\n            if(s.charAt(i) != t.charAt(j)) &#123;\n                return false;\n            &#125;\n        &#125;\n        //此时表示i或者j有一个或者两个越界了\n        //比如i找不到下一位了，但j下一位还有字符需要匹配，这时就说明两个数组不相等\n        else &#123;\n            if(i &gt;= 0 || j &gt;= 0) &#123;\n                return false;\n            &#125;\n        &#125;\n        i--;j--;\n    &#125;\n    return true;\n&#125;977.有序数组的平方题目\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1：\ntxt输入：nums = [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]示例 2：\ntxt输入：nums = [-7,-3,2,3,11]\n输出：[4,9,9,49,121]思路\n设置一个新数组res存放数据，设置left，right分别指向数组头和尾。\n因为是非递减顺序，因此判断数组最左边left和最右边right的平方值的大小。如果left^2比right^2大，则把left的平方值赋值给新数组的尾部，然后尾部索引减一，再重复上诉操作。因为是非递减顺序，此处判断头尾大小可以nums[left] + nums[rigth] &lt; 0。\njavaint i = nums.length;\nint left = 0;\nint right = i - 1;\nint[] res = new int[i];\nwhile (left &lt;= right) &#123;\n    i--;\n    if(nums[left] + nums[right] &lt; 0) &#123;\n        res[i] = nums[left]*nums[left];\n        left++;\n    &#125; else &#123;\n        res[i] = nums[right]*nums[right];\n        right--;\n    &#125;\n&#125;\nreturn res;\n长度最小的子数组题目\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n示例 1：\ntxt输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。示例 2：\ntxt输入：target = 4, nums = [1,4,4]\n输出：1示例 3：\ntxt输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0滑动窗口所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。\n首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。\n在本题中实现滑动窗口，主要确定如下三点：\n\n窗口内是什么？\n如何移动窗口的起始位置？\n如何移动窗口的结束位置？\n\n窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。\n窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。\n\t\n思路\n​\t利用滑动窗口解决问题，索引应为滑动窗口的终止位置，而不是起始位置（起始位置的话，就跟暴力解法双重for循环性质一样了）。如果当前窗口所有的值大于target，则计算当前窗口长度subL = right - left + 1，比较subL和result的值取最小的作为result返回值。sum的值减去滑动窗口的起始位置的值，并且移动窗口的起始位置，重复上诉操作。\n代码实现\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\njavapublic int minSubArrayLen(int target, int[] nums) &#123;\n    int result = Integer.MAX_VALUE;\n    int sum = 0;\n    int left = 0; //滑动窗口起始位置\n    for (int right = 0; right &lt; nums.length; right++) &#123;\n        sum += nums[right];\n        //当集合的总和大于target的时候，缩减集合起始位置\n        while (sum &gt;= target) &#123;\n            //计算当前窗口长度\n            int subL = right - left + 1;\n            //result取当前最小长度\n            result = Math.min(result, subL);\n            sum -= nums[left];\n            left++; //移动初始位置\n        &#125;\n    &#125;\n    return result == Integer.MAX_VALUE ? 0 : result;\n&#125;相关题目练习904. 水果成篮 - 力扣（LeetCode）\n76. 最小覆盖子串 - 力扣（LeetCode）\n904.水果成蓝题目\n你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。\n你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。\n一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。\n\n给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例 1：\ntxt输入：fruits = [1,2,1]\n输出：3\n解释：可以采摘全部 3 棵树。示例 2：\ntxt输入：fruits = [0,1,2,2]\n输出：3\n解释：可以采摘 [1,2,2] 这三棵树。\n如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。示例 3：\ntxt输入：fruits = [1,2,3,2,2]\n输出：4\n解释：可以采摘 [2,3,2,2] 这四棵树。\n如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。示例 4：\ntxt输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]\n输出：5\n解释：可以采摘 [1,2,1,1,2] 这五棵树。思路\n​\t用HashMap存储水果树，key表示水果类型，values表示对应的个数，right是窗口的终止位置，left作为窗口的起始位置，当HashMap长度超过2个时，则说明三个类型的水果，使用while循环缩小窗口，移动left的位置。每次记录当前窗口大小，和之前记录的最大窗口进行比较。\n代码实现\njavapublic int totalFruit(int[] fruits) &#123;\n    int n = fruits.length;\n    //定义map存储水果，key为水果类型，value为水果个数\n    Map&lt;Integer, Integer&gt; countMap = new HashMap&lt;&gt;();\n    int left = 0, maxFruits = 0;\n    for (int right = 0; right &lt; n; ++right) &#123;\n        // 将当前水果添加到窗口中，如果没有则默认为0个\n        countMap.put(fruits[right], countMap.getOrDefault(fruits[right], 0) + 1);\n        // 如果窗口中水果类型超过两种，进入while循环，移动左边界缩小窗口\n        while (countMap.size() &gt; 2) &#123;\n            countMap.put(fruits[left], countMap.get(fruits[left]) - 1);\n            // 如果水果数量为0，从窗口中移除该水果类型\n            if (countMap.get(fruits[left]) == 0) &#123;\n                countMap.remove(fruits[left]);\n            &#125;\n            // 移动左边界\n            ++left;\n        &#125;\n        // 更新最大水果数量 窗口大小和最大值比较\n        maxFruits = Math.max(maxFruits, right - left + 1);\n    &#125;\n    return maxFruits;\n&#125;76.最小覆盖子串题目\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。\n示例 1：\ntxt输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n输出：&quot;BANC&quot;\n解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#39;A&#39;、&#39;B&#39; 和 &#39;C&#39;。示例 2：\ntxt输入：s = &quot;a&quot;, t = &quot;a&quot;\n输出：&quot;a&quot;\n解释：整个字符串 s 是最小覆盖子串。示例 3:\ntxt输入: s = &quot;a&quot;, t = &quot;aa&quot;\n输出: &quot;&quot;\n解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。思路\n​\t建立两个HashMap分别存储字符串t和s的内容，key表示字符，values表示字符数量。首先遍历目标字符串t，将每个字符及其出现的次数存入ori中，设置窗口左右边界，ansL和ansR分别存储最小覆盖子串的起始和终止位置，len为窗口长度。遍历s字符串添加到cnt中，然后判断ori中所有字符的个数是否小于cnt中的个数，如果合法，比较窗口大小，若更小则更新，继续缩减窗口。若左指针指向的字符存在ori中，则在cnt中减少其出现次数，如果是普通字符就只需要缩减窗口。\n代码实现\njava//建立两个HashMap，ori用于存储目标字符串t中每个字符的出现次数\n//cnt用于存储当前窗口中每个字符的出现次数。\nMap&lt;Character, Integer&gt; ori = new HashMap&lt;Character, Integer&gt;();\nMap&lt;Character, Integer&gt; cnt = new HashMap&lt;Character, Integer&gt;();\n\npublic String minWindow(String s, String t) &#123;\n\n    int tLen = t.length();\n\n    //遍历目标字符串t，将每个字符及其出现次数存入ori中\n    for (int i = 0; i &lt; tLen; i++) &#123;\n        char c = t.charAt(i);\n        ori.put(c, ori.getOrDefault(c, 0) + 1);\n    &#125;\n\n    int l = 0, r = -1;//l窗口左边界，r窗口右边界\n    //ansL和ansR用于存储最小覆盖子串的起始位置和结束位置。\n    int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;\n    //s串长度\n    int sLen = s.length();\n    //开始遍历\n    while (r &lt; sLen) &#123;\n        ++r;\n        //遍历原字符串s，右指针r向右移动。若r未越界且当前字符存在于ori中，则将其添加至cnt中并增加其出现次数。\n        if (r &lt; sLen &amp;&amp; ori.containsKey(s.charAt(r))) &#123;\n            //存放窗口内不同目标字符的数量\n            cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);\n        &#125;\n        //判定是否合法\n        while (check() &amp;&amp; l &lt;= r) &#123;\n            //比较窗口大小,如果你后面符合的窗口都比我现在大，就没必要更新了，继续缩短窗口\n            if (r - l + 1 &lt; len) &#123;\n                len = r - l + 1;//更新为窗口大小\n                ansL = l; //符合的左边边界下标就是窗口的左边界\n                ansR = l + len; //符合的右边边界下标\n            &#125;\n            //若左指针指向的字符存在于ori中，则在cnt中减少其出现次数。（因为现在要开始向后移动窗口的左边界）\n            //如果是普通字符就只是简单的移动指针就叫可以了，如果是目标字符，就要减少窗口这个字符的数量\n            if (ori.containsKey(s.charAt(l))) &#123;\n                cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);\n            &#125;\n            //窗口左边界向后移动，缩小窗口\n            ++l;\n        &#125;\n    &#125;\n    //返回最小覆盖子串，若ansL为-1，则说明不存在，返回空串。否则，返回s中从ansL到ansR的子串\n    return ansL == -1 ? &quot;&quot; : s.substring(ansL, ansR);\n&#125;\n\n//判断当前窗口是否包含了目标字符串t的所有字符。(种类和数量都要匹配)\npublic boolean check() &#123;\n\n    //map迭代器\n    Iterator iter = ori.entrySet().iterator();\n    //如果map有元素（就是t字符串的各个字符和它的数量）\n    while (iter.hasNext()) &#123;\n        Map.Entry entry = (Map.Entry) iter.next();\n        //拿到每个key，即字符\n        Character key = (Character) entry.getKey();\n        //拿到每个value，即字符数量\n        Integer val = (Integer) entry.getValue();\n        //如果窗口内的每个字符和它的数量，只要有一个比目标字符串中的字符少，当前窗口肯定不符合了\n        if (cnt.getOrDefault(key, 0) &lt; val) &#123;\n            return false;\n        &#125;\n    &#125;\n    //符合\n    return true;\n&#125;总结滑动窗口最小滑窗模板：给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最小长度。\njavawhile j &lt; len(nums):\n    判断[i, j]是否满足条件\n    while 满足条件：\n        不断更新结果(注意在while内更新！)\n        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）\n    j += 1最大滑窗模板：给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最大长度。\njavawhile j &lt; len(nums):\n    判断[i, j]是否满足条件\n    while 不满足条件：\n        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）\n    不断更新结果（注意在while外更新！）\n    j += 1是的，关键的区别在于，最大滑窗是在迭代右移右边界的过程中更新结果，而最小滑窗是在迭代右移左边界的过程中更新结果。\n\n螺旋矩阵题目\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例 1：\n\ntxt输入：n = 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]示例 2：\ntxt输入：n = 1\n输出：[[1]]思路\n本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。\n求解本题依然是要坚持循环不变量原则。\n模拟顺时针画矩阵的过程:\n\n填充上行从左到右\n填充右列从上到下\n填充下行从右到左\n填充左列从下到上\n\n由外向内一圈一圈这么画下去。每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。\n\n\n1、计算要循环的圈数circle = n / 2，偶数则刚好，如果是奇数则还会多一个，在遍历完后再赋值。\n2、记录每一圈开始的位置startX，startY分别表示每一圈起始的x和y坐标。注意每遍历完一圈++。\n3、设置num从1开始计数，给数组赋值。\n4、注意设置每一圈的边界offset。该题应用的是左闭右开。\n\n①根据序号1的方向，应该是从startY开始，n - offset结束。(行不动，给列赋值 -&gt; j变化)\n②根据序号2的方向，应该是从startX开始，n - offset结束。(列不动，给行赋值 -&gt; i变化)\n③根据序号3的方向，应该是从序号①记录的位置j开始，到startX结束。\n④根据序号4的方向，应该是从序号②记录的位置i开始，到startY结束。\n\n举例：\n\n①从左往右 y变化for (j = startY; j &lt; n - offset; j++)\n②从上往下 x变化for (i = startX; i &lt; n - offset; i++)\n③从右往左 y变化for ( ; j &gt; startX; j--)\n④从下往上 x变化for ( ; i &gt; startY; i--)\n\n5、注意给奇数表n % 2 != 0的最后一位赋值。\n代码实现\n\n时间复杂度 O(n^2): 模拟遍历二维矩阵的时间\n空间复杂度 O(1)\n\njavapublic int[][] generateMatrix(int n) &#123;\n    int[][] res = new int[n][n];\n    //记录每一圈开始的位置\n    int startX = 0,startY = 0;\n    //从1开始计数\n    int num = 1;\n    //需要控制每一条边遍历的长度，每次循环右边界收缩一位\n    int offset = 1;\n    int circle = n / 2;\n    //遍历的圈数，例如3遍历1圈，4遍历2圈\n    while (circle &gt; 0) &#123;\n        int i,j;\n        //1. 从左往右 y变化 例如: 3的话，边界为2\n        for (j = startY; j &lt; n - offset; j++) &#123;\n            res[startX][j] = num++;\n        &#125;\n        //遍历完1时，j的值为2\n        //2. 从上往下 x变化\n        for (i = startX; i &lt; n - offset; i++) &#123;\n            res[i][j] = num++;\n        &#125;\n        //3. 从右往左 y变化\n        //此时i = 2, j = 2 此刻变化j\n        for ( ; j &gt; startX; j--) &#123;\n            res[i][j] = num++;\n        &#125;\n        //4. 从下往上 x变化\n        //j = 0\n        //i = 2\n        for ( ; i &gt; startY; i--) &#123;\n            res[i][j] = num++;\n        &#125;\n        //圈数缩小，同时调整每圈的起始位置。每层边界+1\n        circle--;startX++;startY++;offset++;\n    &#125;\n    //如果是奇数的话，在最后一个位置填上数字\n    if(n % 2 != 0) &#123;\n        res[startX][startY] = num;\n    &#125;\n    return res;\n&#125;相关题目练习\n54.螺旋矩阵(opens new window)\n剑指Offer 29.顺时针打印矩阵\n\n54.螺旋矩阵题目\n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n示例 1：\n\ntxt输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]示例 2：\n\ntxt输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]思路\n\n初始化：\n初始化一个空的 ArrayList 用于存储结果。\n检查输入矩阵是否为空，如果为空则直接返回空的结果列表。\n获取矩阵的行数 lengthX 和列数 lengthY。\n初始化四个边界变量，分别表示当前遍历的范围。\n\n\n顺时针遍历：\n使用 while 循环，循环条件为 startX &lt;= endX &amp;&amp; startY &lt;= endY，即确保还有元素需要遍历。\n从左到右：遍历当前行的元素，并将其加入结果列表，同时更新 startX++。（最上面一行已经遍历过了，将开始行往下移）\n从上到下：遍历当前列的元素（除去已经遍历过的首元素），将其加入结果列表，同时更新 endY--。（最右边已经遍历过了，将最后列往前移）\n从右到左：在当前行中遍历元素（除去已经遍历过的末元素），将其加入结果列表，同时更新 endX--。（最下面已经遍历过了，将最后行往前移）\n从下到上：在当前列中遍历元素（除去已经遍历过的首元素），将其加入结果列表，同时更新 startY++。（最左边已经遍历过了，将开始列往后移）\n\n\n返回结果：\n返回存储了顺时针螺旋顺序遍历结果的列表。\n\n\n\n\n代码实现\njavapublic List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;\n    //返回的list\n    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    if(matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;\n        return list;\n    &#125;\n    //得到数组的行数和列数\n    int lengthX = matrix.length;\n    int lengthY = matrix[0].length;\n    //得到整个数组的边界\n    int startX = 0, endX = lengthX - 1;\n    int startY = 0, endY = lengthY - 1;\n    while (startX &lt;= endX &amp;&amp; startY &lt;= endY) &#123;\n        //1. 从左往右遍历 当遍历完后应当缩小开始行\n        for (int j = startY; j &lt;= endY ; j++) &#123;\n            list.add(matrix[startX][j]);\n        &#125;\n        startX++;\n        //2. 从上往下遍历 缩小最右边的边界\n        for (int i = startX; i &lt;= endX ; i++) &#123;\n            list.add(matrix[i][endY]);\n        &#125;\n        endY--;\n        //3. 从右往左遍历 缩小最下面的边界\n        if (startX &lt;= endX) &#123;\n            for (int j = endY; j &gt;= startY ; j--) &#123;\n                list.add(matrix[endX][j]);\n            &#125;\n            endX--;\n        &#125;\n        //4. 从下往上\n        if (startY &lt;= endY) &#123;\n            for (int i = endX; i &gt;= startX ; i--) &#123;\n                list.add(matrix[i][startY]);\n            &#125;\n            startY++;\n        &#125;\n    &#125;\n    return list;\n&#125;LCR 146. 螺旋遍历二维数组该题和54一模一样。\n\n数组总结二分法\n暴力解法时间复杂度：O(n)\n二分法时间复杂度：O(logn)\n\n在这道题目中讲到了循环不变量原则，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。\n二分法是算法面试中的常考题。\n#双指针法双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n\n暴力解法时间复杂度：O(n^2)\n双指针时间复杂度：O(n)\n\n数组中的元素为什么不能删除，主要是因为以下两点：\n\n数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。\nC++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。\n\n双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。\n#滑动窗口介绍了数组操作中的另一个重要思想：滑动窗口。\n\n暴力解法时间复杂度：O(n^2)\n滑动窗口时间复杂度：O(n)\n\n本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。\n如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。\n#模拟行为模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察对代码的掌控能力。\n在这道题目中，再一次介绍到了循环不变量原则，其实这也是写程序中的重要原则。\n总结\n\n","slug":"算法-数组","date":"2023-11-28T13:34:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"白"},{"id":"ccce3fa211299e936fe89e1eb7d7281f","title":"JDK8-17新特性","content":"JDK8-17新特性目录\n\n如何学习新特性\n\nJava8新特性简介\n\n\nLambda表达式Lambda表达式的使用举例(o1, o2) -&gt; Integer.compare(o1, o2);\njavapublic void test2() &#123;\n    Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() &#123;\n        @Override\n        public int compare(Integer o1, Integer o2) &#123;\n            return Integer.compare(o1, o2);\n        &#125;\n    &#125;;\n    int compare1 = com1.compare(12,21);\n    System.out.println(compare1);\n    //Lambda表达式的写法\n    System.out.println(&quot;===Lambda表达式的写法===&quot;);\n    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2);\n    int compare2 = com2.compare(23,21);\n    System.out.println(compare2);\n&#125;Lambda表达式的格式举例Lambda形参列表 -&gt; lambda体\nLambda表达式的格式-&gt; :\tlambda操作符或箭头操作符\n-&gt;的左边:\tlambda形参列表，对应着重写的接口中的抽象方法的形参列表。前提是参数顺序一致。\n-&gt;的右边:\tlambda体，对应着接口的实现类要重写的方法的方法体。\n六种语法格式举例：使用lambda表达式和不使用的对比\njavapublic void test1() &#123;\n    Runnable r1 = new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;你好&quot;);\n        &#125;\n    &#125;;\n    r1.run();\n    System.out.println(&quot;====&quot;);\n    Runnable r2 = () -&gt; &#123;\n            System.out.println(&quot;你好&quot;);\n    &#125;;\n    r2.run();\n&#125;语法格式一：无参，无返回值。\njavaRunnable r2 = () -&gt; &#123;\n            System.out.println(&quot;你好&quot;);\n&#125;;\nr2.run();语法格式二：lambda需要一个参数，但是没有返回值。\njavaConsumer&lt;String&gt; con1 = (String s) -&gt; &#123;\n    System.out.println(s);\n&#125;;\ncon1.accept(&quot;&quot;);语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型判断”。\n1、数据类型可省略(对比语法格式二)\njavaConsumer&lt;String&gt; con2 = (s) -&gt; &#123;\n    System.out.println(s);\n&#125;;\ncon2.accept(&quot;&quot;);2、类型推断\njavapublic void test3_1() &#123;\n    //int[] arr = new int[]&#123;1,2,3,4&#125;;\n    int[] arr = &#123;1,2,3,4&#125;;  //类型推断\n    HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); //类型推断\n    //Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();\n    var entries = map.entrySet(); //类型推断，在jdk10及之后可以使用\n&#125;语法格式四：lambda若只需要一个参数时，参数的小括号可以省略。\n（对比语法格式三）\njavapublic void test4() &#123;\n    Consumer&lt;String&gt; con2 = s -&gt; &#123;\n        System.out.println(s);\n    &#125;;\n    System.out.println(&quot;世界那么大，我想去看看&quot;);\n&#125;语法格式五：lambda需要两个或以上的参数，多条执行语句，并且可以有返回值。\njavapublic void test5() &#123;\n    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;\n        System.out.println(o1);\n        System.out.println(o2);\n        return o1.compareTo(o2);\n    &#125;;\n    System.out.println(com2.compare(12,21));\n&#125;语法格式六：当lambda体只有一条语句时，return与大括号若有，都可以省略。\njavapublic void test6() &#123;\n    Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;\n        return o1.compareTo(o2);\n    &#125;;\n    System.out.println(com1.compare(12,6));\n    System.out.println(&quot;===lambda表达式===&quot;);\n    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);\n    System.out.println(com2.compare(12,6));\n&#125;Lambda表达式的本质一方面:\tlambda表达式作为接口的实现类的对象。\n另一方法：\tlambda表达式是一个匿名函数。\n体现了–&gt; “万事万物皆对象”\n函数式接口1、什么是函数式接口？为什么需要函数式接口？如果接口中只声明有一个抽象方法，则此接口就成为函数式接口。\n因为只有给函数式接口提供实现类的对象时，我们才可以使用lambda表达式。\n2、api中函数式接口所在的包jdk8中声明的函数式接口都在java.util.function包下。\n3、4个基本的函数式接口\n\n\n函数式接口\n称谓\n参数类型\n用途\n\n\n\nConsumer&lt;T&gt;\n消费型接口\nT\n对类型为T的对象应用操作，包含方法：void accept(T t)\n\n\nSupplier&lt;T&gt;\n供给型接口\n无\n返回类型为T的对象，包含方法：T get( )\n\n\nFunction&lt;T, R&gt;\n函数型接口\nT\n对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R accept(T t)\n\n\nPredicate&lt;T&gt;\n判断型接口\nT\n确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：boolean test(T t)\n\n\nLambda表达式的语法规则总结-&gt;的左边：lambda形参列表，参数的类型都可以省略。如果形参只有一个，则一对( )也可以省略。\n-&gt;的右边：lambda体，对应着重写的方法的方法体。如果方法体种只有一行执行语句，则一堆{ }可以省略。如果有return关键字，则必须一并省略。\n\n方法引用方法引用举例javaComparator&lt;Integer&gt; com3 = Integer :: compare方法引用的理解1、方法引用，可以看做是基于lambda表达式的进一步刻画。（没有lambda表达式就没有方法引用）\n2、当需要提供一个函数式接口的实例时，我们可以使用lambda表达式提供此实例。\n3、当满足一定条件的情况下，我们还可以使用方法引用或构造器引用替换lambda表达式\n方法引用的本质方法引用作为了函数式接口的实例。 –&gt; “万事万物皆对象”\n方法引用的格式格式：类(或对象) :: 方法名\n举例演示①不用lambda表达式（匿名类）②使用lambda表达式③使用方法引用\njavapublic void test1() &#123;\n    //1. 常规匿名类\n    Consumer&lt;String&gt; con1 = new Consumer&lt;String&gt;() &#123;\n        @Override\n        public void accept(String s) &#123;\n            System.out.println(s);\n        &#125;\n    &#125;;\n    con1.accept(&quot;hello&quot;);\n    //2. lambda表达式\n    Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);\n    con2.accept(&quot;hello&quot;);\n    //3. 方法引用\n    Consumer&lt;String&gt; con3 = System.out::println;\n    con3.accept(&quot;hello&quot;);\n&#125;输出结果\ntxthello\nhello\nhello情况1：对象 :: 实例方法 (非)静态方法要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同（或一致-满足多态场景，如自动装箱和自动拆箱）。此时，可以考虑使用方法b实现对方法a的替换、覆盖。此替换或覆盖即为方法引用。\n注意：此方法b是非静态方法，需要对象调用。\n举例：匿名方法返回值类型String和actor.getName的返回值类型是一样的，而且都是无参的方法。因此可写成 actor::getName( )。\njavapublic void test2() &#123;\n    Actor actor = new Actor(1001, &quot;运动员&quot;);\n    //1. 常规匿名类\n    Supplier&lt;String&gt; sup1 = new Supplier&lt;String&gt;() &#123;\n        @Override\n        public String get() &#123;\n            return actor.getName();\n        &#125;\n    &#125;;\n    System.out.println(sup1.get());\n    //2. lambda表达式\n    Supplier&lt;String&gt; sup2 = () -&gt; actor.getName();\n    System.out.println(sup2.get());\n    //3. 方法引用\n    Supplier&lt;String&gt; sup3 = actor::getName();\n    System.out.println(sup3.get());\n&#125;情况2：类 :: 静态方法要求：函数式接口中的抽象方法a与其内部实现时调用的类的某个方法b的形参列表和返回值类型都相同（或一致）。此时，可以考虑使用方法b实现对方法a的替换、覆盖。此替换或覆盖即为方法引用。\n注意：此方法b是静态方法，需要类调用。\njavapublic void test3() &#123;\n    //1. 常规匿名类\n    Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() &#123;\n        @Override\n        public int compare(Integer o1, Integer o2) &#123;\n            return Integer.compare(o1, o2);\n        &#125;\n    &#125;;\n    System.out.println(com1.compare(12, 21));\n    //2. lambda表达式\n    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2);\n    System.out.println(com2.compare(21, 34));\n    //3. 方法引用 类::静态方法\n    Comparator&lt;Integer&gt; com3 = Integer::compare;\n    System.out.println(com3.compare(34, 34));;\n&#125;情况3：类 :: 实例方法要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的返回值类型相同。同时，抽象方法a中有n个参数，方法b中有n-1个参数，且抽象方法a的第1个参数作为方法b的调用者，且抽象方法a的后n-1个参数与方法b的n-1个参数的类型相同（或一致）。则可以考虑使用方法b实现对方法a的替换、覆盖。此替换或覆盖即为方法引用。\n注意：此方法b是非静态的方法，需要对象调用。但是形式上，写出对象a所属的类。\njavapublic void test4() &#123;\n    //1. 常规匿名类\n    Comparator&lt;String&gt; com1 = new Comparator&lt;String&gt;() &#123;\n        @Override\n        public int compare(String o1, String o2) &#123;\n            return o1.compareTo(o2);\n        &#125;\n    &#125;;\n    System.out.println(com1.compare(&quot;abc&quot;, &quot;abd&quot;));\n    //2. lambda表达式\n    Comparator&lt;String&gt; com2 = (s1, s2) -&gt; s1.compareTo(s2);\n    System.out.println(com2.compare(&quot;abc&quot;, &quot;abb&quot;));\n    //3. 方法引用\n    Comparator&lt;String&gt; com3 = String::compareTo;\n    System.out.println(com3.compare(&quot;abc&quot;, &quot;abb&quot;));\n&#125;构造器引用、数组引用构造器引用构造器引用格式类名 :: new\n构造器引用说明1、调用了类名对应的类中的某一个确定的构造器\n2、具体调用的是类中的哪一个构造器取决于函数式接口的抽象方法的形参列表！\n构造器引用举例调用的是Employee类中空参的构造器\njavapublic void test1()&#123;\n    //1. 常规匿名类\n    Supplier&lt;Employee&gt; sup1 = new Supplier&lt;Employee&gt;() &#123;\n        @Override\n        public Employee get() &#123;\n            return new Employee;\n        &#125;\n    &#125;;\n    System.out.println(sup1.get());\n    //2. 构造器引用 调用的是Employee类中空参的构造器\n    Supplier&lt;Exception&gt; sup2 = Employee::new;\n&#125;调用的是Employee类中参数是Integer&#x2F;int类型的构造器\njavapublic void test2()&#123;\n    //1. 常规匿名类\n    Function&lt;Integer, Employee&gt; func1 = new Function&lt;Integer, Employee&gt;() &#123;\n        @Override\n        public Employee apply(Integer id) &#123;\n            return new Employee(id);\n        &#125;\n    &#125;;\n    System.out.println(func1.apply(12));\n    //2. 构造器引用 调用的是Employee类中参数是Integer/int类型的构造器\n    Function&lt;Integer, Employee&gt; func2 = Employee::new;\n&#125;数组引用数组引用格式：数组名[ ] :: new\njavapublic void test4() &#123;\n    //1.\n    Function&lt;Integer, Employee[]&gt; func1 = new Function&lt;Integer, Employee[]&gt;() &#123;\n        @Override\n        public Employee[] apply(Integer integer) &#123;\n            return new Employee[length];\n        &#125;\n    &#125;;\n    System.out.println(func1.apply(10).length);\n    //2.\n    Function&lt;Integer, Employee[]&gt; func2 = Employee[] :: new;\n    System.out.println(func2.apply(20).length);\n&#125;\nStream APIStream API说明![](..&#x2F;images&#x2F;java&#x2F;JDK8-17新特性&#x2F;Stream API说明.png)\n为什么要使用Stream API实际开发中，项目中多数数据源都来自于MySQL，Oracle等，但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。\nStream API vs 集合框架1、Stream API 关注的是多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU的。\n2、集合关注的是数据的存储，面向内存的。\n3、Stream API之于集合，类似于SQL之于数据表的查询。\nStream使用说明1、Stream自己不会存储元素。\n2、Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream。\n3、Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。\n4、Stream一旦执行了终止操作，就不能再调用其他中间操作或终止操作了。\nStream执行流程步骤1：Stream的实例化\n步骤2：一系列的中间操作\n步骤3：执行终止操作\n![](..&#x2F;images&#x2F;java&#x2F;JDK8-17新特性&#x2F;Stream API步骤.png)\nStream的实例化创建Stream方式一：通过集合default Stream&lt;E&gt; stream(): 返回一个顺序流\ndefault Stream&lt;E&gt; parallelStream(): 返回一个并行流\n代码举例\njavapublic void test1() &#123;\n    List&lt;Employee&gt; list = EmployeeData.getEmployees();\n    //default Stream&lt;E&gt; stream(): 返回一个顺序流\n    Stream&lt;Employee&gt; stream = list.stream();\n    //default Stream&lt;E&gt; parallelStream(): 返回一个并行流\n    Stream&lt;Employee&gt; stream1 = list.parallelStream();\n    System.out.println(stream); //打印的是地址\n    System.out.println(stream1);\n&#125;创建Stream方式二：通过数组调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[ ] array)：返回一个流\n代码举例\njavapublic void test2() &#123;\n    //调用Arrays类的static \\&lt;T&gt; Stream\\&lt;T&gt; stream(T[ ] array)：返回一个流\n    Integer[] arr = new Integer[]&#123;1,2,3,4,5&#125;;\n\n    Stream&lt;Integer&gt; stream = Arrays.stream(arr);\n\n    int[] arr1 = new int[]&#123;1,2,3,4,5&#125;;\n    IntStream stream1 = Arrays.stream(arr1);\n    \n&#125;创建Stream方式三：通过Stream的of( )使用Stream的静态方法of( )\n代码举例\t\njavapublic void test3() &#123;\n    Stream&lt;String&gt; stream = Stream.of(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;SS&quot;, &quot;DD&quot;);\n&#125;一系列中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理而在终止操作时一次性全部处理，称为“惰性求值”。\n1、筛选与切片\n\n\n方法\n描述\n\n\n\nfilter(Predicatep)\n接收Lambda，从流中排除某些元素\n\n\ndistinct()\n筛选，通过流所生成元素的hashCode()和equals()去除重复元素\n\n\nlimit(long maxSize)\n截断流，使其元素不超过给定数量\n\n\nskip(long n)\n跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补\n\n\n代码演示\njavapublic void test1() &#123;\n        //1、filter(Predicate p) 接收Lambda，从流中排除某些元素。\n        //练习: 查询员工表中薪资大于7000的员工信息\n        List&lt;Employee&gt; list = EmployeeData.getEmployees();\n        Stream&lt;Employee&gt; stream = list.stream();\n        //Lambda表达式: emp -&gt; emp.getSalary() &gt; 7000\n        //方法引用: System.out::println\n        stream.filter(emp -&gt; emp.getSalary() &gt; 7000).forEach(System.out::println);\n        System.out.println();\n\n        //2、limit(n) 截断流，使其元素不超过给定数量。\n        //错误的执行。因为Stream已经执行了终止操作，就不可以再调用其他的中间操作或终止操作了\n//        stream.limit(2).forEach(System.out::println);\n        list.stream().limit(2).forEach(System.out::println);\n        System.out.println();\n\n        //3、skip(n) 跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。\n        list.stream().skip(5).forEach(System.out::println);\n        System.out.println();\n\n        //4、distinct() 筛选，通过流所生成(重写过)元素的hashCode()和equals()去除重复元素\n        list.stream().distinct().forEach(System.out::println);\n        System.out.println();\n    &#125;2、映射\n\n\n方法\n描述\n\n\n\nmap(Function f)\n接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n\n\nmapToDouble(ToDoubleFunction f)\n接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。\n\n\nmapToInt(ToIntFunction f)\n接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。\n\n\nmapToLong(ToLongFunction f)\n接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。\n\n\nflatMap(Function f)\n接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。\n\n\n代码演示\njavapublic void test2() &#123;\n    //map(Function f) 接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素\n    //练习: 转换成大写\n    List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);\n    //方式1: Lambda表达式\n    list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);\n    //方式2: 方法引用\n    list.stream().map(String::toUpperCase).forEach(System.out::println);\n\n    //获取员工姓名长度大于3的员工(没有用到映射)\n    List&lt;Employee&gt; employees = EmployeeData.getEmployees();\n    employees.stream().filter(emp -&gt; emp.getName().length() &gt; 3).forEach(System.out::println);\n\n    //练习: 获取员工姓名长度大于3的员工的姓名(映射到name)\n    //第一种：先过滤，再映射\n    employees.stream().filter(emp -&gt; emp.getName().length() &gt; 3).map(emp -&gt; emp.getName()).forEach(System.out::println);\n    //第二种：先映射，再过滤 (因为映射完之后只有name这一列，所有lambda表达式变成了name-&gt;name.length()&gt;3)\n    employees.stream().map(emp -&gt; emp.getName()).filter(name -&gt; name.length() &gt; 3).forEach(System.out::println);\n    //第三种：将映射的部分改成方法引用\n    employees.stream().map(Employee::getName).filter(name -&gt; name.length() &gt; 3).forEach(System.out::println);\n&#125;3、排序\n\n\n方法\n描述\n\n\n\nsorted()\n产生一个新流，其中按自然顺序排序\n\n\nsorted(Comparator com)\n产生一个新流，其中按比较器顺序排序\n\n\n代码演示\njavapublic void test3() &#123;\n        //sorted() 自然排序\n        Integer[] arr = new Integer[]&#123;345,3,64,3,46&#125;;\n        String[] arr1 = new String[]&#123;&quot;GG&quot;,&quot;DD&quot;,&quot;MM&quot;,&quot;SS&quot;,&quot;JJ&quot;&#125;;\n\n        Arrays.stream(arr).sorted().forEach(System.out::println);\n        System.out.println(Arrays.toString(arr)); //arr数组并没有因为升序，做调整。\n\n        Arrays.stream(arr1).sorted().forEach(System.out::println);\n        //因为Employee没有实现Comparable接口,所有报错\n//        List&lt;Employee&gt; list = EmployeeData.getEmployees();\n//        list.stream().sorted().forEach(System.out::println);\n\n        //sorted(Comparator com) 定制排序\n        List&lt;Employee&gt; list = EmployeeData.getEmployees();\n        list.stream().sorted((e1,e2) -&gt; e1.getSalary() - e2.getSalary()).forEach(System.out::println);\n\n        //针对字符串从大小排列\n        Arrays.stream(arr1).sorted((s1,s2) -&gt; s1.compareTo(s2)).forEach(System.out::println);\n        Arrays.stream(arr1).sorted(String::compareTo).forEach(System.out::println);\n    &#125;终止操作1、终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void。\n2、流进行了终止操作后，不能再次使用。\n1、匹配与查找\n\n\n方法\n描述\n\n\n\nallMatch(Predicate p)\n检查是否匹配所有元素\n\n\nanyMatch(Predicate p)\n检查是否至少匹配一个元素\n\n\nnoneMatch(Predicate p)\n检查是否没有匹配所有元素\n\n\nfindFirst()\n返回第一个元素\n\n\nfindAny()\n返回当前流中的任意元素\n\n\ncount()\n返回流中元素总数\n\n\nmax(Comparator c)\n返回流中最大值\n\n\nmin(Comparator c)\n返回流中最小值\n\n\nforEach(Consumer c)\n内部迭代(使用 Collection接口需要用户去做迭代，称为外部迭代。相反，Stream API使用内部迭代–它帮你把迭代做了)\n\n\n代码演示\njava//匹配与查找\npublic void test1() &#123;\n    //allMatch(Predicate p) 检查是否匹配所有元素\n    //练习：是否所有员工的年龄都大于18\n    List&lt;Employee&gt; list = EmployeeData.getEmployees();\n    System.out.println(list.stream().allMatch(emp -&gt; emp.getAge() &gt; 18));\n\n    //anyMatch(Predicate p) 检查是否至少匹配一个元素\n    //练习：是否存在年龄大于18岁的员工\n    System.out.println(list.stream().anyMatch(emp -&gt; emp.getAge() &gt; 18));\n    //练习：是否存在员工的工资大于10000\n    System.out.println(list.stream().anyMatch(emp -&gt; emp.getSalary() &gt; 10000));\n\n    //findFirst 返回第一个元素\n    System.out.println(list.stream().findFirst().get());\n\n    //count 返回流中工资大于7000元素的总个数\n    List&lt;Employee&gt; list1 = EmployeeData.getEmployees();\n    System.out.println(list.stream().filter(emp -&gt; emp.getSalary() &gt; 7000).count());\n\n    //max(Comparator c) 返回流中最大值\n    //练习：返回最高工资的员工\n    System.out.println(list.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));\n    //练习：返回最高的工资\n    //方式1\n    System.out.println(list.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())).get().getSalary());\n    //方式2\n    System.out.println(list.stream().map(emp -&gt; emp.getSalary()).max((salary1, salary2) -&gt; Double.compare(salary1, salary2)).get());\n    System.out.println(list.stream().map(emp -&gt; emp.getSalary()).max(Double::compare).get());\n\n    //min(Comparator c) 返回流中最小值\n    //练习：返回最低工资的员工\n    System.out.println(list.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));\n\n    //forEach(Consumer c) 内部迭代\n    list1.stream().forEach(System.out::println);\n\n    //针对集合，jdk8中增加了一个遍历的方法\n    list1.forEach(System.out::println);\n    //针对List来说，遍历的方法：①使用Iterator ②增强for ③一般for ④forEach()\n&#125;2、归约\n\n\n方法\n描述\n\n\n\nreduce(T indentity, BinaryOperator b)\n可以将流中元素反复结合起来，得到一个值。返回T\n\n\nreduce(BinaryOperator b)\n可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;\n\n\n备注：map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名。\n代码演示\njavapublic void test2() &#123;\n    //reduce(T indentity, BinaryOperator) 可以将流中元素反复结合起来，得到一个值。返回T\n    //练习1：计算1-10的自然数的和\n    List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    System.out.println(list.stream().reduce(0, (x1, x2) -&gt; x1 + x2)); //55\n    System.out.println(list.stream().reduce(0, (x1, x2) -&gt; Integer.sum(x1, x2))); //55\n    System.out.println(list.stream().reduce(0, Integer::sum)); //55\n    System.out.println(list.stream().reduce(10, (x1, x2) -&gt; x1 + x2)); //65\n\n    //reduce(BinaryOperator) 可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;\n    //练习2：计算公司所有员工工资的总和\n    List&lt;Employee&gt; employeeList = EmployeeData.getEmployees();\n    System.out.println(employeeList.stream().map(emp -&gt; emp.getSalary()).reduce((salary1, salary2) -&gt; Integer.sum(salary1, salary2)));\n    System.out.println(employeeList.stream().map(emp -&gt; emp.getSalary()).reduce(Integer::sum));\n&#125;3、收集\n\n\n方法\n描述\n\n\n\ncollect(Collector c)\n将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法\n\n\nCollector接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。\n代码演示\njavapublic void test3() &#123;\n    List&lt;Employee&gt; list = EmployeeData.getEmployees();\n    //collect(Collector c) 将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法\n    //练习1：查找工资大于6000的员工，结果返回为一个List或Set\n    List&lt;Employee&gt; list1 = list.stream().filter(emp -&gt; emp.getSalary() &gt; 6000).collect(Collectors.toList());\n    list1.forEach(System.out::println);\n    System.out.println();\n    //源数据并不会改变\n    list.forEach(System.out::println);\n\n    //练习2：按照员工的年龄进行排序，返回到一个新的list中\n    List&lt;Employee&gt; list2 = list.stream().sorted((e1, e2) -&gt; e1.getAge() - e2.getAge()).collect(Collectors.toList());\n    list2.forEach(System.out::println);\n&#125;\n新语法结构异常处理之try-catch资源关闭JDK7的新特性在try后面可以增加一个( )，在括号中可以声明流对象并初始化。try中的代码执行完毕，会自动把流对象释放，就不用写finally了。\n格式：\njavatry(资源对象的声明和初始化) &#123;\n    业务逻辑代码，可能会产生异常\n&#125; catch(异常类型1 e) &#123;\n    处理异常代码\n&#125; catch(异常类型2 e) &#123;\n    处理异常代码\n&#125;原本写法\njavapublic void test1() &#123;\n    FileWriter fw = null;\n    BufferedWriter bw = null;\n    try &#123;\n        fw = new FileWriter(&quot;test.txt&quot;);\n        bw = new BufferedWriter(fw);\n        bw.write(&quot;你好世界&quot;);\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            if(bw != null) &#123;\n                bw.close();\n            &#125;\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;新特性写法\njavapublic void test1() &#123;\n    FileWriter fw = null;\n    BufferedWriter bw = null;\n    try &#123;\n        fw = new FileWriter(&quot;test.txt&quot;);\n        bw = new BufferedWriter(fw);\n        bw.write(&quot;你好世界&quot;);\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            if(bw != null) &#123;\n                bw.close();\n            &#125;\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;JDK9的新特性try的前面可以定义流对象，try后面的( )中可以直接引用流对象的名称。在try代码执行完毕后，流对象也可以释放掉，也不用写finally了。\n格式：\na，b是final的，不可再被赋值。\njavaA a = new A();\nB b = new B();\ntry(a;b) &#123;\n    可能产生的异常代码\n&#125; catch (异常类名 变量名) &#123;\n    异常处理的逻辑\n&#125;局部变量类型推断JDK10新特性\n可以使用的场景\njavapublic void test3() &#123;\n    //1. 局部变量的实例化\n    var list = new ArrayList&lt;String&gt;();\n    var set = new LinkedHashSet&lt;Integer&gt;();\n    \n    //2. 增强for循环中的索引\n    for (var r : list) &#123;\n        System.out.println(r);\n    &#125;\n    \n    //3. 传统for循环中\n    for (var i = 0; i &lt; 100; i++) &#123;\n        System.out.println(i);\n    &#125;\n    \n    //4. 返回值类型含复杂泛型结构\n    var iterator = set.iterator();\n    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n    var entries = map.entrySet();\n&#125;不可以使用的场景\n1、声明一个成员变量\n2、声明一个数组变量，并为数组静态初始化（省略new的情况下）\n3、方法的返回值类型\n4、方法的参数类型\n5、没有初始化的方法内的局部变量声明\n6、作为catch块中异常类型\n7、Lambda表达式中函数式接口的类型\n8、方法引用中函数式接口的类型\ninstanceof模式匹配原本写法-java14之前\njavapublic void test1() &#123;\n    Object obj = new String(&quot;hello.java14&quot;);\n    if(obj instanceof String) &#123;\n        String str = (String) obj;\n        System.out.println(str.contains(&quot;Java&quot;));\n    &#125; else &#123;\n        System.out.println(&quot;非String类型&quot;);\n    &#125;\n&#125;新写法-java14中\njavapublic void test2() &#123;\n    Object obj = new String(&quot;hello.java14&quot;);\n    if(obj instanceof String str) &#123;\n        System.out.println(str.contains(&quot;Java&quot;));\n    &#125; else &#123;\n        System.out.println(&quot;非String类型&quot;);\n    &#125;\n&#125;switch表达式传统switch声明语句的弊端：\n\n匹配是自上而下的，如果忘记写break，后面的case语句不论匹配与否都会执行；\n所有的case语句共用一个块范围，在不同的case语句定义的变量名不能重复；\n不能再一个case里写多个执行结果一致的条件；\n整个switch不能作为表达式返回值；\n\njava//常见错误演示\nswitch (month) &#123;\n    case 3|4|5: // 3|4|5 用了位运算 11 | 100 | 101结果是111是 7\n        System.out.println(&quot;春季&quot;);\n        break;\n    case 6|7|8: // 6|7|8用了位运算 110 | 111 | 1000结果是1111是 15\n        System.out.println(&quot;夏季&quot;);\n        break;\n    case 9|10|11: // 9|10|11用了位运算 1001 | 1010 | 1011结果是1011 是11\n        System.out.println(&quot;秋季&quot;);\n        break;\n    case 12|1|2: // 12|1|2用了位运算 1100 | 1 | 10结果是1111 是15\n        System.out.println(&quot;冬季&quot;);\n        break;\n    default:\n        System.out.println(&quot;输入有误&quot;);\n&#125;JDK12中预览特性\nJava 12将会对switch声明语句进行扩展，使用case L -&gt;来代替以前的break;，省去了break语句，避免了因少写break而出错。\n同时将多个case合并到一行，显得简洁、清晰，也更加优雅的表达逻辑分支。\n为了保持兼容性，case条件语句中依然可以使用字符:，但是同一个switch结构里不能混用-&gt;和:，否则编译错误。\n\n代码演示\njavapublic void test2() &#123;\n    int month = 1;\n    switch (month) &#123;\n        case 3 -&gt; System.out.println(&quot;春季&quot;);\n        case 6,7,8 -&gt; System.out.println(&quot;夏季&quot;);\n        default -&gt; System.out.println(&quot;输入有误&quot;);\n    &#125;\n&#125;JDK12中的写法：还可以使用变量接收switch表达式的结果\njavapublic void test3() &#123;\n    int month = 1;\n    int result = switch (month) &#123;\n        case 3 -&gt; 1;\n        case 6,7,8 -&gt; 2;\n        default -&gt; 3;\n    &#125;;\n    System.out.println(result);\n&#125;JDK13中的写法：引入了yield关键字，用于返回指定的数据，结束switch结果。\n这意味着，switch表达式(返回值)应该使用yield，switch语句(不返回值)应该使用break。\n和return的区别在于：return会直接跳出当前方法，而yield只会跳出当前switch块。\n使用**case -&gt;**的代码演示，需要加&#123; &#125;\njavapublic void test4() &#123;\n    int month = 1;\n    int result = switch (month) &#123;\n        case 3 -&gt; &#123;\n           yield  1;\n        &#125;\n        case 6,7,8 -&gt; &#123;\n            yield 2;\n        &#125;\n        default -&gt; &#123;\n            System.out.println(&quot;值未找到&quot;);\n            yield 3;\n        &#125;\n    &#125;;\n    System.out.println(result);\n&#125;使用**case :**的代码演示，不用加&#123; &#125;\njavapublic void test5() &#123;\n    int month = 1;\n    int result = switch (month) &#123;\n        case 3 :\n            yield  1;\n        case 6,7,8 :\n            yield 2;\n        default :\n            System.out.println(&quot;值未找到&quot;);\n            yield 3;\n    &#125;;\n    System.out.println(result);\n&#125;文本块的使用通过在文字框前后加&quot;&quot;&quot;来实现可复制\nmysql举例对比\n\n\nrecord的使用\n1、可以在record声明的类中定义静态字段、静态方法、构造器或示例方法。\n2、不能在record声明的类中定义实例字段；类不能声明为abstract；不能声明显式的父类等。\n代码举例\njavapublic record Person(int id, String name) &#123;\n    //可以在record声明的类中定义静态字段、静态方法、构造器或实例方法\n    static String info = &quot;我是一个人&quot;;\n    public static void show() &#123;\n        System.out.println(&quot;我是一个人&quot;);\n    &#125;\n    public Person() &#123;\n        this(0, null);\n    &#125;\n    public void eat() &#123;\n        System.out.println(&quot;人吃饭&quot;);\n    &#125;\n&#125;密封类\n代码演示\njava//Person是一个密封类，可以被指定的子类所继承。非指定的类不能继承Person类\npublic sealed class Person permits Student,Teacher,Worker&#123;\n&#125;\n//要求指定的子类必须是final、sealed、non-sealed三者之一\nfinal class Student extends Person&#123;&#125; //Student类不能被继承\n\nsealed class Teacher extends Person permits SeniorTeacher&#123;&#125; //Teacher类只能被指定的子类继承\n\nnon-sealed class SeniorTeacher extends Teacher&#123;&#125;\n\nnon-sealed class Worker extends Person&#123;&#125; //Worker类在继承时，没有任何限制\nAPI的变化Optional类\n创建Optional类对象的方法：\n\nstatic&lt;T&gt; Optional&lt;T&gt; empty(): 用来创建一个空的Optional实例\nstatic&lt;T&gt; Optional&lt;T&gt; of(T value): 用来创建一个Optional实例，value必须非空\nstatic &lt;T&gt; Optional&lt;T&gt; ofNullable(T value): 用来创建一个Optional实例，value可能是空，也可能非空\n\n判断Optional容器中是否包含对象：\n\nboolean isPresent(): 判断Optional容器中的值是否存在\nvoid ifPresent(Consumer&lt;? super T&gt; consumer): 判断Optional容器中的值是否存在，如果存在，就对它进行Consumer指定的操作，如果不存在就不做\n\n获取Optional容器的对象：\n\nT get(): 如果调用对象包含值，返回该值。否则抛异常。T get()与of(T value)配合使用\nT orElse(T other): orElse(T other)与ofNullable(T value)配合使用，如果Optional容器中非空，就返回所包装值，如果为空，就用orElse(T other)orher指定的默认值(备胎)代替\nT orElseGet(Suppiler&lt;? extends T&gt; other): 如果Optional容器中非空，就返回所包装值，如果为空，就用Supplier接口的Lambda表达式提供的值代替\nT orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier): 如果Optional容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的NoSuchElementException\n\n代码演示\njavapublic void test() &#123;\n    String star = &quot;猫&quot;;\n    star = null;\n    //使用Optional避免空指针的问题\n    //1. 实例化\n    //ofNullable(T value):用来创建一个Optional实例，value可能是空，也可能非空\n    Optional&lt;String&gt; optional = Optional.ofNullable(star);\n    //orElse(T other): 如果Optional实例内部的value属性不为null，则返回value，如果value为null，\n    //则返回other\n    String otherStar = &quot;狗&quot;;\n    String finalStar = optional.orElse(otherStar);\n\n    System.out.println(finalStar.toString());\n&#125;\n企业真题JDK8新特性1、谈谈java8新特性(京*旗下、时*宇，信必*、招*信诺,中*外包，金*软件、阿巴)**\ntxt类似问题\nJDK1.8相较于JDK1.7有什么不一-样? (惠+)\nJDK1 . 8的新特性有哪些? Stream API + Lambda表达式，还有吗? (久*国际物流)\nlambda表达式、 Stream API\njdk7的对比:元空间、HashMap等、新的日期时间API、接口变化等。\n\n2、JDK1.8在数据结构上发生了哪些变化? (银*数据)\n\n使用元空间替代永久代。(方法区: jvm规范中提到的结构。\nHotSpot来讲, jdk7: 方法区的落地体现: 永久代。jdk8: 方法区的落地体现:元空间。\nHashMap底层结构\n\n3、JDK1.8用的是哪个垃圾回收器? (0*0)*Parallel GC -&gt; jdk9:默认使用G1GC –&gt; ZGC (低延迟)\nLambda表达式1、Lambda表达式有了解吗，说说如何使用的(0**0)\n\n在给函数式接口提供实例时，都可以考虑使用lambda表达式。\n基本语法的使用(重要)\n\n2、什么是函数式接口?有几种函数式接口(阿**巴)略。java.util.function包下定义了丰富的好函数式接口。有4类基础的函数式接口:消费型接口: Consumervoid accept(T t)供给型接口: Supplier T get()函数型接口: Function&lt;T,R&gt; R apply(T t)判断型接口: Predicate boolean test(T t)\nStream API1、创建Stream的方式(阿**巴)\n三种。2.你讲讲stream表达式是咋用的，干啥的? (中*国际， 上海*网络)\ntxtStream API关注的是多个数据的计算(排序、查找、过滤、映射、遍历等)，面向CPU的。\n集合关注的数据的存储，面向内存的。\nStream API之于集合，类似于SQL之于数据表的查询。3.集合用Stream流怎么实现过滤? (润*软件)\nfilter(Predicate predicate)\n","slug":"JDK8-17新特性","date":"2023-11-28T10:57:00.000Z","categories_index":"Java","tags_index":"Java","author_index":"白"},{"id":"03a1af7058cec8bb8efe418ed228e157","title":"正则表达式","content":"正则表达式正则表达式: regular expression &#x3D;&gt; RegExp\n思维导图\n\n引入:为什么要学习正则表达式\n\n快速入门假设content已经是通过爬虫抓取的文本，从中获取ip地址。通过正则表达式即可很方便的获取\njavapublic static void main(String[] args) &#123;\n    String content = &quot;私有地址（Private address）属于非注册地址，专门为组织机构内部使用。\\n&quot; +\n            &quot;以下列出留用的内部私有地址\\n&quot; +\n            &quot;A类 10.0.0.0--10.255.255.255\\n&quot; +\n            &quot;B类 172.16.0.0--172.31.255.255\\n&quot; +\n            &quot;C类 192.168.0.0--192.168.255.255&quot;;\n    //(1). 传统方法. 使用遍历方式，代码量大，效率不高\n    //(2). 正则表达式技术\n    //1. \\\\d表示一个任意数字\n    Pattern pattern = Pattern.compile(&quot;\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+&quot;);\n    //2. 创建模式对象[即正则表达式对象]\n    //理解： 就是 matcher 匹配器按照 pattern(模式/样式), 到 content 文本中去匹配\n    //找到就返回true, 否则就返回false\n    int no = 0;\n    //3. 创建匹配器\n    //创建匹配器matcher，按照 正则表达式的规则 去匹配，content字符串\n    Matcher matcher = pattern.matcher(content);\n    //4. 可以开始循环匹配\n    while (matcher.find()) &#123;\n        //匹配内容，文本，放到 m.group(0)\n        System.out.println(&quot;找到: &quot; + (++no) + &quot; &quot; +matcher.group(0));\n    &#125;\n&#125;输出效果如图所示\n结论: 为了解决上述问题，Java提供了正则表达式技术，专门用于处理类似文本问题。正则表达式是对字符串执行模式匹配的技术。\n\n(重要)底层实现目标：匹配所有四个数字\n假设String字符串如下\njavaString content = &quot;1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了&quot; +\n        &quot;第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型&quot; +\n        &quot;版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的&quot; +\n        &quot;标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应&quot; +\n        &quot;用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个&quot; +\n        &quot;里程碑，标志着Java的应用开始普及9889 &quot;;matcher.find考虑分组情况： 比如  (\\d\\d)(\\d\\d) ,正则表达式中有() 表示分组,第1个()表示第1组,第2个()表示第2组…\n1、根据指定的规则，定位满足规则的子字符串(比如(19)(98))\n2、找到后，将 子字符串的开始的索引 和 子字符串的结束的索引+1 记录到 matcher对象属性 int[] groups。如果没有分组则只有2.1，如果含有分组则按顺序执行。\n​\t\t2.1  groups[0]  记录开始的索引位置，groups[1]  记录子字符串的结束的索引+1的值（举例: 1998-&gt; groups[0] &#x3D; 0, groups[1] &#x3D; 4）\n​\t\t2.2 groups[2]  记录第一组开始的索引的位置，groups[3]  记录第一组结束的索引+1的值（举例: (19) - &gt; groups[2] &#x3D; 0, groups[3] &#x3D; 2）\n​\t\t2.3 groups[4]  记录第二组开始的索引的位置，groups[5] 记录第二组结束的索引+1的值（举例: (98) - &gt; groups[4] &#x3D; 2, groups[5] &#x3D; 4）\n​\t\t2.4  更多分组同理…..\n​\t3、同时记录oldLast的值为 子字符串结束的索引+1的值，即下次执行find时，就从oldLast开始匹配（举例: 1999-&gt;oldLast&#x3D;35，下次find从35索引开始匹配 ）\nmatcher.group1、如果没有分组，直接执行matcher.group(0)即可打印结果。\n2、如果有分组，如下(条件: 分组的数不能越界)\n​\t2.1 group(0) 表示匹配到的子字符串\n​\t2.2 group(1) 表示匹配到的子字符串的第1组字串\n​\t2.3 group(2) 表示匹配到的子字符串的第2组字串\n源码\njavamatcher.group源码:\npublic String group(int group) &#123;\n        if (first &lt; 0)\n            throw new IllegalStateException(&quot;No match found&quot;);\n        if (group &lt; 0 || group &gt; groupCount())\n            throw new IndexOutOfBoundsException(&quot;No group &quot; + group);\n        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))\n            return null;\n        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();\n&#125;举例说明:  \n根据 groups[0]&#x3D;31 和 groups[1]&#x3D;35 的记录的位置，从content开始截取子字符串返回就是 [31,35) 包含 31 但是不包含索引为 35的位置\n底层分析\n\n正则表达式语法基本介绍如果要想灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为:\n1、限定符\n2、选择匹配符\n3、分组组合和反向引用符\n4、特殊字符\t\n5、字符匹配符\t\n6、定位符\n贪婪匹配和非贪婪匹配贪婪匹配：java匹配默认贪婪匹配，而默认的”贪心的”模式是匹配搜索到的、尽可能长的的字符串。\n非贪婪匹配：针对 ?  字符，当此字符紧随任何其他限定符 ( *、+、?、{n}、{n,m} )  之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串。\n例如: 在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有的”o”。\n“o+”输出结果\ntxt找到=oooo“o+?”输出结果\ntxt找到=o\n找到=o\n找到=o\n找到=o元字符-转义号 \\\\需要用到转义符号:\t. * + ( ) $ &#x2F; \\ ? [ ] ^ { } 共14个\n\\\\符号说明: \t在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果，甚至会报错。在Java的正则表达式中，两个\\\\代表其他语言中的一个\\\n 问题: 用 $ 匹配 “abc$(“ 会怎样? 用 ( 匹配 “abc$(“ 会怎样? \n解答: 会报错，因此使用转义符\n代码演示\njavapublic static void main(String[] args) &#123;\n    String content = &quot;abc$(a.bc(123( )&quot;;\n    //匹配( =&gt; \\\\(\n    //匹配. =&gt; \\\\.\n    String regStr = &quot;\\\\.&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到 &quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到 .元字符-字符匹配符\n\n\n符号\n符号\n示例\n解释\n匹配输入\n\n\n\n[ ]\n可接受的字符列表\n[efgh]\ne、f、g、h中的任意1个字符\ne\n\n\n[^]\n不接收的字符列表\n[^abc]\n除a、b、c之外的任意1个字符，包括数字和特殊符号\nd\n\n\n-\n连字符\nA-Z\n任意单个大写字母\nA\n\n\n.\n匹配除 \\n 以外的任何字符\na..b\n以a开头，b结尾，中间包括2个任意字符的长度为4的字符串\naaab、aefb、a35b、a#*b\n\n\n\\\\d\n匹配单个数字字符，相当于[0-9]\n\\\\d{3}(\\\\d)?\n包含3个或4个数字的字符串\n123、9876\n\n\n\\\\D\n匹配单个非数字字符，相当于[ ^0-9]\n\\\\D(\\\\d)*\n以单个非数字字符开头，后接任意个数字字符串\na、A342\n\n\n\\\\w\n匹配单个数字，大小写字母字符，下划线，相当于[0-9a-zA-Z_]\n\\\\d{3}\\\\w{4}\n以3个数字字符开头的长度为7的数字字母字符串\n234abcd、12345Pe\n\n\n\\\\W\n匹配单个非 数字，大小写字母字符，下划线，相当于[ ^0-9a-zA-Z_]\n\\\\W+\\\\d{2}\n以至少一个非数字字母字符开头，2个数字字符结尾的字符串\n#29、#?@10\n\n\n\\\\s\n匹配任何空白字符(空格, 制表符等)\na @\n\n“ “(一个空格)\n\n\n\\\\S与\\\\s相反\nString regStr &#x3D;  “.” 匹配除了 \\n 的所有字符\nString regStr &#x3D; “[.]” 匹配 . 本身 \n应用案例案例一\n[a-z]： 匹配 a-z之间任意一个字符\nabc：匹配 abc 字符串[默认区分大小写]\njavapublic static void main(String[] args) &#123;\n    String content = &quot;a11c8&quot;;\n    String regStr = &quot;[a-z]&quot;; //匹配 a-z之间任意一个字符\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到&quot; + matcher.group(0));\n    &#125;\n&#125;运行结果\ntxt找到a\n找到c案例二\n[^a-z]：匹配不在a-z之间的任意一个字符\n因为加了Pattern.CASE_INSENSITIVE参数所以不区分大小写，只输出数据。\njavapublic static void main(String[] args) &#123;\n    String content = &quot;a11c8ABC&quot;;\n    String regStr = &quot;[^a-z]&quot;; //匹配 a-z之间任意一个字符\n    Pattern pattern = Pattern.compile(regStr, Pattern.CASE_INSENSITIVE);\n    Matcher matcher = pattern.matcher(content);\n\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到&quot; + matcher.group(0));\n    &#125;\n&#125;运行结果\ntxt找到1\n找到1\n找到8区分大小写java正则表达式默认是区分字母大小写的，如何实现不区分大小写。\n1、(?i)abc :表示abc都不区分大小写\n2、a(?i)bc :表示bc不区分大小写\n3、a((?i)b)c : 表示只有b不区分大小写\n4、设置参数 :Pattern pat &#x3D; Pattern.compile(regEx, Pattern.CASE_INSENSITIVE) 则表示匹配时不区分大小写\n元字符-选择匹配符 |在匹配某个字符串的时候是选择性的，这时就需要 选择匹配字符 |\n\n\n\n符号\n符号\n示例\n解释\n\n\n\n|\n匹配”|” 之前或之后的表达式\nab|cd\nab或cd\n\n\n元字符-限定符用于指定其前面的字符和组合项连续出现多少次\n\n\n\n符号\n含义\n示例\n说明\n匹配输入\n\n\n\n*\n指定符号重复0次或n次 (无要求)\n(abc)*\n仅包含任意abc的字符串，等效于\\w*\nabc、abcabcabc\n\n\n+\n指定字符重复1次或n次 (至少一次)  1到多\nm + (abc)*\n以至少1个m开头，后接任意个abc的字符串\nm、mabc、mabcabc\n\n\n?\n指定字符重复0次或1次 (最多一次) 0到1\nm + abc?\n以至少1个m开头，后接ab或abc的字符串\nmab、mabc、mmmab、mmabc\n\n\n{n}\n只能输入n个字符\n[abcd]{3}\n以abcd中字母组成的任意长度为3的字符串\nabc、dbc、adc\n\n\n{n,}\n指定至少n个匹配\n[abcd]{3,}\n由abcd中字母组成的任意长度不小于3的字符串\naab、dbc、aaabdc\n\n\n{n,m}\n指定至少n个单不多于m个匹配\n[abcd]{3,5}\n由abcd中字母组成的任意长度不小于3，不大于5的字符串\nabc、abcd、aaaaa、bcdab\n\n\njava匹配默认贪婪匹配，即尽可能匹配多的。\n“?”紧随任何其他限定符之后时，匹配模式是非贪婪匹配。\n例如:\tcontent &#x3D; “aaaabc”， \t规则为 a[3, 4]\t，结果返回aaaa，索引定位到b。\n例如:\tcontent &#x3D; “111111a”，\t规则为1+\t\t，结果返回111111，索引定位到a\n例如:\tcontent &#x3D; “a111111b”，\t规则为a1?\t，结果返回a111111，索引定位到b\n元字符-定位符定位符，规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置。\n\n\n\n符号\n含义\n示例\n说明\n匹配输入\n\n\n\n^\n指定起始字符\n^[0-9] + [a-z]*\n以至少1个数字开头，后接任意个小写字母的字符串\n123、6aa、555edf\n\n\n$\n指定结束字符\n^[0-9] \\\\- [a-z] + $\n以1个数字开头后接连字符”-“，并以至少1个小写字母结尾的字符串\n1-a\n\n\n\\\\b\n匹配目标字符串的边界\nhan\\\\b\n这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置\nsphan nnhan\n\n\n\\\\B\n匹配目标字符串的非边界\nhan\\\\B\n和\\b的含义刚好相反\nhansss sphan nnhan\n\n\n例如:\tcontent &#x3D; “123abc12”，\t规则为 ^[0-9] + [a-z]*\t，结果返回123abc。\n例如:\tcontent &#x3D; “123abc12”，\t规则为^[0-9] + [a-z] + $\t，没有结果返回。如果把content修改为 “123abc”，结果返回123abc\n例如:\tcontent &#x3D; “hansss sphan nnhan”，\t规则为han\\\\b\t，结果返回han，han。因为sphan和nnhan匹配成功。\n例如:\tcontent &#x3D; “hansss sphan nnhan”，\t规则为han\\\\B\t，结果返回han。因为hansss匹配成功。\n常用、特别分组常用分组(捕获分组):\t(pattern)，(?&lt;name&gt;pattern) \n特别分组(非捕获分组):\t(?:pattern)，(?&#x3D;pattern)，(?!pattern)\n非捕获分组: 不能matcher.group(1)来获取分组\n\n\n\n分组构造形式\n说明\n\n\n\n(pattern)\n非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其他捕获结果则根据左括号的顺序从1开始自动编号。(1，2，3)\n\n\n(?&lt;name&gt;pattern)\n命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号代替尖括号，例如(?’name’)\n\n\n(?:pattern)\n匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储以后使用的匹配。这对于用”or”字符( | )组合模式部件的情况很有用。例如: industr(?:y | ies) 是比 ‘industry | industries’ 更经济的表达式。\n\n\n(?&#x3D;pattern)\n它是一个非捕获匹配。例如: ‘Windows(?&#x3D;95 | 98 | NT | 2000)’ 匹配 “Windows 2000”中的”Windows”，但不匹配”Windows 3.1” 中的 “Windows”。\n\n\n(?!pattern)\n该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如: ‘Windows (?! 95 | 98 | NT 2000)’ 匹配 “Windows 3.1” 中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。\n\n\n常用分组代码演示(pattern) \nmatcher.group() 传入编号\njavapublic static void main(String[] args) &#123;\n    String content = &quot;sasas s7888 nn1189han&quot;;\n    //下面是非命名分组,说明\n    //1. matcher.group(0) 得到匹配的字符串\n    //2. matcher.group(1) 得到匹配到的字符串的第1个分组内容\n    //3. matcher.group(2) 得到匹配到的字符串的第2个分组内容\n    //4. ....\n    String regStr = &quot;(\\\\d\\\\d)(\\\\d)(\\\\d)&quot;; //匹配四个数字\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while(matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n        System.out.println(&quot;第1个分组=&quot; + matcher.group(1));\n        System.out.println(&quot;第2组分组=&quot; + matcher.group(2));\n        System.out.println(&quot;第3组分组=&quot; + matcher.group(3));\n    &#125;\n&#125;输出结果\ntxt找到=7888\n第1个分组=78\n第2组分组=8\n第3组分组=8\n找到=1189\n第1个分组=11\n第2组分组=8\n第3组分组=9(?&lt;name&gt;pattern) \nmatcher.group() 传入组名\njavapublic static void main(String[] args) &#123;\n    String content = &quot;sasas s7888 nn1189han&quot;;\n    //命名分组: 即可以给分组取名\n    String regStr = &quot;(?&lt;g1&gt;\\\\d\\\\d)(?&lt;g2&gt;\\\\d\\\\d)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n\n    while(matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n        System.out.println(&quot;第1个分组[通过组名]=&quot; + matcher.group(&quot;g1&quot;));\n        System.out.println(&quot;第2组分组[通过组名]=&quot; + matcher.group(&quot;g2&quot;));\n    &#125;\n&#125;输出结果\ntxt找到=7888\n第1个分组[通过组名]=78\n第2组分组[通过组名]=88\n找到=1189\n第1个分组[通过组名]=11\n第2组分组[通过组名]=89特别分组代码演示非捕获分组: 不能matcher.group(1)来获取分组\n(?:pattern)  匹配 pattern 但不捕获该匹配的子表达式\nString regStr &#x3D; “小猫吃鱼 | 小猫抓老鼠 | 小猫乱跑” 等价于”小猫(?:吃鱼|抓老鼠|乱跑)” 是非捕获分组。\njavapublic static void main(String[] args) &#123;\n    String content = &quot;小猫吃鱼 小猫抓老鼠 小猫乱跑&quot;;\n    String regStr = &quot;小猫(?:吃鱼|抓老鼠|乱跑)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到=小猫吃鱼\n找到=小猫抓老鼠\n找到=小猫乱跑(?&#x3D;pattern) 匹配满足?&#x3D;pattern的表达式\n举例: 匹配规则 “小猫(?&#x3D;吃鱼|抓老鼠)” 只匹配后缀是吃鱼和抓老鼠的小猫 \njavapublic static void main(String[] args) &#123;\n    String content = &quot;小猫吃鱼 小猫抓老鼠 小猫乱跑&quot;;\n    String regStr = &quot;小猫(?=吃鱼|抓老鼠)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到=小猫\n找到=小猫(?!pattern) 与(?&#x3D;pattern)匹配规则相反\n举例: 匹配规则 “小猫(?!吃鱼|抓老鼠)” 匹配除了后缀是吃鱼和抓老鼠的小猫\njavapublic static void main(String[] args) &#123;\n    String content = &quot;小猫吃鱼 小猫抓老鼠 小猫乱跑&quot;;\n    String regStr = &quot;小猫(?!吃鱼|抓老鼠)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到=小猫正则应用实例代码样式模板\njavapublic static void main(String[] args) &#123;\n    String content = &quot;&quot;;\t//需要匹配的文本\n    String regStr = &quot;&quot;;\t\t//匹配规则\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while(matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\t//根据需求查询\n    &#125;\n    /*\n    if(matcher.find()) &#123;\n        System.out.println(&quot;满足格式&quot;);\n    &#125;else &#123;\n        System.out.println(&quot;不满足格式&quot;);\n    &#125;\n    */\n&#125;示例问题举例\n\n解答\n1、regStr &#x3D; “^[\\u0391-\\uffe5]+$“ \t\n举例: content &#x3D; “小猫爱吃鱼” sout  &#x3D; “满足格式”  或  content &#x3D; “小猫x吃鱼” sout &#x3D; “不满足格式”\n2、regStr &#x3D; “^[1-9]\\\\d{5}$“\n举例: content &#x3D; “123890” sout  &#x3D; “满足格式”\n3、regStr &#x3D; “^[1-9]\\\\d{4,9}$“\n举例: content &#x3D; “1238990” sout &#x3D; “满足格式”  或  content &#x3D; “1238a990” sout &#x3D; “不满足格式”\n4、regStr &#x3D; “^1[3 | 4 | 5 | 8]\\\\d{9}$“\n举例: content  &#x3D; “13588889999”  sout &#x3D; “满足格式”  或  content &#x3D; “1238990” sout &#x3D; “不满足格式”\n5、验证url地址\n思路分析\n1、先确定url开始部分 https:&#x2F;&#x2F; | http:&#x2F;&#x2F; \t规则-&gt; ^((https | http):&#x2F;&#x2F;)\n2、然后匹配ip地址 www.bilbil.com\t规则-&gt;www. 和bilbil. 匹配 ([\\\\w-]+\\\\.)+ \tcom 匹配的是 [\\\\w-]+\n3、&#x2F;video&#x2F;BV1Qj41177e9&#x2F;?spm_id_from&#x3D;333\t规则-&gt; (\\/[\\\\w-?&#x3D;&amp;&#x2F;%.#]*)?$\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;https://&quot; +\n            &quot;www.bilibili.com&quot; +\n            &quot;/video/BV1Qj41177e9/?spm_id_from=333.1007.tianma.1-3-3.click&amp;vd_source=68ae6e90dea85507b9aca2772fb25cd8&quot;; //url地址\n    /**\n     * 思路\n     * 1. 先确定url开始部分 https:// | http:// -&gt; ^((https|http)://)\n     * 2. 然后匹配ip地址 www.bilibili.com -&gt; www.和bilbil.匹配的是 ([\\w-]+\\.) com匹配的是[\\w-]+\n     * 3. /video/BV1Qj41177e9/?spm_id_from=333 匹配 (\\/[\\w-?=&amp;/%.#]*)?\n     */\n    String regStr = &quot;^((https|http)://)([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w-?=&amp;/%.#]*)?$&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    if(matcher.find()) &#123;\n        System.out.println(&quot;满足格式&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;不满足格式&quot;);\n    &#125;\n&#125;\n正则表达式常用类常用类包括以下三个类\njava.util.regex 包主要包括以下三个类 Pattern类、Matcher类和PatternSyntaxException类\nPattern类基本介绍pattern对象是一个正则表达式对象。Pattern类没有公共构造方法。要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数，比如 Pattern r &#x3D; Pattern.compile(pattern);\n常用方法matches用于整体匹配，在验证输入的字符串是否满足条件使用。返回类型boolean\n区别: 在url判别中，使用原来的方法必须要加 ^ 和 $ 符号锁定开头和结尾。如果不加的话，那么10https…也会匹配成功。但如果使用了matches整体匹配的话，匹配规则可以是  “((https|http):&#x2F;&#x2F;)([\\w-]+\\.)+[\\w-]+(\\&#x2F;[\\w-?&#x3D;&amp;&#x2F;%.#]*)?”  ，就可以不用加定位符 “^” 和 “$”。\njava/**\n * 演示matches方法，用于整体匹配，在验证输入的字符串是否满足条件使用\n */\npublic class PatternMethod &#123;\n    public static void main(String[] args) &#123;\n        String content = &quot;hello abc 吖吖&quot;;\n        String regStr = &quot;hello&quot;; //false\n        String regStr = &quot;hello.*&quot;; //true\n        boolean matches = Pattern.matches(regStr, content);\n        System.out.println(&quot;整体匹配=&quot; + matches);\n    &#125;\n&#125;Matcher类基本介绍Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。\n方法一览\n\n\n方法\n说明\n\n\n\npublic int start()\n返回匹配的初始索引\n\n\npublic int start(int group)\n返回在匹配操作期间，由给定组所捕获的子序列的初始索引\n\n\npublic int end()\n返回最后匹配字符之后的偏移量，也就是匹配的最后一位+1\n\n\npublic int end(int group)\n返回在匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量\n\n\npublic boolean lookingAt()\n尝试将从区域开头开始的输入序列与该模式匹配\n\n\npublic boolean find()\n尝试查找与该模式匹配的输入序列的下一个子序列\n\n\npublic boolean find(int start)\n重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列\n\n\npublic boolean matches()\n尝试将整个区域与模式匹配\n\n\npublic String replaceAll(String replacement)\n替换模式与给定替换字符串相匹配的输入序列的每个子序列\n\n\n代码演示start、end、matches演示\njavapublic static void main(String[] args) &#123;\n    String content = &quot;hello edu jack tom hello smith hello&quot;;\n    String regStr = &quot;hello&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;=================&quot;);\n        System.out.println(matcher.start());\n        System.out.println(matcher.end());\n        System.out.println(&quot;找到=&quot; + content.substring(matcher.start(), matcher.end()));\n    &#125;\n    //整体匹配，检验某个字符串是否满足某个规则\n    System.out.println(&quot;整体匹配=&quot; + matcher.matches());\n&#125;结果演示\ntxt=================\n0\n5\n找到=hello\n=================\n19\n24\n找到=hello\n=================\n31\n36\n找到=hello\n整体匹配=falsereplaceAll(String replacement)  演示\n注意：返回的字符串才是替换后的字符串，原来的content并不会发生变化。\njavapublic static void main(String[] args) &#123;\n    String content = &quot;hello edu jack tom hello smith hello&quot;;\n    String regStr = &quot;hello&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n\n    //注意: 返回的字符串才是替换后的字符串 原来的content不变化\n    String newContent = matcher.replaceAll(&quot;你好&quot;);\n    System.out.println(&quot;newContent= &quot; + newContent);\n    System.out.println(&quot;content= &quot; + content);\n&#125;输出结果\ntxtnewContent= 你好 edu jack tom 你好 smith 你好\ncontent= hello edu jack tom hello smith helloPatternSyntaxException类PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n分组、捕获、反向引用提出需求问题: 给一段文本，请找出所有四个数字连在一起的子串，并且这四个数字要满足\n①第1位与第4位相同\n②第2为与第3为相同\n比如1221，5775……..\n基本介绍\n案例举例\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;hello jack14 tom11 jack22 yyy xxx&quot;;\n    //匹配两个连续相同的数字 (\\\\d)\\\\1\n    String regStr = &quot;(\\\\d)\\\\1&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到= &quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到= 11\n找到= 22额外题\n\n经典题目\n思路分析\n1、去掉所有的.\t匹配所有的 ‘ .’ ，将 ‘ .’ 替换成 “”。\n2.1、去掉重复的字\t用 (.)\\\\1+ 匹配重复的字，因为’ +’ 会得到1-多，所以至少找到两个重复的字。\n2.2、使用反向引用$1来替换匹配到的内容\n代码实现\njavapublic static void main(String[] args) &#123;\n        //通过正则表达式修改成 &quot;我要学编程java&quot;\n        String content = &quot;我...我要.....学学学...编程java!&quot;;\n        //思路:\n        //1. 去掉所有的.\n        Pattern pattern = Pattern.compile(&quot;\\\\.&quot;);\n        Matcher matcher = pattern.matcher(content);\n        content = matcher.replaceAll(&quot;&quot;);\n//        System.out.println(&quot;content=&quot; + content);\n//        //2. 去掉重复的字\n//        //(1) 使用(.)\\\\1+ 匹配重复的字，因为&#39;+&#39;会得到1-多,所以至少找到两个重复的字,满足需求\n//        pattern = Pattern.compile(&quot;(.)\\\\1+&quot;);\n//        matcher = pattern.matcher(content);\n//        while (matcher.find()) &#123;\n//            System.out.println(&quot;找到=&quot; + matcher.group(0));\n//        &#125;\n//        //使用 反向引用$1 来替换匹配到的内容\n//        content = matcher.replaceAll(&quot;$1&quot;);\n//        System.out.println(&quot;content=&quot; + content);\n        //使用一条语句\n        content = Pattern.compile(&quot;(.)\\\\1+&quot;).matcher(content).replaceAll(&quot;$1&quot;);\n        System.out.println(content);\n    &#125;输出结果\ntxt我要学编程java!\nString类使用正则表达式replaceAll替换功能\n\nmatches验证功能\n\nsplit分割功能\n\n\n正则表达式练习问题一\n\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;2312@tsinghua.org.cn&quot;;\n    String regStr = &quot;[\\\\w-]+[@]([a-zA-z]+\\\\.)+[a-zA-z]+&quot;;\n\n    if (content.matches(regStr)) &#123; //String的matches方法是整体匹配\n        System.out.println(&quot;匹配成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;匹配失败&quot;);\n    &#125;\n&#125;问题二\n\n代码实现\n1、先写出简单的正则表达式\n2、再逐步完善\njavapublic static void main(String[] args) &#123;\n        //要求验证是不是整数或者小数\n        //提示: 考虑正数和负数\n        //比如: 123 -345 34.89 -87.9 -0.01 0.45\n        String content = &quot;-23.11&quot;;\n        String regStr = &quot;^[-+]?([1-9]\\\\d*|0)(\\\\.\\\\d+)?$&quot;;\n        if (content.matches(regStr)) &#123; //String的matches方法是整体匹配\n            System.out.println(&quot;匹配成功&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;匹配失败&quot;);\n        &#125;\n&#125;问题三\n\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;http://www.sohu.com:8080/abc/xxx/index.htm&quot;;\n    String regStr = &quot;^([a-zA-z]+)://([a-zA-Z.]+):(\\\\d+)[\\\\w-/]*/([\\\\w.]+)$&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    if(matcher.matches()) &#123; //整体匹配，如果匹配成功，可以通过group(x)，获得对应分组内容\n        System.out.println(&quot;整体匹配=&quot; + matcher.group(0));\n        System.out.println(&quot;协议: &quot; + matcher.group(1));\n        System.out.println(&quot;域名: &quot; + matcher.group(2));\n        System.out.println(&quot;端口: &quot; + matcher.group(3));\n        System.out.println(&quot;文件: &quot; + matcher.group(4));\n    &#125; else &#123;\n        System.out.println(&quot;匹配失败&quot;);\n    &#125;\n&#125;\nJava正则表达式大全(参考)一、校验数字的表达式\n1 数字：^[0-9]*$\n2 n位的数字：^\\d{n}$\n3 至少n位的数字：^\\d{n,}$\n4 m-n位的数字：^\\d{m,n}$\n5 零和非零开头的数字：^(0|[1-9][0-9]*)$\n6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\n7 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$\n8 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$\n9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\n10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\n11 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$\n12 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$\n13 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n14 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n15 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0$\n16 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d*[1-9]\\d*))|0?.0+|0$\n17 正浮点数：^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$\n18 负浮点数：^-([1-9]\\d.\\d|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$\n19 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0)$\n二、校验字符的表达式\n1 汉字：^[\\u4e00-\\u9fa5]{0,}$\n2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\n3 长度为3-20的所有字符：^.{3,20}$\n4 由26个英文字母组成的字符串：^[A-Za-z]+$\n5 由26个大写英文字母组成的字符串：^[A-Z]+$\n6 由26个小写英文字母组成的字符串：^[a-z]+$\n7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\n9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n11 可以输入含有^%&amp;’,;&#x3D;?$&quot;等字符：[^%&amp;’,;&#x3D;?$\\x22]+\n12 禁止输入含有的字符：[^\\x22]+\n三、特殊需求表达式\n1 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$\n2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+&#x2F;.?\n3 InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\\s]* 或 ^https:&#x2F;&#x2F;([\\w-]+.)+[\\w-]+(&#x2F;[\\w-.&#x2F;?%&amp;&#x3D;]*)?$\n4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ \n6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\n7 身份证号：\n​    15或18位身份证：^\\d{15}|\\d{18}$\n​    15位身份证：^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$\n​    18位身份证：^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{4}$\n8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.\\d)(?&#x3D;.[a-z])(?&#x3D;.*[A-Z]).{8,10}$ \n12 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ \n15 钱的输入格式：\n16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ \n17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ \n18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ \n19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ \n20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ \n21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ \n22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ \n23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ \n24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$\n26 中文字符的正则表达式：[\\u4e00-\\u9fa5]\n27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)\n29 HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]&gt;.?|&lt;.*? &#x2F;&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n30 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)\n32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)\n33 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用)\n","slug":"正则表达式","date":"2023-11-25T17:20:00.000Z","categories_index":"正则表达式","tags_index":"Java","author_index":"白"},{"id":"9828133175dbd4abfb8bc2b5ec3d15b8","title":"满汉楼小作业","content":"Mysql满汉楼小作业简要说明技术要求: java + jdbc(druid) + mysql\n项目目标: 训练对mysql和jdbc的能力\n1、去掉界面和事件处理，使用控制台界面\n2、完成 登陆、订座、点餐和结账、查看账单等功能\n怎么开始: 根据程序框架图从底层到业务层逐步构建。\n程序框架图\n\n\n\n1、准备工具类Utility搭建项目的整体结构\n1、新建项目mhl\n2、将整体结构搭建出来。dao包，domain包，service包，utils包，view包\n准备工具类Utility\n1、将三个jar包导入。分别是mysql，druid，Apache-DBUtils相关的jar包。\n2、将JDBCUtilsByDruid，Utility类导入utils包中。(Utility类负责控制输入，JDBCUtilsByDruid类负责连接druid连接池)。\n3、将配置文件druid.properties导入src目录下。!!!注意修改配置文件中的参数,确保数据库正确。\n4、测试Utility类和JDBCUtilsByDruid类。(从其他地方导入可能会出现问题)\nBasicDAO\n针对表进行的操作。\ndml方法-&gt;update\n返回多行结果-&gt;queryMulti\n返回单行结果-&gt;querySingle\n返回单个对象-&gt;queryScaler\njava/**\n * 开发BasicDAO,是其他DAO的父类\n */\npublic class BasicDAO&lt;T&gt; &#123; //泛型指定具体类型\n    private QueryRunner qr = new QueryRunner();\n    //开发通用dml方法，针对任意的表\n    public int update(String sql, Object... parameters) &#123; //sql语句， 参数\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            //返回受影响的行数\n            int update = qr.update(connection, sql, parameters);\n            return update;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //返回多个对象(即查询的结果是多行),针对任意表\n    /**\n     * @param sql sql语句,可以有?\n     * @param clazz 传入一个类的Class对象,比如Actor.class\n     * @param parameters 传入?的具体的值,可以是多个\n     * @return 根据Actor.class 返回对应的ArrayList集合\n     */\n    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; clazz, Object...parameters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(clazz), parameters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行结果的通用方法\n    public T querySingle(String sql, Class&lt;T&gt; clazz, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(clazz), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行单列的方法,即返回单值的方法\n    public Object queryScaler(String sql, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new ScalarHandler(), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n&#125;效果如下图\n\n\n2、显示主菜单、二级菜单和退出系统功能1、代码部分略\n2、显示框架如下\n\n\n3、用户登录要求: 用户登陆时输入id和pwd要和用户表进行匹配。匹配成功可以登陆，失败就退出\n1、创建用户表sql--用户表\nCREATE TABLE employee (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增\n    empId VARCHAR(50) UNIQUE NOT NULL DEFAULT &#39;&#39;, #员工号\n    pwd CHAR(32) NOT NULL DEFAULT &#39;&#39;, #密码md5\n    name VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #姓名\n    job VARCHAR(50) NOT NULL DEFAULT &#39;&#39; #岗位\n)CHARSET=utf8;\n\n--添加测试语句\nINSERT INTO employee VALUES(NULL, &#39;6668612&#39;, MD5(&#39;123456&#39;), &#39;张三丰&#39;, &#39;经理&#39;);\nINSERT INTO employee VALUES(NULL, &#39;6668622&#39;, MD5(&#39;123456&#39;), &#39;小龙女&#39;, &#39;服务员&#39;);\nINSERT INTO employee VALUES(NULL, &#39;6668633&#39;, MD5(&#39;123456&#39;), &#39;张无忌&#39;, &#39;收银员&#39;);\nINSERT INTO employee VALUES(NULL, &#39;666666&#39;, MD5(&#39;123456&#39;), &#39;老虎&#39;, &#39;经理&#39;);2、domian包: Employee根据程序框架图要设置一个与mysql表对应的domain类。\n该类是javabean和emoloyeee对应\njavapublic class Employee &#123;\n    private Integer id;\n    private String empId;\n    private String pwd;\n    private String name;\n    private String job; \n    public Employee() &#123; //无参构造器,反射需要\n    &#125;\n    public Employee(Integer id, String empId, String pwd, String name, String job) &#123;\n        this.id = id;\n        this.empId = empId;\n        this.pwd = pwd;\n        this.name = name;\n        this.job = job;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n&#125;3、DAO包: EmployeeDAO根据程序框架图设置一个能操作employee表的类。\n该类继承BasicDAO类\njavapackage com.mhl.dao;\n\nimport com.mhl.domain.Employee;\n\npublic class EmployeeDAO extends BasicDAO&lt;Employee&gt; &#123;\n    //可以写特有的操作\n&#125;4、(业务层)service包: EmployeeService功能: 根据empId和pwd返回一个Employee对象,如果未匹配则返回null\n根据程序框架图设置一个业务层的employeeservice类，负责组织sql语句完成业务需要。\njava/**\n * 该类完成对employee表的各种操作\n * 通过调用EmployeeDAO对象完成\n */\npublic class EmployeeService &#123;\n    //定义一个 EmployeeDAO\n    private EmployeeDAO employeeDAO = new EmployeeDAO();\n\n    //方法，根据empId和pwd返回一个Employee对象\n    public Employee getEmployeeByIdAndPwd(String empId, String pwd) &#123;\n        return employeeDAO.querySingle(&quot;select * from employee where empId=? and pwd=md5(?)&quot;, Employee.class, empId, pwd);\n    &#125;\n&#125;5、MHLView在主菜单界面调用该方法使用: 调用该方法就必须拥有一个该类的对象，因此创建一个该类的对象。\njava//定义EmployeeService 属性\nprivate EmployeeService employeeService = new EmployeeService();效果演示\n\n4、显示餐桌要求: 显示餐桌编号和餐桌当前状态\n1、创建餐桌表sql--创建diningTable 表(id, state, orderName, orderTel ...)\nCREATE TABLE diningTable (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增,表示餐桌编号\n    state VARCHAR(20) NOT NULL DEFAULT &#39;&#39;, #餐桌的状态\n    orderName VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #预定人的名字\n    orderTel VARCHAR(20) NOT NULL DEFAULT &#39;&#39;\n)CHARSET=utf8;\n\n--添加测试语句\nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); \nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); \nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); 2、domain包:  DiningTablejavabean和diningTable表对应\njavapublic class DiningTable &#123;\n    private Integer id;\n    private String state;\n    private String orderName;\n    private String orderTel;\n\n    public DiningTable() &#123;\n    &#125;\n\n    public DiningTable(Integer id, String state, String orderName, String orderTel) &#123;\n        this.id = id;\n        this.state = state;\n        this.orderName = orderName;\n        this.orderTel = orderTel;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return id + &quot;\\t\\t\\t&quot; + state;\n    &#125;\n&#125;3、DAO包: DiningTableDAOjavapublic class EmployeeDAO extends BasicDAO&lt;Employee&gt; &#123;\n    //可以写特有的操作\n&#125;4、service包: DiningTableService功能: 返回所有的餐桌信息\njavapublic class DiningTableService &#123; //业务层\n    //定义一个DiningTableDAO对象\n    private DiningTableDAO diningTableDAO = new DiningTableDAO();\n    //返回所有餐桌信息\n    public List&lt;DiningTable&gt; list() &#123;\n       return diningTableDAO.queryMulti(&quot;select id, state from diningTable&quot;, DiningTable.class);\n    &#125;\n&#125;5、MHLView在MHLView中封装方法，用于显示所有餐桌的状态。\njava//显示所有餐桌状态\npublic void listDiningTable() &#123;\n    List&lt;DiningTable&gt; list = diningTableService.list();\n    System.out.println(&quot;\\n餐桌编号\\t\\t餐桌状态&quot;);\n    for (DiningTable diningTable : list) &#123;\n        System.out.println(diningTable);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n5、满汉楼订座要求: 实现用户订座，如果座位状态不为空则显示不能订座。\n1、功能分析定制功能建立在diningTable表上，因此订座功能应当在DiningTableService类(针对DiningTable的服务)中实现\n2、DiningTableService扩展扩展两个方法\ngetDiningTableById:  根据传入的id判断餐桌是否存在。若不存在返回null。\norderDiningTable: 根据传入的形参对diningTable表进行更新。成功返回true，失败返回false\njava//根据id, 查询对应的餐桌DiningTable对象\n//如果返回null,表示id编号对应的餐桌不存在\npublic DiningTable getDiningTableById(int id) &#123;\n    //可以直接执行sql语句去测试是否正确\n    return diningTableDAO.querySingle(&quot;select * from diningTable where id = ?&quot;, DiningTable.class, id);\n&#125;\n//如果可以预定,调用方法对diningTable表进行更新\n/**\n * @param id 餐桌id\n * @param orderName 预订人姓名\n * @param orderTel 预订人电话\n * @return\n */\npublic boolean orderDiningTable(int id, String orderName, String orderTel) &#123;\n    int update =\n            diningTableDAO.update(&quot;update diningTable set state=&#39;已经预定&#39;, orderName=?, orderTel=? where id = ?&quot;, orderName, orderTel, id);\n    return update &gt; 0;\n&#125;3、MHLView在MHLView封装方法，实现订座功能。\njava//完成订座\npublic void orderDiningTable() &#123;\n    System.out.println(&quot;==============预定餐桌============&quot;);\n    System.out.print(&quot;请选择要预定的餐桌编号(-1退出): &quot;);\n    int orderId = Utility.readInt();\n    if (orderId == -1) &#123;\n        System.out.println(&quot;==============取消预订餐桌============&quot;);\n        return;\n    &#125;\n    //该方法得到的是 Y 或者 N\n    char key = Utility.readConfirmSelection();\n    if (key == &#39;Y&#39;) &#123;//要预定\n\n        //根据orderId 返回 对应DiningTable对象, 如果为null, 说明该对象不存在\n        DiningTable diningTable = diningTableService.getDiningTableById(orderId);\n        if (diningTable == null) &#123;//\n            System.out.println(&quot;==============预订餐桌不存在============&quot;);\n            return;\n        &#125;\n        //判断该餐桌的状态是否 &quot;空&quot;\n        if (!(&quot;空&quot;.equals(diningTable.getState()))) &#123;//说明当前这个餐桌不是 &quot;空&quot; 状态\n            System.out.println(&quot;==============该餐桌已经预定或者就餐中============&quot;);\n            return;\n        &#125;\n        //接收预定信息\n        System.out.print(&quot;预定人的名字: &quot;);\n        String orderName = Utility.readString(50);\n        System.out.print(&quot;预定人的电话: &quot;);\n        String orderTel = Utility.readString(50);\n\n        //更新餐桌状态\n        if (diningTableService.orderDiningTable(orderId, orderName, orderTel)) &#123;\n            System.out.println(&quot;==============预订餐桌成功============&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;==============预订餐桌失败============&quot;);\n        &#125;\n\n    &#125; else &#123;\n        System.out.println(&quot;==============取消预订餐桌============&quot;);\n    &#125;\n&#125;效果演示\n\n\n6、满汉楼菜单要求: 显示菜单表。\n1、创建菜单表sql--创建menu表(id, name, type, price)\n#菜单\nCREATE TABLE menu (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增,菜单编号\n    name VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #菜名\n    type VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #菜品种类\n    price DOUBLE NOT NULL DEFAULT 0 #价格\n)CHARSET=utf8;\n\n--添加测试数据\nINSERT INTO menu VALUES(NULL, &#39;八宝饭&#39;, &#39;主食&#39;, 10);\nINSERT INTO menu VALUES(NULL, &#39;叉烧包&#39;, &#39;主食&#39;, 20);\nINSERT INTO menu VALUES(NULL, &#39;宫保鸡丁&#39;, &#39;热菜&#39;, 30);\nINSERT INTO menu VALUES(NULL, &#39;山药拔鱼&#39;, &#39;凉菜&#39;, 14);\nINSERT INTO menu VALUES(NULL, &#39;银丝卷&#39;, &#39;甜食&#39;, 9);\nINSERT INTO menu VALUES(NULL, &#39;水煮鱼&#39;, &#39;热菜&#39;, 26);\nINSERT INTO menu VALUES(NULL, &#39;甲鱼汤&#39;, &#39;汤类&#39;, 100);\nINSERT INTO menu VALUES(NULL, &#39;鸡蛋汤&#39;, &#39;汤类&#39;, 16);2、domain包: Menujava/**\n * 该类(javabean)和menu表\n */\npublic class Menu &#123;\n    private Integer id;\n    private String name;\n    private String type;\n    private Double price;\n\n    public Menu() &#123;\n    &#125;\n\n    public Menu(Integer id, String name, String type, Double price) &#123;\n        this.id = id;\n        this.name = name;\n        this.type = type;\n        this.price = price;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return id + &quot;\\t\\t&quot; + name + &quot;\\t\\t&quot; + type + &quot;\\t\\t&quot; + price;\n    &#125;\n&#125;3、DAO包: MenuDAOjavapublic class MenuDAO extends BasicDAO&lt;Menu&gt;&#123;&#125;4、service包: MenuService功能: 返回menu表所有内容\njava/**\n * 完成对menu表的各种操作(通过调用MenuDAO)\n */\npublic class MenuService &#123;\n    //定义MenuDAO属性\n    private MenuDAO menuDAO = new MenuDAO();\n    //返回所有菜品\n    public List&lt;Menu&gt; list() &#123;\n        return menuDAO.queryMulti(&quot;select * from menu&quot;, Menu.class);\n    &#125;\n&#125;5、MHLView在MHLView中封装方法，用于显示所有菜品。\njava//显示所有菜品\npublic void listMenu() &#123;\n    List&lt;Menu&gt; list = menuService.list();\n    System.out.println(&quot;\\n菜品编号\\t\\t菜品名\\t\\t类别\\t\\t价格&quot;);\n    for (Menu menu : list) &#123;\n        System.out.println(menu);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n7、满汉楼点餐要求: 对餐桌号，菜单编号，做合理性校验，如果不合理，给出提示信息。\n思路分析1、餐桌号，菜单编号 校验。\n2、点餐成功，需要修改餐桌状态。\n3、生成账单 -&gt; 创建账单表\n1、创建账单表sql#表bill账单表(id, billId, menuId, nums, billDate, money, state, diningTableId)\nCREATE TABLE bill (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增主键\n    billId VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #账单号 可以安装自己规则生成 UUID\n    menuId INT NOT NULL DEFAULT 0, #菜单编号,可以用外键\n    nums INT NOT NULL DEFAULT 0, #份数\n    money DOUBLE NOT NULL DEFAULT 0, #金额\n    diningTableId INT NOT NULL DEFAULT 0, #餐桌\n    billDate DATE NOT NULL, #订单日期\n    state VARCHAR(50) NOT NULL DEFAULT &#39;&#39; #状态 &#39;未结账&#39;, &#39;已结账&#39;, &#39;挂单&#39;\n)CHARSET=utf8;2、domain包: BillBill是javabean和bill表对应\njava/**\n * 该类(javabean)和bill表对应\n */\npublic class Bill &#123;\n    private Integer id;\n    private String billId;\n    private Integer menuId;\n    private Integer nums;\n    private Double money;\n    private Integer diningTableId;\n    private Date billDate;\n    private String state;\n\n    public Bill() &#123; //无参构造器,用于反射\n    &#125;\n\n    public Bill(Integer id, String billId, Integer menuId, Integer nums, Double money, Integer diningTableId, Date billDate, String state) &#123;\n        this.id = id;\n        this.billId = billId;\n        this.menuId = menuId;\n        this.nums = nums;\n        this.money = money;\n        this.diningTableId = diningTableId;\n        this.billDate = billDate;\n        this.state = state;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return &quot;Bill&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, billId=&#39;&quot; + billId + &#39;\\&#39;&#39; +\n                &quot;, menuId=&quot; + menuId +\n                &quot;, nums=&quot; + nums +\n                &quot;, money=&quot; + money +\n                &quot;, diningTableId=&quot; + diningTableId +\n                &quot;, billDate=&quot; + billDate +\n                &quot;, state=&#39;&quot; + state + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;3、DAO包: BillDAOjavapublic class BillDAO extends BasicDAO&lt;Bill&gt;&#123;&#125;4、service包: BillService功能: 处理和账单相关的业务逻辑\nBillService类\n1、生成账单\n注意事项: 1、生成账单需要计算金额，因此从MenuService中获取menu对象进而得到金额。\n​\t\t\t\t\t2、当生成订单后需要将餐桌状态更新，因此需要DiningTableService属性改变餐桌状态。\n​\t\t\t\t\t综上,MenuService和DiningTableService需要新增方法。\njava/**\n * 处理和账单相关的业务逻辑\n */\npublic class BillService &#123;\n    //定义BillDAO属性\n    private BillDAO billDAO = new BillDAO();\n    //定义一个MenuService属性\n    private MenuService menuService = new MenuService();\n    //定义一个DiningTableService属性\n    private DiningTableService diningTableService = new DiningTableService();\n    //点餐的方法 成功返回true 失败false\n    //1. 生成账单\n    //2. 更新餐桌状态\n    public boolean orderMenu(int menuId, int nums, int diningTableId) &#123;\n        //生成一个账单号,UUID\n        String billId = UUID.randomUUID().toString();\n\n        //将账单生成到bill表,要求直接计算账单金额\n        int update = billDAO.update(&quot;insert into bill values(null,?,?,?,?,?,now(),&#39;未结账&#39;)&quot;,\n                billId, menuId, nums, (menuService.getMenuById(menuId).getPrice() * nums), diningTableId);\n        if(update &lt;= 0) &#123;\n            return false;\n        &#125;\n        //更新餐桌状态\n        return diningTableService.updateDiningTableState(diningTableId, &quot;就餐中&quot;);\n    &#125;\n&#125;MenuService新增方法\njava//方法,根据id,返回Menu对象\npublic Menu getMenuById(int id) &#123;\n    return menuDAO.querySingle(&quot;select * from menu where id = ?&quot;, Menu.class, id);\n&#125;DiningTableService新增方法\njava//方法,更新餐桌状态的方法\npublic boolean updateDiningTableState(int id, String state) &#123;\n    int update = diningTableDAO.update(&quot;update diningTable set state=? where id=?&quot;, state, id);\n    return update &gt; 0;\n&#125;5、MHLView在MHLView封装方法，实现点餐功能。\n验证餐桌号是否存在: 通过diningTableService.getDiningTableById可以判断餐桌是否存在。\n验证菜品编号: 通过menuService.getMenuById判断此id对应的对象是否存在\n点餐: billService.orderMenu创建账单,创建失败则返回false\njava//完成点餐\npublic void orderMenu() &#123;\n    System.out.println(&quot;==============点餐服务============&quot;);\n    System.out.print(&quot;请输入点餐的桌号(-1退出): &quot;);\n    int orderDiningTableId = Utility.readInt();\n    if (orderDiningTableId == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;请输入点餐的菜品号(-1退出): &quot;);\n    int orderMenuId = Utility.readInt();\n    if (orderMenuId == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;请输入点餐的菜品量(-1退出): &quot;);\n    int orderNums = Utility.readInt();\n    if (orderNums == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n\n    //验证餐桌号是否存在.\n    DiningTable diningTable = diningTableService.getDiningTableById(orderDiningTableId);\n    if (diningTable == null) &#123;\n        System.out.println(&quot;==============餐桌号不存在============&quot;);\n        return;\n    &#125;\n    //验证菜品编号\n    Menu menu = menuService.getMenuById(orderMenuId);\n    if (menu == null) &#123;\n        System.out.println(&quot;==============菜品号不存在============&quot;);\n        return;\n    &#125;\n\n    //点餐\n    if (orderMenu(orderMenuId, orderNums, orderDiningTableId)) &#123;\n        System.out.println(&quot;==============点餐成功============&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;==============点餐失败============&quot;);\n    &#125;\n&#125;效果演示\n\n\n8、满汉楼显示账单要求: 显示所有账单\n1、BillService新增功能java//返回所有账单\npublic List&lt;Bill&gt; list() &#123;\n    return billDAO.queryMulti(&quot;select * from bill&quot;, Bill.class);\n&#125;2、MHLViewjava//显示账单信息\npublic void listBill() &#123;\n    List&lt;Bill&gt; bills = billService.list();\n    System.out.println(&quot;\\n编号\\t\\t菜品号\\t\\t菜品量\\t\\t金额\\t\\t桌号\\t\\t日期\\t\\t\\t\\t\\t\\t\\t状态&quot;);\n    for (Bill bill : bills) &#123;\n        System.out.println(bill);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n9、满汉楼结账要求: 实现满汉楼结账\n思路分析1、对餐桌号进行校验\n2、修改bill表的state\n3、修改diningTable信息，结完账就清空\n4、不需要增加新表，不需要增加新类，需要增加方法\n1、BillService新增功能hasPayBillByDiningTableId: 查看未结账账单\npayBill: 完成结账[如果餐桌存在，并且该餐桌有未结账的账单]\njava//查看某个餐桌是否有未结账的账单\npublic boolean hasPayBillByDiningTableId(int diningTableId) &#123;\n\n    Bill bill =\n            billDAO.querySingle(&quot;SELECT * FROM bill WHERE diningTableId=? AND state = &#39;未结账&#39; LIMIT 0, 1&quot;, Bill.class, diningTableId);\n    return bill != null;\n&#125;\n//完成结账[如果餐桌存在，并且该餐桌有未结账的账单]\n//如果成功，返回true, 失败返回 false\npublic boolean payBill(int diningTableId, String payMode) &#123;\n    //如果这里使用事务的话，需要用ThreadLocal来解决 , 框架中比如mybatis 提供了事务支持\n    //1. 修改bill表\n    int update = billDAO.update(&quot;update bill set state=? where diningTableId=? and state=&#39;未结账&#39;&quot;, payMode, diningTableId);\n\n    if(update &lt;= 0) &#123; //如果更新没有成功，则表示失败...\n        return false;\n    &#125;\n    //2. 修改diningTable表\n    //注意：不要直接在这里操作，而应该调用DiningTableService 方法,完成更新，体现各司其职\n    if(!diningTableService.updateDiningTableToFree(diningTableId, &quot;空&quot;)) &#123;\n        return false;\n    &#125;\n    return true;\n&#125;2、DiningTableService新增功能updateDiningTableToFree: 将餐桌设置为空闲状态\njava//提供方法，将指定的餐桌设置为空闲状态\npublic boolean updateDiningTableToFree(int id, String state) &#123;\n    int update = diningTableDAO.update(&quot;update diningTable set state=?,orderName=&#39;&#39;,orderTel=&#39;&#39; where id=?&quot;, state, id);\n    return update &gt; 0;\n&#125;3、MHLViewMHLView封装方法完成结账\n1、判断餐桌是否存在: diningTableService.getDiningTableById\n2、判断该餐桌是否有需要结账的账单: billService.hasPayBillByDiningTableId\n3、完成结账: 调用payBill方法完成结账\njava//完成结账\npublic void payBill() &#123;\n    System.out.println(&quot;==============结账服务============&quot;);\n    System.out.print(&quot;请选择要结账的餐桌编号(-1退出): &quot;);\n    int diningTableId = Utility.readInt();\n    if (diningTableId == -1) &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n        return;\n    &#125;\n    //验证餐桌是否存在\n    DiningTable diningTable = diningTableService.getDiningTableById(diningTableId);\n    if (diningTable == null) &#123;\n        System.out.println(&quot;=============结账的餐桌不存在============&quot;);\n        return;\n    &#125;\n    //验证餐桌是否有需要结账的账单\n    if (!billService.hasPayBillByDiningTableId(diningTableId)) &#123;\n        System.out.println(&quot;=============该餐位没有未结账账单============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;结账方式(现金/支付宝/微信)回车表示退出: &quot;);\n    String payMode = Utility.readString(20, &quot;&quot;);//说明如果回车，就是返回 &quot;&quot;\n    if (&quot;&quot;.equals(payMode)) &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n        return;\n    &#125;\n    char key = Utility.readConfirmSelection();\n    if (key == &#39;Y&#39;) &#123; //结账\n\n        //调用我们写的方法\n        if (billService.payBill(diningTableId, payMode)) &#123;\n            System.out.println(&quot;=============完成结账============&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;=============结账失败============&quot;);\n        &#125;\n\n    &#125; else &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n    &#125;\n&#125;效果演示\n\n10、多表查询注意事项:  1、domain构建MultiTableBean类，属性是通过反射调用set方法赋值，因此无参构造器是必须的。\n​\t\t\t\t\t 2、不查询price值的话，price的值为null，不会对程序造成影响。\n​\t\t\t\t \t3、属性名是否一定要和表的列名保持一致。可以不一致，但是需要sql做相应的修改, 规范需要保持一致.\n细节:  如果sql语句写出如下形式，那么会通过反射找setName2方法来给MultiTableBean类中的属性赋值。因此如果两个表设计到重复名字的话，可以设置别名区分。\n例如: a表设置为name1，b表设置为name2，在MultiTableBean类中分别给name1和name2设置set和get方法就可以区分两个表。\n\n举例:\nMultiTableBean类: private String name2;\nBillSerbvice类: \njava//返回所有的账单并带有菜品名,价格， 提供给View调用\npublic List&lt;MultiTableBean&gt; list2() &#123;\n    return multiTableDAO.queryMulti(&quot;SELECT bill.*, NAME as name2,price &quot; +\n            &quot;FROM bill, menu &quot; +\n            &quot;WHERE bill.menuId = menu.id&quot;, MultiTableBean.class);\n&#125;如果如上设计，那么list2返回的表中name2就不会为null\n1、MultiTableBean类从原先的bill表新增属性，重新设计一个多表类\njavaprivate Integer id;\nprivate String billId;\nprivate Integer menuId;\nprivate Integer nums;\nprivate Double money;\nprivate Integer diningTableId;\nprivate Date billDate;\nprivate String state;\n//增加一个来自menu表的列 name\n//思考 这里的属性名是否一定要和表的列名保持一致.\n//答: 可以不一致，但是需要sql做相应的修改, 规范需要保持一致.\nprivate String name;\n//增加来自menu表的列 price\nprivate Double price;//默认值 nulll2、MultiTableDAO类javapublic class MultiTableDAO extends BasicDAO&lt;MultiTableBean&gt; &#123;&#125;3、BillService类注意:  用String连接mysql语句时要注意空格，否则sql语句不通过\njava//返回所有的账单并带有菜品名,价格， 提供给View调用\npublic List&lt;MultiTableBean&gt; list2() &#123;\n    return multiTableDAO.queryMulti(&quot;SELECT bill.*, NAME,price &quot; +\n            &quot;FROM bill, menu &quot; +\n            &quot;WHERE bill.menuId = menu.id&quot;, MultiTableBean.class);\n&#125;4、MHLView从新建的multiTableBeans类获取list集合，可获得menu表中的name和price值。\nprice值可以为null，不会对程序造成影响。\njava//显示账单信息\n    public void listBill() &#123;\n        List&lt;MultiTableBean&gt; multiTableBeans = billService.list2();\n        System.out.println(&quot;\\n编号\\t\\t菜品号\\t\\t菜品量\\t\\t金额\\t\\t桌号\\t\\t日期\\t\\t\\t\\t\\t\\t\\t状态\\t\\t菜品名\\t\\t价格&quot;);\n        for (MultiTableBean bill : multiTableBeans) &#123;\n            System.out.println(bill);\n        &#125;\n        System.out.println(&quot;==============显示完毕============&quot;);\n    &#125;效果演示\n\n\n总结1、思路路程根据程序框架图从底层开始搭建。\n1、首先设置好utils工具类，druid配置文件\n2、domain层: 例如创建Menu表对应一个domian类-Menu类。Menu类含有无参构造器-&gt;反射需要。含有Menu表该有的属性和tostring方法。\n3、DAO层: 在DAO层构建一个MenuDAO类，负责对Menu表的增删改查和特有的操作。该层的类都会继承BasicDAO类，BasicDAO中是通用的方法。\n4、service层: 构建MenuService类，负责组织sql语句，并调用MenuDAO对象完成综合的需求。\n5、View层: MHLView界面层调用service层的类，得到结果，显示数据。\n","slug":"Mysql章节满汉楼项目","date":"2023-11-24T16:25:00.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"白"},{"id":"fb7466e40a0c693c18329664f28f2eb5","title":"JDBC和数据库连接池","content":"Mysql学习笔记一、Mysql简要说明使用命令行窗口连接 MYSQL 数据库\n\n操作示意图\n\n二、创建数据库txt\\#使用指令创建数据库\n\nCREATE DATABASE hsp_db01;\n\n\\#删除数据库指令\n\nDROP DATABASE hsp_db01\n\n\\#创建一个使用 utf8 字符集的 hsp_db02 数据库\n\nCREATE DATABASE hsp_db02 CHARACTER SET utf8\n\n\\#创建一个使用 utf8 字符集，并带校对规则的 hsp_db03 数据库\n\nCREATE DATABASE hsp_db03 CHARACTER SET utf8 COLLATE utf8_bin\n\n\\#校对规则 utf8_bin 区分大小 默认 utf8_general_ci 不区分大小写\n章节: JDBC和数据库连接池一、JDBC 连接 MySQL准备工作将下载的mysql-connector-java.jar 放入在目录里面的 libs 里面（如果没有就自己创建一个，记得要打包文件）\n右键选中加载到库中\n\n\n二、介绍JDBC1、JDBC的概念 JDBC 是 Java DataBase Connectivity (Java 数据连接)技术的简称，是一种可用于执行 SQL 语句的 Java API。它由一些 java 语言编写的类和接口组成；程序员通过使用 jdbc 可以方便地将 SQL 语句传送给几乎任何一种数据库。\n2、JDBC 的功能(1) 与数据库建立连接。(2) 向数据库发送 SQL 语句并执行这些语句。(3) 处理数据返回的结果。\n3、JDBC 的常用接口和类(1) Driver 接口:加载驱动程序。(2) DriverManager 类:装人所需的 JDBC 驱动程序，编程时调用它的方法来创建连接。(3) Connection 接口:编程时使用该类对象创建 Statement 对象。(4) Statement 接口:编程时使用该类对象得到 ResultSet 对象。(5) ResultSet 类:负责保存 Statement 执行后所产生的查询结果。\n\n三、连接 MySQL小提示：\n1.mysql驱动5.1.6可以无需CLass.forName(“com.mysql.jdbc.Driver”);\n2.从jkd1.5以后使用jdbc4，不再需要显示调用class.forName()注册驱动而是自动调用驱动jar包下META-INF\\services\\java.sql.Driver文本中的类名称去注册\n3.建议还是写上Class.forName(“com.mysql.cj.jdbc.Driver”),更加明确\n\n(1)、注册驱动使用反射加载Driver类\ntxtClass.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);(2)、获取连接方法一:  DriverManager.getConnection() 传入形参 String url ,Properties info\n方法二:  DriverManager.getConnection() 传入形参 String url ,String user, String password\ntxt Connection com = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/hspeducode&quot;, &quot;root&quot;, &quot;123456&quot;);(3)、获取执行者连接txtStatement stat = com.createStatement();(4)、执行 SQL 语句，并接受结果txtString sql = &quot;SELECT * FROM user&quot;;\n\nResultSet rs = stat.executeQuery(sql);(5)、处理结果txtwhile (rs.next())&#123;\n        System.out.println(rs.getInt(&quot;id&quot;) + &quot;\\t&quot; + rs.getString(&quot;name&quot;));\n&#125;(6)、释放资源txtcom.close();\nstat.close();\ncom.close();（重要）通过不同方式连接mysql方式一：映射之后连接mysqljavapublic void connect01() throws ClassNotFoundException, SQLException &#123;\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(&quot;方式一: &quot;+connection);\n&#125;方式二：通过读取配置文件来连接mysql\njavapublic void connect02() throws IOException, ClassNotFoundException, SQLException &#123;\n    //通过Properties对象获取配置文件\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n    //获取相关的值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    String driver = properties.getProperty(&quot;driver&quot;);\n\n    Class.forName(driver);//建议写上\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(&quot;方式二: &quot; + connection);\n&#125;\n四、ResultSet[结果集]1.基本介绍1.表示数据库结果集的数据库，通常通过执行查询数据库的语句生成\n2.ResultSet对象保持一个光标指向其当前的数据行。最初，光标位于第一行之前\n3.next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环来遍历结果集\n2.ResultSet图像说明\n3.ResultSet底层\n4.代码举例演示javapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        //1. 加载驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        //创建url和user和password\n        String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n        String user = &quot;root&quot;;\n        String password = &quot;20031214gr&quot;;\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n        //3. 得到Statement\n        Statement statement = connection.createStatement();\n        //4. 组织sql\n        String sql = &quot;select id, name, sex, borndate, phone from actor&quot;;\n        //执行给定的SQL语句,该语句返回单个ResultSet对象\n        ResultSet resultSet = statement.executeQuery(sql);\n        //5. 使用while取出数据\n        while (resultSet.next()) &#123; //让光标向下移动,如果没有更多信息,返回false\n            int id = resultSet.getInt(1); //获取该行的第1列\n            String name = resultSet.getString(2); //获取该行第2列\n            String sex = resultSet.getString(3); //获取该行第3列\n            Date borndate = resultSet.getDate(4); //获取该行第4列\n            String phone = resultSet.getString(5); //获取该行第5列\n\n            System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + borndate + &quot;\\t&quot; + phone);\n        &#125;\n        //6. 关闭连接\n        resultSet.close();\n        connection.close();\n        statement.close();\n    &#125;​\t\t输出演示\ntxt1\t周星驰\t男\t1970-11-11\t110\n2\t刘德华\t男\t1970-11-11\t110\n五、Statement接口1.基本介绍\n2.sql注入​\t\t前置准备\ntxt-- 创建一张表\n\nCREATE TABLE admin ( -- 管理员表\n\nNAME VARCHAR(32) NOT NULL UNIQUE, \n\npwd VARCHAR(32) NOT NULL DEFAULT &#39;&#39;) CHARACTER SET utf8; \n\n-- 添加数据\n\nINSERT INTO admin VALUES(&#39;tom&#39;, &#39;123&#39;);​\t\t正常查询\ntxtSELECT *\n\nFROM admin\n\nWHERE NAME = &#39;tom&#39; AND pwd = &#39;123&#39;​\t\tSQL注入\ntxt-- 输入用户名 为 1&#39; or\n\n-- 输入万能密码 为 or &#39;1&#39;= &#39;1\n\nSELECT *\n\nFROM admin\n\nWHERE NAME = &#39;1&#39; OR&#39; AND pwd = &#39;OR &#39;1&#39;= &#39;1&#39; \n-- &#39;1&#39; = &#39;1&#39;一定成立,因此有隐患\n\nSELECT * FROM admin3.代码举例演示sql注入​\t\t代码内容演示\njavapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n    Scanner scanner = new Scanner(System.in);\n    //next(): 当接收到 空格 或者 &#39; 就是表示结束\n    //nextLine(): 接受到 回车 表示结束\n    System.out.print(&quot;请输入管理员的名字: &quot;);\n    String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n    System.out.print(&quot;请输入管理员的密码: &quot;);\n    String admin_pws = scanner.nextLine();\n    //1. 加载驱动\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    //3. 得到Statement\n    Statement statement = connection.createStatement();\n    //4. 组织sql\n    String sql = &quot;select name, pwd from admin where name = &#39;&quot;\n            + admin_name + &quot;&#39; and pwd = &#39;&quot; +admin_pws+ &quot;&#39;&quot;;\n    //执行给定的SQL语句,该语句返回单个ResultSet对象\n    ResultSet resultSet = statement.executeQuery(sql);\n    //5.查询表\n    if(resultSet.next()) &#123;\n        System.out.println(&quot;恭喜,登陆成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;抱歉,登录失败&quot;);\n    &#125;\n\n    //6. 关闭连接\n    resultSet.close();\n    connection.close();\n    statement.close();\n&#125;​\t\t演示sql注入的结果\n\n\n六、PreparedStatement接口[预处理]1.基本介绍\n​\t\tsql语句编写\ntxtString sql = &quot;SELECT COUNT(*) FROM admin WHERE username =? AND PASSWORD =?&quot;2.预处理的好处 \n3.代码举例演示预处理javapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n    Scanner scanner = new Scanner(System.in);\n    //next(): 当接收到 空格 或者 &#39; 就是表示结束\n    //nextLine(): 接受到 回车 表示结束\n    System.out.print(&quot;请输入管理员的名字: &quot;);\n    String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n    System.out.print(&quot;请输入管理员的密码: &quot;);\n    String admin_pws = scanner.nextLine();\n\n    //1. 加载驱动\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    //3. 得到PreparedStatement\n    //3.1 组织sql,sql语句的 ?相当于占位符\n    String sql = &quot;select name, pwd from admin where name =? and pwd =?&quot;;\n    //3.2 preparedStatement对象实现了PreparedStatement接口的实现类的对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //3.3 给?赋值\n    preparedStatement.setString(1, admin_name);\n    preparedStatement.setString(2, admin_pws);\n\n    //4. 执行select语句使用 executeQuery\n    //   如果执行的是 dml语句(update, insert, delete) executeUpdate()\n    //   这里执行executeQuery不用再写sql语句,因为已经被PreparedStatement处理过了\n    //\t 除非sql语句不含?,才可以写在executeQuery里面\n    ResultSet resultSet = preparedStatement.executeQuery();\n    //5. 查询表\n    if(resultSet.next()) &#123;\n        System.out.println(&quot;恭喜,登陆成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;抱歉,登录失败&quot;);\n    &#125;\n\n    //6. 关闭连接\n    resultSet.close();\n    preparedStatement.close();\n    connection.close();\n&#125;​\t\t演示sql注入的结果\n\n4.演示使用DML语句DML语句(update, insert, delete)使用  executeUpdate()\nselect语句使用 executeQuery()\njavapublic static void main(String[] args) throws Exception &#123;\n    //看 PreparedStatement 类图\n    Scanner scanner = new Scanner(System.in);\n    //让用户输入管理员名和密码\n    System.out.print(&quot;请输删除管理员的名字: &quot;); //next(): 当接收到 空格或者 &#39;就是表示结束\n    String admin_name = scanner.nextLine(); // 老师说明，如果希望看到 SQL 注入，这里需要用 nextLine\n    // System.out.print(&quot;请输入管理员的新密码: &quot;);\n    // String admin_pwd = scanner.nextLine();\n    //通过 Properties 对象获取配置文件的信息\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;javacode\\\\src\\\\mysql.properties&quot;));\n    //获取相关的值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String driver = properties.getProperty(&quot;driver&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    //1. 注册驱动\n    Class.forName(driver);//建议写上\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n***主要部分\n    //3. 得到 PreparedStatement\n    //3.1 组织 SqL , Sql 语句的 ? 就相当于占位符\n    //添加记录\n    //String sql = &quot;insert into admin values(?, ?)&quot;;\n    //String sql = &quot;update admin set pwd = ? where name = ?&quot;; 此刻 setString(1, admin_p)\n    String sql = &quot;delete from admin where name = ?&quot;;\n    //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //3.3 给 ? 赋值 此处要对应?赋正确的值\n    preparedStatement.setString(1, admin_name);\n    //preparedStatement.setString(2, admin_name);\n    //4. 执行 dml 语句使用 executeUpdate\n    int rows = preparedStatement.executeUpdate();\n    System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);\n***    \n    //关闭连接\n    preparedStatement.close();\n    connection.close();\n&#125;\n七、例题练习1、题目要求\n2、问题解析2.使用PreparedStatement添加5条数据javapublic class PreparedStatementwork1 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        Scanner scanner = new Scanner(System.in);\n        //next(): 当接收到 空格 或者 &#39; 就是表示结束\n        //nextLine(): 接受到 回车 表示结束\n        System.out.print(&quot;请输入管理员的名字: &quot;);\n        String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n        System.out.print(&quot;请输入管理员的密码: &quot;);\n        String admin_pws = scanner.nextLine();\n\n        //1. 加载驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n        String user = &quot;root&quot;;\n        String password = &quot;20031214gr&quot;;\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        //3. 得到PreparedStatement\n        //3.1 设置sql语句\n        String sql = &quot;insert into admin values(?, ?)&quot;;\n        //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //3.3 给 ? 赋值\n        preparedStatement.setString(1, admin_name);\n        preparedStatement.setString(2, admin_pws);\n\n        //4. 执行dml 语句使用 executeUpdate\n        int rows = preparedStatement.executeUpdate();\n        System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);\n\n        //关闭连接\n        preparedStatement.close();\n        connection.close();\n    &#125;\n&#125;3.修改tom的记录, 将username改成 kingjava//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;update admin set name = &#39;king&#39; where name =? &quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n//3.3 给 ? 赋值\npreparedStatement.setString(1, admin_name);\n\n//4. 执行dml 语句使用 executeUpdate\nint rows = preparedStatement.executeUpdate();\nSystem.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);4.删除 一条 记录java//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;delete from admin where name = ?&quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n//3.3 给 ? 赋值\npreparedStatement.setString(1, admin_name);\n\n//4. 执行dml 语句使用 executeUpdate\nint rows = preparedStatement.executeUpdate();\nSystem.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);5.查询全部记录，并显示在控制台使用select语句应该用executeQuery方法, 并且用ResultSet结果集接收, 在末尾要关闭ResultSet\njava//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;select * from admin&quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n\n//4. 执行select 语句使用 executeQuery\nResultSet resultSet = preparedStatement.executeQuery();\n\n//5. 使用while取出数据\nwhile(resultSet.next()) &#123; //让光标向下移动\n    String name = resultSet.getString(1);\n    String pwd = resultSet.getString(2);\n    System.out.println(name + &quot;\\t&quot; + pwd);\n&#125;\n//关闭连接\npreparedStatement.close();\nresultSet.close();\nconnection.close();\n八、JDBC的API小结\n\n\n九、封装 JDBC[关闭连接,得到连接]1.封装JDBCUtils[关闭连接, 得到连接]说明：在JDBC操作中，获取连接 和 释放资源 是经常使用到的，可以将其封装JDBC连接到的工具类 JDBCUtils\nJDBCUtils代码：\njavapackage com.JDBC.utils;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * 这是一个工具类,完成mysql的连接和关闭资源\n */\npublic class JDBCUtils &#123;\n    //定义相关属性(4个),只需要一份,做成static\n    private static String user; //用户名\n    private static String password; //密码\n    private static String url; //url\n    private static String driver; //驱动名\n\n    //在static代码块去初始化\n    static &#123;\n        try &#123;\n            Properties properties = new Properties();\n            properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n            //获取相关的属性值\n            user = properties.getProperty(&quot;user&quot;);\n            password = properties.getProperty(&quot;password&quot;);\n            url = properties.getProperty(&quot;url&quot;);\n            driver = properties.getProperty(&quot;driver&quot;);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n\n    //连接数据库,返回Connection\n    public static Connection getConnection() &#123;\n        try &#123;\n            return DriverManager.getConnection(url, user, password);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    //关闭相关资源\n    /*\n        1. ResultSet 结果集\n        2. Statement 或者 PreparedStatement\n        3. Connection\n        4. 如果关闭资源,就传入对象,否则传入null\n     */\n    public static void close(ResultSet set, Statement statement, Connection connection) &#123;\n        //判断是否为null\n        try &#123;\n            if(set != null) &#123;\n                set.close();\n            &#125;\n            if(statement != null) &#123;\n                statement.close();\n            &#125;\n            if(connection != null) &#123;\n                connection.close();\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;2.演示如何使用JDBCUtils类1、使用JDBCUtils执行DML语句javapublic void testDML() &#123; //insert, update, delete\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update actor set name = ? where id = ?&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null; //为了在finally关闭资源,扩大作用域\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        preparedStatement = connection.prepareStatement(sql);\n        //给占位符赋值\n        preparedStatement.setString(1, &quot;蘑菇&quot;);\n        preparedStatement.setInt(2, 1);\n        //执行sql语句 update属于 dml语句\n        preparedStatement.executeUpdate();\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        //关闭资源\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;2、使用JDBCUtils执行select语句javapublic void testSelect() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql语句\n    String sql = &quot;select * from actor&quot;;\n    //3. 创建一个PreparedStament 对象\n    PreparedStatement preparedStatement = null;\n    ResultSet resultSet = null;\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句返回一个ResultSet结果集\n        resultSet = preparedStatement.executeQuery();\n        //通过while循环取出resultSet\n        while (resultSet.next()) &#123;\n            int id = resultSet.getInt(1);\n            String name = resultSet.getString(2);\n            String sex = resultSet.getString(3);\n            Date borndate = resultSet.getDate(4);\n            String phone = resultSet.getString(5);\n            System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + borndate + &quot;\\t&quot; + phone);\n        &#125;\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        JDBCUtils.close(resultSet, preparedStatement, connection);\n    &#125;\n&#125;\n十、事务1.简要说明\n2.应用实例: 模拟经典的转账业务1.模拟数据库txt-- 创建案例表\ncreate table account(\n    id int primary key auto_increment,\n    name varchar(32) not null default &#39;&#39;,\n    balance double not null default 0)\n    character set utf8;\n-- 插入数据\ninsert into account values(null, &#39;马云&#39;, 3000);\ninsert into account values(null, &#39;马化腾&#39;, 10000);2.不使用事务可能出现的问题模拟​\t在默认情况下,connection会自动提交。当执行到 int i &#x3D; 1&#x2F;0的时候,抛出异常,则不会继续执行try块后面的内容,就会使甲方转出了钱，但是乙方没有收到钱，这显然是不合理的，因此需要使用事务处理。\njavapublic void noTransaction() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update account set balance = balance - 100 where id = 1&quot;;\n    String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null;\n    try &#123;\n        connection = JDBCUtils.getConnection(); //在默认情况下,connection会自动提交\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句\n        preparedStatement.executeUpdate();\n\n        int i = 1/0; //抛出异常\n        //执行sql2语句\n        preparedStatement = connection.prepareStatement(sql2);\n        preparedStatement.executeUpdate();\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;3.使用事务解决上述问题​\t首先，先将connection设置为不自动提交，当设置后就表示开启了事务。如果发生异常就要回滚，所以在catch块中设置connection.rollback() 该方法默认回滚到事务开始的地方。在语句全部执行完后才提交事务connection.commit()。\njavapublic void userTransaction() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update account set balance = balance - 100 where id = 1&quot;;\n    String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null;\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        //将connection设置为不自动提交\n        connection.setAutoCommit(false); //开启了事务\n\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句\n        preparedStatement.executeUpdate();\n\n        //int i = 1/0; //抛出异常\n        //执行sql2语句\n        preparedStatement = connection.prepareStatement(sql2);\n        preparedStatement.executeUpdate();\n        //提交事务\n        connection.commit();\n\n    &#125; catch (SQLException e) &#123;\n        //在这里进行回滚，即撤销执行sql\n        System.out.println(&quot;执行发生了异常,撤销执行的sql语句&quot;);\n        try &#123;\n            connection.rollback(); //默认回滚到事务开始的地方\n        &#125; catch (SQLException ex) &#123;\n            throw new RuntimeException(ex);\n        &#125;\n        e.printStackTrace();\n    &#125; finally &#123;\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;\n十一、批处理1.基本介绍\n2.批处理底层实际上是一个集合存储sql语句，满了之后扩容。  |  扩容之后如下。\n\n3.源码分析将 sql 语句加入到批处理包中 -&gt; 看源码\n1、第一就创建 ArrayList - elementData &#x3D;&gt; Object[]\n2、elementData &#x3D;&gt; Object[] 就会存放我们预处理的 sql 语句\n3、当 elementData 满后,就按照 1.5 倍扩容\n4、当添加到指定的值后，就 executeBatch\n5、批量处理会减少我们发送 sql 语句的网络开销，而且减少编译次数，因此效率提高\njavapublic void addBatch() throws SQLException &#123;\n    synchronized(this.checkClosed().getConnectionMutex()) &#123;\n    if (this.batchedArgs == null) &#123;\n        this.batchedArgs = new ArrayList();\n    &#125;\n    for(int i = 0; i &lt; this.parameterValues.length; ++i) &#123;\n        this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);\n    &#125;\n    this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));\n    &#125;\n&#125;4.使用批处理一定要在url中加入参数 ?rewriteBatchedStatements&#x3D;true\n配置文件内容:\ntxtuser=root\npassword=20031214gr\nurl=jdbc:mysql://localhost:3306/hspeducode?rewriteBatchedStatements=true\ndriver=com.mysql.cj.jdbc.Driver代码实现批处理操作sql语句\njavapublic void batch() throws SQLException &#123;\n    Connection connection = JDBCUtils.getConnection();\n    String sql = &quot;insert into admin2 values(null, ?, ?)&quot;;\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    System.out.println(&quot;开始执行&quot;);\n    long start = System.currentTimeMillis(); //开始时间\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        preparedStatement.setString(1, &quot;jack&quot;+i);\n        preparedStatement.setString(2, &quot;123&quot;);\n        //将sql语句加入到批处理包中\n        preparedStatement.addBatch();\n        //当有1000条时，再批量执行\n        if((i + 1) % 1000 == 0) &#123;\n            preparedStatement.executeBatch();\n            //清空语句\n            preparedStatement.clearBatch();\n        &#125;\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;批量处理 耗时时间: &quot; + (end - start));\n    //关闭连接\n    JDBCUtils.close(null, preparedStatement, connection);\n&#125;\n十二、数据库连接池1.提出问题问题：java程序频繁的连接数据库，需要得到多次连接\n传统连接数据库：\n\n多次连接数据库：\n\n传统方式连接mysql5000次代码模拟\njava//连接 mysql 5000 次\npublic void testCon() &#123;\n    //看看连接-关闭 connection 会耗用多久\n    long start = System.currentTimeMillis();\n    System.out.println(&quot;开始连接.....&quot;);\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //使用传统的 jdbc 方式，得到连接\n        Connection connection = JDBCUtils.getConnection();\n        //做一些工作，比如得到 PreparedStatement ，发送 sql\n        //.......... //关闭\n        JDBCUtils.close(null, null, connection);\n    &#125;\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;传统方式 5000 次 耗时=&quot; + (end - start));//传统方式 5000 次 耗时=7099\n    &#125;\n&#125;2.传统获取Connection问题分析\n3.数据库连接池基本介绍\n4.数据库连接池示意图1、当连接被占用时进入等待队列，等待连接可用。如果连接没有被占用，则可以直接获得连接，不需要等待。\n2、放回连接池是指把连接的引用断开，连接对象任然还在。\n\n5.数据库连接池的种类\n\nC3P0数据库连接池1.使用C3P0数据库连接池的准备工作添加jar包并且添加到库里。\n\n2.使用C3P0数据库连接池(代码实现)方式一: 在程序中指定user, url, password等java//方式一: 相关参数，在程序中指定user, url, password等\npublic void testC3P0_01() throws Exception &#123;\n    //1. 创建一个数据源对象\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();\n    //2. 通过配置文件(mysql.properties)获取相关连接的信息\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n    //读取相关属性值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    String diver = properties.getProperty(&quot;diver&quot;);\n\n    //给数据源 comboPooledDataSource 设置相关参数\n    //注意: 连接管理是由 comboPooledDataSource 来管理\n    comboPooledDataSource.setDriverClass(diver);\n    comboPooledDataSource.setJdbcUrl(url);\n    comboPooledDataSource.setUser(user);\n    comboPooledDataSource.setPassword(password);\n\n    //设置初始化连接数\n    comboPooledDataSource.setInitialPoolSize(10);\n    //设置最大连接数\n    comboPooledDataSource.setMaxPoolSize(50);\n    //测试连接池的效率、测试对mysql 5000次操作\n    long start = System.currentTimeMillis(); //开始时间\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //得到连接池的连接\n        Connection connection = comboPooledDataSource.getConnection(); //从DataSource接口实现的连接\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;C3P0 5000次连接mysql耗时: &quot; + (end- start)); //C3P0 5000次连接mysql耗时: 509\n&#125;方式二: 使用配置文件模板来完成1、将C3P0提供的c3p0.config.xml文件拷贝到src目录下\n2、该文件指定了连接数据库和连接池的相关参数\n3、在xml中配置好参数\njava//方式二: 使用配置文件模板来完成\n//1. 将c3p0提供的c3p0.config.xml拷贝到src目录下\n//2. 该文件指定了连接数据库和连接池的相关参数\npublic void testC3P0_02() throws SQLException &#123;\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(&quot;hsp_edu&quot;);\n    long start = System.currentTimeMillis(); //开始时间\n    //测试5000次连接mysql\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //直接连接\n        Connection connection = comboPooledDataSource.getConnection();\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;C3P0方式二 5000次连接mysql耗时: &quot; + (end -start)); //C3P0方式二 5000次连接mysql耗时: 461\n&#125;\nDruid(德鲁伊)数据库连接池1.使用Druid数据库连接池的准备工作1.添加jar包并且添加到库里。 加入配置文件druid.properties文件到src目录下\n2.配置druid.properties的参数\n2.使用Druid数据库连接池(代码实现)javapublic void testDruid() throws Exception &#123;\n    //1. 加入Druid jar包\n    //2. 加入配置文件 druid.properties, 将该文件拷贝项目的src目录\n    //3. 创建Properties对象,读取配置文件\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));\n    //4. 创建一个指定参数的数据库连接池, Druid连接池\n    DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n    long start = System.currentTimeMillis();\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //获取连接\n        Connection connection = dataSource.getConnection();\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;Druid连接池的耗时: &quot; + (end - start)); //Druid连接池的耗时: 603\n&#125;\nApache-DBUtils1.问题提出:1、关闭connection后，resultSet结果集无法使用\n2、resultSet不利于数据的管理\n3、示意图 \n因此将结果集记录封装到ArrayList&lt;&gt;集合中方便数据的管理和使用\n\n2.基本介绍\n3.准备工作略: 引入commons-dbutils-1.3.jar包到libs目录下并添加到库中\n4.代码实现​\t(要确保mysql中设置的类型和Actor类中对象类型保持一致,否则会报错)\n1、查询多行记录(返回ArrayList集合)​\t\t使用的是new BeanListHandler&lt;&gt;(Actor.class)\n​\t\t解读queryRunner.query\n(1) query方法就是执行一个sql语句得到一个resultset –封装到 –&gt; ArrayList集合中(2) 返回集合(3) connection: 连接(4) sql: 执行的sql语句(5) new BeanListHandler&lt;&gt;(Actor.class): 将resultset -取出-&gt; Actor对象 -封装-&gt; ArraryList集合.底层使用反射机制 去获取Actor类的属性,然后封装(6) 1: 就是给sql中的?赋值,可以有多个值(例如1,2,3) 因为是可变参数Object… params(7) 底层得到的resultset,会在query方法关闭,还会关闭PreparedStatement\njava//使用apache-DBUtils工具类 + druid完成对表的crud操作\npublic void testQueryMany() throws SQLException &#123; //返回结果是多行的情况\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 就可以执行相关的方法,返回ArrayList 结果集\n    String sql = &quot;select * from actor where id &gt;= 1&quot;;\n    //解读:\n    //(1) query方法就是执行一个sql语句得到一个resultset --封装到 --&gt; ArrayList集合中\n    //(2) 返回集合\n    //(3) connection: 连接\n    //(4) sql: 执行的sql语句\n    //(5) new BeanListHandler&lt;&gt;(Actor.class): 将resultset -取出-&gt; Actor对象 -封装-&gt; ArraryList集合\n    //    底层使用反射机制 去获取Actor类的属性,然后封装\n    //(6) 1: 就是给sql中的?赋值,可以有多个值(例如1,2,3) 因为是可变参数Object... params\n    //(7) 底层得到的resultset,会在query方法关闭,还会关闭PreparedStatement\n    List&lt;Actor&gt; list =\n            queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(Actor.class));\n    //迭代器遍历\n    System.out.println(&quot;输出集合的信息&quot;);\n    for (Actor actor : list) &#123;\n        System.out.println(actor);\n    &#125;\n    \n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;​\t\t输出结果\ntxt输出集合的信息\nActor&#123;id=1, name=&#39;蘑菇&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;\nActor&#123;id=2, name=&#39;刘德华&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;2、查询单行记录(返回单个对象)​\t\t使用的是new BeanHandler&lt;&gt;(Actor.class) \n​\t\t如果没有查到的话，输出actor返回的是 null\njava//演示apache-dbutils + druid 完成 返回的结果是单行记录(单个对象)\npublic void testQuerySingle() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 执行相关方法,返回单个对象\n    String sql = &quot;select * from actor where id = ?&quot;;\n    //解读:\n    //因为返回的是单行记录&lt;--&gt;单个对象, 使用的是Handler 是BeanHandler\n    Actor actor = queryRunner.query(connection, sql, new BeanHandler&lt;&gt;(Actor.class), 1);\n    System.out.println(actor);\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;​\t\t输出结果\ntxtActor&#123;id=1, name=&#39;蘑菇&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;3、查询单行单列(返回Object)​\t\t使用的是new ScalarHandler()\t输出结果:略\njava//演示apache-dbutils + druid 完成查询结果是单行单列-返回的是object\npublic void testScalar() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 执行相关方法,返回单行单列,返回的是object\n    String sql = &quot;select name from actor where id = ?&quot;;\n    //解读: 因为返回的是一个对象, 使用的handler 是 ScalarHandler\n    Object object = queryRunner.query(connection, sql, new ScalarHandler(), 1);\n    System.out.println(object);\n\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;4、DML语句操作​\t\t使用的是queryRunner.update()\n​\t\t注意事项: “小明”, 1 是用来替换 sql 中的 ? \njava//演示apache-dbutils + druid 完成 dml (update, insert, delete)\npublic void testDML() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n\n    //4. 这里组织sql 完成 updatae, insert, delete(此处只演示update)\n    String sql = &quot;update actor set name = ? where id = ?&quot;;\n    //解读:\n    //(1) 执行dml 操作是queryRunner.update()\n    //(2) 返回的值是受影响的行数\n    int affectedRow = queryRunner.update(connection, sql, &quot;小明&quot;, 1);\n    System.out.println(affectedRow &gt; 0 ? &quot;执行成功&quot; : &quot;执行sql没有影响到表&quot;);\n\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;\n表和JavaBean类型的映射关系\n\nBasicDaoDAO和增删改查的通用方法-BasicDao\n1.问题提出apache-dbutils+Druid简化了JDBC开发，但还有不足:\n1、SQL语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查。\n2、对应select操作，如果有返回值，返回类型不能固定，需要使用泛型。\n3、将来的表很多，业务需求复杂，不可能只靠一个java类完成。\n4、引出&#x3D;》 BasicDAO\n2.简单的BasicDAO示意图\n\n3.基本说明1、DAO: data access object数据访问对象\n2、这样的通用类，称为BasicDao，是专门和数据库交互的，即完成对数据库(表)的crud操作。\n3、在BaiscDao的基础上，实现一张表对应一个Dao，更好的完成功能。(比如Cusromer表-下面是代码演示)\n4.代码实现1、简单设计1.com.dao_.utils &#x2F;&#x2F;工具类\n2.com.dao_.domain &#x2F;&#x2F;javabean\n3.com.dao_.dao &#x2F;&#x2F;存放XxxDAO 和BasicDAO\n4.com.dao_.test &#x2F;&#x2F;写测试类\n2、utils包​\t\t使用了druid数据库连接池\njavapackage com.dao_.utils;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\n/**\n * 基于druid数据库连接池的工具类\n */\npublic class JDBCUtilsByDruid &#123;\n    private static DataSource ds;\n    //在静态代码块完成ds的初始化\n    static &#123;\n        Properties properties = new Properties();\n        try &#123;\n            properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));\n            ds = DruidDataSourceFactory.createDataSource(properties);\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    //编写getConnection方法\n    public static Connection getConnection() throws SQLException &#123;\n        return ds.getConnection();\n    &#125;\n    //关闭连接  在数据库连接池中,close方法不是真正断掉连接\n    // 而是把使用的Connection对象放回连接池\n    public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;\n        try &#123;\n            if(resultSet != null) &#123;\n                resultSet.close();\n            &#125;\n            if(statement != null) &#123;\n                statement.close();\n            &#125;\n            if(connection != null) &#123;\n                connection.close();\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;3、domain包javapackage com.dao_.domain;\n\nimport java.util.Date;\n\n/**\n * Actor对象和actor表的记录对应\n */\npublic class Actor &#123; //Javaben, POJO, Domain对象\n    private Integer id;\n    private String name;\n    private String sex;\n    private Date borndate;\n    private String phone;\n\n    public Actor() &#123; //一定要给一个无参构造器[反射需要]\n    &#125;\n\n    public Actor(Integer id, String name, String sex, Date borndate, String phone) &#123;\n        this.id = id;\n        this.name = name;\n        this.sex = sex;\n        this.borndate = borndate;\n        this.phone = phone;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    public Date getBorndate() &#123;\n        return borndate;\n    &#125;\n\n    public void setBorndate(Date borndate) &#123;\n        this.borndate = borndate;\n    &#125;\n\n    public String getPhone() &#123;\n        return phone;\n    &#125;\n\n    public void setPhone(String phone) &#123;\n        this.phone = phone;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Actor&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, sex=&#39;&quot; + sex + &#39;\\&#39;&#39; +\n                &quot;, borndate=&quot; + borndate +\n                &quot;, phone=&#39;&quot; + phone + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;4、dao包注意: 每个方法中返回不同类型的值所调用的API不同\n​\t\tBasicDAO类: 是其他DAO的父类 \njavapackage com.dao_.dao;\n\nimport com.JDBC.utils.JDBCUtilsByDruid;\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\n/**\n * 开发BasicDAO,是其他DAO的父类\n */\npublic class BasicDAO&lt;T&gt; &#123; //泛型指定具体类型\n    private QueryRunner qr = new QueryRunner();\n    //开发通用dml方法，针对任意的表\n    public int update(String sql, Object... parameters) &#123; //sql语句， 参数\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            //返回受影响的行数\n            int update = qr.update(connection, sql, parameters);\n            return update;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //返回多个对象(即查询的结果是多行),针对任意表\n    /**\n     * @param sql sql语句,可以有?\n     * @param clazz 传入一个类的Class对象,比如Actor.class\n     * @param parameters 传入?的具体的值,可以是多个\n     * @return 根据Actor.class 返回对应的ArrayList集合\n     */\n    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; clazz, Object...parameters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(clazz), parameters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行结果的通用方法\n    public T querySingle(String sql, Class&lt;T&gt; clazz, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(clazz), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行单列的方法,即返回单值的方法\n    public Object queryScaler(String sql, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new ScalarHandler(), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n&#125;​\t\tActorDAO类: 继承BasicDAO类\njavapackage com.dao_.dao;\n\nimport com.dao_.domain.Actor;\n\npublic class ActorDAO extends BasicDAO&lt;Actor&gt; &#123;\n    //1. 继承拥有BasicDAO的方法\n    //2. 根据业务需要，可以编写特有的方法\n&#125;5、testdao包在DAO包底层会自动把连接关闭 JDBCUtilsByDruid.close(null, null, connection);\n​\t\tTestDAO类: 演示如何使用ActorDAO对actor表进行crud操作\njavapackage com.dao_.test;\n\nimport com.dao_.dao.ActorDAO;\nimport com.dao_.domain.Actor;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\npublic class TestDAO &#123;\n    @Test\n    //测试ActorDAO 对actor表的crud操作\n    public void testActorDAO() &#123;\n        ActorDAO actorDAO = new ActorDAO();\n        //1. 查询\n        List&lt;Actor&gt; actors = actorDAO.queryMulti(&quot;select * from actor where id &gt;= ?&quot;, Actor.class, 1);\n        System.out.println(&quot;==查询结果==&quot;);\n        for (Actor actor : actors) &#123;\n            System.out.println(actor);\n        &#125;\n        //2. 查询单行记录\n        Actor actor = actorDAO.querySingle(&quot;select * from actor where id = ?&quot;, Actor.class, 2);\n        System.out.println(&quot;==查询单行结果==&quot;);\n        System.out.println(actor);\n        //3. 查询单行单列\n        Object object = actorDAO.queryScaler(&quot;select name from actor where id = ?&quot;, 1);\n        System.out.println(&quot;==查询单行单列结果==&quot;);\n        System.out.println(object);\n        //4. dml操作 insert,update, delete\n        int update = actorDAO.update(&quot;insert into actor values(null, ?, ?, ?, ?)&quot;, &quot;张飞&quot;, &quot;男&quot;, &quot;2000-11-11&quot;, &quot;9999&quot;);\n        System.out.println(update &gt; 0 ? &quot;执行成功&quot; : &quot;执行没有影响表&quot;);\n    &#125;\n&#125;","slug":"Mysql章节JDBC和数据库连接池","date":"2023-11-23T15:28:20.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"白"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deploy\nMore info: Deployment\n\n\n\n\n\n\n\n\n\n引用\n\n 任务列表\n\n\n有序列表\n3\n\n\n无须列表\n1\n\n[^脚注]: \n[链接引用]: \n[TOC]\n","slug":"hello-world","date":"2023-11-21T11:10:22.100Z","categories_index":"","tags_index":"","author_index":"白"}]