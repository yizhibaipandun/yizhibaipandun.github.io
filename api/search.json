[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deploy\nMore info: Deployment\n","slug":"hello2","date":"2023-11-23T17:18:59.472Z","categories_index":"","tags_index":"","author_index":"白"},{"id":"fb7466e40a0c693c18329664f28f2eb5","title":"JDBC和数据库连接池","content":"Mysql学习笔记一、Mysql简要说明使用命令行窗口连接 MYSQL 数据库\n\n操作示意图\n\n二、创建数据库txt\\#使用指令创建数据库\n\nCREATE DATABASE hsp_db01;\n\n\\#删除数据库指令\n\nDROP DATABASE hsp_db01\n\n\\#创建一个使用 utf8 字符集的 hsp_db02 数据库\n\nCREATE DATABASE hsp_db02 CHARACTER SET utf8\n\n\\#创建一个使用 utf8 字符集，并带校对规则的 hsp_db03 数据库\n\nCREATE DATABASE hsp_db03 CHARACTER SET utf8 COLLATE utf8_bin\n\n\\#校对规则 utf8_bin 区分大小 默认 utf8_general_ci 不区分大小写\n章节: JDBC 和数据库连接池一、JDBC 连接 MySQL准备工作将下载的mysql-connector-java.jar 放入在目录里面的 libs 里面（如果没有就自己创建一个，记得要打包文件）\n右键选中加载到库中\n\n\n二、介绍JDBC1、JDBC 的概念 JDBC 是 Java DataBase Connectivity (Java 数据连接)技术的简称，是一种可用于执行 SQL 语句的 Java API。它由一些 java 语言编写的类和接口组成；程序员通过使用 jdbc 可以方便地将 SQL 语句传送给几乎任何一种数据库。\n2、JDBC 的功能(1) 与数据库建立连接。(2) 向数据库发送 SQL 语句并执行这些语句。(3) 处理数据返回的结果。\n3、JDBC 的常用接口和类(1) Driver 接口:加载驱动程序。(2) DriverManager 类:装人所需的 JDBC 驱动程序，编程时调用它的方法来创建连接。(3) Connection 接口:编程时使用该类对象创建 Statement 对象。(4) Statement 接口:编程时使用该类对象得到 ResultSet 对象。(5) ResultSet 类:负责保存 Statement 执行后所产生的查询结果。\n\n三、连接 MySQL小提示：\n1.mysql驱动5.1.6可以无需CLass.forName(“com.mysql.jdbc.Driver”);\n2.从jkd1.5以后使用jdbc4，不再需要显示调用class.forName()注册驱动而是自动调用驱动jar包下META-INF\\services\\java.sql.Driver文本中的类名称去注册\n3.建议还是写上Class.forName(“com.mysql.cj.jdbc.Driver”),更加明确\n\n(1)、注册驱动使用反射加载Driver类\ntxtClass.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);(2)、获取连接方法一:  DriverManager.getConnection() 传入形参 String url ,Properties info\n方法二:  DriverManager.getConnection() 传入形参 String url ,String user, String password\ntxt Connection com = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/hspeducode&quot;, &quot;root&quot;, &quot;123456&quot;);(3)、获取执行者连接txtStatement stat = com.createStatement();(4)、执行 SQL 语句，并接受结果txtString sql = &quot;SELECT * FROM user&quot;;\n\nResultSet rs = stat.executeQuery(sql);(5)、处理结果txtwhile (rs.next())&#123;\n        System.out.println(rs.getInt(&quot;id&quot;) + &quot;\\t&quot; + rs.getString(&quot;name&quot;));\n&#125;(6)、释放资源txtcom.close();\nstat.close();\ncom.close();（重要）通过不同方式连接mysql方式一：映射之后连接mysqljavapublic void connect01() throws ClassNotFoundException, SQLException &#123;\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(&quot;方式一: &quot;+connection);\n&#125;方式二：通过读取配置文件来连接mysql\njavapublic void connect02() throws IOException, ClassNotFoundException, SQLException &#123;\n    //通过Properties对象获取配置文件\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n    //获取相关的值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    String driver = properties.getProperty(&quot;driver&quot;);\n\n    Class.forName(driver);//建议写上\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(&quot;方式二: &quot; + connection);\n&#125;\n四、ResultSet[结果集]1.基本介绍1.表示数据库结果集的数据库，通常通过执行查询数据库的语句生成\n2.ResultSet对象保持一个光标指向其当前的数据行。最初，光标位于第一行之前\n3.next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环来遍历结果集\n2.ResultSet图像说明\n3.ResultSet底层\n4.代码举例演示javapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        //1. 加载驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        //创建url和user和password\n        String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n        String user = &quot;root&quot;;\n        String password = &quot;20031214gr&quot;;\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n        //3. 得到Statement\n        Statement statement = connection.createStatement();\n        //4. 组织sql\n        String sql = &quot;select id, name, sex, borndate, phone from actor&quot;;\n        //执行给定的SQL语句,该语句返回单个ResultSet对象\n        ResultSet resultSet = statement.executeQuery(sql);\n        //5. 使用while取出数据\n        while (resultSet.next()) &#123; //让光标向下移动,如果没有更多信息,返回false\n            int id = resultSet.getInt(1); //获取该行的第1列\n            String name = resultSet.getString(2); //获取该行第2列\n            String sex = resultSet.getString(3); //获取该行第3列\n            Date borndate = resultSet.getDate(4); //获取该行第4列\n            String phone = resultSet.getString(5); //获取该行第5列\n\n            System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + borndate + &quot;\\t&quot; + phone);\n        &#125;\n        //6. 关闭连接\n        resultSet.close();\n        connection.close();\n        statement.close();\n    &#125;​\t\t输出演示\ntxt1\t周星驰\t男\t1970-11-11\t110\n2\t刘德华\t男\t1970-11-11\t110\n五、Statement接口1.基本介绍\n2.sql注入​\t\t前置准备\ntxt-- 创建一张表\n\nCREATE TABLE admin ( -- 管理员表\n\nNAME VARCHAR(32) NOT NULL UNIQUE, \n\npwd VARCHAR(32) NOT NULL DEFAULT &#39;&#39;) CHARACTER SET utf8; \n\n-- 添加数据\n\nINSERT INTO admin VALUES(&#39;tom&#39;, &#39;123&#39;);​\t\t正常查询\ntxtSELECT *\n\nFROM admin\n\nWHERE NAME = &#39;tom&#39; AND pwd = &#39;123&#39;​\t\tSQL注入\ntxt-- 输入用户名 为 1&#39; or\n\n-- 输入万能密码 为 or &#39;1&#39;= &#39;1\n\nSELECT *\n\nFROM admin\n\nWHERE NAME = &#39;1&#39; OR&#39; AND pwd = &#39;OR &#39;1&#39;= &#39;1&#39; \n-- &#39;1&#39; = &#39;1&#39;一定成立,因此有隐患\n\nSELECT * FROM admin3.代码举例演示sql注入​\t\t代码内容演示\njavapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n    Scanner scanner = new Scanner(System.in);\n    //next(): 当接收到 空格 或者 &#39; 就是表示结束\n    //nextLine(): 接受到 回车 表示结束\n    System.out.print(&quot;请输入管理员的名字: &quot;);\n    String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n    System.out.print(&quot;请输入管理员的密码: &quot;);\n    String admin_pws = scanner.nextLine();\n    //1. 加载驱动\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    //3. 得到Statement\n    Statement statement = connection.createStatement();\n    //4. 组织sql\n    String sql = &quot;select name, pwd from admin where name = &#39;&quot;\n            + admin_name + &quot;&#39; and pwd = &#39;&quot; +admin_pws+ &quot;&#39;&quot;;\n    //执行给定的SQL语句,该语句返回单个ResultSet对象\n    ResultSet resultSet = statement.executeQuery(sql);\n    //5.查询表\n    if(resultSet.next()) &#123;\n        System.out.println(&quot;恭喜,登陆成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;抱歉,登录失败&quot;);\n    &#125;\n\n    //6. 关闭连接\n    resultSet.close();\n    connection.close();\n    statement.close();\n&#125;​\t\t演示sql注入的结果\n\n\n六、PreparedStatement接口[预处理]1.基本介绍\n​\t\tsql语句编写\ntxtString sql = &quot;SELECT COUNT(*) FROM admin WHERE username =? AND PASSWORD =?&quot;2.预处理的好处 \n3.代码举例演示预处理javapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n    Scanner scanner = new Scanner(System.in);\n    //next(): 当接收到 空格 或者 &#39; 就是表示结束\n    //nextLine(): 接受到 回车 表示结束\n    System.out.print(&quot;请输入管理员的名字: &quot;);\n    String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n    System.out.print(&quot;请输入管理员的密码: &quot;);\n    String admin_pws = scanner.nextLine();\n\n    //1. 加载驱动\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    //3. 得到PreparedStatement\n    //3.1 组织sql,sql语句的 ?相当于占位符\n    String sql = &quot;select name, pwd from admin where name =? and pwd =?&quot;;\n    //3.2 preparedStatement对象实现了PreparedStatement接口的实现类的对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //3.3 给?赋值\n    preparedStatement.setString(1, admin_name);\n    preparedStatement.setString(2, admin_pws);\n\n    //4. 执行select语句使用 executeQuery\n    //   如果执行的是 dml语句(update, insert, delete) executeUpdate()\n    //   这里执行executeQuery不用再写sql语句,因为已经被PreparedStatement处理过了\n    //\t 除非sql语句不含?,才可以写在executeQuery里面\n    ResultSet resultSet = preparedStatement.executeQuery();\n    //5. 查询表\n    if(resultSet.next()) &#123;\n        System.out.println(&quot;恭喜,登陆成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;抱歉,登录失败&quot;);\n    &#125;\n\n    //6. 关闭连接\n    resultSet.close();\n    preparedStatement.close();\n    connection.close();\n&#125;​\t\t演示sql注入的结果\n\n4.演示使用DML语句DML语句(update, insert, delete)使用  executeUpdate()\nselect语句使用 executeQuery()\njavapublic static void main(String[] args) throws Exception &#123;\n    //看 PreparedStatement 类图\n    Scanner scanner = new Scanner(System.in);\n    //让用户输入管理员名和密码\n    System.out.print(&quot;请输删除管理员的名字: &quot;); //next(): 当接收到 空格或者 &#39;就是表示结束\n    String admin_name = scanner.nextLine(); // 老师说明，如果希望看到 SQL 注入，这里需要用 nextLine\n    // System.out.print(&quot;请输入管理员的新密码: &quot;);\n    // String admin_pwd = scanner.nextLine();\n    //通过 Properties 对象获取配置文件的信息\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;javacode\\\\src\\\\mysql.properties&quot;));\n    //获取相关的值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String driver = properties.getProperty(&quot;driver&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    //1. 注册驱动\n    Class.forName(driver);//建议写上\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n***主要部分\n    //3. 得到 PreparedStatement\n    //3.1 组织 SqL , Sql 语句的 ? 就相当于占位符\n    //添加记录\n    //String sql = &quot;insert into admin values(?, ?)&quot;;\n    //String sql = &quot;update admin set pwd = ? where name = ?&quot;; 此刻 setString(1, admin_p)\n    String sql = &quot;delete from admin where name = ?&quot;;\n    //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //3.3 给 ? 赋值 此处要对应?赋正确的值\n    preparedStatement.setString(1, admin_name);\n    //preparedStatement.setString(2, admin_name);\n    //4. 执行 dml 语句使用 executeUpdate\n    int rows = preparedStatement.executeUpdate();\n    System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);\n***    \n    //关闭连接\n    preparedStatement.close();\n    connection.close();\n&#125;\n七、例题练习1、题目要求\n2、问题解析2.使用PreparedStatement添加5条数据javapublic class PreparedStatementwork1 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        Scanner scanner = new Scanner(System.in);\n        //next(): 当接收到 空格 或者 &#39; 就是表示结束\n        //nextLine(): 接受到 回车 表示结束\n        System.out.print(&quot;请输入管理员的名字: &quot;);\n        String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n        System.out.print(&quot;请输入管理员的密码: &quot;);\n        String admin_pws = scanner.nextLine();\n\n        //1. 加载驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n        String user = &quot;root&quot;;\n        String password = &quot;20031214gr&quot;;\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        //3. 得到PreparedStatement\n        //3.1 设置sql语句\n        String sql = &quot;insert into admin values(?, ?)&quot;;\n        //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //3.3 给 ? 赋值\n        preparedStatement.setString(1, admin_name);\n        preparedStatement.setString(2, admin_pws);\n\n        //4. 执行dml 语句使用 executeUpdate\n        int rows = preparedStatement.executeUpdate();\n        System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);\n\n        //关闭连接\n        preparedStatement.close();\n        connection.close();\n    &#125;\n&#125;3.修改tom的记录, 将username改成 kingjava//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;update admin set name = &#39;king&#39; where name =? &quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n//3.3 给 ? 赋值\npreparedStatement.setString(1, admin_name);\n\n//4. 执行dml 语句使用 executeUpdate\nint rows = preparedStatement.executeUpdate();\nSystem.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);4.删除 一条 记录java//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;delete from admin where name = ?&quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n//3.3 给 ? 赋值\npreparedStatement.setString(1, admin_name);\n\n//4. 执行dml 语句使用 executeUpdate\nint rows = preparedStatement.executeUpdate();\nSystem.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);5.查询全部记录，并显示在控制台使用select语句应该用executeQuery方法, 并且用ResultSet结果集接收, 在末尾要关闭ResultSet\njava//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;select * from admin&quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n\n//4. 执行select 语句使用 executeQuery\nResultSet resultSet = preparedStatement.executeQuery();\n\n//5. 使用while取出数据\nwhile(resultSet.next()) &#123; //让光标向下移动\n    String name = resultSet.getString(1);\n    String pwd = resultSet.getString(2);\n    System.out.println(name + &quot;\\t&quot; + pwd);\n&#125;\n//关闭连接\npreparedStatement.close();\nresultSet.close();\nconnection.close();\n八、JDBC的API小结\n\n\n九、封装 JDBC[关闭连接,得到连接]1.封装JDBCUtils[关闭连接, 得到连接]说明：在JDBC操作中，获取连接 和 释放资源 是经常使用到的，可以将其封装JDBC连接到的工具类 JDBCUtils\nJDBCUtils代码：\njavapackage com.JDBC.utils;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * 这是一个工具类,完成mysql的连接和关闭资源\n */\npublic class JDBCUtils &#123;\n    //定义相关属性(4个),只需要一份,做成static\n    private static String user; //用户名\n    private static String password; //密码\n    private static String url; //url\n    private static String driver; //驱动名\n\n    //在static代码块去初始化\n    static &#123;\n        try &#123;\n            Properties properties = new Properties();\n            properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n            //获取相关的属性值\n            user = properties.getProperty(&quot;user&quot;);\n            password = properties.getProperty(&quot;password&quot;);\n            url = properties.getProperty(&quot;url&quot;);\n            driver = properties.getProperty(&quot;driver&quot;);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n\n    //连接数据库,返回Connection\n    public static Connection getConnection() &#123;\n        try &#123;\n            return DriverManager.getConnection(url, user, password);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    //关闭相关资源\n    /*\n        1. ResultSet 结果集\n        2. Statement 或者 PreparedStatement\n        3. Connection\n        4. 如果关闭资源,就传入对象,否则传入null\n     */\n    public static void close(ResultSet set, Statement statement, Connection connection) &#123;\n        //判断是否为null\n        try &#123;\n            if(set != null) &#123;\n                set.close();\n            &#125;\n            if(statement != null) &#123;\n                statement.close();\n            &#125;\n            if(connection != null) &#123;\n                connection.close();\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;2.演示如何使用JDBCUtils类1、使用JDBCUtils执行DML语句javapublic void testDML() &#123; //insert, update, delete\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update actor set name = ? where id = ?&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null; //为了在finally关闭资源,扩大作用域\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        preparedStatement = connection.prepareStatement(sql);\n        //给占位符赋值\n        preparedStatement.setString(1, &quot;蘑菇&quot;);\n        preparedStatement.setInt(2, 1);\n        //执行sql语句 update属于 dml语句\n        preparedStatement.executeUpdate();\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        //关闭资源\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;2、使用JDBCUtils执行select语句javapublic void testSelect() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql语句\n    String sql = &quot;select * from actor&quot;;\n    //3. 创建一个PreparedStament 对象\n    PreparedStatement preparedStatement = null;\n    ResultSet resultSet = null;\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句返回一个ResultSet结果集\n        resultSet = preparedStatement.executeQuery();\n        //通过while循环取出resultSet\n        while (resultSet.next()) &#123;\n            int id = resultSet.getInt(1);\n            String name = resultSet.getString(2);\n            String sex = resultSet.getString(3);\n            Date borndate = resultSet.getDate(4);\n            String phone = resultSet.getString(5);\n            System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + borndate + &quot;\\t&quot; + phone);\n        &#125;\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        JDBCUtils.close(resultSet, preparedStatement, connection);\n    &#125;\n&#125;\n十、事务1.简要说明\n2.应用实例: 模拟经典的转账业务1.模拟数据库txt-- 创建案例表\ncreate table account(\n    id int primary key auto_increment,\n    name varchar(32) not null default &#39;&#39;,\n    balance double not null default 0)\n    character set utf8;\n-- 插入数据\ninsert into account values(null, &#39;马云&#39;, 3000);\ninsert into account values(null, &#39;马化腾&#39;, 10000);2.不使用事务可能出现的问题模拟​\t在默认情况下,connection会自动提交。当执行到 int i &#x3D; 1&#x2F;0的时候,抛出异常,则不会继续执行try块后面的内容,就会使甲方转出了钱，但是乙方没有收到钱，这显然是不合理的，因此需要使用事务处理。\njavapublic void noTransaction() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update account set balance = balance - 100 where id = 1&quot;;\n    String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null;\n    try &#123;\n        connection = JDBCUtils.getConnection(); //在默认情况下,connection会自动提交\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句\n        preparedStatement.executeUpdate();\n\n        int i = 1/0; //抛出异常\n        //执行sql2语句\n        preparedStatement = connection.prepareStatement(sql2);\n        preparedStatement.executeUpdate();\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;3.使用事务解决上述问题​\t首先，先将connection设置为不自动提交，当设置后就表示开启了事务。如果发生异常就要回滚，所以在catch块中设置connection.rollback() 该方法默认回滚到事务开始的地方。在语句全部执行完后才提交事务connection.commit()。\njavapublic void userTransaction() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update account set balance = balance - 100 where id = 1&quot;;\n    String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null;\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        //将connection设置为不自动提交\n        connection.setAutoCommit(false); //开启了事务\n\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句\n        preparedStatement.executeUpdate();\n\n        //int i = 1/0; //抛出异常\n        //执行sql2语句\n        preparedStatement = connection.prepareStatement(sql2);\n        preparedStatement.executeUpdate();\n        //提交事务\n        connection.commit();\n\n    &#125; catch (SQLException e) &#123;\n        //在这里进行回滚，即撤销执行sql\n        System.out.println(&quot;执行发生了异常,撤销执行的sql语句&quot;);\n        try &#123;\n            connection.rollback(); //默认回滚到事务开始的地方\n        &#125; catch (SQLException ex) &#123;\n            throw new RuntimeException(ex);\n        &#125;\n        e.printStackTrace();\n    &#125; finally &#123;\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;\n十一、批处理1.基本介绍\n2.批处理底层实际上是一个集合存储sql语句，满了之后扩容。  |  扩容之后如下。\n\n3.源码分析将 sql 语句加入到批处理包中 -&gt; 看源码\n1、第一就创建 ArrayList - elementData &#x3D;&gt; Object[]\n2、elementData &#x3D;&gt; Object[] 就会存放我们预处理的 sql 语句\n3、当 elementData 满后,就按照 1.5 倍扩容\n4、当添加到指定的值后，就 executeBatch\n5、批量处理会减少我们发送 sql 语句的网络开销，而且减少编译次数，因此效率提高\njavapublic void addBatch() throws SQLException &#123;\n    synchronized(this.checkClosed().getConnectionMutex()) &#123;\n    if (this.batchedArgs == null) &#123;\n        this.batchedArgs = new ArrayList();\n    &#125;\n    for(int i = 0; i &lt; this.parameterValues.length; ++i) &#123;\n        this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);\n    &#125;\n    this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));\n    &#125;\n&#125;4.使用批处理一定要在url中加入参数 ?rewriteBatchedStatements&#x3D;true\n配置文件内容:\ntxtuser=root\npassword=20031214gr\nurl=jdbc:mysql://localhost:3306/hspeducode?rewriteBatchedStatements=true\ndriver=com.mysql.cj.jdbc.Driver代码实现批处理操作sql语句\njavapublic void batch() throws SQLException &#123;\n    Connection connection = JDBCUtils.getConnection();\n    String sql = &quot;insert into admin2 values(null, ?, ?)&quot;;\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    System.out.println(&quot;开始执行&quot;);\n    long start = System.currentTimeMillis(); //开始时间\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        preparedStatement.setString(1, &quot;jack&quot;+i);\n        preparedStatement.setString(2, &quot;123&quot;);\n        //将sql语句加入到批处理包中\n        preparedStatement.addBatch();\n        //当有1000条时，再批量执行\n        if((i + 1) % 1000 == 0) &#123;\n            preparedStatement.executeBatch();\n            //清空语句\n            preparedStatement.clearBatch();\n        &#125;\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;批量处理 耗时时间: &quot; + (end - start));\n    //关闭连接\n    JDBCUtils.close(null, preparedStatement, connection);\n&#125;\n十二、数据库连接池1.提出问题问题：java程序频繁的连接数据库，需要得到多次连接\n传统连接数据库：\n\n多次连接数据库：\n\n传统方式连接mysql5000次代码模拟\njava//连接 mysql 5000 次\npublic void testCon() &#123;\n    //看看连接-关闭 connection 会耗用多久\n    long start = System.currentTimeMillis();\n    System.out.println(&quot;开始连接.....&quot;);\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //使用传统的 jdbc 方式，得到连接\n        Connection connection = JDBCUtils.getConnection();\n        //做一些工作，比如得到 PreparedStatement ，发送 sql\n        //.......... //关闭\n        JDBCUtils.close(null, null, connection);\n    &#125;\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;传统方式 5000 次 耗时=&quot; + (end - start));//传统方式 5000 次 耗时=7099\n    &#125;\n&#125;2.传统获取Connection问题分析\n3.数据库连接池基本介绍\n4.数据库连接池示意图1、当连接被占用时进入等待队列，等待连接可用。如果连接没有被占用，则可以直接获得连接，不需要等待。\n2、放回连接池是指把连接的引用断开，连接对象任然还在。\n\n5.数据库连接池的种类\n\nC3P0数据库连接池1.使用C3P0数据库连接池的准备工作添加jar包并且添加到库里。\n\n2.使用C3P0数据库连接池(代码实现)方式一: 在程序中指定user, url, password等java//方式一: 相关参数，在程序中指定user, url, password等\npublic void testC3P0_01() throws Exception &#123;\n    //1. 创建一个数据源对象\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();\n    //2. 通过配置文件(mysql.properties)获取相关连接的信息\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n    //读取相关属性值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    String diver = properties.getProperty(&quot;diver&quot;);\n\n    //给数据源 comboPooledDataSource 设置相关参数\n    //注意: 连接管理是由 comboPooledDataSource 来管理\n    comboPooledDataSource.setDriverClass(diver);\n    comboPooledDataSource.setJdbcUrl(url);\n    comboPooledDataSource.setUser(user);\n    comboPooledDataSource.setPassword(password);\n\n    //设置初始化连接数\n    comboPooledDataSource.setInitialPoolSize(10);\n    //设置最大连接数\n    comboPooledDataSource.setMaxPoolSize(50);\n    //测试连接池的效率、测试对mysql 5000次操作\n    long start = System.currentTimeMillis(); //开始时间\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //得到连接池的连接\n        Connection connection = comboPooledDataSource.getConnection(); //从DataSource接口实现的连接\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;C3P0 5000次连接mysql耗时: &quot; + (end- start)); //C3P0 5000次连接mysql耗时: 509\n&#125;方式二: 使用配置文件模板来完成1、将C3P0提供的c3p0.config.xml文件拷贝到src目录下\n2、该文件指定了连接数据库和连接池的相关参数\n3、在xml中配置好参数\njava//方式二: 使用配置文件模板来完成\n//1. 将c3p0提供的c3p0.config.xml拷贝到src目录下\n//2. 该文件指定了连接数据库和连接池的相关参数\npublic void testC3P0_02() throws SQLException &#123;\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(&quot;hsp_edu&quot;);\n    long start = System.currentTimeMillis(); //开始时间\n    //测试5000次连接mysql\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //直接连接\n        Connection connection = comboPooledDataSource.getConnection();\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;C3P0方式二 5000次连接mysql耗时: &quot; + (end -start)); //C3P0方式二 5000次连接mysql耗时: 461\n&#125;\nDruid(德鲁伊)数据库连接池1.使用Druid数据库连接池的准备工作1.添加jar包并且添加到库里。 加入配置文件druid.properties文件到src目录下\n2.配置druid.properties的参数\n2.使用Druid数据库连接池(代码实现)javapublic void testDruid() throws Exception &#123;\n    //1. 加入Druid jar包\n    //2. 加入配置文件 druid.properties, 将该文件拷贝项目的src目录\n    //3. 创建Properties对象,读取配置文件\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));\n    //4. 创建一个指定参数的数据库连接池, Druid连接池\n    DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n    long start = System.currentTimeMillis();\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //获取连接\n        Connection connection = dataSource.getConnection();\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;Druid连接池的耗时: &quot; + (end - start)); //Druid连接池的耗时: 603\n&#125;\nApache-DBUtils1.问题提出:1、关闭connection后，resultSet结果集无法使用\n2、resultSet不利于数据的管理\n3、示意图 \n因此将结果集记录封装到ArrayList&lt;&gt;集合中方便数据的管理和使用\n\n2.基本介绍\n3.准备工作略: 引入commons-dbutils-1.3.jar包到libs目录下并添加到库中\n4.代码实现​\t(要确保mysql中设置的类型和Actor类中对象类型保持一致,否则会报错)\n1、查询多行记录(返回ArrayList集合)​\t\t使用的是new BeanListHandler&lt;&gt;(Actor.class)\n​\t\t解读queryRunner.query\n(1) query方法就是执行一个sql语句得到一个resultset –封装到 –&gt; ArrayList集合中(2) 返回集合(3) connection: 连接(4) sql: 执行的sql语句(5) new BeanListHandler&lt;&gt;(Actor.class): 将resultset -取出-&gt; Actor对象 -封装-&gt; ArraryList集合.底层使用反射机制 去获取Actor类的属性,然后封装(6) 1: 就是给sql中的?赋值,可以有多个值(例如1,2,3) 因为是可变参数Object… params(7) 底层得到的resultset,会在query方法关闭,还会关闭PreparedStatement\njava//使用apache-DBUtils工具类 + druid完成对表的crud操作\npublic void testQueryMany() throws SQLException &#123; //返回结果是多行的情况\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 就可以执行相关的方法,返回ArrayList 结果集\n    String sql = &quot;select * from actor where id &gt;= 1&quot;;\n    //解读:\n    //(1) query方法就是执行一个sql语句得到一个resultset --封装到 --&gt; ArrayList集合中\n    //(2) 返回集合\n    //(3) connection: 连接\n    //(4) sql: 执行的sql语句\n    //(5) new BeanListHandler&lt;&gt;(Actor.class): 将resultset -取出-&gt; Actor对象 -封装-&gt; ArraryList集合\n    //    底层使用反射机制 去获取Actor类的属性,然后封装\n    //(6) 1: 就是给sql中的?赋值,可以有多个值(例如1,2,3) 因为是可变参数Object... params\n    //(7) 底层得到的resultset,会在query方法关闭,还会关闭PreparedStatement\n    List&lt;Actor&gt; list =\n            queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(Actor.class));\n    //迭代器遍历\n    System.out.println(&quot;输出集合的信息&quot;);\n    for (Actor actor : list) &#123;\n        System.out.println(actor);\n    &#125;\n    \n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;​\t\t输出结果\ntxt输出集合的信息\nActor&#123;id=1, name=&#39;蘑菇&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;\nActor&#123;id=2, name=&#39;刘德华&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;2、查询单行记录(返回单个对象)​\t\t使用的是new BeanHandler&lt;&gt;(Actor.class) \n​\t\t如果没有查到的话，输出actor返回的是 null\njava//演示apache-dbutils + druid 完成 返回的结果是单行记录(单个对象)\npublic void testQuerySingle() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 执行相关方法,返回单个对象\n    String sql = &quot;select * from actor where id = ?&quot;;\n    //解读:\n    //因为返回的是单行记录&lt;--&gt;单个对象, 使用的是Handler 是BeanHandler\n    Actor actor = queryRunner.query(connection, sql, new BeanHandler&lt;&gt;(Actor.class), 1);\n    System.out.println(actor);\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;​\t\t输出结果\ntxtActor&#123;id=1, name=&#39;蘑菇&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;3、查询单行单列(返回Object)​\t\t使用的是new ScalarHandler()\t输出结果:略\njava//演示apache-dbutils + druid 完成查询结果是单行单列-返回的是object\npublic void testScalar() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 执行相关方法,返回单行单列,返回的是object\n    String sql = &quot;select name from actor where id = ?&quot;;\n    //解读: 因为返回的是一个对象, 使用的handler 是 ScalarHandler\n    Object object = queryRunner.query(connection, sql, new ScalarHandler(), 1);\n    System.out.println(object);\n\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;4、DML语句操作​\t\t使用的是queryRunner.update()\n​\t\t注意事项: “小明”, 1 是用来替换 sql 中的 ? \njava//演示apache-dbutils + druid 完成 dml (update, insert, delete)\npublic void testDML() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n\n    //4. 这里组织sql 完成 updatae, insert, delete(此处只演示update)\n    String sql = &quot;update actor set name = ? where id = ?&quot;;\n    //解读:\n    //(1) 执行dml 操作是queryRunner.update()\n    //(2) 返回的值是受影响的行数\n    int affectedRow = queryRunner.update(connection, sql, &quot;小明&quot;, 1);\n    System.out.println(affectedRow &gt; 0 ? &quot;执行成功&quot; : &quot;执行sql没有影响到表&quot;);\n\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;\n表和JavaBean类型的映射关系\n\nBasicDaoDAO和增删改查的通用方法-BasicDao\n1.问题提出apache-dbutils+Druid简化了JDBC开发，但还有不足:\n1、SQL语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查。\n2、对应select操作，如果有返回值，返回类型不能固定，需要使用泛型。\n3、将来的表很多，业务需求复杂，不可能只靠一个java类完成。\n4、引出&#x3D;》 BasicDAO\n2.简单的BasicDAO示意图\n\n3.基本说明1、DAO: data access object数据访问对象\n2、这样的通用类，称为BasicDao，是专门和数据库交互的，即完成对数据库(表)的crud操作。\n3、在BaiscDao的基础上，实现一张表对应一个Dao，更好的完成功能。(比如Cusromer表-下面是代码演示)\n4.代码实现1、简单设计1.com.dao_.utils &#x2F;&#x2F;工具类\n2.com.dao_.domain &#x2F;&#x2F;javabean\n3.com.dao_.dao &#x2F;&#x2F;存放XxxDAO 和BasicDAO\n4.com.dao_.test &#x2F;&#x2F;写测试类\n2、utils包​\t\t使用了druid数据库连接池\njavapackage com.dao_.utils;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\n/**\n * 基于druid数据库连接池的工具类\n */\npublic class JDBCUtilsByDruid &#123;\n    private static DataSource ds;\n    //在静态代码块完成ds的初始化\n    static &#123;\n        Properties properties = new Properties();\n        try &#123;\n            properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));\n            ds = DruidDataSourceFactory.createDataSource(properties);\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    //编写getConnection方法\n    public static Connection getConnection() throws SQLException &#123;\n        return ds.getConnection();\n    &#125;\n    //关闭连接  在数据库连接池中,close方法不是真正断掉连接\n    // 而是把使用的Connection对象放回连接池\n    public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;\n        try &#123;\n            if(resultSet != null) &#123;\n                resultSet.close();\n            &#125;\n            if(statement != null) &#123;\n                statement.close();\n            &#125;\n            if(connection != null) &#123;\n                connection.close();\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;3、domain包javapackage com.dao_.domain;\n\nimport java.util.Date;\n\n/**\n * Actor对象和actor表的记录对应\n */\npublic class Actor &#123; //Javaben, POJO, Domain对象\n    private Integer id;\n    private String name;\n    private String sex;\n    private Date borndate;\n    private String phone;\n\n    public Actor() &#123; //一定要给一个无参构造器[反射需要]\n    &#125;\n\n    public Actor(Integer id, String name, String sex, Date borndate, String phone) &#123;\n        this.id = id;\n        this.name = name;\n        this.sex = sex;\n        this.borndate = borndate;\n        this.phone = phone;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    public Date getBorndate() &#123;\n        return borndate;\n    &#125;\n\n    public void setBorndate(Date borndate) &#123;\n        this.borndate = borndate;\n    &#125;\n\n    public String getPhone() &#123;\n        return phone;\n    &#125;\n\n    public void setPhone(String phone) &#123;\n        this.phone = phone;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Actor&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, sex=&#39;&quot; + sex + &#39;\\&#39;&#39; +\n                &quot;, borndate=&quot; + borndate +\n                &quot;, phone=&#39;&quot; + phone + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;4、dao包注意: 每个方法中返回不同类型的值所调用的API不同\n​\t\tBasicDAO类: 是其他DAO的父类 \njavapackage com.dao_.dao;\n\nimport com.JDBC.utils.JDBCUtilsByDruid;\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\n/**\n * 开发BasicDAO,是其他DAO的父类\n */\npublic class BasicDAO&lt;T&gt; &#123; //泛型指定具体类型\n    private QueryRunner qr = new QueryRunner();\n    //开发通用dml方法，针对任意的表\n    public int update(String sql, Object... parameters) &#123; //sql语句， 参数\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            //返回受影响的行数\n            int update = qr.update(connection, sql, parameters);\n            return update;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //返回多个对象(即查询的结果是多行),针对任意表\n    /**\n     * @param sql sql语句,可以有?\n     * @param clazz 传入一个类的Class对象,比如Actor.class\n     * @param parameters 传入?的具体的值,可以是多个\n     * @return 根据Actor.class 返回对应的ArrayList集合\n     */\n    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; clazz, Object...parameters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(clazz), parameters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行结果的通用方法\n    public T querySingle(String sql, Class&lt;T&gt; clazz, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(clazz), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行单列的方法,即返回单值的方法\n    public Object queryScaler(String sql, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new ScalarHandler(), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n&#125;​\t\tActorDAO类: 继承BasicDAO类\njavapackage com.dao_.dao;\n\nimport com.dao_.domain.Actor;\n\npublic class ActorDAO extends BasicDAO&lt;Actor&gt; &#123;\n    //1. 继承拥有BasicDAO的方法\n    //2. 根据业务需要，可以编写特有的方法\n&#125;5、testdao包在DAO包底层会自动把连接关闭 JDBCUtilsByDruid.close(null, null, connection);\n​\t\tTestDAO类: 演示如何使用ActorDAO对actor表进行crud操作\njavapackage com.dao_.test;\n\nimport com.dao_.dao.ActorDAO;\nimport com.dao_.domain.Actor;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\npublic class TestDAO &#123;\n    @Test\n    //测试ActorDAO 对actor表的crud操作\n    public void testActorDAO() &#123;\n        ActorDAO actorDAO = new ActorDAO();\n        //1. 查询\n        List&lt;Actor&gt; actors = actorDAO.queryMulti(&quot;select * from actor where id &gt;= ?&quot;, Actor.class, 1);\n        System.out.println(&quot;==查询结果==&quot;);\n        for (Actor actor : actors) &#123;\n            System.out.println(actor);\n        &#125;\n        //2. 查询单行记录\n        Actor actor = actorDAO.querySingle(&quot;select * from actor where id = ?&quot;, Actor.class, 2);\n        System.out.println(&quot;==查询单行结果==&quot;);\n        System.out.println(actor);\n        //3. 查询单行单列\n        Object object = actorDAO.queryScaler(&quot;select name from actor where id = ?&quot;, 1);\n        System.out.println(&quot;==查询单行单列结果==&quot;);\n        System.out.println(object);\n        //4. dml操作 insert,update, delete\n        int update = actorDAO.update(&quot;insert into actor values(null, ?, ?, ?, ?)&quot;, &quot;张飞&quot;, &quot;男&quot;, &quot;2000-11-11&quot;, &quot;9999&quot;);\n        System.out.println(update &gt; 0 ? &quot;执行成功&quot; : &quot;执行没有影响表&quot;);\n    &#125;\n&#125;","slug":"Mysql章节JDBC和数据库连接池","date":"2023-11-23T15:28:20.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"白"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2023-11-21T11:10:22.100Z","categories_index":"","tags_index":"","author_index":"白"}]