[{"id":"e7c70105ffe2ca6c1f7ec0019b5a4c40","title":"JavaScript","content":"JavaScript笔记一、JS简介1.1 JS特点\n脚本语言\nJavaScript是一种解释型的脚本语言。不同于C、C++、Java等语言先编译后执行,\tJavaScript不会产生编译出来的字节码文件，而是在程序的运行过程中对源文件逐行进行解释。\n\n\n基于对象\nJavaScript能够实现封装，可以模拟继承，不支持多态，所以它不是一门面向对象的编程语言。\n\n\n弱类型\nJavaScript中也有明确的数据类型，但是声明一个变量后它可以接收任何类型的数据，并且会在程序执行过程中根据上下文自动转换类型。\n\n\n事件驱动\nJavaScript是一种采用事件驱动的脚本语言，它不需要经过Web服务器就可以对用户的输入做出响应。\n\n\n跨平台性\nJavaScript脚本语言不依赖于操作系统，仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用，前提是机器上的浏览器支持JavaScript脚本语言。目前JavaScript已被大多数的浏览器所支持。\n\n\n\n1.2 JS组成部分\nBOM编程\n\n\n\n\n\n\n\n\n\n\nBOM是Browser Object Model的简写，即浏览器对象模型。\n\nBOM有一系列对象组成，是访问、控制、修改浏览器的属性和方法\n\nBOM没有统一的标准(每种客户端都可以自定标准)。\n\nBOM编程是将浏览器窗口的各个组成部分抽象成各个对象,通过各个对象的API操作组件行为的一种编程\n\nBOM编程的对象结构如下\n\nwindow 顶级对象,代表整个浏览器窗口\nlocation对象        window对象的属性之一,代表浏览器的地址栏\nhistory对象          window对象的属性之一,代表浏览器的访问历史\nscreen对象           window对象的属性之一,代表屏幕\nnavigator对象      window对象的属性之一,代表浏览器软件本身\ndocument对象     window对象的属性之一,代表浏览器窗口目前解析的html文档\n\n\n\n\n\n\nDOM编程\n\n\n\n\n\n\n\n\n\n\n简单来说:DOM编程就是使用document对象的API完成对网页HTML文档进行动态修改,以实现网页数据和样式动态变化效果的编程.\ndocument对象代表整个html文档，可用来访问页面中的所有元素，是最复杂的一个dom对象，可以说是学习好dom编程的关键所在。\n根据HTML代码结构特点,document对象本身是一种树形结构的文档对象。\n\n\n\n上面的代码生成的树如下\n\n\n\nDOM编程其实就是用window对象的document属性的相关API完成对页面元素的控制的编程\n\n\n1.3 JS的引入方式方式一：内嵌式\t&#x3D;》\t在head中通过一对script标签定义脚本代码\n\n在页面中,通过一对script标签引入JS代码\nscript代码放置位置具备一定的随意性,一般放在head标签中居多\n\n方式二：引入外部脚本文件\t&#x3D;》\t在head中通过一对script标签引入外部JS文件\n\n内部脚本仅能在当前页面上使用,代码复用度不高\n可以将脚本放在独立的JS文件中,通过script标签引入外部脚本文件\n一对script标签要么用于定义内部脚本,要么用于引入外部js文件,不能混用！\n一个html文档中,可以有多个script标签\n\n演示两种方式\n方式一：内嵌式\n\n代码\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n        &lt;title&gt;小标题&lt;/title&gt;\n        &lt;style&gt;\n            /* 通过选择器确定样式的作用范围 */\n            .btn1 &#123;\n                display: block;\n                width: 150px; \n                height: 40px; \n                background-color: rgb(245, 241, 129); \n                color: rgb(238, 31, 31);\n                border: 3px solid rgb(238, 23, 66);\n                font-size: 22px;\n                font-family: &#39;隶书&#39;;\n                line-height: 30px;\n                border-radius: 5px;\n            &#125;\n        &lt;/style&gt;\n        &lt;script&gt;\n            function suprise()&#123;\n                alert(&quot;Hello,我是惊喜&quot;)\n            &#125;\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;button class=&quot;btn1&quot; onclick=&quot;suprise()&quot;&gt;点我有惊喜&lt;/button&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n效果\n\n\n方式二：引入外部脚本文件\n\n抽取脚本代码到独立的js文件中\n\n\n\n在html文件中,通过script标签引入外部脚本文件\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n        &lt;title&gt;小标题&lt;/title&gt;\n        &lt;style&gt;\n            /* 通过选择器确定样式的作用范围 */\n            .btn1 &#123;\n                display: block;\n                width: 150px; \n                height: 40px; \n                background-color: rgb(245, 241, 129); \n                color: rgb(238, 31, 31);\n                border: 3px solid rgb(238, 23, 66);\n                font-size: 22px;\n                font-family: &#39;隶书&#39;;\n                line-height: 30px;\n                border-radius: 5px;\n            &#125;\n        &lt;/style&gt;\n        &lt;script src=&quot;js/button.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\n    &lt;/head&gt;\n\n    &lt;body&gt;\n        &lt;button class=&quot;btn1&quot; onclick=&quot;suprise()&quot;&gt;点我有惊喜&lt;/button&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n二、JS的数据类型和运算符2.1 JS的数据类型JS是弱类型的，不是没有类型，是变量在声明时不指定类型，赋值时才确定类型，JS中的变量的声明，统统使用var。\ntxtJava: int i = 10\t\t\t\tJS:\tvar i = 10\n     String str = &quot;asdf&quot;\t\t\tvar str = &quot;asdf&quot;数值类型-number：数值类型统一为 number,不区分整数和浮点数。\n字符串类型-string：字符串类型为 string 和JAVA中的String相似,JS中不严格区分单双引号,都可以用于表示字符串\n布尔类型-boolean：布尔类型为boolean 和Java中的boolean相似,但是在JS的if语句中,非空字符串会被转换为’真’,非零数字也会被认为是’真’\n引用数据类型-Object：引用数据类型对象是Object类型, 各种对象和数组在JS中都是Object类型\nfunction类型-function：JS中的各种函数属于function数据类型\n命名未赋值-undefined：js为弱类型语言,统一使用 var声明对象和变量,在赋值时才确定真正的数据类型,变量如果只声明没有赋值的话,数据类型为undefined\n赋予NULL值-Object：在JS中,如果给一个变量赋值为null,其数据类型是Object, 可以通过typeof关键字判断数据类型\n2.2 JS的变量JS中的变量具有如下特征\n\n\n\n\n\n\n\n\n\n\n1、弱类型变量,可以统一声明成var\n2、var声明的变量可以再次声明\n3、变量可以使用不同的数据类型多次赋值\n4、JS的语句可以以; 结尾,也可以不用;结尾\n5、变量标识符严格区分大小写\n6、标识符的命名规则参照JAVA\n7、如果使用了 一个没有声明的变量,那么运行时会报uncaught ReferenceError: *** is not defined   at index.html:行号:列号\n8、如果一个变量只声明,没赋值,那么值是undefined\n\n2.3 JS的运算符\n算数运算符  + - * /  %\n其中需要注意的是 / 和 % \n/在除0时,结果是Infinity ,而不是报错\n%在模0时,结果是NaN,意思为 not a number ,而不是报错\n\n\n复合算数运算符 ++ --  += -= *= /= %=\n符合算数运算符基本和JAVA一致,同样需要注意 /=和%=\n在/=0时,结果是Infinity,而不是报错\n在%=0时,结果是NaN,意思为 not a number ,而不是报错\n\n\n关系运算符  &gt;   &lt;  &gt;= &lt;= == === !=\n需要注意的是 == 和 === 差别\n== 符号,如果两端的数据类型不一致,会尝试将两端的数据转换成number,再对比number大小\n&#39;123&#39; -&gt; 123\ntrue -&gt; 1 \nfalse -&gt;0\n\n\n===  符号,如果两端数据类型不一致,直接返回false,数据类型一致在比较是否相同\n\n\n逻辑运算符  || &amp;&amp;    \n几乎和JAVA中的一样,需要注意的是,这里直接就是短路逻辑运算符,单个的 |   和 &amp;  以及 ^ 是位运算符\n\n\n条件运算符 条件? 值1  : 值2\n几乎和JAVA中的一样\n\n\n位运算符  |  &amp;  ^  &lt;&lt;  &gt;&gt;  &gt;&gt;&gt;\n和 java中的类似(了解)\n\n\n\n代码举例演示\njsconsole.log(&#39;算数运算符&#39;)\nconsole.log(10/2)\nconsole.log(10/4)\nconsole.log(10/0)\nconsole.log(10%0)\nconsole.log(&#39;复合算数运算&#39;)\nvar i = 10\nconsole.log(i /= 0)\nconsole.log(&#39;关系运算符&#39;)\nconsole.log(1 == 1)\nconsole.log(1 == &#39;1&#39;)\nconsole.log(1 == true)效果\n在网页按F12打开控制台查看\n\n\n三、JS的流程控制和函数3.1 JS分支结构if结构\n\n这里的if结构几乎和JAVA中的一样,需要注意的是\nif()中的非空字符串会被认为是true\nif()中的非空对象会被判断为true\nif()中的非零数字会被认为是true\n\n\n\n代码\njavascriptif(&#39;false&#39;)&#123;// 非空字符串 if判断为true\n    console.log(true)\n&#125;else&#123;\n    console.log(false)\n&#125;\nif(new Object())&#123; //非空对象\n    console.log(true)\n&#125;else&#123;\n    console.log(false)\n&#125;\nif(&#39;&#39;)&#123;// 长度为0字符串 if判断为false\n    console.log(true)\n&#125;else&#123;\n    console.log(false)\n&#125;\nif(1)&#123;// 非零数字 if判断为true\n    console.log(true)\n&#125;else&#123;\n    console.log(false)\n&#125;\nif(0)&#123;\n    console.log(true)\n&#125;else&#123;\n    console.log(false)\n&#125;效果\n\nswitch结构\n\n几乎和JAVA的语法一致\n\n代码\njavascriptvar monthStr=prompt(&quot;请输入月份&quot;,&quot;例如:10 &quot;);\nvar month= Number.parseInt(monthStr)\nswitch(month)&#123;\n    case 3:\n    case 4:\n    case 5:\n        console.log(&quot;春季&quot;);\n        break;\n    case 6:\n    case 7:\n    case 8:\n        console.log(&quot;夏季&quot;);\n        break;\n    case 9:\n    case 10:\n    case 11:\n        console.log(&quot;秋季&quot;);\n        break;\n    case 1:\n    case 2:\n    case 12:\n        console.log(&quot;冬季&quot;);\n        break;\n    default :\n        console.log(&quot;月份有误&quot;)\n&#125;效果\n\n3.2 JS循环结构while结构\n\n几乎和JAVA一致\n\n代码\ndocument.write在浏览器的窗口上打印。\njavascript/* 打印99 乘法表 */\nvar i = 1;\nwhile(i &lt;= 9)&#123;\n    var j = 1;\n    while(j &lt;= i)&#123;\n        document.write(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);\n        j++;\n    &#125;\n    document.write(&quot;&lt;hr/&gt;&quot;);\n    i++;\n&#125;效果\n\nfor循环\n\n几乎和JAVA一致\n\n代码\njavascript/* 打印99 乘法表 */\nfor(  var i = 1;i &lt;= 9; i++)&#123;\n    for(var j = 1;j &lt;= i;j++)&#123;\n        document.write(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);\n    &#125;\n    document.write(&quot;&lt;hr/&gt;&quot;);\n&#125;效果\n\nforeach循环\n\n迭代数组时,和java不一样\n括号中的临时变量表示的是元素的索引,不是元素的值,\n()中也不在使用: 分隔,而是使用 in 关键字\n\n\n\n代码\njavascriptvar cities =[&quot;北京&quot;,&quot;上海&quot;,&quot;深圳&quot;,&quot;武汉&quot;,&quot;西安&quot;,&quot;成都&quot;]\ndocument.write(&quot;&lt;ul&gt;&quot;)\nfor(var index in  cities)&#123;\n    document.write(&quot;&lt;li&gt;&quot;+cities[index]+&quot;&lt;/li&gt;&quot;)\n&#125;\ndocument.write(&quot;&lt;/ul&gt;&quot;)效果\n\n3.3 JS函数声明JS中的方法,多称为函数,函数的声明语法和JAVA中有较大区别\n函数说明\n\n函数没有访问修饰符\n不用声明函数的返回值类型,需要返回在函数体中直接return即可,也无需void关键字\n参数列表中,无需数据类型\n调用函数时,实参和形参的个数可以不一致，在方法内部可以通过arguments(是个数组)获得调用时的实参\n声明函数时需要用function关键字\nJS函数没有异常列表\n函数也可以作为参数传递给另一个方法\n\n函数声明的语法\njs方式一： function 函数名(参数列表) &#123;函数体&#125;\n方式二： var 函数名 = function (参数列表) &#123;函数体&#125;代码\njavascript/* \n语法1 \n    function 函数名 (参数列表)&#123;函数体&#125;\n            */\nfunction sum(a, b)&#123;\n    return a+b;\n&#125;\nvar result =sum(10,20);\nconsole.log(result)\n\n/* \n语法2\n    var 函数名 = function (参数列表)&#123;函数体&#125;\n            */\nvar add = function(a, b)&#123;\n    return a+b;\n&#125;\nvar result = add(1,2);\nconsole.log(result);效果演示\n\n\n四、JS的对象和JSON4.1 JS声明对象的语法创建对象的语法\n方式一： new Object()\n方式二：&#123;属性名:属性值, ... ..., 函数名:function()&#123;&#125;&#125;\n代码演示\n语法1：通过new Object()直接创建对象\n注意：如果没有name属性，则添加一个name属性。\n\n代码\n\njavascriptvar person =new Object();\n// 给对象添加属性并赋值\nperson.name=&quot;张小明&quot;;\nperson.age=10;\nperson.foods=[&quot;苹果&quot;,&quot;橘子&quot;,&quot;香蕉&quot;,&quot;葡萄&quot;];\n// 给对象添加功能函数\nperson.eat= function ()&#123;\n    console.log(this.age+&quot;岁的&quot;+this.name+&quot;喜欢吃:&quot;)\n    for(var i = 0;i&lt;this.foods.length;i++)&#123;\n        console.log(this.foods[i])\n    &#125; \n&#125;\n//获得对象属性值\nconsole.log(person.name)\nconsole.log(person.age)\n//调用对象方法\nperson.eat();\n效果\n\n\n语法2：通过 &#123;&#125;形式创建对象\n语法为：var person =&#123;&quot;属性名&quot;:&quot;属性值&quot;,&quot;属性名&quot;,&quot;属性值&quot;,&quot;函数名&quot;:函数&#125;\n\n代码\n\njavascriptvar person =&#123;\n    &quot;name&quot;:&quot;张小明&quot;,\n    &quot;age&quot;:10,\n    &quot;foods&quot;:[&quot;苹果&quot;,&quot;香蕉&quot;,&quot;橘子&quot;,&quot;葡萄&quot;],\n    &quot;eat&quot;:function ()&#123;\n        console.log(this.age+&quot;岁的&quot;+this.name+&quot;喜欢吃:&quot;)\n        for(var i = 0;i&lt;this.foods.length;i++)&#123;\n            console.log(this.foods[i])\n        &#125; \n    &#125;\n&#125;\n//获得对象属性值\nconsole.log(person.name)\nconsole.log(person.age)\n//调用对象方法\nperson.eat();\n效果\n\n\n4.2 JSON格式\n\n\n\n\n\n\n\n\n JSON（JavaScript Object Notation, JS对象简谱）是一种轻量级的数据交换格式。它基于ECMAScript（European Computer Manufacturers Association, 欧洲计算机协会的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率 简单来说,JSON 就是一种字符串格式,这种格式无论是在前端还是在后端,都可以很容易的转换成对象,所以常用于前后端数据传递\n说明\n\nJSON的语法：var obj=&quot;&#123;&#39;属性名&#39;:&#39;属性值&#39;,&#39;属性名&#39;:&#123;&#39;属性名&#39;:&#39;属性值&#39;&#125;,&#39;属性名&#39;:[&#39;值1&#39;,&#39;值1&#39;,&#39;值3&#39;]&#125;&quot;\n\nJSON字符串一般用于传递数据,所以字符串中的函数就显得没有意义,在此不做研究\n\n通过JSON.parse()方法可以将一个JSON串转换成对象\n\n通过JSON.stringify()方法可以将一个对象转换成一个JSON格式的字符串\n\n\nJSON在客户端的使用\n\n代码\n\njavascript/* 定义一个JSON串 */\nvar personStr =&#39;&#123;&quot;name&quot;:&quot;张小明&quot;,&quot;age&quot;:20,&quot;girlFriend&quot;:&#123;&quot;name&quot;:&quot;铁铃&quot;,&quot;age&quot;:23&#125;,&quot;foods&quot;:[&quot;苹果&quot;,&quot;香蕉&quot;,&quot;橘子&quot;,&quot;葡萄&quot;],&quot;pets&quot;:[&#123;&quot;petName&quot;:&quot;大黄&quot;,&quot;petType&quot;:&quot;dog&quot;&#125;,&#123;&quot;petName&quot;:&quot;小花&quot;,&quot;petType&quot;:&quot;cat&quot;&#125;]&#125;&#39;\nconsole.log(personStr)\nconsole.log(typeof personStr)\n/* 将一个JSON串转换为对象 */\nvar person =JSON.parse(personStr);\nconsole.log(person)\nconsole.log(typeof person)\n/* 获取对象属性值 */\nconsole.log(person.name)\nconsole.log(person.age)\nconsole.log(person.girlFriend.name)\nconsole.log(person.foods[1])\nconsole.log(person.pets[1].petName)\nconsole.log(person.pets[1].petType)javascript/* 定义一个对象 */\nvar person=&#123;\n    &#39;name&#39;:&#39;张小明&#39;,\n    &#39;age&#39;:20,\n    &#39;girlFriend&#39;:&#123;\n        &#39;name&#39;:&#39;铁铃&#39;,\n        &#39;age&#39;:23\n    &#125;,\n    &#39;foods&#39;:[&#39;苹果&#39;,&#39;香蕉&#39;,&#39;橘子&#39;,&#39;葡萄&#39;],\n    &#39;pets&#39;:[\n        &#123;\n            &#39;petName&#39;:&#39;大黄&#39;,\n            &#39;petType&#39;:&#39;dog&#39;\n        &#125;,\n        &#123;\n            &#39;petName&#39;:&#39;小花&#39;,\n            &#39;petType&#39;:&#39;cat&#39;\n        &#125;\n    ]\n&#125;\n\n/* 获取对象属性值 */\nconsole.log(person.name)\nconsole.log(person.age)\nconsole.log(person.girlFriend.name)\nconsole.log(person.foods[1])\nconsole.log(person.pets[1].petName)\nconsole.log(person.pets[1].petType)\n/* 将对象转换成JSON字符串 */\nvar personStr =JSON.stringify(person)\nconsole.log(personStr)\nconsole.log(typeof personStr)JSON在服务端的使用\njavapublic void testWriteJson() throws JsonProcessingException &#123;\n    //实例化Person对象，将Person对象转换成JSON串\n    Dog dog = new Dog(&quot;小黄&quot;);\n    Person person = new Person(&quot;张三&quot;, 10, dog);\n\n    //将Person对象转换成一个字符串 Gson Jackson Fastjson\n    ObjectMapper objectMapper = new ObjectMapper();\n    String personStr = objectMapper.writeValueAsString(person);\n    System.out.println(personStr); \n    //输出结果: &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:10,&quot;dog&quot;:&#123;&quot;name&quot;:&quot;小黄&quot;&#125;&#125;\n&#125;\npublic void testReadJson() throws JsonProcessingException &#123;\n    String personStr = &quot;&#123;\\&quot;name\\&quot;:\\&quot;张三\\&quot;,\\&quot;age\\&quot;:10,\\&quot;dog\\&quot;:&#123;\\&quot;name\\&quot;:\\&quot;小黄\\&quot;&#125;&#125;&quot;;\n    ObjectMapper objectMapper = new ObjectMapper();\n    Person person = objectMapper.readValue(personStr, Person.class);\n    System.out.println(person); //可设置断点查看person的值\n&#125;JSON和Map_List_Array之间的转换\n\nmap\n\njavapublic void testMapToJson() throws JsonProcessingException &#123;\n    Map data = new HashMap&lt;&gt;();\n    data.put(&quot;a&quot;, &quot;valuea&quot;);\n    data.put(&quot;b&quot;, &quot;valueb&quot;);\n\n    ObjectMapper objectMapper = new ObjectMapper();\n    String s = objectMapper.writeValueAsString(data);\n    System.out.println(s);\n&#125;\n输出结果： &#123;&quot;a&quot;:&quot;valuea&quot;,&quot;b&quot;:&quot;valueb&quot;&#125;\nlist &#x2F; array\n\nlist和array打印的值是一样的，因此前端可能收到此类的值有两种情况。\njavapublic void testListToJson() throws JsonProcessingException &#123;\n//1、     List data = new ArrayList&lt;&gt;();\n//        data.add(&quot;a&quot;);\n//        data.add(&quot;b&quot;);\n//        data.add(&quot;c&quot;);\n//2、     String[] data = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;\n//3、\n    Dog dog = new Dog(&quot;小黄&quot;);\n    Person person = new Person(&quot;张三&quot;, 10, dog);\n    List data = new ArrayList&lt;&gt;();\n    data.add(person);\n\n    ObjectMapper objectMapper = new ObjectMapper();\n    String s = objectMapper.writeValueAsString(data);\n    System.out.println(s);\n&#125;\n输出结果：\n    1：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n    2：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n    3：[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:10,&quot;dog&quot;:&#123;&quot;name&quot;:&quot;小黄&quot;&#125;&#125;]前后端传递数据\n\n4.3 JS常见对象4.3.1 数组\n\n\n\n\n\n\n\n\n创建数组的四种方式\n\nnew Array()                                                   创建空数组\nnew Array(5)                                                 创建数组时给定长度\nnew Array(ele1,ele2,ele3,... ... ,elen);          创建数组时指定元素值\n[ele1,ele2,ele3,... ... ,elen];                           相当于第三种语法的简写\n\n\n\n\n\n\n\n\n\n\n数组的常见API\n\n在JS中,数组属于Object类型,其长度是可以变化的,更像JAVA中的集合\n\n\n\n\n方法\n描述\n\n\n\nconcat()\n连接两个或更多的数组，并返回结果。\n\n\ncopyWithin()\n从数组的指定位置拷贝元素到数组的另一个指定位置中。\n\n\nentries()\n返回数组的可迭代对象。\n\n\nevery()\n检测数值元素的每个元素是否都符合条件。\n\n\nfill()\n使用一个固定值来填充数组。\n\n\nfilter()\n检测数值元素，并返回符合条件所有元素的数组。\n\n\nfind()\n返回符合传入测试（函数）条件的数组元素。\n\n\nfindIndex()\n返回符合传入测试（函数）条件的数组元素索引。\n\n\nforEach()\n数组每个元素都执行一次回调函数。\n\n\nfrom()\n通过给定的对象中创建一个数组。\n\n\nincludes()\n判断一个数组是否包含一个指定的值。\n\n\nindexOf()\n搜索数组中的元素，并返回它所在的位置。\n\n\nisArray()\n判断对象是否为数组。\n\n\njoin()\n把数组的所有元素放入一个字符串。\n\n\nkeys()\n返回数组的可迭代对象，包含原始数组的键(key)。\n\n\nlastIndexOf()\n搜索数组中的元素，并返回它最后出现的位置。\n\n\nmap()\n通过指定函数处理数组的每个元素，并返回处理后的数组。\n\n\npop()\n删除数组的最后一个元素并返回删除的元素。\n\n\npush()\n向数组的末尾添加一个或更多元素，并返回新的长度。\n\n\nreduce()\n将数组元素计算为一个值（从左到右）。\n\n\nreduceRight()\n将数组元素计算为一个值（从右到左）。\n\n\nreverse()\n反转数组的元素顺序。\n\n\nshift()\n删除并返回数组的第一个元素。\n\n\nslice()\n选取数组的一部分，并返回一个新数组。\n\n\nsome()\n检测数组元素中是否有元素符合指定条件。\n\n\nsort()\n对数组的元素进行排序。\n\n\nsplice()\n从数组中添加或删除元素。\n\n\ntoString()\n把数组转换为字符串，并返回结果。\n\n\nunshift()\n向数组的开头添加一个或更多元素，并返回新的长度。\n\n\nvalueOf()\n返回数组对象的原始值。\n\n\nArray.of()\n将一组值转换为数组。\n\n\nArray.at()\n用于接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。\n\n\nArray.flat()\n创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。\n\n\nArray.flatMap()\n使用映射函数映射每个元素，然后将结果压缩成一个新数组。\n\n\n4.3.2 Boolean对象\n\n\n\n\n\n\n\n\nboolean对象的方法比较简单\n\n\n\n方法\n描述\n\n\n\ntoString()\n把布尔值转换为字符串，并返回结果。\n\n\nvalueOf()\n返回 Boolean 对象的原始值。\n\n\n4.3.3 Date对象\n\n\n\n\n\n\n\n\n和JAVA中的Date类比较类似\n\n\n\n方法\n描述\n\n\n\ngetDate()\n从 Date 对象返回一个月中的某一天 (1 ~ 31)。\n\n\ngetDay()\n从 Date 对象返回一周中的某一天 (0 ~ 6)。\n\n\ngetFullYear()\n从 Date 对象以四位数字返回年份。\n\n\ngetHours()\n返回 Date 对象的小时 (0 ~ 23)。\n\n\ngetMilliseconds()\n返回 Date 对象的毫秒(0 ~ 999)。\n\n\ngetMinutes()\n返回 Date 对象的分钟 (0 ~ 59)。\n\n\ngetMonth()\n从 Date 对象返回月份 (0 ~ 11)。\n\n\ngetSeconds()\n返回 Date 对象的秒数 (0 ~ 59)。\n\n\ngetTime()\n返回 1970 年 1 月 1 日至今的毫秒数。\n\n\ngetTimezoneOffset()\n返回本地时间与格林威治标准时间 (GMT) 的分钟差。\n\n\ngetUTCDate()\n根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。\n\n\ngetUTCDay()\n根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。\n\n\ngetUTCFullYear()\n根据世界时从 Date 对象返回四位数的年份。\n\n\ngetUTCHours()\n根据世界时返回 Date 对象的小时 (0 ~ 23)。\n\n\ngetUTCMilliseconds()\n根据世界时返回 Date 对象的毫秒(0 ~ 999)。\n\n\ngetUTCMinutes()\n根据世界时返回 Date 对象的分钟 (0 ~ 59)。\n\n\ngetUTCMonth()\n根据世界时从 Date 对象返回月份 (0 ~ 11)。\n\n\ngetUTCSeconds()\n根据世界时返回 Date 对象的秒钟 (0 ~ 59)。\n\n\ngetYear()\n已废弃。 请使用 getFullYear() 方法代替。\n\n\nparse()\n返回1970年1月1日午夜到指定日期（字符串）的毫秒数。\n\n\nsetDate()\n设置 Date 对象中月的某一天 (1 ~ 31)。\n\n\nsetFullYear()\n设置 Date 对象中的年份（四位数字）。\n\n\nsetHours()\n设置 Date 对象中的小时 (0 ~ 23)。\n\n\nsetMilliseconds()\n设置 Date 对象中的毫秒 (0 ~ 999)。\n\n\nsetMinutes()\n设置 Date 对象中的分钟 (0 ~ 59)。\n\n\nsetMonth()\n设置 Date 对象中月份 (0 ~ 11)。\n\n\nsetSeconds()\n设置 Date 对象中的秒钟 (0 ~ 59)。\n\n\nsetTime()\nsetTime() 方法以毫秒设置 Date 对象。\n\n\nsetUTCDate()\n根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。\n\n\nsetUTCFullYear()\n根据世界时设置 Date 对象中的年份（四位数字）。\n\n\nsetUTCHours()\n根据世界时设置 Date 对象中的小时 (0 ~ 23)。\n\n\nsetUTCMilliseconds()\n根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。\n\n\nsetUTCMinutes()\n根据世界时设置 Date 对象中的分钟 (0 ~ 59)。\n\n\nsetUTCMonth()\n根据世界时设置 Date 对象中的月份 (0 ~ 11)。\n\n\nsetUTCSeconds()\nsetUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段。\n\n\nsetYear()\n已废弃。请使用 setFullYear() 方法代替。\n\n\ntoDateString()\n把 Date 对象的日期部分转换为字符串。\n\n\ntoGMTString()\n已废弃。请使用 toUTCString() 方法代替。\n\n\ntoISOString()\n使用 ISO 标准返回字符串的日期格式。\n\n\ntoJSON()\n以 JSON 数据格式返回日期字符串。\n\n\ntoLocaleDateString()\n根据本地时间格式，把 Date 对象的日期部分转换为字符串。\n\n\ntoLocaleTimeString()\n根据本地时间格式，把 Date 对象的时间部分转换为字符串。\n\n\ntoLocaleString()\n根据本地时间格式，把 Date 对象转换为字符串。\n\n\ntoString()\n把 Date 对象转换为字符串。\n\n\ntoTimeString()\n把 Date 对象的时间部分转换为字符串。\n\n\ntoUTCString()\n根据世界时，把 Date 对象转换为字符串。实例：var today = new Date(); var UTCstring = today.toUTCString();\n\n\nUTC()\n根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。\n\n\nvalueOf()\n返回 Date 对象的原始值。\n\n\n4.3.4 Math\n\n\n\n\n\n\n\n\n 和JAVA中的Math类比较类似\n\n\n\n方法\n描述\n\n\n\nabs(x)\n返回 x 的绝对值。\n\n\nacos(x)\n返回 x 的反余弦值。\n\n\nasin(x)\n返回 x 的反正弦值。\n\n\natan(x)\n以介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间的数值来返回 x 的反正切值。\n\n\natan2(y,x)\n返回从 x 轴到点 (x,y) 的角度（介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间）。\n\n\nceil(x)\n对数进行上舍入。\n\n\ncos(x)\n返回数的余弦。\n\n\nexp(x)\n返回 Ex 的指数。\n\n\nfloor(x)\n对 x 进行下舍入。\n\n\nlog(x)\n返回数的自然对数（底为e）。\n\n\nmax(x,y,z,…,n)\n返回 x,y,z,…,n 中的最高值。\n\n\nmin(x,y,z,…,n)\n返回 x,y,z,…,n中的最低值。\n\n\npow(x,y)\n返回 x 的 y 次幂。\n\n\nrandom()\n返回 0 ~ 1 之间的随机数。\n\n\nround(x)\n四舍五入。\n\n\nsin(x)\n返回数的正弦。\n\n\nsqrt(x)\n返回数的平方根。\n\n\ntan(x)\n返回角的正切。\n\n\ntanh(x)\n返回一个数的双曲正切函数值。\n\n\ntrunc(x)\n将数字的小数部分去掉，只保留整数部分。\n\n\n4.3.5 Number\n\n\n\n\n\n\n\n\nNumber中准备了一些基础的数据处理函数\n\n\n\n方法\n描述\n\n\n\nisFinite\n检测指定参数是否为无穷大。\n\n\nisInteger\n检测指定参数是否为整数。\n\n\nisNaN\n检测指定参数是否为 NaN。\n\n\nisSafeInteger\n检测指定参数是否为安全整数。\n\n\ntoExponential(x)\n把对象的值转换为指数计数法。\n\n\ntoFixed(x)\n把数字转换为字符串，结果的小数点后有指定位数的数字。\n\n\ntoLocaleString(locales, options)\n返回数字在特定语言环境下的表示字符串。\n\n\ntoPrecision(x)\n把数字格式化为指定的长度。\n\n\ntoString()\n把数字转换为字符串，使用指定的基数。\n\n\nvalueOf()\n返回一个 Number 对象的基本数字值。\n\n\n4.3.6 String\n\n\n\n\n\n\n\n\n和JAVA中的String类似\n\n\n\n方法\n描述\n\n\n\ncharAt()\n返回在指定位置的字符。\n\n\ncharCodeAt()\n返回在指定的位置的字符的 Unicode 编码。\n\n\nconcat()\n连接两个或更多字符串，并返回新的字符串。\n\n\nendsWith()\n判断当前字符串是否是以指定的子字符串结尾的（区分大小写）。\n\n\nfromCharCode()\n将 Unicode 编码转为字符。\n\n\nindexOf()\n返回某个指定的字符串值在字符串中首次出现的位置。\n\n\nincludes()\n查找字符串中是否包含指定的子字符串。\n\n\nlastIndexOf()\n从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。\n\n\nmatch()\n查找找到一个或多个正则表达式的匹配。\n\n\nrepeat()\n复制字符串指定次数，并将它们连接在一起返回。\n\n\nreplace()\n在字符串中查找匹配的子串，并替换与正则表达式匹配的子串。\n\n\nreplaceAll()\n在字符串中查找匹配的子串，并替换与正则表达式匹配的所有子串。\n\n\nsearch()\n查找与正则表达式相匹配的值。\n\n\nslice()\n提取字符串的片断，并在新的字符串中返回被提取的部分。\n\n\nsplit()\n把字符串分割为字符串数组。\n\n\nstartsWith()\n查看字符串是否以指定的子字符串开头。\n\n\nsubstr()\n从起始索引号提取字符串中指定数目的字符。\n\n\nsubstring()\n提取字符串中两个指定的索引号之间的字符。\n\n\ntoLowerCase()\n把字符串转换为小写。\n\n\ntoUpperCase()\n把字符串转换为大写。\n\n\ntrim()\n去除字符串两边的空白。\n\n\ntoLocaleLowerCase()\n根据本地主机的语言环境把字符串转换为小写。\n\n\ntoLocaleUpperCase()\n根据本地主机的语言环境把字符串转换为大写。\n\n\nvalueOf()\n返回某个字符串对象的原始值。\n\n\ntoString()\n返回一个字符串。\n\n\n\n五、事件的绑定(重要)5.1 什么是事件\n\n\n\n\n\n\n\n\n HTML 事件可以是浏览器行为，也可以是用户行为。 当这些一些行为发生时,可以自动触发对应的JS函数的运行,我们称之为事件发生.JS的事件驱动指的就是行为触发代码运行的这种特点\n5.2 常见事件\n\n\n\n\n\n\n\n\n鼠标事件\n\n\n\n属性\n描述\n\n\n\nonclick\n当用户点击某个对象时调用的事件句柄。\n\n\noncontextmenu\n在用户点击鼠标右键打开上下文菜单时触发\n\n\nondblclick\n当用户双击某个对象时调用的事件句柄。\n\n\nonmousedown\n鼠标按钮被按下。\n\n\nonmouseenter\n当鼠标指针移动到元素上时触发。\n\n\nonmouseleave\n当鼠标指针移出元素时触发\n\n\nonmousemove\n鼠标被移动。\n\n\nonmouseover\n鼠标移到某元素之上。\n\n\nonmouseout\n鼠标从某元素移开。\n\n\nonmouseup\n鼠标按键被松开。\n\n\n\n\n\n\n\n\n\n\n\n键盘事件\n\n\n\n属性\n描述\n\n\n\nonkeydown\n某个键盘按键被按下。\n\n\nonkeypress\n某个键盘按键被按下并松开。\n\n\nonkeyup\n某个键盘按键被松开。\n\n\n\n\n\n\n\n\n\n\n\n表单事件\n\n\n\n属性\n描述\n\n\n\nonblur\n元素失去焦点时触发\n\n\nonchange\n该事件在表单元素的内容改变时触发( &lt;input&gt;, &lt;keygen&gt;, &lt;select&gt;, 和 &lt;textarea&gt;)\n\n\nonfocus\n元素获取焦点时触发\n\n\nonfocusin\n元素即将获取焦点时触发\n\n\nonfocusout\n元素即将失去焦点时触发\n\n\noninput\n元素获取用户输入时触发\n\n\nonreset\n表单重置时触发\n\n\nonsearch\n用户向搜索域输入文本时触发 ( &lt;input&#x3D;”search”&gt;)\n\n\nonselect\n用户选取文本时触发 ( &lt;input&gt; 和 &lt;textarea&gt;)\n\n\nonsubmit\n表单提交时触发\n\n\n5.3 事件的绑定事件的绑定方式\n\n\n\n\n\n\n\n\n\n1、通过元素的属性绑定\ton***\n\n通过事件属性绑定函数,在行为发生时会自动执行函数\n\n一个事件可以同时绑定多个函数\n\n一个元素可以同时绑定多个事件\n\n方法中可以传入 this对象,代表当前元素\n\n\n2、通过DOM编程动态绑定\n弹窗的三种方式\n\nalert()：信息提示框\nprompt：信息输入框\nconfirm：信息确认框\n\n常见的事件(演示内容)\n\n鼠标事件：onclick鼠标单击，ondbclick鼠标双击，onmouseover鼠标悬停，onmousemove鼠标移动，onmouseleave鼠标离开\n键盘事件：onkeydown键盘按下，onkeyup键盘松开\n表单事件：onreset表单提交，onsubmit表单重置\n页面加载事件：onload针对浏览器页面加载\n\n代码实现\n\n\n\n\n\n\n\n\n\n1、通过元素的属性绑定\n&lt;head&gt;标签部分\n\nevent.preventDefault() ：可以阻止组件的默认行为。\n也可以通过confirm获取提交表单的信息，通过返回的信息trueorfalse来决定是否阻止提交表单的行为。需要注意在&lt;form&gt;表单标签内对应的函数位置写上return。\n\nhtml&lt;script&gt;\n        function fun1()&#123;\n            console.log(&quot;按钮被点击了&quot;)\n        &#125;\n        function fun2()&#123;\n            console.log(&quot;鼠标单击了&quot;)\n        &#125;\n        function fun3()&#123;\n            console.log(&quot;鼠标双击了&quot;)\n        &#125;\n        function fun4()&#123;\n            console.log(&quot;鼠标悬停&quot;)\n        &#125;\n        function fun5()&#123;\n            console.log(&quot;鼠标移动&quot;)\n        &#125;\n        function fun6()&#123;\n            console.log(&quot;鼠标离开&quot;)\n        &#125;\n        function fun7()&#123;\n            console.log(&quot;按键按下&quot;)\n        &#125;\n        function fun8()&#123;\n            console.log(&quot;按键抬起&quot;)\n        &#125;\n        function testFoucs()&#123;\n            console.log(&quot;获得焦点&quot;)\n        &#125;\n        function testBlur()&#123;\n            console.log(&quot;失去焦点&quot;)\n        &#125;\n        function testChange(value)&#123;\n            console.log(&quot;内容改变为:&quot;+value)\n        &#125;\n        function testChange2(value)&#123;\n            console.log(&quot;选项改变为:&quot;+value)\n        &#125;\n        function testSubmit()&#123;\n            //alert(&quot;表单发生了提交&quot;)\n            //在这里可以阻止表单的提交\n            //event.preventDefault() //阻止组件的默认行为\n            var flag = confirm(&quot;你确定要提交吗?&quot;)\n            if(!flag)&#123;\n                return false\n            &#125;\n            return true\n        &#125;\n        function testReset()&#123;\n            alert(&quot;表单发生了重置&quot;)\n        &#125;\n&lt;/script&gt;&lt;body&gt;标签部分\nhtml&lt;body&gt;\n    &lt;form action=&quot;01JS的引入方式.html&quot; method=&quot;get&quot; onreset=&quot;testReset()&quot; onsubmit=&quot;return testSubmit()&quot;&gt;\n        用户昵称:&lt;input \n            type=&quot;text&quot; \n            name=&quot;realName&quot; \n            onfocus=&quot;testFoucs()&quot;\n            onblur=&quot;testBlur()&quot;\n            onchange=&quot;testChange(this.value)&quot;\n            &gt; &lt;br&gt;\n        登录账号:&lt;input type=&quot;text&quot; name=&quot;loginName&quot;&gt; &lt;br&gt;\n        选择籍贯:\n            &lt;select onchange=&quot;testChange2(this.value)&quot;&gt;\n                &lt;option value=&quot;1&quot;&gt;湖北&lt;/option&gt;\n                &lt;option value=&quot;2&quot;&gt;湖南&lt;/option&gt;\n                &lt;option value=&quot;3&quot;&gt;广东&lt;/option&gt;\n            &lt;/select&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;\n        &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;\n    &lt;/form&gt;\n    \n    &lt;input \n        type=&quot;button&quot; \n        value=&quot;按钮&quot; \n        onclick = &quot;fun1(),fun2()&quot;\n        ondblclick=&quot;fun3()&quot;\n    &gt; \n    &lt;input type=&quot;text&quot; onkeydown=&quot;fun7()&quot; onkeyup=&quot;fun8()&quot;&gt;\n    &lt;br&gt;\n    \n    &lt;img src=&quot;img/logo.png&quot; onmouseover=&quot;fun4()&quot; onmousemove=&quot;fun5()&quot; onmouseleave=&quot;fun6()&quot; &gt;\n&lt;/body&gt;效果\n\n\n\n\n\n\n\n\n\n\n2、通过DOM编程绑定\n因为程序是从上往下执行的，当执行script中的var btn = document.getElementById(&quot;btn1&quot;)时，btn得到的值为NULL。因此需要用到页面加载事件，在函数设置页面加载就能够解决问题。\n代码实现\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script&gt;\n        window.onload=function()&#123;\n            //通过dom获得要操作的元素\n            var btn = document.getElementById(&quot;btn1&quot;);\n            btn.onclick=function()&#123;\n                alert(&quot;你点击了按钮&quot;);\n            &#125;\n        &#125;\n    &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id = &quot;d1&quot; class=&quot;div1&quot;&gt;&lt;/div&gt;\n\n    &lt;button id = &quot;btn1&quot;&gt;按钮&lt;/button&gt;\n&lt;/body&gt;\n&lt;/html&gt;效果\n\n5.4 事件的触发\n\n\n\n\n\n\n\n\n\n行为触发：事件绑定中已有演示。略\nDOM编程触发\n\n通过DOM编程,用代码触发,执行某些代码相当于发生了某些行为\n代码实现\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script&gt;\n        window.onload=function()&#123;\n            //为div1绑定单击事件\n            var div1 = document.getElementById(&quot;d1&quot;);\n            div1.onclick=function()&#123;\n                div1.style.backgroundColor=&quot;red&quot;;\n            &#125;\n\n            //通过dom获得要操作的元素\n            var btn = document.getElementById(&quot;btn1&quot;);\n            btn.onclick=function()&#123;\n                alert(&quot;你点击了按钮&quot;);\n                //通过DOM编程触发div的单击事件\n                div1.onclick()\n            &#125;\n        &#125;\n    &lt;/script&gt;\n    &lt;style&gt;\n        .div1&#123;\n            width: 50px;\n            height: 50px;\n            background-color: yellow;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id = &quot;d1&quot; class=&quot;div1&quot;&gt;&lt;/div&gt;\n\n    &lt;button id = &quot;btn1&quot;&gt;按钮&lt;/button&gt;\n&lt;/body&gt;\n&lt;/html&gt;效果\n点击前为黄色，点击后触发事件，改变div块颜色。\n\n\n六、BOM编程6.1 什么是BOM\n\n\n\n\n\n\n\n\n\nBOM是Browser Object Model的简写，即浏览器对象模型。\n\nBOM由一系列对象组成，是访问、控制、修改浏览器的属性和方法(通过window对象及属性的一系列方法 控制浏览器行为的一种编程)\n\nBOM没有统一的标准(每种客户端都可以自定标准)。\n\nBOM编程是将浏览器窗口的各个组成部分抽象成各个对象,通过各个对象的API操作组件行为的一种编程\n\n\nBOM编程的对象结构如下\nwindow 顶级对象,代表整个浏览器窗口\n\nlocation对象：代表浏览器的地址栏\nhistory对象：代表浏览器的访问历史\nscreen对象：代表屏幕\nnavigator对象：代表浏览器软件本身\ndocument对象：代表浏览器窗口目前解析的html文档\nconsole对象：代表浏览器开发者工具的控制台\nlocalStorage对象：代表浏览器的本地数据持久化存储\nsessionStorage对象：代表浏览器的本地数据会话级存储\n\n\n6.2 window对象的常见属性(了解)\n\n\n属性\n描述\n\n\n\nclosed\n返回窗口是否已被关闭。\n\n\ndefaultStatus\n设置或返回窗口状态栏中的默认文本。\n\n\ndocument\n对 Document 对象的只读引用。(请参阅对象)\n\n\nframes\n返回窗口中所有命名的框架。该集合是 Window 对象的数组，每个 Window 对象在窗口中含有一个框架。\n\n\nhistory\n对 History 对象的只读引用。请参数 History 对象。\n\n\ninnerHeight\n返回窗口的文档显示区的高度。\n\n\ninnerWidth\n返回窗口的文档显示区的宽度。\n\n\nlocalStorage\n在浏览器中存储 key&#x2F;value 对。没有过期时间。\n\n\nlength\n设置或返回窗口中的框架数量。\n\n\nlocation\n用于窗口或框架的 Location 对象。请参阅 Location 对象。\n\n\nname\n设置或返回窗口的名称。\n\n\nnavigator\n对 Navigator 对象的只读引用。请参数 Navigator 对象。\n\n\nopener\n返回对创建此窗口的窗口的引用。\n\n\nouterHeight\n返回窗口的外部高度，包含工具条与滚动条。\n\n\nouterWidth\n返回窗口的外部宽度，包含工具条与滚动条。\n\n\npageXOffset\n设置或返回当前页面相对于窗口显示区左上角的 X 位置。\n\n\npageYOffset\n设置或返回当前页面相对于窗口显示区左上角的 Y 位置。\n\n\nparent\n返回父窗口。\n\n\nscreen\n对 Screen 对象的只读引用。请参数 Screen 对象。\n\n\nscreenLeft\n返回相对于屏幕窗口的x坐标\n\n\nscreenTop\n返回相对于屏幕窗口的y坐标\n\n\nscreenX\n返回相对于屏幕窗口的x坐标\n\n\nsessionStorage\n在浏览器中存储 key&#x2F;value 对。 在关闭窗口或标签页之后将会删除这些数据。\n\n\nscreenY\n返回相对于屏幕窗口的y坐标\n\n\nself\n返回对当前窗口的引用。等价于 Window 属性。\n\n\nstatus\n设置窗口状态栏的文本。\n\n\ntop\n返回最顶层的父窗口。\n\n\n6.3 window对象的常见方法(了解)\n\n\n方法\n描述\n\n\n\nalert()\n显示带有一段消息和一个确认按钮的警告框。\n\n\natob()\n解码一个 base-64 编码的字符串。\n\n\nbtoa()\n创建一个 base-64 编码的字符串。\n\n\nblur()\n把键盘焦点从顶层窗口移开。\n\n\nclearInterval()\n取消由 setInterval() 设置的 timeout。\n\n\nclearTimeout()\n取消由 setTimeout() 方法设置的 timeout。\n\n\nclose()\n关闭浏览器窗口。\n\n\nconfirm()\n显示带有一段消息以及确认按钮和取消按钮的对话框。\n\n\ncreatePopup()\n创建一个 pop-up 窗口。\n\n\nfocus()\n把键盘焦点给予一个窗口。\n\n\ngetSelection()\n返回一个 Selection 对象，表示用户选择的文本范围或光标的当前位置。\n\n\ngetComputedStyle()\n获取指定元素的 CSS 样式。\n\n\nmatchMedia()\n该方法用来检查 media query 语句，它返回一个 MediaQueryList对象。\n\n\nmoveBy()\n可相对窗口的当前坐标把它移动指定的像素。\n\n\nmoveTo()\n把窗口的左上角移动到一个指定的坐标。\n\n\nopen()\n打开一个新的浏览器窗口或查找一个已命名的窗口。\n\n\nprint()\n打印当前窗口的内容。\n\n\nprompt()\n显示可提示用户输入的对话框。\n\n\nresizeBy()\n按照指定的像素调整窗口的大小。\n\n\nresizeTo()\n把窗口的大小调整到指定的宽度和高度。\n\n\nscroll()\n已废弃。 该方法已经使用了 scrollTo() 方法来替代。\n\n\nscrollBy()\n按照指定的像素值来滚动内容。\n\n\nscrollTo()\n把内容滚动到指定的坐标。\n\n\nsetInterval()\n按照指定的周期（以毫秒计）来调用函数或计算表达式。\n\n\nsetTimeout()\n在指定的毫秒数后调用函数或计算表达式。\n\n\nstop()\n停止页面载入。\n\n\npostMessage()\n安全地实现跨源通信。\n\n\n6.4 通过BOM编程控制浏览器行为演示\n\n\n\n\n\n\n\n\n三种弹窗方式\n代码实现\n&lt;html&gt;标签内容\nhtml&lt;script&gt;\n    function fun1()&#123;\n        window.alert(&#39;信息提示框&#39;)\n    &#125;\n    function fun2()&#123;\n        var name = window.prompt(&#39;请输入你的名字&#39;)\n        console.log(name)\n    &#125;\n    function fun3()&#123;\n        var res = prompt(&#39;确定要删除吗？&#39;)\n        console.log(res)\n    &#125;\n&lt;/script&gt;&lt;body&gt;标签内容\nhtml&lt;body&gt;\t\n    &lt;button onclick=&quot;fun1()&quot;&gt;信息提示框&lt;/button&gt;\n    &lt;button onclick=&quot;fun2()&quot;&gt;信息输入框&lt;/button&gt;\n    &lt;button onclick=&quot;fun3()&quot;&gt;信息确认框&lt;/button&gt;\n&lt;/body&gt;效果演示\n\n\n\n\n\n\n\n\n\n\n\n页面跳转\n代码实现\n&lt;html&gt;标签内容\nhtml&lt;script&gt;\t\t\n    function funA()&#123;\n        //向前翻页\n        window.history.back()\n    &#125;\n    function funB()&#123;\n        //向后翻页\n        window.history.forward()\n    &#125;\n    function funC()&#123;\n        //跳转到指定页面\n        window.location.href = &#39;https://www.w3school.com.cn/&#39;\n    &#125;\n&lt;/script&gt;&lt;body&gt;标签内容\nhtml&lt;body&gt;\n    &lt;button onclick=&quot;funA()&quot;&gt;上一页&lt;/button&gt;\n    &lt;button onclick=&quot;funB()&quot;&gt;下一页&lt;/button&gt;\n    &lt;a href=&quot;https://www.w3school.com.cn/&quot;&gt;w3school&lt;/a&gt;\n    &lt;button onclick=&quot;funC()&quot;&gt;演示location跳转&lt;/button&gt;\n&lt;/body&gt;效果演示\n\n6.5 通过BOM编程实现会话级和持久级数据存储\n会话级数据 : 内存型数据,是浏览器在内存上临时存储的数据,浏览器关闭后,数据失去,通过window的sessionStorge属性实现\n持久级数据 : 磁盘型数据,是浏览器在磁盘上持久存储的数据,浏览器关闭后,数据仍在,通过window的localStorge实现\n可以用于将来存储一些服务端响应回来的数据,比如:token令牌,或者一些其他功能数据,根据数据的业务范围我们可以选择数据存储的会话&#x2F;持久 级别\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;script&gt;\n        function saveItem()&#123;\n            // 让浏览器存储一些会话级数据\n            window.sessionStorage.setItem(&quot;sessionMsg&quot;,&quot;sessionValue&quot;)\n            // 让浏览器存储一些持久级数据\n            window.localStorage.setItem(&quot;localMsg&quot;,&quot;localValue&quot;)\n\n            console.log(&quot;haha&quot;)\n        &#125;\n\n        function removeItem()&#123;\n            // 删除数据\n            sessionStorage.removeItem(&quot;sessionMsg&quot;)\n            localStorage.removeItem(&quot;localMsg&quot;)\n        &#125;\n\n        function readItem()&#123;\n            console.log(&quot;read&quot;)\n            // 读取数据\n            console.log(&quot;session:&quot;+sessionStorage.getItem(&quot;sessionMsg&quot;))\n            console.log(&quot;local:&quot;+localStorage.getItem(&quot;localMsg&quot;))\n        &#125;\n    &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;button onclick=&quot;saveItem()&quot;&gt;存储数据&lt;/button&gt;\n    &lt;button onclick=&quot;removeItem()&quot;&gt;删除数据&lt;/button&gt;\n    &lt;button onclick=&quot;readItem()&quot;&gt;读取数据&lt;/button&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n测试,存储数据后,再读取数据,然后关闭浏览器,获取数据,发现sessionStorge的数据没有了,localStorge的数据还在\n通过removeItem可以将这些数据直接删除\n在F12开发者工具的应用程序栏,可以查看数据的状态\n\n\n\n七、DOM编程","slug":"Javaweb_JavaScript","date":"2023-12-05T16:32:00.000Z","categories_index":"Javaweb","tags_index":"Javaweb","author_index":"白"},{"id":"f3f2df35f49c4b62e5dd8763403aa68d","title":"HTML&CSS笔记","content":"一 HTML入门1.1 HTML&amp;CSS&amp;JavaScript的作用\nHTML 主要用于网页主体结构的搭建\nCSS 主要用于页面元素美化\t\nJavaScript 主要用于页面元素的动态处理\n\n1.2 HTML基础结构\n文档声明\n\nHTML文件中第一行的内容，用来告诉浏览器当前HTML文档的基本信息，其中最重要的就是当前HTML文档遵循的语法标准。这里我们只需要知道HTML有4和5这两个大的版本\nHTML4版本的文档类型声明是：\n\nhtml&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;\n&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\nHTML5版本的文档类型声明是：\n\nhtml&lt;!DOCTYPE html&gt;\n根标签\n\nhtml标签是整个文档的根标签，所有其他标签都必须放在html标签里面。\n\n\n头部元素\n\nhead标签用于定义文档的头部，其他头部元素都放在head标签里。头部元素包括title标签、script标签、style标签、link标签、meta标签等等。\n\n\n主体元素\n\nbody标签定义网页的主体内容，在浏览器窗口内显示的内容都定义到body标签内。\n\n\n注释\n\nHTML注释的写法是\n\ntxt&lt;!-- 注释内容 --&gt;\n\n基础结构演示\n\n1.3 HTML的入门程序代码实现\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;我的第一个html&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello VSCode 你好世界&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;结果演示\n\n1.4 HTML概念词汇解释\n标签\n代码中的一个 &lt;&gt; 叫做一个标签,有些标签成对出现,称之为双标签,有些标签单独出现,称之为单标签\n\n\n属性\n一般在开始标签中,用于定义标签的一些特征\n\n\n文本\n双标签中间的文字,包含空格换行等结构\n\n\n元素\n经过浏览器解析后,每一个完整的标签(标签+属性+文本)可以称之为一个元素\n\n\n\n1.5 HTML的语法规则\n1 根标签有且只能有一个\n\n2 无论是双标签还是单标签都需要正确关闭\n\n3 标签可以嵌套但不能交叉嵌套\n\n4 注释语法为  ,注意不能嵌套\n\n5 属性必须有值，值必须加引号,H5中属性名和值相同时可以省略属性值\n\n6 HTML中不严格区分字符串使用单双引号\n\n7 HTML标签不严格区分大小写,但是不能大小写混用\n\n8 HTML中不允许自定义标签名,强行自定义则无效\n\n\n1.6 在线帮助文档http://www.w3school.com.cn\n\n二 HTML常见标签2.1 标题标签标题标签一般用于在页面上定义一些标题性的内容,如新闻标题,文章标题等,有h1到h6六级标题。\n\n代码\n\nhtml&lt;body&gt;\n    &lt;h1&gt;一级标题&lt;/h1&gt;\n    &lt;h2&gt;二级标题&lt;/h2&gt;\n    &lt;h3&gt;三级标题&lt;/h3&gt;\n    &lt;h4&gt;四级标题&lt;/h4&gt;\n    &lt;h5&gt;五级标题&lt;/h5&gt;\n    &lt;h6&gt;六级标题&lt;/h6&gt;\n&lt;/body&gt;\n效果\n\n\n2.2 段落标签段落标签一般用于定义一些在页面上要显示的大段文字,多个段落标签之间实现自动分段的效果\n\n代码\n\nhtml&lt;body&gt;\n    &lt;p&gt;\n        记者从工信部了解到，近年来我国算力产业规模快速增长，年增长率近30%，算力规模排名全球第二。\n    &lt;/p&gt;\n    &lt;p&gt;\n        工信部统计显示，截至去年底，我国算力总规模达到180百亿亿次浮点运算/秒，存力总规模超过1000EB（1万亿GB）。\n        国家枢纽节点间的网络单向时延降低到20毫秒以内，算力核心产业规模达到1.8万亿元。中国信息通信研究院测算，\n        算力每投入1元，将带动3至4元的GDP经济增长。\n    &lt;/p&gt;\n    &lt;p&gt; \n        近年来，我国算力基础设施发展成效显著，梯次优化的算力供给体系初步构建，算力基础设施的综合能力显著提升。\n        当前，算力正朝智能敏捷、绿色低碳、安全可靠方向发展。\n    &lt;/p&gt;\n&lt;/body&gt;\n效果\n\n\n2.3 换行标签br ：实现换行。\nhr ：添加分割线。\n\n代码\n\nhtml&lt;body&gt;\n        工信部统计显示，截至去年底，我国算力总规模达到180百亿亿次浮点运算/秒，存力总规模超过1000EB（1万亿GB）。\n    &lt;br&gt;\n        国家枢纽节点间的网络单向时延降低到20毫秒以内，算力核心产业规模达到1.8万亿元。\n    &lt;hr&gt;\n        中国信息通信研究院测算，算力每投入1元，将带动3至4元的GDP经济增长。\n&lt;/body&gt;\n效果\n\n\n2.4 列表标签1、有序列表  ：分条列项展示数据的标签, 其每一项前面的符号带有顺序特征\n\n列表标签 ol\n列表项标签 li\n\n代码\nhtml&lt;ol&gt;\n    &lt;li&gt;JAVA&lt;/li&gt;\n    &lt;li&gt;前端&lt;/li&gt;\n    &lt;li&gt;大数据&lt;/li&gt;\n&lt;/ol&gt;效果\n\n2、无序列表  ：分条列项展示数据的标签, 其每一项前面的符号不带有顺序特征\n\n列表标签 ul\n列表项标签 li\n\n代码\nhtml&lt;ul&gt;\n    &lt;li&gt;JAVASE&lt;/li&gt;\n    &lt;li&gt;JAVAEE&lt;/li&gt;\n    &lt;li&gt;数据库&lt;/li&gt;\n&lt;/ul&gt;效果\n\n3、嵌套列表 ： 列表和列表之前可以签到,实现某一项内容详细展示\n\n代码\n\nhtml&lt;ol&gt;\n    &lt;li&gt;\n        JAVA\n        &lt;ul&gt;\n            &lt;li&gt;JAVASE&lt;/li&gt;\n            &lt;li&gt;JAVAEE&lt;/li&gt;\n            &lt;li&gt;数据库&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/li&gt;\n    &lt;li&gt;前端&lt;/li&gt;\n    &lt;li&gt;大数据&lt;/li&gt;\n&lt;/ol&gt;\n效果\n\n\n2.5 超链接标签点击后带有链接跳转的标签 ,也叫作a标签。\n\nhref 属性用于定义要跳转的目标资源的地址\n\n绝对路径：以/开头,始终以一个固定路径作为基准路径作为出发点\n无论当前资源在哪，使用以固定的位置作为出发点去找目标资源。以/开头。\n\n\n相对路径：不以/开头,以当前资源的所在路径为出发点去找目标资源。\n./ 表示当前资源的所在路径，可以省略不写的。\n../表示当前资源的上一层路径，需要时必须显示写出。\n\n\n完整的URL：https://www.w3school.com.cn/\n\n\ntarget 用于定义目标资源的打开方式\n\n_blank 在新窗口中打开目标资源\n_self  在当前窗口中打开目标资源\n\n\n代码\n\n\nhtml&lt;body&gt;\n   &lt;a href=&quot;01html的基本结构.html&quot; target=&quot;_blank&quot;&gt;相对路径本地资源连接&lt;/a&gt; &lt;br&gt;\n   &lt;a href=&quot;/day01-html/01html的基本结构.html&quot; target=&quot;_self&quot;&gt;绝对路径本地资源连接&lt;/a&gt; &lt;br&gt;\n   &lt;a href=&quot;https://www.w3school.com.cn&quot; target=&quot;_blank&quot;&gt;外部资源链接&lt;/a&gt; &lt;br&gt;  \n&lt;/body&gt;\n效果\n\n\n2.6 多媒体标签img(重点) ： 图片标签,用于在页面上引入图片\n\nsrc：用于定义图片的连接\ntitle：用于定义鼠标悬停时显示的文字\nalt：用于定义图片加载失败时显示的提示文字\n\n代码\nhtml&lt;img src=&quot;img/logo.png&quot;  title=&quot;w3school&quot; alt=&quot;w3schoollogo&quot; /&gt;效果\n\naudio： 用于在页面上引入一段声音\n\nsrc：用于定义目标声音资源\nautoplay：用于控制打开页面时是否自动播放\ncontrols： 用于控制是否展示控制面板\nloop：用于控制是否进行循环播放\n\n代码\nhtml&lt;body&gt;\n   &lt;audio src=&quot;img/music.mp3&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; /&gt;\n&lt;/body&gt;效果\n\nvideo： 用于在页面上引入一段视频\n\nsrc： 用于定义目标视频资源\nautoplay：用于控制打开页面时是否自动播放\ncontrols： 用于控制是否展示控制面板\nloop：用于控制是否进行循环播放\n\n代码\nhtml&lt;body&gt;\n   &lt;video src=&quot;img/movie.mp4&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; width=&quot;400px&quot; /&gt;\n&lt;/body&gt;效果\n\n2.7 表格标签(重点)常规表格\n\ntable标签： 代表表格\nthead标签： 代表表头 可以省略不写\ntbody标签： 代表表体 可以省略不写\ntfoot标签： 代表表尾  可以省略不写\ntr标签： 代表一行\ntd标签： 代表行内的一格\nth标签： 自带加粗和居中效果的td\n\n代码\nhtml    &lt;h3 style=&quot;text-align: center;&quot;&gt;员工技能竞赛评分表&lt;/h3&gt;\n    &lt;table  border=&quot;1px&quot; style=&quot;width: 400px; margin: 0px auto;&quot;&gt;\n        &lt;tr&gt;\n            &lt;th&gt;排名&lt;/th&gt;\n            &lt;th&gt;姓名&lt;/th&gt;\n            &lt;th&gt;分数&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;1&lt;/td&gt;\n            &lt;td&gt;张小明&lt;/td&gt;\n            &lt;td&gt;100&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;2&lt;/td&gt;\n            &lt;td&gt;李小东&lt;/td&gt;&lt;/td&gt;\n            &lt;td&gt;99&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;3&lt;/td&gt;\n            &lt;td&gt;王小虎&lt;/td&gt;\n            &lt;td&gt;98&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;效果\n\n单元格跨行\n通过td的rowspan属性实现上下跨行\n\n代码\n\nhtml    &lt;h3 style=&quot;text-align: center;&quot;&gt;员工技能竞赛评分表&lt;/h3&gt;\n    &lt;table  border=&quot;1px&quot; style=&quot;width: 400px; margin: 0px auto;&quot;&gt;\n        &lt;tr&gt;\n            &lt;th&gt;排名&lt;/th&gt;\n            &lt;th&gt;姓名&lt;/th&gt;\n            &lt;th&gt;分数&lt;/th&gt;\n            &lt;th&gt;备注&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;1&lt;/td&gt;\n            &lt;td&gt;张小明&lt;/td&gt;\n            &lt;td&gt;100&lt;/td&gt;\n            &lt;td rowspan=&quot;3&quot;&gt;\n                前三名升职加薪\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;2&lt;/td&gt;\n            &lt;td&gt;李小东&lt;/td&gt;&lt;/td&gt;\n            &lt;td&gt;99&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;3&lt;/td&gt;\n            &lt;td&gt;王小虎&lt;/td&gt;\n            &lt;td&gt;98&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n效果\n\n\n单元格跨行\n通过td的colspan属性实现左右跨列\n\n代码\n\nhtml    &lt;h3 style=&quot;text-align: center;&quot;&gt;员工技能竞赛评分表&lt;/h3&gt;\n    &lt;table  border=&quot;1px&quot; style=&quot;width: 400px; margin: 0px auto;&quot;&gt;\n        &lt;tr&gt;\n            &lt;th&gt;排名&lt;/th&gt;\n            &lt;th&gt;姓名&lt;/th&gt;\n            &lt;th&gt;分数&lt;/th&gt;\n            &lt;th&gt;备注&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;1&lt;/td&gt;\n            &lt;td&gt;张小明&lt;/td&gt;\n            &lt;td&gt;100&lt;/td&gt;\n            &lt;td rowspan=&quot;6&quot;&gt;\n                前三名升职加薪\n            &lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;2&lt;/td&gt;\n            &lt;td&gt;李小东&lt;/td&gt;&lt;/td&gt;\n            &lt;td&gt;99&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;3&lt;/td&gt;\n            &lt;td&gt;王小虎&lt;/td&gt;\n            &lt;td&gt;98&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;总人数&lt;/td&gt;\n            &lt;td colspan=&quot;2&quot;&gt;2000&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;平均分&lt;/td&gt;\n            &lt;td colspan=&quot;2&quot;&gt;90&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;及格率&lt;/td&gt;\n            &lt;td colspan=&quot;2&quot;&gt;80%&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n效果\n\n\n2.8 表单标签(重点)表单标签：可以实现让用户在界面上输入各种信息并提交的一种标签. 是向服务端发送数据主要的方式之一\n\nform标签：表单标签,其内部用于定义可以让用户输入信息的表单项标签\n\ntarget：from标签的属性之一，设置要跳转的新地址打开位置；值_self、_blank\naction：form标签的属性之一,用于定义信息提交的服务器的地址\nmethod：form标签的属性之一,用于定义信息的提交方式\nget方式：数据会缀到url后,以?作为参数开始的标识,多个参数用&amp;隔开\turl?key=value&amp;key=value&amp;key=value\n数据直接暴露在地址栏上，相对不安全\n地址栏长度有限制，所以提交的数据量不大\n地址栏上，只能是字符，不能提交文件\n相比于post效率高一些\n\n\npost方式：数据会通过请求体发送,不会在缀到url后\n参数默认不放到url后\n数据不会直接暴露在地址栏上，相对安全\n数据是单独打包通过请求体发送，提交的数据量比较大\n请求体中，可以是字符，也可以字节数据，可以提交文件\n相比于get效率略低一些\n\n\n\n\n\n\ninput标签：主要的表单项标签,可以用于定义表单项\n\nname：input标签的属性之一,用于定义提交的参数名\ntype：input标签的属性之一,用于定义表单项类型\ntext：文本框\npassword：密码框\nbutton：普通按钮，需要通过JavaScript绑定单击响应函数\nsubmit：提交按钮\nreset：重置按钮\nradio：单选框，多个选项选其一，多个单选框使用相同的name属性值，则就会有互斥效果\ncheckbox：复选框 ，多个选项选多个\nhidden：隐藏域 ，不显示在页面上，提交时会携带\nfile：文件上传框\n\n\n\n\n\n代码\nhtml   &lt;form action=&quot;http://www.atguigu.com&quot; method=&quot;get&quot;&gt;\n        用户名 &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;br&gt;\n        密&amp;nbsp;&amp;nbsp;&amp;nbsp;码 &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;br&gt;\n        &lt;input type=&quot;submit&quot;  value=&quot;登录&quot; /&gt;\n        &lt;input type=&quot;reset&quot;  value=&quot;重置&quot; /&gt;\n   &lt;/form&gt;效果\n\nreadonly：只读，提交时携带\ndisabled：不可用提交时，不携带\nhtml&lt;input type=&quot;hidden&quot;name=&quot;id&quot;value=&quot;123&quot;&gt;\n&lt;input type=&quot;text&quot;name=&quot;pid&quot;value=&quot;456&quot;readonly&gt;&lt;br&gt;\n&lt;input type=&quot;text&quot;name=&quot;tid&quot;value=&quot;789&quot;disabled&gt;&lt;br&gt;2.9 常见表单项标签(重点)1、单行文本框\n\n代码\n\nhtml个性签名：&lt;input type=&quot;text&quot; name=&quot;signal&quot;/&gt;&lt;br/&gt;\n效果\n\n\n2、密码框\n\n代码\n\nhtml密码：&lt;input type=&quot;password&quot; name=&quot;secret&quot;/&gt;&lt;br/&gt;\n效果\n\n\n3、单选框\n简要说明\n\nname属性相同的radio为一组，组内互斥\n当用户选择了一个radio并提交表单，这个radio的name属性和value属性组成一个键值对发送给服务器\n设置checked=&quot;checked&quot;属性设置默认被选中的radio\n如果属性名和属性值一样的话，可以省略属性值，只写checked即可\n\n代码\nhtml你的性别是：\n&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;spring&quot; /&gt;男\n&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;summer&quot; checked=&quot;checked&quot; /&gt;女效果\n\n4、复选框\n设置checked=&quot;checked&quot;属性设置默认被选中的checkbox\n\n代码\n\nhtml你喜欢的球队是：\n&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;Brazil&quot;/&gt;巴西\n&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;German&quot; checked/&gt;德国\n&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;France&quot;/&gt;法国\n&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;China&quot; checked=&quot;checked&quot;/&gt;中国\n&lt;input type=&quot;checkbox&quot; name=&quot;team&quot; value=&quot;Italian&quot;/&gt;意大利\n效果\n\n\n5、下拉框\n简要说明\n\n下拉列表用到了两种标签，其中select标签用来定义下拉列表，而option标签设置列表项。\nname属性在select标签中设置,value属性在option标签中设置。\noption标签的标签体是显示出来给用户看的，提交到服务器的是value属性的值。\n通过在option标签中设置selected=&quot;selected&quot;属性实现默认选中的效果。\n\n代码\nhtml你喜欢的运动是：\n&lt;select name=&quot;interesting&quot;&gt;\n    &lt;option value=&quot;swimming&quot;&gt;游泳&lt;/option&gt;\n    &lt;option value=&quot;running&quot;&gt;跑步&lt;/option&gt;\n    &lt;option value=&quot;shooting&quot; selected=&quot;selected&quot;&gt;射击&lt;/option&gt;\n    &lt;option value=&quot;skating&quot;&gt;溜冰&lt;/option&gt;\n&lt;/select&gt;效果\n\n6、按钮\n简要说明\n\n普通按钮: 点击后无效果，需要通过JavaScript绑定单击响应函数\n重置按钮: 点击后将表单内的所有表单项都恢复为默认值\n提交按钮: 点击后提交表单\n\n代码\nhtml&lt;button type=&quot;button&quot;&gt;普通按钮&lt;/button&gt;或&lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;/&gt;\n&lt;button type=&quot;reset&quot;&gt;重置按钮&lt;/button&gt;或&lt;input type=&quot;reset&quot; value=&quot;重置按钮&quot;/&gt;\n&lt;button type=&quot;submit&quot;&gt;提交按钮&lt;/button&gt;或&lt;input type=&quot;submit&quot; value=&quot;提交按钮&quot;/&gt;效果\n\n7、隐藏域\n简要说明\n\n通过表单隐藏域设置的表单项不会显示到页面上，用户看不到。但是提交表单时会一起被提交。用来设置一些需要和表单一起提交但是不希望用户看到的数据，例如：用户id等等。\n\n代码\nhtml&lt;input type=&quot;hidden&quot; name=&quot;userId&quot; value=&quot;2233&quot;/&gt;8、多行文本框\n简要说明\n\ntextarea没有value属性，如果要设置默认值需要写在开始和结束标签之间。\n\n代码\nhtml自我介绍：&lt;textarea name=&quot;desc&quot;&gt;&lt;/textarea&gt;效果\n\n9、文件标签\n简要说明\n\n不同浏览器显示的样式有微小差异\n\n代码\nhtml头像:&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;效果\n\n2.10 布局相关标签div标签：  俗称”块”,主要用于划分页面结构,做页面布局。块元素的CSS样式的宽，高等等往往都是生效的。\nspan标签： 俗称”层”,主要用于划分元素范围,配合CSS做页面元素样式的修饰。行内的CSS样式的宽，高等待很多都是不生效的。\n\n代码\n\nhtml    &lt;div style=&quot;width: 500px; height: 400px;background-color: cadetblue;&quot;&gt;\n        &lt;div style=&quot;width: 400px; height: 100px;background-color: beige;margin: 10px auto;&quot;&gt;\n            &lt;span style=&quot;color: blueviolet;&quot;&gt;页面开头部分&lt;/span&gt;\n        &lt;/div&gt; \n        &lt;div style=&quot;width: 400px; height: 100px;background-color: blanchedalmond;margin: 10px auto;&quot;&gt;\n            &lt;span style=&quot;color: blueviolet;&quot;&gt;页面中间部分&lt;/span&gt;\n        &lt;/div&gt; \n        &lt;div style=&quot;width: 400px; height: 100px;background-color: burlywood;margin: 10px auto;&quot;&gt;\n            &lt;span style=&quot;color: blueviolet;&quot;&gt;页面结尾部分&lt;/span&gt;\n        &lt;/div&gt; \n    &lt;/div&gt;\n展示效果\n\n\n2.11 特殊字符Html特殊字符表 - 在线工具 (tool.lu)\n常见字符实体总结：\n\n\n代码\n\nhtml&amp;lt;span&amp;gt;  &lt;br&gt;    \n&amp;lt;a href=&quot;https://www.w3school.com.cn/index.html&quot;&amp;gt;特殊&amp;nbsp;字&amp;nbsp;符&amp;lt;/a&amp;gt; &lt;br&gt;\n&amp;amp;amp;\n效果\n\n\n\n三 CSS的使用CSS  层叠样式表(英文全称：(Cascading Style Sheets)   能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力 ,简单来说,美化页面。\n3.1 CSS引入方式方式一：行内式\n\n通过元素开始标签的style属性引入。\n语法：style=&quot;样式名:样式值;样式名:样式值;... ....&quot;\n缺点：1、代码复用度低，不利于维护。 2、css样式代码和html结构代码交织在一起，影响文件大小，影响性能。\n\n方式二：内嵌式\n\n内嵌式样式需要在head标签中,通过一对style标签定义CSS样式\nCSS样式的作用范围控制要依赖选择器\nCSS的样式代码中注释的方式为 /*   */\n内嵌式虽然对样式代码做了抽取,但是CSS代码仍然在html文件中\n内嵌样式仅仅能作用于当前文件,代码复用度还是不够,不利于网站风格统一\n\n方式三：外部样式表\n\n将css代码单独放入一个.css文件中，哪个html需要这些代码就在head中通过link标签引入\n&lt;link href=&quot;css/btn.css&quot; rel=&quot;stylesheet&quot;&gt;\n\n如下图所示\n\n代码演示\n1、方式一：行内式\n\n代码\n\nhtml&lt;input \n    type=&quot;button&quot; \n    value=&quot;按钮&quot;\n    style=&quot;\n        display: block;\n        width: 60px; \n        height: 40px; \n        background-color: rgb(140, 235, 100); \n        color: white;\n        border: 3px solid green;\n        font-size: 22px;\n        font-family: &#39;隶书&#39;;\n        line-height: 30px;\n        border-radius: 5px;\n&quot;/&gt; \n效果\n\n\n2、方式二：内嵌式\n\n代码\n\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;style&gt;\n        /* 通过选择器确定样式的作用范围 */\n        input &#123;\n            display: block;\n            width: 80px; \n            height: 40px; \n            background-color: rgb(140, 235, 100); \n            color: white;\n            border: 3px solid green;\n            font-size: 22px;\n            font-family: &#39;隶书&#39;;\n            line-height: 30px;\n            border-radius: 5px;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; \n&lt;/body&gt;\n效果\n\n\n3、方式三：外部样式表\n\n代码\n\nbuttons.css\ncssinput &#123;\n    display: block;\n    width: 80px; \n    height: 40px; \n    background-color: rgb(140, 235, 100); \n    color: white;\n    border: 3px solid green;\n    font-size: 22px;\n    font-family: &#39;隶书&#39;;\n    line-height: 30px;\n    border-radius: 5px;\n&#125;html\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;link href=&quot;css/buttons.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; \n&lt;/body&gt;\n效果\n\n\n3.2 CSS选择器\n元素选择器\n根据标签名确定样式的作用范围\n语法：元素名 &#123;&#125;\n样式只能作用到同名标签上,其他标签不可用\n相同的标签未必需要相同的样式,会造成样式的作用范围太大\n\n\nid选择器\n根据元素id属性的值确定样式的作用范围\n语法：#id值 &#123;&#125;\nid属性的值在页面上具有唯一性,所有id选择器也只能影响一个元素的样式\n因为id属性值不够灵活,所以使用该选择器的情况较少\n\n\nclass选择器\n根据元素class属性的值确定样式的作用范围\n语法： .class值 &#123;&#125;\nclass属性值可以有一个,也可以有多个,多个不同的标签也可以是使用相同的class值\n多个选择器的样式可以在同一个元素上进行叠加\n因为class选择器非常灵活,所以在CSS中,使用该选择器的情况较多\n\n\n\n代码演示\n1、元素选择器\n\n代码\n\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n   &lt;style&gt;\n    input &#123;\n        display: block;\n        width: 80px; \n        height: 40px; \n        background-color: rgb(140, 235, 100); \n        color: white;\n        border: 3px solid green;\n        font-size: 22px;\n        font-family: &#39;隶书&#39;;\n        line-height: 30px;\n        border-radius: 5px;\n    &#125;\n   &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; \n    &lt;input type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; \n    &lt;button&gt;按钮5&lt;/button&gt;\n&lt;/body&gt;\n效果\n\n\n2、id选择器\n\n代码\n\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n   &lt;style&gt;\n    #btn1 &#123;\n        display: block;\n        width: 80px; \n        height: 40px; \n        background-color: rgb(140, 235, 100); \n        color: white;\n        border: 3px solid green;\n        font-size: 22px;\n        font-family: &#39;隶书&#39;;\n        line-height: 30px;\n        border-radius: 5px;\n    &#125;\n   &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; \n    &lt;input id=&quot;btn2&quot; type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; \n    &lt;input id=&quot;btn3&quot; type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; \n    &lt;input id=&quot;btn4&quot; type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; \n    &lt;button id=&quot;btn5&quot;&gt;按钮5&lt;/button&gt;\n&lt;/body&gt;\n效果\n\n\n3、class选择器\n\n代码\n\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n   &lt;style&gt;\n    .shapeClass &#123;\n        display: block;\n        width: 80px; \n        height: 40px; \n        border-radius: 5px;\n    &#125;\n    .colorClass&#123;\n        background-color: rgb(140, 235, 100); \n        color: white;\n        border: 3px solid green;\n    &#125;\n    .fontClass &#123;\n        font-size: 22px;\n        font-family: &#39;隶书&#39;;\n        line-height: 30px;\n    &#125;\n\n   &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;input  class =&quot;shapeClass colorClass fontClass&quot;type=&quot;button&quot; value=&quot;按钮1&quot;/&gt; \n    &lt;input  class =&quot;shapeClass colorClass&quot; type=&quot;button&quot; value=&quot;按钮2&quot;/&gt; \n    &lt;input  class =&quot;colorClass fontClass&quot; type=&quot;button&quot; value=&quot;按钮3&quot;/&gt; \n    &lt;input  class =&quot;fontClass&quot; type=&quot;button&quot; value=&quot;按钮4&quot;/&gt; \n    &lt;button class=&quot;shapeClass colorClass fontClass&quot; &gt;按钮5&lt;/button&gt;\n&lt;/body&gt;\n效果\n\n\n3.3 CSS浮动CSS 的 Float（浮动）使元素脱离文档流，按照指定的方向（左或右发生移动），直到它的外边缘碰到包含框或另一个浮动框的边框为止。\n\n浮动设计的初衷为了解决文字环绕图片问题，浮动后一定不会将文字挡住，这是设计初衷。\n文档流是是文档中可显示对象在排列时所占用的位置&#x2F;空间，而脱离文档流就是在页面中不占位置了。\n\n浮动原理\n向右浮动：当把框 1 向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘\n\n\n\n向左浮动：当框 1 向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。如果把所有三个框都向左移动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。\n\n\n\n如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”\n\n\n浮动的样式名:float\n\n\n\n值\n描述\n\n\n\nleft\n元素向左浮动。\n\n\nright\n元素向右浮动。\n\n\nnone\n默认值。元素不浮动，并会显示在其文本中出现的位置。\n\n\n代码\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n   &lt;style&gt;\n    .outerDiv &#123;\n        width: 500px;\n        height: 300px;\n        border: 1px solid green;\n        background-color: rgb(230, 224, 224);\n    &#125;\n    .innerDiv&#123;\n        width: 100px;\n        height: 100px;\n        border: 1px solid blue;\n        float: left;\n    &#125;\n    .d1&#123;\n        background-color: greenyellow;\n       /*  float: right; */\n    &#125;\n    .d2&#123;\n        background-color: rgb(79, 230, 124);\n    &#125;\n    .d3&#123;\n        background-color: rgb(26, 165, 208);\n    &#125;\n   &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n   &lt;div class=&quot;outerDiv&quot;&gt;\n        &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n   &lt;/div&gt; \n&lt;/body&gt;效果\n\n3.4 CSS定位position 属性指定了元素的定位类型。\n\n这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。\n\n元素可以使用的顶部，底部，左侧和右侧属性定位。然而，这些属性无法工作，除非是先设定position属性。他们也有不同的工作方式，这取决于定位方法。\n\n\n\n\n\n值\n描述\n\n\n\nabsolute\n生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。元素的位置通过left,top,right以及bottom属性进行规定。\n\n\nfixed\n生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过left,top,right以及bottom属性进行规定，\n\n\nrelative\n生成相对定位的元素，相对于其正常位置进行定位。因此，left:20会向元素的LEFT位置添加20像素。\n\n\nstatic\n默认值。没有定位，元素出现在正常的流中（忽路top,bottom,left,right或者Z-index声明）\n\n\n1、静态定位\n说明\n\n不设置的时候的默认值就是static，静态定位，没有定位，元素出现在该出现的位置，块级元素垂直排列，行内元素水平排列\n\n代码\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;style&gt;\n        .innerDiv&#123;\n                width: 100px;\n                height: 100px;\n        &#125;\n        .d1&#123;\n            background-color: rgb(166, 247, 46);\n            position: static;\n        &#125;\n        .d2&#123;\n            background-color: rgb(79, 230, 124);\n        &#125;\n        .d3&#123;\n            background-color: rgb(26, 165, 208);\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n&lt;/body&gt;效果\n\n2、绝对定位 \n说明\n\nabsolute ,通过 top left right bottom 指定元素在页面上的固定位置\n定位后元素会让出原来位置,其他元素可以占用\n\n代码\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;style&gt;\n        .innerDiv&#123;\n                width: 100px;\n                height: 100px;\n        &#125;\n        .d1&#123;\n            background-color: rgb(166, 247, 46);\n            position: absolute;\n            left: 300px;\n            top: 100px;\n        &#125;\n        .d2&#123;\n            background-color: rgb(79, 230, 124);\n        &#125;\n        .d3&#123;\n            background-color: rgb(26, 165, 208);\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n&lt;/body&gt;效果\n\n3、相对定位\n说明\n\nrelative 相对于自己原来的位置进行地位\n定位后保留原来的站位,其他元素不会移动到该位置\n\n代码\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;style&gt;\n        .innerDiv&#123;\n                width: 100px;\n                height: 100px;\n        &#125;\n        .d1&#123;\n            background-color: rgb(166, 247, 46);\n            position: relative;\n            left: 30px;\n            top: 30px;\n        &#125;\n        .d2&#123;\n            background-color: rgb(79, 230, 124);\n        &#125;\n        .d3&#123;\n            background-color: rgb(26, 165, 208);\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n&lt;/body&gt;效果\n\n4、固定定位\n说明\n\nfixed 定位在浏览器窗口固定位置,不会随着页面的上下移动而移动\n元素定位后会让出原来的位置,其他元素可以占用\n\n代码\nhtml&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;style&gt;\n        .innerDiv&#123;\n                width: 100px;\n                height: 100px;\n        &#125;\n        .d1&#123;\n            background-color: rgb(166, 247, 46);\n            position: fixed;\n            right: 30px;\n            top: 30px;\n        &#125;\n        .d2&#123;\n            background-color: rgb(79, 230, 124);\n        &#125;\n        .d3&#123;\n            background-color: rgb(26, 165, 208);\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n        &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n        br*100+tab\n&lt;/body&gt;效果\n\n3.5 CSS盒子模型所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。\n\nCSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin），边框（border），填充（padding），和实际内容（content）。\n\n\n盒子模型介绍\n\nMargin(外边距) - 清除边框外的区域，外边距是透明的。\nBorder(边框) - 围绕在内边距和内容外的边框。\nPadding(内边距) - 清除内容周围的区域，内边距是透明的。\nContent(内容) - 盒子的内容，显示文本和图像。\n\n\n代码\nhtml    &lt;head&gt;\n        &lt;meta charset=&quot;UTF-8&quot;&gt;\n       &lt;style&gt;\n        .outerDiv &#123;\n            width: 800px;\n            height: 300px;\n            border: 1px solid green;\n            background-color: rgb(230, 224, 224);\n            margin: 0px auto;\n        &#125;\n        .innerDiv&#123;\n            width: 100px;\n            height: 100px;\n            border: 1px solid blue;\n            float: left;\n            /* margin-top: 10px;\n            margin-right: 20px;\n            margin-bottom: 30px;\n            margin-left: 40px; */\n            margin: 10px 20px 30px 40px;\n           \n        &#125;\n        .d1&#123;\n            background-color: greenyellow;\n            /* padding-top: 10px;\n            padding-right: 20px;\n            padding-bottom: 30px;\n            padding-left: 40px; */\n            padding: 10px 20px 30px 40px;\n        &#125;\n        .d2&#123;\n            background-color: rgb(79, 230, 124);\n        &#125;\n        .d3&#123;\n            background-color: rgb(26, 165, 208);\n        &#125;\n       &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n       &lt;div class=&quot;outerDiv&quot;&gt;\n            &lt;div class=&quot;innerDiv d1&quot;&gt;框1&lt;/div&gt;\n            &lt;div class=&quot;innerDiv d2&quot;&gt;框2&lt;/div&gt;\n            &lt;div class=&quot;innerDiv d3&quot;&gt;框3&lt;/div&gt;\n       &lt;/div&gt; \n    &lt;/body&gt;效果\n\n在浏览器上,通过F12工具查看盒子模型状态\n\n","slug":"Javaweb_HTML&CSS","date":"2023-12-05T16:32:00.000Z","categories_index":"Javaweb","tags_index":"Javaweb","author_index":"白"},{"id":"8b3d229c812de5f72244620edb5f9588","title":"算法学习_链表篇","content":"算法学习_链表篇链表的类型单链表链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。\n链表的入口节点称为链表的头结点也就是head。\n\n双链表单链表中的指针域只能指向节点的下一个节点。\n双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。\n双链表 既可以向前查询也可以向后查询。 \n\n循环链表循环链表，顾名思义，就是链表首尾相连。\n循环链表可以用来解决约瑟夫环问题。\n\n\n链表的操作删除节点删除D节点，如图所示：\n\n只要将C节点的next指针 指向E节点就可以了。\n添加节点如图所示：\n\n可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。\n但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。\n\n性能分析再把链表的特性和数组的特性进行一个对比，如图所示：\n\n\n\n\n插入删除（时间复杂度)\n查询（时间复杂度)\n适用场景\n\n\n\n数组\nO(n)\nO(1)\n数据量固定，频繁查询，较少增删\n\n\n链表\nO(1)\nO(n)\n数据量不固定，频繁增删，较少查询\n\n\nJava：\njavapublic class ListNode &#123;\n    // 结点的值\n    int val;\n\n    // 下一个结点\n    ListNode next;\n\n    // 节点的构造函数(无参)\n    public ListNode() &#123;\n    &#125;\n\n    // 节点的构造函数(有一个参数)\n    public ListNode(int val) &#123;\n        this.val = val;\n    &#125;\n\n    // 节点的构造函数(有两个参数)\n    public ListNode(int val, ListNode next) &#123;\n        this.val = val;\n        this.next = next;\n    &#125;\n&#125;\n移除链表元素题目\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n示例 1：\n\ntxt输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]示例 2：\ntxt输入：head = [], val = 1\n输出：[]示例 3：\ntxt输入：head = [7,7,7,7], val = 7\n输出：[]思路\n\n\n红色标记的prev，head表示链表开始时，head为遍历当前链表所在位置，prev为该结点的上一个结点。dummy指向头结点，返回结果为dummy-&gt;next。\n若当前的值满足head.val == val，则将prev移到head的下一个位置，如图第一条灰色线。执行prev.next = head.next，prev的下一位执行了2所在位置。\n若当前的值不满足head.val == val，则将prev移到当前位置。执行prev = head。\nwhile循环里遍历链表head = head.next。\n\n代码实现\njavapublic ListNode removeElements(ListNode head, int val) &#123;\n    //设置一个虚拟指向头结点的指针\n    ListNode dummy = new ListNode(0);\n    ListNode prev = new ListNode(0);\n    dummy.next = head;\n    //设置一个指向前一个结点的指针，方便移除链表元素\n    prev = dummy;\n    while (head != null) &#123;\n        //相等则移除\n        if (head.val == val) &#123;\n            prev.next = head.next;\n        &#125; else &#123;\n            //匹配失败把prev移到当前位置\n            prev = head;\n        &#125;\n        head = head.next;\n    &#125;\n    return dummy.next;\n&#125;\n设计链表 - 力扣题目\n你可以选择使用单链表或者双链表，设计并实现自己的链表。\n单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。\n如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\n实现 MyLinkedList 类：\n\nMyLinkedList() 初始化 MyLinkedList 对象。\nint get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\nvoid addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\nvoid addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\nvoid addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\nvoid deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\n\n 示例：\ntxt输入\n[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]\n[[], [1], [3], [1, 2], [1], [1], [1]]\n输出\n[null, null, null, null, 2, null, 3]\n\n解释\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3\nmyLinkedList.get(1);              // 返回 2\nmyLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3\nmyLinkedList.get(1);              // 返回 3思路\n\n每次对链表操作设置一个新的虚拟头结点current，不能直接对原链表头结点直接操作。\n如果有添加或者删除结点的操作时注意对size操作，并且需要设置prev指向上一个结点，current指向当前结点。\nsize表示链表长度，该链表下标由0开始，因此注意边界条件为(index &lt; 0 || index &gt;= size)\n\n该题难度不大，为了熟练对链表操作的掌握。\n代码实现\njavaclass MyLinkedList &#123;\n    //size存储链表元素的个数\n    int size;\n    //虚拟头结点\n    ListNode dummy;\n    public MyLinkedList() &#123;\n        size = 0;\n        dummy = new ListNode(0);\n    &#125;\n\n    public int get(int index) &#123;\n        //遍历链表获取链表中下标为index的节点的值\n        if(index &lt; 0 || index &gt;= size) &#123;\n            return -1; //下标无效\n        &#125;\n        //定义一个头结点\n        ListNode current = dummy;\n        for (int i = 0; i &lt; size; i++) &#123;\n            current = current.next;\n            if(i == index) &#123;\n                break;\n            &#125;\n        &#125;\n        return current.val;\n    &#125;\n    //插入到第一个元素之前\n    public void addAtHead(int val) &#123;\n        //新设一个头结点\n        ListNode current = dummy;\n        //需要插入的结点\n        ListNode newval  = new ListNode(val);\n        newval.next = current.next;\n        current.next = newval;\n        size++; //插入后链表长度发生变化\n    &#125;\n\n    //插入到最后一位\n    public void addAtTail(int val) &#123;\n        //新设一个头结点，遍历到链表最后一位\n        ListNode current = dummy;\n        for (int i = 0; i &lt; size; i++) &#123;\n            current = current.next;\n        &#125;\n        ListNode newval = new ListNode(val);\n        newval.next = null;\n        current.next = newval;\n        size++;\n    &#125;\n\n    public void addAtIndex(int index, int val) &#123;\n        if(index &gt; size) &#123;\n            return;\n        &#125;\n        //小于最小的结点则插入头\n        if(index &lt; 0) &#123;\n            addAtHead(val);\n        &#125; else if (index == size) &#123; //刚好等于链表长度,插入尾\n            addAtTail(val);\n        &#125; else &#123; //在链表中\n            //遍历链表的指针\n            ListNode current = dummy.next;\n            //前一个的指针\n            ListNode prev = dummy;\n            for (int i = 0; i &lt; size; i++) &#123;\n                if (i == index) &#123;\n                    //新数据\n                    ListNode node = new ListNode(val);\n                    node.next = current;\n                    prev.next = node;\n                    size++;\n                    break;\n                &#125;\n                prev = current;\n                if (current.next != null) &#123;\n                    current = current.next;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    public void deleteAtIndex(int index) &#123;\n        if (index &lt; 0 || index &gt; size) &#123;\n            return;\n        &#125;\n        //有效进行删除\n        ListNode prev = dummy;\n        ListNode current = dummy.next;\n        for (int i = 0; i &lt; size; i++) &#123;\n            if (i == index) &#123;\n                prev.next = current.next;\n                size--;\n                break;\n            &#125;\n            prev = current;\n            if (current.next != null) &#123;\n                current = current.next;\n            &#125;\n        &#125;\n    &#125;\n&#125;反转链表 题目\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n\ntxt输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]示例 2：\ntxt输入：head = [1,2]\n输出：[2,1]示例 3：\ntxt输入：head = []\n输出：[]思路\n如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。\n其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。\n之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改变next指针的方向。\n\n动画应该是先移动pre，在移动cur\n\n首先定义一个cur指针，指向头结点，再定义一个prev指针，初始化为null。\n然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。\n为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向，将cur-&gt;next 指向prev ，此时已经反转了第一个节点了。\n反转过后应该遍历链表。循环条件：while(cur != null)，遍历链表：prev = cur，cur = temp。\n最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。\n\n\n代码实现\n双指针法\n时间复杂度: O(n)\n空间复杂度: O(1)\n\njavapublic ListNode reverseList(ListNode head) &#123;\n    //保存cur下一个结点\n    ListNode temp = new ListNode();\n    ListNode cur = head;\n    ListNode prev = null;\n    while (cur != null) &#123;\n        temp = cur.next; //临时存储下一个结点\n        cur.next = prev;\n        //移动prev和cur指针\n        prev = cur;\n        cur = temp;\n    &#125;\n    return prev;\n&#125;递归法\n时间复杂度: O(n), 要递归处理链表的每个节点\n空间复杂度: O(n), 递归调用了 n 层栈空间\n\njavapublic ListNode reverseList(ListNode head) &#123;\n        return reverse(null, head);\n&#125;\nprivate ListNode reverse(ListNode prev, ListNode cur) &#123;\n    if (cur == null) &#123;\n       return prev;\n    &#125;\n    ListNode temp = null;\n    temp = cur.next; //保存下一个结点\n    cur.next = prev; //反转\n    //更新prev和cur位置\n    //prev = cur;\n    //cur = temp;\n    return reverse(cur, temp);\n&#125; 两两交换链表中的节点 题目\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n示例 1：\n\ntxt输入：head = [1,2,3,4]\n输出：[2,1,4,3]示例 2：\ntxt输入：head = []\n输出：[]示例 3：\ntxt输入：head = [1]\n输出：[1]思路\n画图操作步骤如下，当temp存在的话就进行交换，因此条件为temp != null。\n\n代码实现\njavapublic ListNode swapPairs(ListNode head) &#123;\n    //设置虚拟头结点dummy用来返回\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    //前一个指针\n    ListNode prev = dummy;\n    while (head != null) &#123;\n        ListNode temp = head.next;\n        //如果后面的元素不为空则交换\n        if (temp != null) &#123;\n            prev.next = temp;\n            head.next = temp.next;\n            temp.next = head;\n        &#125;\n        prev = head;\n        head = head.next;\n    &#125;\n    return dummy.next;\n&#125;删除链表的倒数第N个结点 题目\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n 示例 1：\n\ntxt输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]示例 2：\ntxt输入：head = [1], n = 1\n输出：[]示例 3：\ntxt输入：head = [1,2], n = 1\n输出：[1]思路\n双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。\n但是需要注意一些细节\n\n定义fast指针和slow指针，初始值为虚拟头结点。\n\nfast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： \n\nfast和slow同时移动，直到fast指向末尾，如题： \n\n删除slow指向的下一个节点，如图： \n\n\n代码实现\njavapublic ListNode removeNthFromEnd(ListNode head, int n) &#123;\n    //设置一个虚拟头结点，用来返回\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    //设置快慢指针,快指针先走n+1步\n    ListNode fast = dummy;\n    ListNode slow = dummy;\n    //快指针先走n+1步\n    while (n-- &gt; 0 &amp;&amp; fast != null) &#123;\n        fast = fast.next;\n    &#125;\n    //再移动一次fast\n    fast = fast.next;\n    //同时移动快慢指针，当fast指针指向null停止\n    while (fast != null) &#123;\n        fast = fast.next;\n        slow = slow.next;\n    &#125;\n    //删除slow下一个结点\n    slow.next = slow.next.next;\n    return dummy.next;\n&#125;面试题 02.07. 链表相交","slug":"算法-链表","date":"2023-12-05T11:33:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"白"},{"id":"1451337e2cd8330994910442b8a41dbc","title":"Java学习笔记","content":"Java笔记\n第 2 章 Java 概述Java 技术体系平台\nJava 重要特点\nJava 语言是面向对象的(oop)\nJava 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证\nJava 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]\nJava 语言是解释型的[了解]\n\n\n解释性语言：javascript,PHP, java 编译性语言: c &#x2F; c++\n区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可\n以直接被机器执行, c &#x2F;c++\n\nJava运行机制及运行过程\nJava核心机制Java 虚拟机 [JVM java virtual machine]\n基本介绍\nJVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在\n\nJDK 中. \n\n对于不同的平台，有不同的虚拟机。\nJava 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行” [说明]\n\n示意图\n什么是 JDK，JREJDK基本介绍\nJDK 的全称(Java Development Kit Java 开发工具包)\n\n​\tJDK &#x3D; JRE + java 的开发工具 [java, javac,javadoc,javap 等]\n\nJDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE 了\n\nJRE 基本介绍\nJRE(Java Runtime Environment Java 运行环境)\n\nJRE &#x3D; JVM + Java 的核心类库[类]\n\n包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。\n\nJDK、JRE 和 JVM 的包含关系\nJDK &#x3D; JRE + 开发工具集（例如 Javac,java 编译工具等)\nJRE &#x3D; JVM + Java SE 标准类库（java 核心类库）\n如果只想运行开发好的 .class 文件 只需要 JRE\n\nJava开发注意事项和细节说明\nJava转义字符Java常用的转义字符\n在控制台，输入 tab 键，可以实现命令补全\n\\t ：一个制表位，实现对齐的功能\n\\n ：换行符\n\\\\ ：一个\\\n\\&quot; :一个&quot;\n\\&#39; ：一个&#39; \n\\r :一个回车\n注释(comment)Java中的注释类型\n单行注释 //\n多行注释 /*  */\n文档注释 /**  */\n\n单行注释：格式： &#x2F;&#x2F;注释文字\n多行注释：格式： &#x2F;* 注释文字 *&#x2F;\n使用细节\n被注释的文字，不会被 JVM（java 虚拟机）解释执行\n多行注释里面不允许有多行注释嵌套\n\nDOS命令DOS介绍Dos： Disk Operating System 磁盘操作系统。\n原理图\n相对路径，绝对路径\n常用的dos命令DOS内部命令\ndir—-显示指定路径下所有文件和目录的信息\ncd—-进入指定目录\nmd—-创建指定目录\ncd&gt;—-创建指定文件\nrd—-删除指定空目录\ndel—-删除指定文件\ncopy—-复制文件\nren—-改名\nver—-显示当前DOS系统版本号\ntype—-在命令行窗口打开文件\ncls—-清空DOS命令窗口\nchkdsk—-检查磁盘使用情况\ntime—-显示和设置DOS的系统时间\ndate—-显示和设置DOS的系统日期\nsys—-传递系统文件命令\nexit—-退出cmd.exe程序\n\n常用DOS外部命令\nxcopy—-批量复制\ncertmgr—-证书管理\ncalc—-计算器\ncleanmgr—-垃圾整理\ncliconfg—-SQL SERVER客户端网络使用程序\ncompmgmt—-管理\ndevmgmt—-设备管理器\neventvwr—-事件查看器\nexplorer—-资源管理器\ngpedit—-组策略\nlusrmgr—-用户组\nmspaint—-画图板\nmstsc—-桌面远程连接\nnotepad—-记事本\nregedit—-注册表\nsfc—-系统文件检查器\nsfc&#x2F;scannow—-文件保护\ntaskmgr—-任务管理器\nwrite—-写字板\nipconfig—-查看电脑的IP地址\nping—-网络诊断\n\n\n第 3 章 变量3.1 数据类型\n3.2 整数类型整型的类型\n\n\n类型\n占用存储空间\n范围\n\n\n\nbyte[字节]\n1字节\n-128 ~ 127为啥存放的范围是这个&#x3D;&gt;二进制\n\n\nshort[短整型]\n2字节\n-(2^15) ~ 2^15 - 1-32768 ~ 32767\n\n\nint[整型]\n4字节\n-2^31 ~ 2^31 - 1-2147483648 - 2147483647\n\n\nIong[长整型]\n8字节\n-2^63 ~ 2^63 - 1\n\n\n整型的使用细节\nJva各整数类型有固定的范围和字段长度，不受具体OS[操作系统]的影响，以保证java程序的可移植性。\nJava的整型常量（具体值）默认为int型，声明long型常量须后加&#39;I&#39;或&#39;L&#39; \njava程序中变量常声明为int型，除非不足以表示大数，才使用long \nbit:计算机中的最小存储单位。byte:计算机中基本存储单元，1byte&#x3D;8bit。\n\n3.3 浮点类型浮点型的分类\n\n\n类型\n占用存储空间\n范围\n\n\n\n单精度float\n4字节\n-3.403E38 ~ 3.403E38\n\n\n双精度double\n8字节\n-1.798E308 ~ 1.798E308\n\n\n\n关于浮点数在机器中存放形式的简单说明,浮点数&#x3D;符号位+指数位+尾数位\n尾数部分可能丢失，造成精度损失(小数都是近似值)。\n\n浮点型使用细节\n与整数类型类以，Java浮点类型也有固定的范围和字段长度，不受具体OS的影响。[float  4个字节\tdouble是8个字节] \nJava的浮点型常量（具体值）默认为doublei型，声明float型常量，须后加 &#39;f&#39;或&#39;F&#39; \n浮点型常量有两种表示形式\n\n\n十进制数形式：如：5.12   512.0f    .512(必须有小数点)\n科学计数法形式：如：5.12e2 [5.12*10的2次方]  5.12E-2  [5.12&#x2F;10的2次方]\n\n\n通常情况下，应该使用doublei型，因为它比float?型更精确。[举例说明]\n\n\ndouble num9 &#x3D; 2.1234567851；\nfloat num10 &#x3D; 2.1234567851F；\n\n\n浮点数使用陷阱：2.7和8.1&#x2F;3比较\n\njavadouble num7 2.7;\ndouble num8 =8.1/3;\nif(Math.abs(num7-num8)&lt;0.00001)&#123; \n    Svstem.out.println(&quot;相等~~~&quot;);3.4 Java API文档\nAPI (Application Programming Interface, 应用程序编程接口) 是 Java提供的基本编程接口 (java提供的类还有相关的方法)。中文在线文档： https://www.matools.com \nJava语言提供了大量的基础类，因此Oracle公司也为这些基础类提供了相应的API文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。 \nJava类的组织形式。\n\n\n3. 5 字符类型字符类型使用细节\n字符常量是用单引号( &#39; &#39; )括起来的单个字符。例如： char c1 &#x3D; ‘a’ ；char c2 &#x3D; ‘中’ ；char c3 &#x3D; ‘9’；\nJava中还允许使用转义字符&#39;\\&#39;来将其后的字符转变为特殊字符型常量。例如：char c3 &#x3D; ‘n’；’\\n’表示换行符 \n在java中，char的本质是一个整数，在输出时，是 unicode码对应的字符。 http://tool.chinaz.com/Tools/Unicode.aspx \n可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出 [97-&gt; a]\ncha类型是可以进行运算的，相当于一个整数，因为它都对应有Unicodet码.\n\n3.6 ASCII &#x2F; Unicode &#x2F; UTF-8 编码介绍ASCII码\n\nASCII码：上个世纪60年代，美国制定了一套字符编码（使用一个字节），对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。ASCII码一共规定了128个学符的编被，只占用了二个学节的后面7位，最前面的1位统一规定为0。特别提示：一个字节可以表示256个字符，ASCII码只用了128个学符。\n缺点：不能表示所有字符。\n\nUnicode编码\n\nUnicode的好处：一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用Unicode没有乱码的问题。 \nUnicode的缺点：一个英文字母和一个汉字都占用2个字节，这对于存储空间来说是浪费。 \n2的16次方是65536，所以最多编码是65536个字符。 \n编码0-127的字符是与ASCIIE的编码一样。比如 ‘a’ 在ASCII码是 0x61，在unicode码是 ox0061，都对应97。因此Unicode码兼容ASCII码。\n\nUTF-8编码\n\nUTF-8是在互联网上使用最广的一种 Unicode的实现方式（改进）\nUTF-8是一种变长的编码方式。它可以使用1-6个字节表示一个符号，根据不同的符号而变化字节长度。\n使用 大小可变的编码 字母占1个字节，汉字占3个字节\n\n3.7 布尔类型：boolean\n布尔类型也叫boolean类型，booolean类型数据只允许取值true和false，无 null \nboolean类型占1个字节。\nboolean类型适于逻辑运算，一般用于程序流程控制。\n\n3.8 基本数据类型转换自动类型转换当ava程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型这个就是自动类型转换。\n数据类型按精度(容量)大小排序如图\n\n自动类型转换注意和细节\n\n有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。\n当我们把精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错，反之就会进行自动类型转换。 \n(byte,short) 和 char之间不会相互自动转换。 当把具体数赋给 byte 时，(1)先判断该数是否在 byte 范围内，如果是就可以。\nbyte，short，char 他们三者可以计算，在计算时首先转换为int类型。\nboolean不参与转换\n自动提升原则：表达式结果的类型自动提升为操作数中最大的类型\n\n代码例题演示①\njavaint n1 = 10;\t/ok\n\nfloat d1 = n1 + 1.1;\t/错误 n1 + 1.1 =&gt; 结果类型是 double\n\ndouble d1 = n1 + 1.1;\t/对 n1 + 1.1 =&gt; 结果类型是 double\n\nfloat d1 = n1 + 1.1F;\t/对 n1 + 1.1 =&gt; 结果类型是 float②\njavaint n2 = 1.1;\t/错误 double -&gt; int③\njavabyte b1 = 10;\t/对 , -128-127\n\nint n2 = 1;\t\t/n2 是 int\n\nbyte b2 = n2; \t/错误，原因： 如果是变量赋值，判断类型\n\nchar c1 = b1; \t/错误， 原因 byte 不能自动转成 char④\njavabyte b2 = 1;\nbyte b3 = 2;\nshort s1 = 1;\n\nshort s2 = b2 + s1;\t/错, b2 + s1 =&gt; int\n\nint s2 = b2 + s1;\t/对, b2 + s1 =&gt; int\n\nbyte b4 = b2 + b3; \t/错误: b2 + b3 =&gt; int ⑤\njavaboolean pass = true;\n\nint num100 = pass;\t/boolean 不参与类型的自动转换⑥\njavabyte b4 = 1;\nshort s3 = 100;\nint num200 = 1;\nfloat num300 = 1.1F;\n\ndouble num500 = b4 + s3 + num200 + num300; /float -&gt; double强制类型转换自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成精度降低或溢出,格外要注意。\n强制类型转换细节说明\n1、当进行数据的大小从大一&gt;小，就需要使用到强制转换强转换\n2、强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级\njava//int x=(int)10*3.5+6*1.5;\nint y=(int)(10*3.5+6*1.5);\nSystem.out.println(y); 3、char类型可以保存int的常量值，但不能保存int的变量值，需要强转 \njavachar c1 100; \t/ok \nint m 100; \t/ok \nchar c2=m; \t/错误 \nchar c3 =(char)m; \t/ok \nSystem.out.println(c3); \t/100对应的字符4、byte和short,char类型在进行运算时，当做int类型处理。\n","slug":"Java学习笔记","date":"2023-12-04T13:29:00.000Z","categories_index":"Java","tags_index":"Java","author_index":"白"},{"id":"52a2a9bb6ef1e7b81577358c82fded8e","title":"Python初级入门","content":"Python初级入门爬虫的流程第一步：获取网页内容\nHTTP协议\nHTTP响应\n\nPython Requests\n第二步：解析网页内容\nHTML定义网页的结构和信息 \nCSs定义网页的样式 \nJavaScript定义用户和网页的交互逻辑\nhtml网页结构\nBeautiful Soup\n第三步：储存或分析数据\n","slug":"Python初级入门","date":"2023-12-02T06:50:00.000Z","categories_index":"Python","tags_index":"Python","author_index":"白"},{"id":"929904857381a43e5a2e7edb558ba72e","title":"算法学习_数组篇","content":"算法学习_数组篇二分查找前提条件1、被搜索的序列必须是有序的，可以是升序或降序。\n2、数据集中的元素必须是可比较的。(因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。)\n使用二分查找不一定要求数组是有序的。只需要能够找到一个分割点，将序列分为两个类别即可，通常来说这个分割点用中点。\n二分查找类型(重要)写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。\n在java中设置int mid &#x3D; left + ( left + right )&#x2F;2是为了防止溢出。相当于 right + left &gt;&gt; 1;\n左闭右闭[left, right]因为定义target在[left, right]区间，所以有如下两点：\n\nwhile (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;\nif (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1\n\n例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：\n\n代码实现\n\n时间复杂度：O(log n)\n空间复杂度：O(1)\n\njavaclass Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        // 避免当 target 小于nums[0] 大于nums[nums.length - 1]时多次循环运算\n        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123;\n            return -1;\n        &#125;\n        int left = 0, right = nums.length - 1;\n        while (left &lt;= right) &#123;\n            int mid = left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] == target)\n                return mid;\n            else if (nums[mid] &lt; target)\n                left = mid + 1;\n            else if (nums[mid] &gt; target)\n                right = mid - 1;\n        &#125;\n        return -1;\n    &#125;\n&#125;左闭右开[left, right)如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。\n\nwhile (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的\nif (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]\n\n在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（注意和方法一的区别）\n\n代码实现\n\n时间复杂度：O(log n)\n空间复杂度：O(1)\n\njavaclass Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        int left = 0, right = nums.length;\n        while (left &lt; right) &#123;\n            int mid = left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] == target)\n                return mid;\n            else if (nums[mid] &lt; target)\n                left = mid + 1;\n            else if (nums[mid] &gt; target)\n                right = mid;\n        &#125;\n        return -1;\n    &#125;\n&#125;相关题目练习\n(35. 搜索插入位置 - 力扣（LeetCode）)\n(34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）)\n(69. x 的平方根 - 力扣（LeetCode）)\n(367. 有效的完全平方数 - 力扣（LeetCode）)\n\n35.搜索插入位置题目\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\n示例 1:\ntxt输入: nums = [1,3,5,6], target = 5\n输出: 2示例 2:\ntxt输入: nums = [1,3,5,6], target = 2\n输出: 1示例 3:\ntxt输入: nums = [1,3,5,6], target = 7\n输出: 4思路\n\n当target &#x3D; 2 &gt; nums[mid]的时候，l &#x3D; mid + 1，因此l就移动到3（索引为1）的位置，此刻left&gt;right不满足循环条件，因此退出循环。最后应当返回left所在位置为插入位置。\n\n\n代码实现\njavapublic int searchInsert(int[] nums, int target) &#123;\n    int left = 0, right = nums.length-1;\n    while(left &lt;= right) &#123; //左闭右闭\n        int mid = ((left + right) /2);\n        if(target &gt; nums[mid]) &#123;\n            left = mid + 1;\n        &#125; else if(target &lt; nums[mid]) &#123;\n            right = mid -1;\n        &#125; else &#123;\n            return mid;\n        &#125;\n    &#125;\n    return left;\n&#125;34.在排序数组中查找元素的第一个和最后一个位置题目\n给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：\ntxt输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]示例 2：\ntxt输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]示例 3：\ntxt输入：nums = [], target = 0\n输出：[-1,-1]思路\n\n代码实现\njavapublic int[] searchRange(int[] nums, int target) &#123;\n    int len = nums.length;\n    if(len == 0) &#123;\n        return new int[]&#123;-1,-1&#125;;\n    &#125;\n    int firstPosition = findFirstPosition(nums, target);\n    if(firstPosition == -1) &#123;\n        return new int[]&#123;-1, -1&#125;;\n    &#125;\n    int lastPosition = findLastPosition(nums, target);\n    return new int[]&#123;firstPosition, lastPosition&#125;;\n&#125;\n//返回第一个\npublic int findFirstPosition(int[] nums, int target) &#123;\n    int first = -1;\n    int left = 0, right = nums.length-1;\n    while(left &lt;= right) &#123; //左闭右闭\n        int mid = ((left + right) /2);\n        if(target &gt; nums[mid]) &#123;\n            left = mid + 1;\n        &#125; else if(target &lt; nums[mid]) &#123;\n            right = mid -1;\n        &#125; else &#123;\n            first = mid;\n            right = mid-1;\n        &#125;\n    &#125;\n    return first;\n&#125;\npublic int findLastPosition(int[] nums, int target) &#123;\n    int last = -1;\n    int left = 0, right = nums.length-1;\n    while(left &lt;= right) &#123; //左闭右闭\n        int mid = ((left + right) /2);\n        if(target &gt; nums[mid]) &#123;\n            left = mid + 1;\n        &#125; else if(target &lt; nums[mid]) &#123;\n            right = mid -1;\n        &#125; else &#123;\n            last = mid;\n            left = mid +1;\n        &#125;\n    &#125;\n    return last;\n&#125;69.x的平方根题目\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1：\ntxt输入：x = 4\n输出：2示例 2：\ntxt输入：x = 8\n输出：2\n解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。思路\nx设为right，通过二分法查找值，mid*mid &#x3D; x时则表示找到。为了防止溢出这里不能用 mid*mid&#x3D;x应该用 x&#x2F;mid&#x3D;mid。\n代码实现\njavapublic int mySqrt(int x) &#123;\n    if(x == 0 || x == 1)&#123;\n        return x;\n    &#125;\n    int left = 0;\n    int right = x;\n    while(left &lt;= right) &#123;\n        int mid = (left + right) / 2;\n        if(x/mid == mid) &#123;\n            return mid;\n        &#125;\n        if(x/mid &lt; mid) &#123;\n            right = mid - 1;\n        &#125; else if(x/mid &gt; mid) &#123;\n            left = mid + 1;\n        &#125;\n    &#125;\n    return right;\n&#125;367.有效的完全平方数题目\n给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。\n完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n不能使用任何内置的库函数，如 sqrt 。\n示例 1：\ntxt输入：num = 16\n输出：true\n解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。示例 2：\ntxt输入：num = 14\n输出：false\n解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。思路\n设置一个临时变量t存储num&#x2F;mid的值，再借此判断t与mid的关系。如果此时t &#x3D;&#x3D; mid，还要再判断余数，若余数为0则满足是完全平方数。\n代码实现\njavapublic boolean isPerfectSquare(int num) &#123;\n    int low = 1;\n    int high = num;\n    while (low &lt;= high) &#123;\n        int mid = low + (high-low)/2;\n        int t = num/mid; //求完全平方数\n        if(t == mid) &#123;\n            return num % mid == 0;\n        &#125; else if (t &lt; mid) &#123;\n            high = mid - 1;\n        &#125; else &#123;\n            low = mid + 1;\n        &#125;\n    &#125;\n    return  false;\n&#125;\n移除元素题目\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1：\ntxt输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。示例 2：\ntxt输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,3,0,4]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。双指针法双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。\n定义快慢指针\n\n快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组\n慢指针：指向更新 新数组下标的位置\n\n删除过程如下\n\n代码实现\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n设置快慢指针，快指针从头开始遍历数组，将符合条件的筛选出来。例如本题val=3的话，将val!=3的数据加入到数组中，在本题中就利用慢指针开始覆盖掉原数组内容，快指针遍历数组并进行筛选。\njavapublic int removeElement(int[] nums, int val) &#123;\n    int slowIndex = 0;\n    for (int flastIndex = 0; flastIndex &lt; nums.length; flastIndex++) &#123;\n        if(nums[flastIndex] != val) &#123;\n            nums[slowIndex++] = nums[flastIndex];\n        &#125;\n    &#125;\n    return slowIndex;\n&#125;相关题目练习\n26.删除排序数组中的重复项\n283.移动零\n844.比较含退格的字符串\n977.有序数组的平方\n\n26.删除有序数组中的重复项题目\n给你一个 非严格递增排列 的数组 nums ，请你  原地   删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。\n返回 k 。\n\n示例 1：\ntxt输入：nums = [1,1,2]\n输出：2, nums = [1,2,_]\n解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。示例 2：\ntxt输入：nums = [0,0,1,1,1,2,2,3,3,4]\n输出：5, nums = [0,1,2,3,4]\n解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。思路\n设置双指针，lowindex和highindex都从0开始。highindex遍历数组，lowindex记录数据序号，当highindex查询到与当前lowindex所在位置数据相同时，跳过当前循环。如果查询到新数据，先将lowindex向后移一位，再把当前新数据存储到nums数组中，返回结果时注意lowindex+1。\njavapublic int removeDuplicates(int[] nums) &#123;\n    int lowindex = 0;\n    for (int highindex = 0; highindex &lt; nums.length; highindex++) &#123;\n        if(nums[highindex] == nums[lowindex]) &#123;\n            continue;\n        &#125;\n        nums[++lowindex] = nums[highindex];\n    &#125;\n    return ++lowindex;\n&#125;283.移动零题目\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\ntxt输入: nums = [0,1,0,3,12]\n输出: [1,3,12,0,0]示例 2:\ntxt输入: nums = [0]\n输出: [0]思路\n解法一：\n两次遍历创建两个指针i和j，i指针负责记录有多少个非0元素，i指针从头遍历数组，j指针负责找到非0的值，当找到非0元素直接赋值给i指针所在位置，i指针指向下一个。当j指针遍历到数组尾部时，i指针指向的下标就是最后一个非0元素的后一个位置。\n演示\nb从头遍历，当a指针找到非0的数据，直接覆盖掉b所在位置。然后b++，指向下一位，a指针找到非0的值直接覆盖。当a指针遍历完数组后，从b指针开始给数组其他位赋值0。\n\njavapublic void moveZeroes(int[] nums) &#123;\n    int lowindex = 0;\n    for (int highindex = 0; highindex &lt; nums.length; highindex++) &#123;\n        //highindex不为0直接赋值给lowindex，并且l递增\n        if(nums[highindex] != 0) &#123;\n            nums[lowindex++] = nums[highindex];\n        &#125;\n    &#125;\n    //当highindex遍历完数组时，应该为后面的填0\n    for (int i = lowindex; i &lt; nums.length; i++) &#123;\n        nums[i] = 0;\n    &#125;\n&#125;解法二：\n​\t这里参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点 x，然后把所有小于等于 x 的元素放到 x 的左边，大于 x 的元素放到其右边。这里我们可以用 0 当做这个中间点，把不等于 0(注意题目没说不能有负数)的放到中间点的左边，等于 0 的放到其右边。这的中间点就是 0 本身，所以实现起来比快速排序简单很多，我们使用两个指针 i 和 j，只要 nums[i]!=0，我们就交换 nums[i] 和 nums[j]，并且让i指针指向下一个数据。\n演示\na，b指针都从0开始遍历数组，b指针从头遍历，a指针找非0数据，当找到非0数据就与b交换，并且b++。\n\njavapublic void moveZeroes(int[] nums) &#123;\n    int left = 0;\n    int temp;\n    for (int right = 0; right &lt; nums.length; right++) &#123;\n        if(nums[right] != 0) &#123;\n            temp = nums[right];\n            nums[right] = nums[left];\n            nums[left++] = temp;\n            //left++;\n        &#125;\n    &#125;\n&#125;844.比较含退格的字符串题目\n给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n注意：如果对空文本输入退格字符，文本继续为空。\n示例 1：\ntxt输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;\n输出：true\n解释：s 和 t 都会变成 &quot;ac&quot;。示例 2：\ntxt输入：s = &quot;ab##&quot;, t = &quot;c#d#&quot;\n输出：true\n解释：s 和 t 都会变成 &quot;&quot;。示例 3：\ntxt输入：s = &quot;a#c&quot;, t = &quot;b&quot;\n输出：false\n解释：s 会变成 &quot;c&quot;，但 t 仍然是 &quot;b&quot;。思路\n由于#号会消除左边的一个字符，所以对右边字符无影响，所以我们选择从后往前遍历S，T字符串。\n步骤解析\n1、准备两个指针i,j分别指向 S，T 的末位字符，再准备两个变量skipS，skipT来分别存放 S，T 字符串中的 # 数量。\n2、从后往前遍历S，所遇到的情况有三个。\n\n2.1 若当前字符是#，则skipS自增1；\n2.2 若当前字符不是#，且skipS不为0，则skipS自减1；\n2.3 若当前字符不是#，且skipS为0，则代表当前字符不会被消除，这时我们就需要和T中的当前字符作比较。\n\n3、从后往前遍历T和2相同。\n4、若对比出现S、T当前字符不匹配，则遍历结束，返回false，若S、T都遍历结束，且都能一一匹配，则返回true。\njavapublic boolean backspaceCompare(String s, String t) &#123;\n    //设置两个指针位置，定义skip*为#个数\n    int i = s.length() - 1, j = t.length() - 1;\n    int skipS = 0,skipT = 0;\n    while (i &gt;= 0 || j &gt;= 0) &#123;\n        //该while循环找s字符串右边不被消除的字符\n        while (i &gt;= 0) &#123;\n            if (s.charAt(i) == &#39;#&#39;) &#123;\n                skipS++;\n                i--;\n            &#125; else if (skipS &gt; 0) &#123;\n                skipS--;\n                i--;\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n        //该while循环找t字符串右边不被消除的字符\n        while (j &gt;= 0) &#123;\n            if (t.charAt(j) == &#39;#&#39;) &#123;\n                skipT++;\n                j--;\n            &#125; else if (skipT &gt; 0) &#123;\n                skipT--;\n                j--;\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n        //如果i和j没越界，就看i，j指向的值是否相等\n        if(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;\n            //匹配当前最后一个字符\n            if(s.charAt(i) != t.charAt(j)) &#123;\n                return false;\n            &#125;\n        &#125;\n        //此时表示i或者j有一个或者两个越界了\n        //比如i找不到下一位了，但j下一位还有字符需要匹配，这时就说明两个数组不相等\n        else &#123;\n            if(i &gt;= 0 || j &gt;= 0) &#123;\n                return false;\n            &#125;\n        &#125;\n        i--;j--;\n    &#125;\n    return true;\n&#125;977.有序数组的平方题目\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1：\ntxt输入：nums = [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]示例 2：\ntxt输入：nums = [-7,-3,2,3,11]\n输出：[4,9,9,49,121]思路\n设置一个新数组res存放数据，设置left，right分别指向数组头和尾。\n因为是非递减顺序，因此判断数组最左边left和最右边right的平方值的大小。如果left^2比right^2大，则把left的平方值赋值给新数组的尾部，然后尾部索引减一，再重复上诉操作。因为是非递减顺序，此处判断头尾大小可以nums[left] + nums[rigth] &lt; 0。\njavaint i = nums.length;\nint left = 0;\nint right = i - 1;\nint[] res = new int[i];\nwhile (left &lt;= right) &#123;\n    i--;\n    if(nums[left] + nums[right] &lt; 0) &#123;\n        res[i] = nums[left]*nums[left];\n        left++;\n    &#125; else &#123;\n        res[i] = nums[right]*nums[right];\n        right--;\n    &#125;\n&#125;\nreturn res;\n长度最小的子数组题目\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n示例 1：\ntxt输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。示例 2：\ntxt输入：target = 4, nums = [1,4,4]\n输出：1示例 3：\ntxt输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0滑动窗口所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。\n首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。\n在本题中实现滑动窗口，主要确定如下三点：\n\n窗口内是什么？\n如何移动窗口的起始位置？\n如何移动窗口的结束位置？\n\n窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。\n窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。\n\t\n思路\n​\t利用滑动窗口解决问题，索引应为滑动窗口的终止位置，而不是起始位置（起始位置的话，就跟暴力解法双重for循环性质一样了）。如果当前窗口所有的值大于target，则计算当前窗口长度subL = right - left + 1，比较subL和result的值取最小的作为result返回值。sum的值减去滑动窗口的起始位置的值，并且移动窗口的起始位置，重复上诉操作。\n代码实现\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\njavapublic int minSubArrayLen(int target, int[] nums) &#123;\n    int result = Integer.MAX_VALUE;\n    int sum = 0;\n    int left = 0; //滑动窗口起始位置\n    for (int right = 0; right &lt; nums.length; right++) &#123;\n        sum += nums[right];\n        //当集合的总和大于target的时候，缩减集合起始位置\n        while (sum &gt;= target) &#123;\n            //计算当前窗口长度\n            int subL = right - left + 1;\n            //result取当前最小长度\n            result = Math.min(result, subL);\n            sum -= nums[left];\n            left++; //移动初始位置\n        &#125;\n    &#125;\n    return result == Integer.MAX_VALUE ? 0 : result;\n&#125;相关题目练习904. 水果成篮 - 力扣（LeetCode）\n76. 最小覆盖子串 - 力扣（LeetCode）\n904.水果成蓝题目\n你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。\n你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。\n一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。\n\n给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例 1：\ntxt输入：fruits = [1,2,1]\n输出：3\n解释：可以采摘全部 3 棵树。示例 2：\ntxt输入：fruits = [0,1,2,2]\n输出：3\n解释：可以采摘 [1,2,2] 这三棵树。\n如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。示例 3：\ntxt输入：fruits = [1,2,3,2,2]\n输出：4\n解释：可以采摘 [2,3,2,2] 这四棵树。\n如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。示例 4：\ntxt输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]\n输出：5\n解释：可以采摘 [1,2,1,1,2] 这五棵树。思路\n​\t用HashMap存储水果树，key表示水果类型，values表示对应的个数，right是窗口的终止位置，left作为窗口的起始位置，当HashMap长度超过2个时，则说明三个类型的水果，使用while循环缩小窗口，移动left的位置。每次记录当前窗口大小，和之前记录的最大窗口进行比较。\n代码实现\njavapublic int totalFruit(int[] fruits) &#123;\n    int n = fruits.length;\n    //定义map存储水果，key为水果类型，value为水果个数\n    Map&lt;Integer, Integer&gt; countMap = new HashMap&lt;&gt;();\n    int left = 0, maxFruits = 0;\n    for (int right = 0; right &lt; n; ++right) &#123;\n        // 将当前水果添加到窗口中，如果没有则默认为0个\n        countMap.put(fruits[right], countMap.getOrDefault(fruits[right], 0) + 1);\n        // 如果窗口中水果类型超过两种，进入while循环，移动左边界缩小窗口\n        while (countMap.size() &gt; 2) &#123;\n            countMap.put(fruits[left], countMap.get(fruits[left]) - 1);\n            // 如果水果数量为0，从窗口中移除该水果类型\n            if (countMap.get(fruits[left]) == 0) &#123;\n                countMap.remove(fruits[left]);\n            &#125;\n            // 移动左边界\n            ++left;\n        &#125;\n        // 更新最大水果数量 窗口大小和最大值比较\n        maxFruits = Math.max(maxFruits, right - left + 1);\n    &#125;\n    return maxFruits;\n&#125;76.最小覆盖子串题目\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。\n示例 1：\ntxt输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n输出：&quot;BANC&quot;\n解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#39;A&#39;、&#39;B&#39; 和 &#39;C&#39;。示例 2：\ntxt输入：s = &quot;a&quot;, t = &quot;a&quot;\n输出：&quot;a&quot;\n解释：整个字符串 s 是最小覆盖子串。示例 3:\ntxt输入: s = &quot;a&quot;, t = &quot;aa&quot;\n输出: &quot;&quot;\n解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。思路\n​\t建立两个HashMap分别存储字符串t和s的内容，key表示字符，values表示字符数量。首先遍历目标字符串t，将每个字符及其出现的次数存入ori中，设置窗口左右边界，ansL和ansR分别存储最小覆盖子串的起始和终止位置，len为窗口长度。遍历s字符串添加到cnt中，然后判断ori中所有字符的个数是否小于cnt中的个数，如果合法，比较窗口大小，若更小则更新，继续缩减窗口。若左指针指向的字符存在ori中，则在cnt中减少其出现次数，如果是普通字符就只需要缩减窗口。\n代码实现\njava//建立两个HashMap，ori用于存储目标字符串t中每个字符的出现次数\n//cnt用于存储当前窗口中每个字符的出现次数。\nMap&lt;Character, Integer&gt; ori = new HashMap&lt;Character, Integer&gt;();\nMap&lt;Character, Integer&gt; cnt = new HashMap&lt;Character, Integer&gt;();\n\npublic String minWindow(String s, String t) &#123;\n\n    int tLen = t.length();\n\n    //遍历目标字符串t，将每个字符及其出现次数存入ori中\n    for (int i = 0; i &lt; tLen; i++) &#123;\n        char c = t.charAt(i);\n        ori.put(c, ori.getOrDefault(c, 0) + 1);\n    &#125;\n\n    int l = 0, r = -1;//l窗口左边界，r窗口右边界\n    //ansL和ansR用于存储最小覆盖子串的起始位置和结束位置。\n    int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;\n    //s串长度\n    int sLen = s.length();\n    //开始遍历\n    while (r &lt; sLen) &#123;\n        ++r;\n        //遍历原字符串s，右指针r向右移动。若r未越界且当前字符存在于ori中，则将其添加至cnt中并增加其出现次数。\n        if (r &lt; sLen &amp;&amp; ori.containsKey(s.charAt(r))) &#123;\n            //存放窗口内不同目标字符的数量\n            cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);\n        &#125;\n        //判定是否合法\n        while (check() &amp;&amp; l &lt;= r) &#123;\n            //比较窗口大小,如果你后面符合的窗口都比我现在大，就没必要更新了，继续缩短窗口\n            if (r - l + 1 &lt; len) &#123;\n                len = r - l + 1;//更新为窗口大小\n                ansL = l; //符合的左边边界下标就是窗口的左边界\n                ansR = l + len; //符合的右边边界下标\n            &#125;\n            //若左指针指向的字符存在于ori中，则在cnt中减少其出现次数。（因为现在要开始向后移动窗口的左边界）\n            //如果是普通字符就只是简单的移动指针就叫可以了，如果是目标字符，就要减少窗口这个字符的数量\n            if (ori.containsKey(s.charAt(l))) &#123;\n                cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);\n            &#125;\n            //窗口左边界向后移动，缩小窗口\n            ++l;\n        &#125;\n    &#125;\n    //返回最小覆盖子串，若ansL为-1，则说明不存在，返回空串。否则，返回s中从ansL到ansR的子串\n    return ansL == -1 ? &quot;&quot; : s.substring(ansL, ansR);\n&#125;\n\n//判断当前窗口是否包含了目标字符串t的所有字符。(种类和数量都要匹配)\npublic boolean check() &#123;\n\n    //map迭代器\n    Iterator iter = ori.entrySet().iterator();\n    //如果map有元素（就是t字符串的各个字符和它的数量）\n    while (iter.hasNext()) &#123;\n        Map.Entry entry = (Map.Entry) iter.next();\n        //拿到每个key，即字符\n        Character key = (Character) entry.getKey();\n        //拿到每个value，即字符数量\n        Integer val = (Integer) entry.getValue();\n        //如果窗口内的每个字符和它的数量，只要有一个比目标字符串中的字符少，当前窗口肯定不符合了\n        if (cnt.getOrDefault(key, 0) &lt; val) &#123;\n            return false;\n        &#125;\n    &#125;\n    //符合\n    return true;\n&#125;总结滑动窗口最小滑窗模板：给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最小长度。\njavawhile j &lt; len(nums):\n    判断[i, j]是否满足条件\n    while 满足条件：\n        不断更新结果(注意在while内更新！)\n        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）\n    j += 1最大滑窗模板：给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最大长度。\njavawhile j &lt; len(nums):\n    判断[i, j]是否满足条件\n    while 不满足条件：\n        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）\n    不断更新结果（注意在while外更新！）\n    j += 1是的，关键的区别在于，最大滑窗是在迭代右移右边界的过程中更新结果，而最小滑窗是在迭代右移左边界的过程中更新结果。\n\n螺旋矩阵题目\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例 1：\n\ntxt输入：n = 3\n输出：[[1,2,3],[8,9,4],[7,6,5]]示例 2：\ntxt输入：n = 1\n输出：[[1]]思路\n本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。\n求解本题依然是要坚持循环不变量原则。\n模拟顺时针画矩阵的过程:\n\n填充上行从左到右\n填充右列从上到下\n填充下行从右到左\n填充左列从下到上\n\n由外向内一圈一圈这么画下去。每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。\n\n\n1、计算要循环的圈数circle = n / 2，偶数则刚好，如果是奇数则还会多一个，在遍历完后再赋值。\n2、记录每一圈开始的位置startX，startY分别表示每一圈起始的x和y坐标。注意每遍历完一圈++。\n3、设置num从1开始计数，给数组赋值。\n4、注意设置每一圈的边界offset。该题应用的是左闭右开。\n\n①根据序号1的方向，应该是从startY开始，n - offset结束。(行不动，给列赋值 -&gt; j变化)\n②根据序号2的方向，应该是从startX开始，n - offset结束。(列不动，给行赋值 -&gt; i变化)\n③根据序号3的方向，应该是从序号①记录的位置j开始，到startX结束。\n④根据序号4的方向，应该是从序号②记录的位置i开始，到startY结束。\n\n举例：\n\n①从左往右 y变化for (j = startY; j &lt; n - offset; j++)\n②从上往下 x变化for (i = startX; i &lt; n - offset; i++)\n③从右往左 y变化for ( ; j &gt; startX; j--)\n④从下往上 x变化for ( ; i &gt; startY; i--)\n\n5、注意给奇数表n % 2 != 0的最后一位赋值。\n代码实现\n\n时间复杂度 O(n^2): 模拟遍历二维矩阵的时间\n空间复杂度 O(1)\n\njavapublic int[][] generateMatrix(int n) &#123;\n    int[][] res = new int[n][n];\n    //记录每一圈开始的位置\n    int startX = 0,startY = 0;\n    //从1开始计数\n    int num = 1;\n    //需要控制每一条边遍历的长度，每次循环右边界收缩一位\n    int offset = 1;\n    int circle = n / 2;\n    //遍历的圈数，例如3遍历1圈，4遍历2圈\n    while (circle &gt; 0) &#123;\n        int i,j;\n        //1. 从左往右 y变化 例如: 3的话，边界为2\n        for (j = startY; j &lt; n - offset; j++) &#123;\n            res[startX][j] = num++;\n        &#125;\n        //遍历完1时，j的值为2\n        //2. 从上往下 x变化\n        for (i = startX; i &lt; n - offset; i++) &#123;\n            res[i][j] = num++;\n        &#125;\n        //3. 从右往左 y变化\n        //此时i = 2, j = 2 此刻变化j\n        for ( ; j &gt; startX; j--) &#123;\n            res[i][j] = num++;\n        &#125;\n        //4. 从下往上 x变化\n        //j = 0\n        //i = 2\n        for ( ; i &gt; startY; i--) &#123;\n            res[i][j] = num++;\n        &#125;\n        //圈数缩小，同时调整每圈的起始位置。每层边界+1\n        circle--;startX++;startY++;offset++;\n    &#125;\n    //如果是奇数的话，在最后一个位置填上数字\n    if(n % 2 != 0) &#123;\n        res[startX][startY] = num;\n    &#125;\n    return res;\n&#125;相关题目练习\n54.螺旋矩阵(opens new window)\n剑指Offer 29.顺时针打印矩阵\n\n54.螺旋矩阵题目\n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n示例 1：\n\ntxt输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]示例 2：\n\ntxt输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]思路\n\n初始化：\n初始化一个空的 ArrayList 用于存储结果。\n检查输入矩阵是否为空，如果为空则直接返回空的结果列表。\n获取矩阵的行数 lengthX 和列数 lengthY。\n初始化四个边界变量，分别表示当前遍历的范围。\n\n\n顺时针遍历：\n使用 while 循环，循环条件为 startX &lt;= endX &amp;&amp; startY &lt;= endY，即确保还有元素需要遍历。\n从左到右：遍历当前行的元素，并将其加入结果列表，同时更新 startX++。（最上面一行已经遍历过了，将开始行往下移）\n从上到下：遍历当前列的元素（除去已经遍历过的首元素），将其加入结果列表，同时更新 endY--。（最右边已经遍历过了，将最后列往前移）\n从右到左：在当前行中遍历元素（除去已经遍历过的末元素），将其加入结果列表，同时更新 endX--。（最下面已经遍历过了，将最后行往前移）\n从下到上：在当前列中遍历元素（除去已经遍历过的首元素），将其加入结果列表，同时更新 startY++。（最左边已经遍历过了，将开始列往后移）\n\n\n返回结果：\n返回存储了顺时针螺旋顺序遍历结果的列表。\n\n\n\n\n代码实现\njavapublic List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;\n    //返回的list\n    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    if(matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;\n        return list;\n    &#125;\n    //得到数组的行数和列数\n    int lengthX = matrix.length;\n    int lengthY = matrix[0].length;\n    //得到整个数组的边界\n    int startX = 0, endX = lengthX - 1;\n    int startY = 0, endY = lengthY - 1;\n    while (startX &lt;= endX &amp;&amp; startY &lt;= endY) &#123;\n        //1. 从左往右遍历 当遍历完后应当缩小开始行\n        for (int j = startY; j &lt;= endY ; j++) &#123;\n            list.add(matrix[startX][j]);\n        &#125;\n        startX++;\n        //2. 从上往下遍历 缩小最右边的边界\n        for (int i = startX; i &lt;= endX ; i++) &#123;\n            list.add(matrix[i][endY]);\n        &#125;\n        endY--;\n        //3. 从右往左遍历 缩小最下面的边界\n        if (startX &lt;= endX) &#123;\n            for (int j = endY; j &gt;= startY ; j--) &#123;\n                list.add(matrix[endX][j]);\n            &#125;\n            endX--;\n        &#125;\n        //4. 从下往上\n        if (startY &lt;= endY) &#123;\n            for (int i = endX; i &gt;= startX ; i--) &#123;\n                list.add(matrix[i][startY]);\n            &#125;\n            startY++;\n        &#125;\n    &#125;\n    return list;\n&#125;LCR 146. 螺旋遍历二维数组该题和54一模一样。\n\n数组总结来源：代码随想录 (programmercarl.com)\n二分法\n暴力解法时间复杂度：O(n)\n二分法时间复杂度：O(logn)\n\n在这道题目中讲到了循环不变量原则，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。\n二分法是算法面试中的常考题。\n#双指针法双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n\n暴力解法时间复杂度：O(n^2)\n双指针时间复杂度：O(n)\n\n数组中的元素为什么不能删除，主要是因为以下两点：\n\n数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。\nC++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。\n\n双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。\n#滑动窗口介绍了数组操作中的另一个重要思想：滑动窗口。\n\n暴力解法时间复杂度：O(n^2)\n滑动窗口时间复杂度：O(n)\n\n本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。\n如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。\n#模拟行为模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察对代码的掌控能力。\n在这道题目中，再一次介绍到了循环不变量原则，其实这也是写程序中的重要原则。\n总结\n\n","slug":"算法-数组","date":"2023-11-28T13:34:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"白"},{"id":"ccce3fa211299e936fe89e1eb7d7281f","title":"JDK8-17新特性","content":"JDK8-17新特性目录\n\n如何学习新特性\n\nJava8新特性简介\n\n\nLambda表达式Lambda表达式的使用举例(o1, o2) -&gt; Integer.compare(o1, o2);\njavapublic void test2() &#123;\n    Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() &#123;\n        @Override\n        public int compare(Integer o1, Integer o2) &#123;\n            return Integer.compare(o1, o2);\n        &#125;\n    &#125;;\n    int compare1 = com1.compare(12,21);\n    System.out.println(compare1);\n    //Lambda表达式的写法\n    System.out.println(&quot;===Lambda表达式的写法===&quot;);\n    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2);\n    int compare2 = com2.compare(23,21);\n    System.out.println(compare2);\n&#125;Lambda表达式的格式举例Lambda形参列表 -&gt; lambda体\nLambda表达式的格式-&gt; :\tlambda操作符或箭头操作符\n-&gt;的左边:\tlambda形参列表，对应着重写的接口中的抽象方法的形参列表。前提是参数顺序一致。\n-&gt;的右边:\tlambda体，对应着接口的实现类要重写的方法的方法体。\n六种语法格式举例：使用lambda表达式和不使用的对比\njavapublic void test1() &#123;\n    Runnable r1 = new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;你好&quot;);\n        &#125;\n    &#125;;\n    r1.run();\n    System.out.println(&quot;====&quot;);\n    Runnable r2 = () -&gt; &#123;\n            System.out.println(&quot;你好&quot;);\n    &#125;;\n    r2.run();\n&#125;语法格式一：无参，无返回值。\njavaRunnable r2 = () -&gt; &#123;\n            System.out.println(&quot;你好&quot;);\n&#125;;\nr2.run();语法格式二：lambda需要一个参数，但是没有返回值。\njavaConsumer&lt;String&gt; con1 = (String s) -&gt; &#123;\n    System.out.println(s);\n&#125;;\ncon1.accept(&quot;&quot;);语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型判断”。\n1、数据类型可省略(对比语法格式二)\njavaConsumer&lt;String&gt; con2 = (s) -&gt; &#123;\n    System.out.println(s);\n&#125;;\ncon2.accept(&quot;&quot;);2、类型推断\njavapublic void test3_1() &#123;\n    //int[] arr = new int[]&#123;1,2,3,4&#125;;\n    int[] arr = &#123;1,2,3,4&#125;;  //类型推断\n    HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); //类型推断\n    //Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();\n    var entries = map.entrySet(); //类型推断，在jdk10及之后可以使用\n&#125;语法格式四：lambda若只需要一个参数时，参数的小括号可以省略。\n（对比语法格式三）\njavapublic void test4() &#123;\n    Consumer&lt;String&gt; con2 = s -&gt; &#123;\n        System.out.println(s);\n    &#125;;\n    System.out.println(&quot;世界那么大，我想去看看&quot;);\n&#125;语法格式五：lambda需要两个或以上的参数，多条执行语句，并且可以有返回值。\njavapublic void test5() &#123;\n    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;\n        System.out.println(o1);\n        System.out.println(o2);\n        return o1.compareTo(o2);\n    &#125;;\n    System.out.println(com2.compare(12,21));\n&#125;语法格式六：当lambda体只有一条语句时，return与大括号若有，都可以省略。\njavapublic void test6() &#123;\n    Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123;\n        return o1.compareTo(o2);\n    &#125;;\n    System.out.println(com1.compare(12,6));\n    System.out.println(&quot;===lambda表达式===&quot;);\n    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2);\n    System.out.println(com2.compare(12,6));\n&#125;Lambda表达式的本质一方面:\tlambda表达式作为接口的实现类的对象。\n另一方法：\tlambda表达式是一个匿名函数。\n体现了–&gt; “万事万物皆对象”\n函数式接口1、什么是函数式接口？为什么需要函数式接口？如果接口中只声明有一个抽象方法，则此接口就成为函数式接口。\n因为只有给函数式接口提供实现类的对象时，我们才可以使用lambda表达式。\n2、api中函数式接口所在的包jdk8中声明的函数式接口都在java.util.function包下。\n3、4个基本的函数式接口\n\n\n函数式接口\n称谓\n参数类型\n用途\n\n\n\nConsumer&lt;T&gt;\n消费型接口\nT\n对类型为T的对象应用操作，包含方法：void accept(T t)\n\n\nSupplier&lt;T&gt;\n供给型接口\n无\n返回类型为T的对象，包含方法：T get( )\n\n\nFunction&lt;T, R&gt;\n函数型接口\nT\n对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R accept(T t)\n\n\nPredicate&lt;T&gt;\n判断型接口\nT\n确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：boolean test(T t)\n\n\nLambda表达式的语法规则总结-&gt;的左边：lambda形参列表，参数的类型都可以省略。如果形参只有一个，则一对( )也可以省略。\n-&gt;的右边：lambda体，对应着重写的方法的方法体。如果方法体种只有一行执行语句，则一堆{ }可以省略。如果有return关键字，则必须一并省略。\n\n方法引用方法引用举例javaComparator&lt;Integer&gt; com3 = Integer :: compare方法引用的理解1、方法引用，可以看做是基于lambda表达式的进一步刻画。（没有lambda表达式就没有方法引用）\n2、当需要提供一个函数式接口的实例时，我们可以使用lambda表达式提供此实例。\n3、当满足一定条件的情况下，我们还可以使用方法引用或构造器引用替换lambda表达式\n方法引用的本质方法引用作为了函数式接口的实例。 –&gt; “万事万物皆对象”\n方法引用的格式格式：类(或对象) :: 方法名\n举例演示①不用lambda表达式（匿名类）②使用lambda表达式③使用方法引用\njavapublic void test1() &#123;\n    //1. 常规匿名类\n    Consumer&lt;String&gt; con1 = new Consumer&lt;String&gt;() &#123;\n        @Override\n        public void accept(String s) &#123;\n            System.out.println(s);\n        &#125;\n    &#125;;\n    con1.accept(&quot;hello&quot;);\n    //2. lambda表达式\n    Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);\n    con2.accept(&quot;hello&quot;);\n    //3. 方法引用\n    Consumer&lt;String&gt; con3 = System.out::println;\n    con3.accept(&quot;hello&quot;);\n&#125;输出结果\ntxthello\nhello\nhello情况1：对象 :: 实例方法 (非)静态方法要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同（或一致-满足多态场景，如自动装箱和自动拆箱）。此时，可以考虑使用方法b实现对方法a的替换、覆盖。此替换或覆盖即为方法引用。\n注意：此方法b是非静态方法，需要对象调用。\n举例：匿名方法返回值类型String和actor.getName的返回值类型是一样的，而且都是无参的方法。因此可写成 actor::getName( )。\njavapublic void test2() &#123;\n    Actor actor = new Actor(1001, &quot;运动员&quot;);\n    //1. 常规匿名类\n    Supplier&lt;String&gt; sup1 = new Supplier&lt;String&gt;() &#123;\n        @Override\n        public String get() &#123;\n            return actor.getName();\n        &#125;\n    &#125;;\n    System.out.println(sup1.get());\n    //2. lambda表达式\n    Supplier&lt;String&gt; sup2 = () -&gt; actor.getName();\n    System.out.println(sup2.get());\n    //3. 方法引用\n    Supplier&lt;String&gt; sup3 = actor::getName();\n    System.out.println(sup3.get());\n&#125;情况2：类 :: 静态方法要求：函数式接口中的抽象方法a与其内部实现时调用的类的某个方法b的形参列表和返回值类型都相同（或一致）。此时，可以考虑使用方法b实现对方法a的替换、覆盖。此替换或覆盖即为方法引用。\n注意：此方法b是静态方法，需要类调用。\njavapublic void test3() &#123;\n    //1. 常规匿名类\n    Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() &#123;\n        @Override\n        public int compare(Integer o1, Integer o2) &#123;\n            return Integer.compare(o1, o2);\n        &#125;\n    &#125;;\n    System.out.println(com1.compare(12, 21));\n    //2. lambda表达式\n    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2);\n    System.out.println(com2.compare(21, 34));\n    //3. 方法引用 类::静态方法\n    Comparator&lt;Integer&gt; com3 = Integer::compare;\n    System.out.println(com3.compare(34, 34));;\n&#125;情况3：类 :: 实例方法要求：函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的返回值类型相同。同时，抽象方法a中有n个参数，方法b中有n-1个参数，且抽象方法a的第1个参数作为方法b的调用者，且抽象方法a的后n-1个参数与方法b的n-1个参数的类型相同（或一致）。则可以考虑使用方法b实现对方法a的替换、覆盖。此替换或覆盖即为方法引用。\n注意：此方法b是非静态的方法，需要对象调用。但是形式上，写出对象a所属的类。\njavapublic void test4() &#123;\n    //1. 常规匿名类\n    Comparator&lt;String&gt; com1 = new Comparator&lt;String&gt;() &#123;\n        @Override\n        public int compare(String o1, String o2) &#123;\n            return o1.compareTo(o2);\n        &#125;\n    &#125;;\n    System.out.println(com1.compare(&quot;abc&quot;, &quot;abd&quot;));\n    //2. lambda表达式\n    Comparator&lt;String&gt; com2 = (s1, s2) -&gt; s1.compareTo(s2);\n    System.out.println(com2.compare(&quot;abc&quot;, &quot;abb&quot;));\n    //3. 方法引用\n    Comparator&lt;String&gt; com3 = String::compareTo;\n    System.out.println(com3.compare(&quot;abc&quot;, &quot;abb&quot;));\n&#125;构造器引用、数组引用构造器引用构造器引用格式类名 :: new\n构造器引用说明1、调用了类名对应的类中的某一个确定的构造器\n2、具体调用的是类中的哪一个构造器取决于函数式接口的抽象方法的形参列表！\n构造器引用举例调用的是Employee类中空参的构造器\njavapublic void test1()&#123;\n    //1. 常规匿名类\n    Supplier&lt;Employee&gt; sup1 = new Supplier&lt;Employee&gt;() &#123;\n        @Override\n        public Employee get() &#123;\n            return new Employee;\n        &#125;\n    &#125;;\n    System.out.println(sup1.get());\n    //2. 构造器引用 调用的是Employee类中空参的构造器\n    Supplier&lt;Exception&gt; sup2 = Employee::new;\n&#125;调用的是Employee类中参数是Integer&#x2F;int类型的构造器\njavapublic void test2()&#123;\n    //1. 常规匿名类\n    Function&lt;Integer, Employee&gt; func1 = new Function&lt;Integer, Employee&gt;() &#123;\n        @Override\n        public Employee apply(Integer id) &#123;\n            return new Employee(id);\n        &#125;\n    &#125;;\n    System.out.println(func1.apply(12));\n    //2. 构造器引用 调用的是Employee类中参数是Integer/int类型的构造器\n    Function&lt;Integer, Employee&gt; func2 = Employee::new;\n&#125;数组引用数组引用格式：数组名[ ] :: new\njavapublic void test4() &#123;\n    //1.\n    Function&lt;Integer, Employee[]&gt; func1 = new Function&lt;Integer, Employee[]&gt;() &#123;\n        @Override\n        public Employee[] apply(Integer integer) &#123;\n            return new Employee[length];\n        &#125;\n    &#125;;\n    System.out.println(func1.apply(10).length);\n    //2.\n    Function&lt;Integer, Employee[]&gt; func2 = Employee[] :: new;\n    System.out.println(func2.apply(20).length);\n&#125;\nStream APIStream API说明![](..&#x2F;images&#x2F;java&#x2F;JDK8-17新特性&#x2F;Stream API说明.png)\n为什么要使用Stream API实际开发中，项目中多数数据源都来自于MySQL，Oracle等，但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。\nStream API vs 集合框架1、Stream API 关注的是多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU的。\n2、集合关注的是数据的存储，面向内存的。\n3、Stream API之于集合，类似于SQL之于数据表的查询。\nStream使用说明1、Stream自己不会存储元素。\n2、Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream。\n3、Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。\n4、Stream一旦执行了终止操作，就不能再调用其他中间操作或终止操作了。\nStream执行流程步骤1：Stream的实例化\n步骤2：一系列的中间操作\n步骤3：执行终止操作\n![](..&#x2F;images&#x2F;java&#x2F;JDK8-17新特性&#x2F;Stream API步骤.png)\nStream的实例化创建Stream方式一：通过集合default Stream&lt;E&gt; stream(): 返回一个顺序流\ndefault Stream&lt;E&gt; parallelStream(): 返回一个并行流\n代码举例\njavapublic void test1() &#123;\n    List&lt;Employee&gt; list = EmployeeData.getEmployees();\n    //default Stream&lt;E&gt; stream(): 返回一个顺序流\n    Stream&lt;Employee&gt; stream = list.stream();\n    //default Stream&lt;E&gt; parallelStream(): 返回一个并行流\n    Stream&lt;Employee&gt; stream1 = list.parallelStream();\n    System.out.println(stream); //打印的是地址\n    System.out.println(stream1);\n&#125;创建Stream方式二：通过数组调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[ ] array)：返回一个流\n代码举例\njavapublic void test2() &#123;\n    //调用Arrays类的static \\&lt;T&gt; Stream\\&lt;T&gt; stream(T[ ] array)：返回一个流\n    Integer[] arr = new Integer[]&#123;1,2,3,4,5&#125;;\n\n    Stream&lt;Integer&gt; stream = Arrays.stream(arr);\n\n    int[] arr1 = new int[]&#123;1,2,3,4,5&#125;;\n    IntStream stream1 = Arrays.stream(arr1);\n    \n&#125;创建Stream方式三：通过Stream的of( )使用Stream的静态方法of( )\n代码举例\t\njavapublic void test3() &#123;\n    Stream&lt;String&gt; stream = Stream.of(&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;SS&quot;, &quot;DD&quot;);\n&#125;一系列中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理而在终止操作时一次性全部处理，称为“惰性求值”。\n1、筛选与切片\n\n\n方法\n描述\n\n\n\nfilter(Predicatep)\n接收Lambda，从流中排除某些元素\n\n\ndistinct()\n筛选，通过流所生成元素的hashCode()和equals()去除重复元素\n\n\nlimit(long maxSize)\n截断流，使其元素不超过给定数量\n\n\nskip(long n)\n跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补\n\n\n代码演示\njavapublic void test1() &#123;\n        //1、filter(Predicate p) 接收Lambda，从流中排除某些元素。\n        //练习: 查询员工表中薪资大于7000的员工信息\n        List&lt;Employee&gt; list = EmployeeData.getEmployees();\n        Stream&lt;Employee&gt; stream = list.stream();\n        //Lambda表达式: emp -&gt; emp.getSalary() &gt; 7000\n        //方法引用: System.out::println\n        stream.filter(emp -&gt; emp.getSalary() &gt; 7000).forEach(System.out::println);\n        System.out.println();\n\n        //2、limit(n) 截断流，使其元素不超过给定数量。\n        //错误的执行。因为Stream已经执行了终止操作，就不可以再调用其他的中间操作或终止操作了\n//        stream.limit(2).forEach(System.out::println);\n        list.stream().limit(2).forEach(System.out::println);\n        System.out.println();\n\n        //3、skip(n) 跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。\n        list.stream().skip(5).forEach(System.out::println);\n        System.out.println();\n\n        //4、distinct() 筛选，通过流所生成(重写过)元素的hashCode()和equals()去除重复元素\n        list.stream().distinct().forEach(System.out::println);\n        System.out.println();\n    &#125;2、映射\n\n\n方法\n描述\n\n\n\nmap(Function f)\n接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n\n\nmapToDouble(ToDoubleFunction f)\n接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。\n\n\nmapToInt(ToIntFunction f)\n接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。\n\n\nmapToLong(ToLongFunction f)\n接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。\n\n\nflatMap(Function f)\n接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。\n\n\n代码演示\njavapublic void test2() &#123;\n    //map(Function f) 接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素\n    //练习: 转换成大写\n    List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);\n    //方式1: Lambda表达式\n    list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);\n    //方式2: 方法引用\n    list.stream().map(String::toUpperCase).forEach(System.out::println);\n\n    //获取员工姓名长度大于3的员工(没有用到映射)\n    List&lt;Employee&gt; employees = EmployeeData.getEmployees();\n    employees.stream().filter(emp -&gt; emp.getName().length() &gt; 3).forEach(System.out::println);\n\n    //练习: 获取员工姓名长度大于3的员工的姓名(映射到name)\n    //第一种：先过滤，再映射\n    employees.stream().filter(emp -&gt; emp.getName().length() &gt; 3).map(emp -&gt; emp.getName()).forEach(System.out::println);\n    //第二种：先映射，再过滤 (因为映射完之后只有name这一列，所有lambda表达式变成了name-&gt;name.length()&gt;3)\n    employees.stream().map(emp -&gt; emp.getName()).filter(name -&gt; name.length() &gt; 3).forEach(System.out::println);\n    //第三种：将映射的部分改成方法引用\n    employees.stream().map(Employee::getName).filter(name -&gt; name.length() &gt; 3).forEach(System.out::println);\n&#125;3、排序\n\n\n方法\n描述\n\n\n\nsorted()\n产生一个新流，其中按自然顺序排序\n\n\nsorted(Comparator com)\n产生一个新流，其中按比较器顺序排序\n\n\n代码演示\njavapublic void test3() &#123;\n        //sorted() 自然排序\n        Integer[] arr = new Integer[]&#123;345,3,64,3,46&#125;;\n        String[] arr1 = new String[]&#123;&quot;GG&quot;,&quot;DD&quot;,&quot;MM&quot;,&quot;SS&quot;,&quot;JJ&quot;&#125;;\n\n        Arrays.stream(arr).sorted().forEach(System.out::println);\n        System.out.println(Arrays.toString(arr)); //arr数组并没有因为升序，做调整。\n\n        Arrays.stream(arr1).sorted().forEach(System.out::println);\n        //因为Employee没有实现Comparable接口,所有报错\n//        List&lt;Employee&gt; list = EmployeeData.getEmployees();\n//        list.stream().sorted().forEach(System.out::println);\n\n        //sorted(Comparator com) 定制排序\n        List&lt;Employee&gt; list = EmployeeData.getEmployees();\n        list.stream().sorted((e1,e2) -&gt; e1.getSalary() - e2.getSalary()).forEach(System.out::println);\n\n        //针对字符串从大小排列\n        Arrays.stream(arr1).sorted((s1,s2) -&gt; s1.compareTo(s2)).forEach(System.out::println);\n        Arrays.stream(arr1).sorted(String::compareTo).forEach(System.out::println);\n    &#125;终止操作1、终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void。\n2、流进行了终止操作后，不能再次使用。\n1、匹配与查找\n\n\n方法\n描述\n\n\n\nallMatch(Predicate p)\n检查是否匹配所有元素\n\n\nanyMatch(Predicate p)\n检查是否至少匹配一个元素\n\n\nnoneMatch(Predicate p)\n检查是否没有匹配所有元素\n\n\nfindFirst()\n返回第一个元素\n\n\nfindAny()\n返回当前流中的任意元素\n\n\ncount()\n返回流中元素总数\n\n\nmax(Comparator c)\n返回流中最大值\n\n\nmin(Comparator c)\n返回流中最小值\n\n\nforEach(Consumer c)\n内部迭代(使用 Collection接口需要用户去做迭代，称为外部迭代。相反，Stream API使用内部迭代–它帮你把迭代做了)\n\n\n代码演示\njava//匹配与查找\npublic void test1() &#123;\n    //allMatch(Predicate p) 检查是否匹配所有元素\n    //练习：是否所有员工的年龄都大于18\n    List&lt;Employee&gt; list = EmployeeData.getEmployees();\n    System.out.println(list.stream().allMatch(emp -&gt; emp.getAge() &gt; 18));\n\n    //anyMatch(Predicate p) 检查是否至少匹配一个元素\n    //练习：是否存在年龄大于18岁的员工\n    System.out.println(list.stream().anyMatch(emp -&gt; emp.getAge() &gt; 18));\n    //练习：是否存在员工的工资大于10000\n    System.out.println(list.stream().anyMatch(emp -&gt; emp.getSalary() &gt; 10000));\n\n    //findFirst 返回第一个元素\n    System.out.println(list.stream().findFirst().get());\n\n    //count 返回流中工资大于7000元素的总个数\n    List&lt;Employee&gt; list1 = EmployeeData.getEmployees();\n    System.out.println(list.stream().filter(emp -&gt; emp.getSalary() &gt; 7000).count());\n\n    //max(Comparator c) 返回流中最大值\n    //练习：返回最高工资的员工\n    System.out.println(list.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));\n    //练习：返回最高的工资\n    //方式1\n    System.out.println(list.stream().max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())).get().getSalary());\n    //方式2\n    System.out.println(list.stream().map(emp -&gt; emp.getSalary()).max((salary1, salary2) -&gt; Double.compare(salary1, salary2)).get());\n    System.out.println(list.stream().map(emp -&gt; emp.getSalary()).max(Double::compare).get());\n\n    //min(Comparator c) 返回流中最小值\n    //练习：返回最低工资的员工\n    System.out.println(list.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));\n\n    //forEach(Consumer c) 内部迭代\n    list1.stream().forEach(System.out::println);\n\n    //针对集合，jdk8中增加了一个遍历的方法\n    list1.forEach(System.out::println);\n    //针对List来说，遍历的方法：①使用Iterator ②增强for ③一般for ④forEach()\n&#125;2、归约\n\n\n方法\n描述\n\n\n\nreduce(T indentity, BinaryOperator b)\n可以将流中元素反复结合起来，得到一个值。返回T\n\n\nreduce(BinaryOperator b)\n可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;\n\n\n备注：map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名。\n代码演示\njavapublic void test2() &#123;\n    //reduce(T indentity, BinaryOperator) 可以将流中元素反复结合起来，得到一个值。返回T\n    //练习1：计算1-10的自然数的和\n    List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    System.out.println(list.stream().reduce(0, (x1, x2) -&gt; x1 + x2)); //55\n    System.out.println(list.stream().reduce(0, (x1, x2) -&gt; Integer.sum(x1, x2))); //55\n    System.out.println(list.stream().reduce(0, Integer::sum)); //55\n    System.out.println(list.stream().reduce(10, (x1, x2) -&gt; x1 + x2)); //65\n\n    //reduce(BinaryOperator) 可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;\n    //练习2：计算公司所有员工工资的总和\n    List&lt;Employee&gt; employeeList = EmployeeData.getEmployees();\n    System.out.println(employeeList.stream().map(emp -&gt; emp.getSalary()).reduce((salary1, salary2) -&gt; Integer.sum(salary1, salary2)));\n    System.out.println(employeeList.stream().map(emp -&gt; emp.getSalary()).reduce(Integer::sum));\n&#125;3、收集\n\n\n方法\n描述\n\n\n\ncollect(Collector c)\n将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法\n\n\nCollector接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。\n代码演示\njavapublic void test3() &#123;\n    List&lt;Employee&gt; list = EmployeeData.getEmployees();\n    //collect(Collector c) 将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法\n    //练习1：查找工资大于6000的员工，结果返回为一个List或Set\n    List&lt;Employee&gt; list1 = list.stream().filter(emp -&gt; emp.getSalary() &gt; 6000).collect(Collectors.toList());\n    list1.forEach(System.out::println);\n    System.out.println();\n    //源数据并不会改变\n    list.forEach(System.out::println);\n\n    //练习2：按照员工的年龄进行排序，返回到一个新的list中\n    List&lt;Employee&gt; list2 = list.stream().sorted((e1, e2) -&gt; e1.getAge() - e2.getAge()).collect(Collectors.toList());\n    list2.forEach(System.out::println);\n&#125;\n新语法结构异常处理之try-catch资源关闭JDK7的新特性在try后面可以增加一个( )，在括号中可以声明流对象并初始化。try中的代码执行完毕，会自动把流对象释放，就不用写finally了。\n格式：\njavatry(资源对象的声明和初始化) &#123;\n    业务逻辑代码，可能会产生异常\n&#125; catch(异常类型1 e) &#123;\n    处理异常代码\n&#125; catch(异常类型2 e) &#123;\n    处理异常代码\n&#125;原本写法\njavapublic void test1() &#123;\n    FileWriter fw = null;\n    BufferedWriter bw = null;\n    try &#123;\n        fw = new FileWriter(&quot;test.txt&quot;);\n        bw = new BufferedWriter(fw);\n        bw.write(&quot;你好世界&quot;);\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            if(bw != null) &#123;\n                bw.close();\n            &#125;\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;新特性写法\njavapublic void test1() &#123;\n    FileWriter fw = null;\n    BufferedWriter bw = null;\n    try &#123;\n        fw = new FileWriter(&quot;test.txt&quot;);\n        bw = new BufferedWriter(fw);\n        bw.write(&quot;你好世界&quot;);\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            if(bw != null) &#123;\n                bw.close();\n            &#125;\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;JDK9的新特性try的前面可以定义流对象，try后面的( )中可以直接引用流对象的名称。在try代码执行完毕后，流对象也可以释放掉，也不用写finally了。\n格式：\na，b是final的，不可再被赋值。\njavaA a = new A();\nB b = new B();\ntry(a;b) &#123;\n    可能产生的异常代码\n&#125; catch (异常类名 变量名) &#123;\n    异常处理的逻辑\n&#125;局部变量类型推断JDK10新特性\n可以使用的场景\njavapublic void test3() &#123;\n    //1. 局部变量的实例化\n    var list = new ArrayList&lt;String&gt;();\n    var set = new LinkedHashSet&lt;Integer&gt;();\n    \n    //2. 增强for循环中的索引\n    for (var r : list) &#123;\n        System.out.println(r);\n    &#125;\n    \n    //3. 传统for循环中\n    for (var i = 0; i &lt; 100; i++) &#123;\n        System.out.println(i);\n    &#125;\n    \n    //4. 返回值类型含复杂泛型结构\n    var iterator = set.iterator();\n    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n    var entries = map.entrySet();\n&#125;不可以使用的场景\n1、声明一个成员变量\n2、声明一个数组变量，并为数组静态初始化（省略new的情况下）\n3、方法的返回值类型\n4、方法的参数类型\n5、没有初始化的方法内的局部变量声明\n6、作为catch块中异常类型\n7、Lambda表达式中函数式接口的类型\n8、方法引用中函数式接口的类型\ninstanceof模式匹配原本写法-java14之前\njavapublic void test1() &#123;\n    Object obj = new String(&quot;hello.java14&quot;);\n    if(obj instanceof String) &#123;\n        String str = (String) obj;\n        System.out.println(str.contains(&quot;Java&quot;));\n    &#125; else &#123;\n        System.out.println(&quot;非String类型&quot;);\n    &#125;\n&#125;新写法-java14中\njavapublic void test2() &#123;\n    Object obj = new String(&quot;hello.java14&quot;);\n    if(obj instanceof String str) &#123;\n        System.out.println(str.contains(&quot;Java&quot;));\n    &#125; else &#123;\n        System.out.println(&quot;非String类型&quot;);\n    &#125;\n&#125;switch表达式传统switch声明语句的弊端：\n\n匹配是自上而下的，如果忘记写break，后面的case语句不论匹配与否都会执行；\n所有的case语句共用一个块范围，在不同的case语句定义的变量名不能重复；\n不能再一个case里写多个执行结果一致的条件；\n整个switch不能作为表达式返回值；\n\njava//常见错误演示\nswitch (month) &#123;\n    case 3|4|5: // 3|4|5 用了位运算 11 | 100 | 101结果是111是 7\n        System.out.println(&quot;春季&quot;);\n        break;\n    case 6|7|8: // 6|7|8用了位运算 110 | 111 | 1000结果是1111是 15\n        System.out.println(&quot;夏季&quot;);\n        break;\n    case 9|10|11: // 9|10|11用了位运算 1001 | 1010 | 1011结果是1011 是11\n        System.out.println(&quot;秋季&quot;);\n        break;\n    case 12|1|2: // 12|1|2用了位运算 1100 | 1 | 10结果是1111 是15\n        System.out.println(&quot;冬季&quot;);\n        break;\n    default:\n        System.out.println(&quot;输入有误&quot;);\n&#125;JDK12中预览特性\nJava 12将会对switch声明语句进行扩展，使用case L -&gt;来代替以前的break;，省去了break语句，避免了因少写break而出错。\n同时将多个case合并到一行，显得简洁、清晰，也更加优雅的表达逻辑分支。\n为了保持兼容性，case条件语句中依然可以使用字符:，但是同一个switch结构里不能混用-&gt;和:，否则编译错误。\n\n代码演示\njavapublic void test2() &#123;\n    int month = 1;\n    switch (month) &#123;\n        case 3 -&gt; System.out.println(&quot;春季&quot;);\n        case 6,7,8 -&gt; System.out.println(&quot;夏季&quot;);\n        default -&gt; System.out.println(&quot;输入有误&quot;);\n    &#125;\n&#125;JDK12中的写法：还可以使用变量接收switch表达式的结果\njavapublic void test3() &#123;\n    int month = 1;\n    int result = switch (month) &#123;\n        case 3 -&gt; 1;\n        case 6,7,8 -&gt; 2;\n        default -&gt; 3;\n    &#125;;\n    System.out.println(result);\n&#125;JDK13中的写法：引入了yield关键字，用于返回指定的数据，结束switch结果。\n这意味着，switch表达式(返回值)应该使用yield，switch语句(不返回值)应该使用break。\n和return的区别在于：return会直接跳出当前方法，而yield只会跳出当前switch块。\n使用**case -&gt;**的代码演示，需要加&#123; &#125;\njavapublic void test4() &#123;\n    int month = 1;\n    int result = switch (month) &#123;\n        case 3 -&gt; &#123;\n           yield  1;\n        &#125;\n        case 6,7,8 -&gt; &#123;\n            yield 2;\n        &#125;\n        default -&gt; &#123;\n            System.out.println(&quot;值未找到&quot;);\n            yield 3;\n        &#125;\n    &#125;;\n    System.out.println(result);\n&#125;使用**case :**的代码演示，不用加&#123; &#125;\njavapublic void test5() &#123;\n    int month = 1;\n    int result = switch (month) &#123;\n        case 3 :\n            yield  1;\n        case 6,7,8 :\n            yield 2;\n        default :\n            System.out.println(&quot;值未找到&quot;);\n            yield 3;\n    &#125;;\n    System.out.println(result);\n&#125;文本块的使用通过在文字框前后加&quot;&quot;&quot;来实现可复制\nmysql举例对比\n\n\nrecord的使用\n1、可以在record声明的类中定义静态字段、静态方法、构造器或示例方法。\n2、不能在record声明的类中定义实例字段；类不能声明为abstract；不能声明显式的父类等。\n代码举例\njavapublic record Person(int id, String name) &#123;\n    //可以在record声明的类中定义静态字段、静态方法、构造器或实例方法\n    static String info = &quot;我是一个人&quot;;\n    public static void show() &#123;\n        System.out.println(&quot;我是一个人&quot;);\n    &#125;\n    public Person() &#123;\n        this(0, null);\n    &#125;\n    public void eat() &#123;\n        System.out.println(&quot;人吃饭&quot;);\n    &#125;\n&#125;密封类\n代码演示\njava//Person是一个密封类，可以被指定的子类所继承。非指定的类不能继承Person类\npublic sealed class Person permits Student,Teacher,Worker&#123;\n&#125;\n//要求指定的子类必须是final、sealed、non-sealed三者之一\nfinal class Student extends Person&#123;&#125; //Student类不能被继承\n\nsealed class Teacher extends Person permits SeniorTeacher&#123;&#125; //Teacher类只能被指定的子类继承\n\nnon-sealed class SeniorTeacher extends Teacher&#123;&#125;\n\nnon-sealed class Worker extends Person&#123;&#125; //Worker类在继承时，没有任何限制\nAPI的变化Optional类\n创建Optional类对象的方法：\n\nstatic&lt;T&gt; Optional&lt;T&gt; empty(): 用来创建一个空的Optional实例\nstatic&lt;T&gt; Optional&lt;T&gt; of(T value): 用来创建一个Optional实例，value必须非空\nstatic &lt;T&gt; Optional&lt;T&gt; ofNullable(T value): 用来创建一个Optional实例，value可能是空，也可能非空\n\n判断Optional容器中是否包含对象：\n\nboolean isPresent(): 判断Optional容器中的值是否存在\nvoid ifPresent(Consumer&lt;? super T&gt; consumer): 判断Optional容器中的值是否存在，如果存在，就对它进行Consumer指定的操作，如果不存在就不做\n\n获取Optional容器的对象：\n\nT get(): 如果调用对象包含值，返回该值。否则抛异常。T get()与of(T value)配合使用\nT orElse(T other): orElse(T other)与ofNullable(T value)配合使用，如果Optional容器中非空，就返回所包装值，如果为空，就用orElse(T other)orher指定的默认值(备胎)代替\nT orElseGet(Suppiler&lt;? extends T&gt; other): 如果Optional容器中非空，就返回所包装值，如果为空，就用Supplier接口的Lambda表达式提供的值代替\nT orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier): 如果Optional容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的NoSuchElementException\n\n代码演示\njavapublic void test() &#123;\n    String star = &quot;猫&quot;;\n    star = null;\n    //使用Optional避免空指针的问题\n    //1. 实例化\n    //ofNullable(T value):用来创建一个Optional实例，value可能是空，也可能非空\n    Optional&lt;String&gt; optional = Optional.ofNullable(star);\n    //orElse(T other): 如果Optional实例内部的value属性不为null，则返回value，如果value为null，\n    //则返回other\n    String otherStar = &quot;狗&quot;;\n    String finalStar = optional.orElse(otherStar);\n\n    System.out.println(finalStar.toString());\n&#125;\n企业真题JDK8新特性1、谈谈java8新特性(京*旗下、时*宇，信必*、招*信诺,中*外包，金*软件、阿巴)**\ntxt类似问题\nJDK1.8相较于JDK1.7有什么不一-样? (惠+)\nJDK1 . 8的新特性有哪些? Stream API + Lambda表达式，还有吗? (久*国际物流)\nlambda表达式、 Stream API\njdk7的对比:元空间、HashMap等、新的日期时间API、接口变化等。\n\n2、JDK1.8在数据结构上发生了哪些变化? (银*数据)\n\n使用元空间替代永久代。(方法区: jvm规范中提到的结构。\nHotSpot来讲, jdk7: 方法区的落地体现: 永久代。jdk8: 方法区的落地体现:元空间。\nHashMap底层结构\n\n3、JDK1.8用的是哪个垃圾回收器? (0*0)*Parallel GC -&gt; jdk9:默认使用G1GC –&gt; ZGC (低延迟)\nLambda表达式1、Lambda表达式有了解吗，说说如何使用的(0**0)\n\n在给函数式接口提供实例时，都可以考虑使用lambda表达式。\n基本语法的使用(重要)\n\n2、什么是函数式接口?有几种函数式接口(阿**巴)略。java.util.function包下定义了丰富的好函数式接口。有4类基础的函数式接口:消费型接口: Consumervoid accept(T t)供给型接口: Supplier T get()函数型接口: Function&lt;T,R&gt; R apply(T t)判断型接口: Predicate boolean test(T t)\nStream API1、创建Stream的方式(阿**巴)\n三种。2.你讲讲stream表达式是咋用的，干啥的? (中*国际， 上海*网络)\ntxtStream API关注的是多个数据的计算(排序、查找、过滤、映射、遍历等)，面向CPU的。\n集合关注的数据的存储，面向内存的。\nStream API之于集合，类似于SQL之于数据表的查询。3.集合用Stream流怎么实现过滤? (润*软件)\nfilter(Predicate predicate)\n","slug":"JDK8-17新特性","date":"2023-11-28T10:57:00.000Z","categories_index":"Java","tags_index":"Java","author_index":"白"},{"id":"03a1af7058cec8bb8efe418ed228e157","title":"正则表达式","content":"正则表达式正则表达式: regular expression &#x3D;&gt; RegExp\n思维导图\n\n引入:为什么要学习正则表达式\n\n快速入门假设content已经是通过爬虫抓取的文本，从中获取ip地址。通过正则表达式即可很方便的获取\njavapublic static void main(String[] args) &#123;\n    String content = &quot;私有地址（Private address）属于非注册地址，专门为组织机构内部使用。\\n&quot; +\n            &quot;以下列出留用的内部私有地址\\n&quot; +\n            &quot;A类 10.0.0.0--10.255.255.255\\n&quot; +\n            &quot;B类 172.16.0.0--172.31.255.255\\n&quot; +\n            &quot;C类 192.168.0.0--192.168.255.255&quot;;\n    //(1). 传统方法. 使用遍历方式，代码量大，效率不高\n    //(2). 正则表达式技术\n    //1. \\\\d表示一个任意数字\n    Pattern pattern = Pattern.compile(&quot;\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+&quot;);\n    //2. 创建模式对象[即正则表达式对象]\n    //理解： 就是 matcher 匹配器按照 pattern(模式/样式), 到 content 文本中去匹配\n    //找到就返回true, 否则就返回false\n    int no = 0;\n    //3. 创建匹配器\n    //创建匹配器matcher，按照 正则表达式的规则 去匹配，content字符串\n    Matcher matcher = pattern.matcher(content);\n    //4. 可以开始循环匹配\n    while (matcher.find()) &#123;\n        //匹配内容，文本，放到 m.group(0)\n        System.out.println(&quot;找到: &quot; + (++no) + &quot; &quot; +matcher.group(0));\n    &#125;\n&#125;输出效果如图所示\n结论: 为了解决上述问题，Java提供了正则表达式技术，专门用于处理类似文本问题。正则表达式是对字符串执行模式匹配的技术。\n\n(重要)底层实现目标：匹配所有四个数字\n假设String字符串如下\njavaString content = &quot;1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了&quot; +\n        &quot;第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型&quot; +\n        &quot;版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的&quot; +\n        &quot;标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应&quot; +\n        &quot;用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个&quot; +\n        &quot;里程碑，标志着Java的应用开始普及9889 &quot;;matcher.find考虑分组情况： 比如  (\\d\\d)(\\d\\d) ,正则表达式中有() 表示分组,第1个()表示第1组,第2个()表示第2组…\n1、根据指定的规则，定位满足规则的子字符串(比如(19)(98))\n2、找到后，将 子字符串的开始的索引 和 子字符串的结束的索引+1 记录到 matcher对象属性 int[] groups。如果没有分组则只有2.1，如果含有分组则按顺序执行。\n​\t\t2.1  groups[0]  记录开始的索引位置，groups[1]  记录子字符串的结束的索引+1的值（举例: 1998-&gt; groups[0] &#x3D; 0, groups[1] &#x3D; 4）\n​\t\t2.2 groups[2]  记录第一组开始的索引的位置，groups[3]  记录第一组结束的索引+1的值（举例: (19) - &gt; groups[2] &#x3D; 0, groups[3] &#x3D; 2）\n​\t\t2.3 groups[4]  记录第二组开始的索引的位置，groups[5] 记录第二组结束的索引+1的值（举例: (98) - &gt; groups[4] &#x3D; 2, groups[5] &#x3D; 4）\n​\t\t2.4  更多分组同理…..\n​\t3、同时记录oldLast的值为 子字符串结束的索引+1的值，即下次执行find时，就从oldLast开始匹配（举例: 1999-&gt;oldLast&#x3D;35，下次find从35索引开始匹配 ）\nmatcher.group1、如果没有分组，直接执行matcher.group(0)即可打印结果。\n2、如果有分组，如下(条件: 分组的数不能越界)\n​\t2.1 group(0) 表示匹配到的子字符串\n​\t2.2 group(1) 表示匹配到的子字符串的第1组字串\n​\t2.3 group(2) 表示匹配到的子字符串的第2组字串\n源码\njavamatcher.group源码:\npublic String group(int group) &#123;\n        if (first &lt; 0)\n            throw new IllegalStateException(&quot;No match found&quot;);\n        if (group &lt; 0 || group &gt; groupCount())\n            throw new IndexOutOfBoundsException(&quot;No group &quot; + group);\n        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))\n            return null;\n        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();\n&#125;举例说明:  \n根据 groups[0]&#x3D;31 和 groups[1]&#x3D;35 的记录的位置，从content开始截取子字符串返回就是 [31,35) 包含 31 但是不包含索引为 35的位置\n底层分析\n\n正则表达式语法基本介绍如果要想灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为:\n1、限定符\n2、选择匹配符\n3、分组组合和反向引用符\n4、特殊字符\t\n5、字符匹配符\t\n6、定位符\n贪婪匹配和非贪婪匹配贪婪匹配：java匹配默认贪婪匹配，而默认的”贪心的”模式是匹配搜索到的、尽可能长的的字符串。\n非贪婪匹配：针对 ?  字符，当此字符紧随任何其他限定符 ( *、+、?、{n}、{n,m} )  之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串。\n例如: 在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有的”o”。\n“o+”输出结果\ntxt找到=oooo“o+?”输出结果\ntxt找到=o\n找到=o\n找到=o\n找到=o元字符-转义号 \\\\需要用到转义符号:\t. * + ( ) $ &#x2F; \\ ? [ ] ^ { } 共14个\n\\\\符号说明: \t在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果，甚至会报错。在Java的正则表达式中，两个\\\\代表其他语言中的一个\\\n 问题: 用 $ 匹配 “abc$(“ 会怎样? 用 ( 匹配 “abc$(“ 会怎样? \n解答: 会报错，因此使用转义符\n代码演示\njavapublic static void main(String[] args) &#123;\n    String content = &quot;abc$(a.bc(123( )&quot;;\n    //匹配( =&gt; \\\\(\n    //匹配. =&gt; \\\\.\n    String regStr = &quot;\\\\.&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到 &quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到 .元字符-字符匹配符\n\n\n符号\n符号\n示例\n解释\n匹配输入\n\n\n\n[ ]\n可接受的字符列表\n[efgh]\ne、f、g、h中的任意1个字符\ne\n\n\n[^]\n不接收的字符列表\n[^abc]\n除a、b、c之外的任意1个字符，包括数字和特殊符号\nd\n\n\n-\n连字符\nA-Z\n任意单个大写字母\nA\n\n\n.\n匹配除 \\n 以外的任何字符\na..b\n以a开头，b结尾，中间包括2个任意字符的长度为4的字符串\naaab、aefb、a35b、a#*b\n\n\n\\\\d\n匹配单个数字字符，相当于[0-9]\n\\\\d{3}(\\\\d)?\n包含3个或4个数字的字符串\n123、9876\n\n\n\\\\D\n匹配单个非数字字符，相当于[ ^0-9]\n\\\\D(\\\\d)*\n以单个非数字字符开头，后接任意个数字字符串\na、A342\n\n\n\\\\w\n匹配单个数字，大小写字母字符，下划线，相当于[0-9a-zA-Z_]\n\\\\d{3}\\\\w{4}\n以3个数字字符开头的长度为7的数字字母字符串\n234abcd、12345Pe\n\n\n\\\\W\n匹配单个非 数字，大小写字母字符，下划线，相当于[ ^0-9a-zA-Z_]\n\\\\W+\\\\d{2}\n以至少一个非数字字母字符开头，2个数字字符结尾的字符串\n#29、#?@10\n\n\n\\\\s\n匹配任何空白字符(空格, 制表符等)\na @\n\n“ “(一个空格)\n\n\n\\\\S与\\\\s相反\nString regStr &#x3D;  “.” 匹配除了 \\n 的所有字符\nString regStr &#x3D; “[.]” 匹配 . 本身 \n应用案例案例一\n[a-z]： 匹配 a-z之间任意一个字符\nabc：匹配 abc 字符串[默认区分大小写]\njavapublic static void main(String[] args) &#123;\n    String content = &quot;a11c8&quot;;\n    String regStr = &quot;[a-z]&quot;; //匹配 a-z之间任意一个字符\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到&quot; + matcher.group(0));\n    &#125;\n&#125;运行结果\ntxt找到a\n找到c案例二\n[^a-z]：匹配不在a-z之间的任意一个字符\n因为加了Pattern.CASE_INSENSITIVE参数所以不区分大小写，只输出数据。\njavapublic static void main(String[] args) &#123;\n    String content = &quot;a11c8ABC&quot;;\n    String regStr = &quot;[^a-z]&quot;; //匹配 a-z之间任意一个字符\n    Pattern pattern = Pattern.compile(regStr, Pattern.CASE_INSENSITIVE);\n    Matcher matcher = pattern.matcher(content);\n\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到&quot; + matcher.group(0));\n    &#125;\n&#125;运行结果\ntxt找到1\n找到1\n找到8区分大小写java正则表达式默认是区分字母大小写的，如何实现不区分大小写。\n1、(?i)abc :表示abc都不区分大小写\n2、a(?i)bc :表示bc不区分大小写\n3、a((?i)b)c : 表示只有b不区分大小写\n4、设置参数 :Pattern pat &#x3D; Pattern.compile(regEx, Pattern.CASE_INSENSITIVE) 则表示匹配时不区分大小写\n元字符-选择匹配符 |在匹配某个字符串的时候是选择性的，这时就需要 选择匹配字符 |\n\n\n\n符号\n符号\n示例\n解释\n\n\n\n|\n匹配”|” 之前或之后的表达式\nab|cd\nab或cd\n\n\n元字符-限定符用于指定其前面的字符和组合项连续出现多少次\n\n\n\n符号\n含义\n示例\n说明\n匹配输入\n\n\n\n*\n指定符号重复0次或n次 (无要求)\n(abc)*\n仅包含任意abc的字符串，等效于\\w*\nabc、abcabcabc\n\n\n+\n指定字符重复1次或n次 (至少一次)  1到多\nm + (abc)*\n以至少1个m开头，后接任意个abc的字符串\nm、mabc、mabcabc\n\n\n?\n指定字符重复0次或1次 (最多一次) 0到1\nm + abc?\n以至少1个m开头，后接ab或abc的字符串\nmab、mabc、mmmab、mmabc\n\n\n{n}\n只能输入n个字符\n[abcd]{3}\n以abcd中字母组成的任意长度为3的字符串\nabc、dbc、adc\n\n\n{n,}\n指定至少n个匹配\n[abcd]{3,}\n由abcd中字母组成的任意长度不小于3的字符串\naab、dbc、aaabdc\n\n\n{n,m}\n指定至少n个单不多于m个匹配\n[abcd]{3,5}\n由abcd中字母组成的任意长度不小于3，不大于5的字符串\nabc、abcd、aaaaa、bcdab\n\n\njava匹配默认贪婪匹配，即尽可能匹配多的。\n“?”紧随任何其他限定符之后时，匹配模式是非贪婪匹配。\n例如:\tcontent &#x3D; “aaaabc”， \t规则为 a[3, 4]\t，结果返回aaaa，索引定位到b。\n例如:\tcontent &#x3D; “111111a”，\t规则为1+\t\t，结果返回111111，索引定位到a\n例如:\tcontent &#x3D; “a111111b”，\t规则为a1?\t，结果返回a111111，索引定位到b\n元字符-定位符定位符，规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置。\n\n\n\n符号\n含义\n示例\n说明\n匹配输入\n\n\n\n^\n指定起始字符\n^[0-9] + [a-z]*\n以至少1个数字开头，后接任意个小写字母的字符串\n123、6aa、555edf\n\n\n$\n指定结束字符\n^[0-9] \\\\- [a-z] + $\n以1个数字开头后接连字符”-“，并以至少1个小写字母结尾的字符串\n1-a\n\n\n\\\\b\n匹配目标字符串的边界\nhan\\\\b\n这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置\nsphan nnhan\n\n\n\\\\B\n匹配目标字符串的非边界\nhan\\\\B\n和\\b的含义刚好相反\nhansss sphan nnhan\n\n\n例如:\tcontent &#x3D; “123abc12”，\t规则为 ^[0-9] + [a-z]*\t，结果返回123abc。\n例如:\tcontent &#x3D; “123abc12”，\t规则为^[0-9] + [a-z] + $\t，没有结果返回。如果把content修改为 “123abc”，结果返回123abc\n例如:\tcontent &#x3D; “hansss sphan nnhan”，\t规则为han\\\\b\t，结果返回han，han。因为sphan和nnhan匹配成功。\n例如:\tcontent &#x3D; “hansss sphan nnhan”，\t规则为han\\\\B\t，结果返回han。因为hansss匹配成功。\n常用、特别分组常用分组(捕获分组):\t(pattern)，(?&lt;name&gt;pattern) \n特别分组(非捕获分组):\t(?:pattern)，(?&#x3D;pattern)，(?!pattern)\n非捕获分组: 不能matcher.group(1)来获取分组\n\n\n\n分组构造形式\n说明\n\n\n\n(pattern)\n非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其他捕获结果则根据左括号的顺序从1开始自动编号。(1，2，3)\n\n\n(?&lt;name&gt;pattern)\n命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号代替尖括号，例如(?’name’)\n\n\n(?:pattern)\n匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储以后使用的匹配。这对于用”or”字符( | )组合模式部件的情况很有用。例如: industr(?:y | ies) 是比 ‘industry | industries’ 更经济的表达式。\n\n\n(?&#x3D;pattern)\n它是一个非捕获匹配。例如: ‘Windows(?&#x3D;95 | 98 | NT | 2000)’ 匹配 “Windows 2000”中的”Windows”，但不匹配”Windows 3.1” 中的 “Windows”。\n\n\n(?!pattern)\n该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如: ‘Windows (?! 95 | 98 | NT 2000)’ 匹配 “Windows 3.1” 中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。\n\n\n常用分组代码演示(pattern) \nmatcher.group() 传入编号\njavapublic static void main(String[] args) &#123;\n    String content = &quot;sasas s7888 nn1189han&quot;;\n    //下面是非命名分组,说明\n    //1. matcher.group(0) 得到匹配的字符串\n    //2. matcher.group(1) 得到匹配到的字符串的第1个分组内容\n    //3. matcher.group(2) 得到匹配到的字符串的第2个分组内容\n    //4. ....\n    String regStr = &quot;(\\\\d\\\\d)(\\\\d)(\\\\d)&quot;; //匹配四个数字\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while(matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n        System.out.println(&quot;第1个分组=&quot; + matcher.group(1));\n        System.out.println(&quot;第2组分组=&quot; + matcher.group(2));\n        System.out.println(&quot;第3组分组=&quot; + matcher.group(3));\n    &#125;\n&#125;输出结果\ntxt找到=7888\n第1个分组=78\n第2组分组=8\n第3组分组=8\n找到=1189\n第1个分组=11\n第2组分组=8\n第3组分组=9(?&lt;name&gt;pattern) \nmatcher.group() 传入组名\njavapublic static void main(String[] args) &#123;\n    String content = &quot;sasas s7888 nn1189han&quot;;\n    //命名分组: 即可以给分组取名\n    String regStr = &quot;(?&lt;g1&gt;\\\\d\\\\d)(?&lt;g2&gt;\\\\d\\\\d)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n\n    while(matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n        System.out.println(&quot;第1个分组[通过组名]=&quot; + matcher.group(&quot;g1&quot;));\n        System.out.println(&quot;第2组分组[通过组名]=&quot; + matcher.group(&quot;g2&quot;));\n    &#125;\n&#125;输出结果\ntxt找到=7888\n第1个分组[通过组名]=78\n第2组分组[通过组名]=88\n找到=1189\n第1个分组[通过组名]=11\n第2组分组[通过组名]=89特别分组代码演示非捕获分组: 不能matcher.group(1)来获取分组\n(?:pattern)  匹配 pattern 但不捕获该匹配的子表达式\nString regStr &#x3D; “小猫吃鱼 | 小猫抓老鼠 | 小猫乱跑” 等价于”小猫(?:吃鱼|抓老鼠|乱跑)” 是非捕获分组。\njavapublic static void main(String[] args) &#123;\n    String content = &quot;小猫吃鱼 小猫抓老鼠 小猫乱跑&quot;;\n    String regStr = &quot;小猫(?:吃鱼|抓老鼠|乱跑)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到=小猫吃鱼\n找到=小猫抓老鼠\n找到=小猫乱跑(?&#x3D;pattern) 匹配满足?&#x3D;pattern的表达式\n举例: 匹配规则 “小猫(?&#x3D;吃鱼|抓老鼠)” 只匹配后缀是吃鱼和抓老鼠的小猫 \njavapublic static void main(String[] args) &#123;\n    String content = &quot;小猫吃鱼 小猫抓老鼠 小猫乱跑&quot;;\n    String regStr = &quot;小猫(?=吃鱼|抓老鼠)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到=小猫\n找到=小猫(?!pattern) 与(?&#x3D;pattern)匹配规则相反\n举例: 匹配规则 “小猫(?!吃鱼|抓老鼠)” 匹配除了后缀是吃鱼和抓老鼠的小猫\njavapublic static void main(String[] args) &#123;\n    String content = &quot;小猫吃鱼 小猫抓老鼠 小猫乱跑&quot;;\n    String regStr = &quot;小猫(?!吃鱼|抓老鼠)&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到=小猫正则应用实例代码样式模板\njavapublic static void main(String[] args) &#123;\n    String content = &quot;&quot;;\t//需要匹配的文本\n    String regStr = &quot;&quot;;\t\t//匹配规则\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while(matcher.find()) &#123;\n        System.out.println(&quot;找到=&quot; + matcher.group(0));\t//根据需求查询\n    &#125;\n    /*\n    if(matcher.find()) &#123;\n        System.out.println(&quot;满足格式&quot;);\n    &#125;else &#123;\n        System.out.println(&quot;不满足格式&quot;);\n    &#125;\n    */\n&#125;示例问题举例\n\n解答\n1、regStr &#x3D; “^[\\u0391-\\uffe5]+$“ \t\n举例: content &#x3D; “小猫爱吃鱼” sout  &#x3D; “满足格式”  或  content &#x3D; “小猫x吃鱼” sout &#x3D; “不满足格式”\n2、regStr &#x3D; “^[1-9]\\\\d{5}$“\n举例: content &#x3D; “123890” sout  &#x3D; “满足格式”\n3、regStr &#x3D; “^[1-9]\\\\d{4,9}$“\n举例: content &#x3D; “1238990” sout &#x3D; “满足格式”  或  content &#x3D; “1238a990” sout &#x3D; “不满足格式”\n4、regStr &#x3D; “^1[3 | 4 | 5 | 8]\\\\d{9}$“\n举例: content  &#x3D; “13588889999”  sout &#x3D; “满足格式”  或  content &#x3D; “1238990” sout &#x3D; “不满足格式”\n5、验证url地址\n思路分析\n1、先确定url开始部分 https:&#x2F;&#x2F; | http:&#x2F;&#x2F; \t规则-&gt; ^((https | http):&#x2F;&#x2F;)\n2、然后匹配ip地址 www.bilbil.com\t规则-&gt;www. 和bilbil. 匹配 ([\\\\w-]+\\\\.)+ \tcom 匹配的是 [\\\\w-]+\n3、&#x2F;video&#x2F;BV1Qj41177e9&#x2F;?spm_id_from&#x3D;333\t规则-&gt; (\\/[\\\\w-?&#x3D;&amp;&#x2F;%.#]*)?$\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;https://&quot; +\n            &quot;www.bilibili.com&quot; +\n            &quot;/video/BV1Qj41177e9/?spm_id_from=333.1007.tianma.1-3-3.click&amp;vd_source=68ae6e90dea85507b9aca2772fb25cd8&quot;; //url地址\n    /**\n     * 思路\n     * 1. 先确定url开始部分 https:// | http:// -&gt; ^((https|http)://)\n     * 2. 然后匹配ip地址 www.bilibili.com -&gt; www.和bilbil.匹配的是 ([\\w-]+\\.) com匹配的是[\\w-]+\n     * 3. /video/BV1Qj41177e9/?spm_id_from=333 匹配 (\\/[\\w-?=&amp;/%.#]*)?\n     */\n    String regStr = &quot;^((https|http)://)([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w-?=&amp;/%.#]*)?$&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    if(matcher.find()) &#123;\n        System.out.println(&quot;满足格式&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;不满足格式&quot;);\n    &#125;\n&#125;\n正则表达式常用类常用类包括以下三个类\njava.util.regex 包主要包括以下三个类 Pattern类、Matcher类和PatternSyntaxException类\nPattern类基本介绍pattern对象是一个正则表达式对象。Pattern类没有公共构造方法。要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数，比如 Pattern r &#x3D; Pattern.compile(pattern);\n常用方法matches用于整体匹配，在验证输入的字符串是否满足条件使用。返回类型boolean\n区别: 在url判别中，使用原来的方法必须要加 ^ 和 $ 符号锁定开头和结尾。如果不加的话，那么10https…也会匹配成功。但如果使用了matches整体匹配的话，匹配规则可以是  “((https|http):&#x2F;&#x2F;)([\\w-]+\\.)+[\\w-]+(\\&#x2F;[\\w-?&#x3D;&amp;&#x2F;%.#]*)?”  ，就可以不用加定位符 “^” 和 “$”。\njava/**\n * 演示matches方法，用于整体匹配，在验证输入的字符串是否满足条件使用\n */\npublic class PatternMethod &#123;\n    public static void main(String[] args) &#123;\n        String content = &quot;hello abc 吖吖&quot;;\n        String regStr = &quot;hello&quot;; //false\n        String regStr = &quot;hello.*&quot;; //true\n        boolean matches = Pattern.matches(regStr, content);\n        System.out.println(&quot;整体匹配=&quot; + matches);\n    &#125;\n&#125;Matcher类基本介绍Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。\n方法一览\n\n\n方法\n说明\n\n\n\npublic int start()\n返回匹配的初始索引\n\n\npublic int start(int group)\n返回在匹配操作期间，由给定组所捕获的子序列的初始索引\n\n\npublic int end()\n返回最后匹配字符之后的偏移量，也就是匹配的最后一位+1\n\n\npublic int end(int group)\n返回在匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量\n\n\npublic boolean lookingAt()\n尝试将从区域开头开始的输入序列与该模式匹配\n\n\npublic boolean find()\n尝试查找与该模式匹配的输入序列的下一个子序列\n\n\npublic boolean find(int start)\n重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列\n\n\npublic boolean matches()\n尝试将整个区域与模式匹配\n\n\npublic String replaceAll(String replacement)\n替换模式与给定替换字符串相匹配的输入序列的每个子序列\n\n\n代码演示start、end、matches演示\njavapublic static void main(String[] args) &#123;\n    String content = &quot;hello edu jack tom hello smith hello&quot;;\n    String regStr = &quot;hello&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;=================&quot;);\n        System.out.println(matcher.start());\n        System.out.println(matcher.end());\n        System.out.println(&quot;找到=&quot; + content.substring(matcher.start(), matcher.end()));\n    &#125;\n    //整体匹配，检验某个字符串是否满足某个规则\n    System.out.println(&quot;整体匹配=&quot; + matcher.matches());\n&#125;结果演示\ntxt=================\n0\n5\n找到=hello\n=================\n19\n24\n找到=hello\n=================\n31\n36\n找到=hello\n整体匹配=falsereplaceAll(String replacement)  演示\n注意：返回的字符串才是替换后的字符串，原来的content并不会发生变化。\njavapublic static void main(String[] args) &#123;\n    String content = &quot;hello edu jack tom hello smith hello&quot;;\n    String regStr = &quot;hello&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n\n    //注意: 返回的字符串才是替换后的字符串 原来的content不变化\n    String newContent = matcher.replaceAll(&quot;你好&quot;);\n    System.out.println(&quot;newContent= &quot; + newContent);\n    System.out.println(&quot;content= &quot; + content);\n&#125;输出结果\ntxtnewContent= 你好 edu jack tom 你好 smith 你好\ncontent= hello edu jack tom hello smith helloPatternSyntaxException类PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n分组、捕获、反向引用提出需求问题: 给一段文本，请找出所有四个数字连在一起的子串，并且这四个数字要满足\n①第1位与第4位相同\n②第2为与第3为相同\n比如1221，5775……..\n基本介绍\n案例举例\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;hello jack14 tom11 jack22 yyy xxx&quot;;\n    //匹配两个连续相同的数字 (\\\\d)\\\\1\n    String regStr = &quot;(\\\\d)\\\\1&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    while (matcher.find()) &#123;\n        System.out.println(&quot;找到= &quot; + matcher.group(0));\n    &#125;\n&#125;输出结果\ntxt找到= 11\n找到= 22额外题\n\n经典题目\n思路分析\n1、去掉所有的.\t匹配所有的 ‘ .’ ，将 ‘ .’ 替换成 “”。\n2.1、去掉重复的字\t用 (.)\\\\1+ 匹配重复的字，因为’ +’ 会得到1-多，所以至少找到两个重复的字。\n2.2、使用反向引用$1来替换匹配到的内容\n代码实现\njavapublic static void main(String[] args) &#123;\n        //通过正则表达式修改成 &quot;我要学编程java&quot;\n        String content = &quot;我...我要.....学学学...编程java!&quot;;\n        //思路:\n        //1. 去掉所有的.\n        Pattern pattern = Pattern.compile(&quot;\\\\.&quot;);\n        Matcher matcher = pattern.matcher(content);\n        content = matcher.replaceAll(&quot;&quot;);\n//        System.out.println(&quot;content=&quot; + content);\n//        //2. 去掉重复的字\n//        //(1) 使用(.)\\\\1+ 匹配重复的字，因为&#39;+&#39;会得到1-多,所以至少找到两个重复的字,满足需求\n//        pattern = Pattern.compile(&quot;(.)\\\\1+&quot;);\n//        matcher = pattern.matcher(content);\n//        while (matcher.find()) &#123;\n//            System.out.println(&quot;找到=&quot; + matcher.group(0));\n//        &#125;\n//        //使用 反向引用$1 来替换匹配到的内容\n//        content = matcher.replaceAll(&quot;$1&quot;);\n//        System.out.println(&quot;content=&quot; + content);\n        //使用一条语句\n        content = Pattern.compile(&quot;(.)\\\\1+&quot;).matcher(content).replaceAll(&quot;$1&quot;);\n        System.out.println(content);\n    &#125;输出结果\ntxt我要学编程java!\nString类使用正则表达式replaceAll替换功能\n\nmatches验证功能\n\nsplit分割功能\n\n\n正则表达式练习问题一\n\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;2312@tsinghua.org.cn&quot;;\n    String regStr = &quot;[\\\\w-]+[@]([a-zA-z]+\\\\.)+[a-zA-z]+&quot;;\n\n    if (content.matches(regStr)) &#123; //String的matches方法是整体匹配\n        System.out.println(&quot;匹配成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;匹配失败&quot;);\n    &#125;\n&#125;问题二\n\n代码实现\n1、先写出简单的正则表达式\n2、再逐步完善\njavapublic static void main(String[] args) &#123;\n        //要求验证是不是整数或者小数\n        //提示: 考虑正数和负数\n        //比如: 123 -345 34.89 -87.9 -0.01 0.45\n        String content = &quot;-23.11&quot;;\n        String regStr = &quot;^[-+]?([1-9]\\\\d*|0)(\\\\.\\\\d+)?$&quot;;\n        if (content.matches(regStr)) &#123; //String的matches方法是整体匹配\n            System.out.println(&quot;匹配成功&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;匹配失败&quot;);\n        &#125;\n&#125;问题三\n\n代码实现\njavapublic static void main(String[] args) &#123;\n    String content = &quot;http://www.sohu.com:8080/abc/xxx/index.htm&quot;;\n    String regStr = &quot;^([a-zA-z]+)://([a-zA-Z.]+):(\\\\d+)[\\\\w-/]*/([\\\\w.]+)$&quot;;\n    Pattern pattern = Pattern.compile(regStr);\n    Matcher matcher = pattern.matcher(content);\n    if(matcher.matches()) &#123; //整体匹配，如果匹配成功，可以通过group(x)，获得对应分组内容\n        System.out.println(&quot;整体匹配=&quot; + matcher.group(0));\n        System.out.println(&quot;协议: &quot; + matcher.group(1));\n        System.out.println(&quot;域名: &quot; + matcher.group(2));\n        System.out.println(&quot;端口: &quot; + matcher.group(3));\n        System.out.println(&quot;文件: &quot; + matcher.group(4));\n    &#125; else &#123;\n        System.out.println(&quot;匹配失败&quot;);\n    &#125;\n&#125;\nJava正则表达式大全(参考)一、校验数字的表达式\n1 数字：^[0-9]*$\n2 n位的数字：^\\d{n}$\n3 至少n位的数字：^\\d{n,}$\n4 m-n位的数字：^\\d{m,n}$\n5 零和非零开头的数字：^(0|[1-9][0-9]*)$\n6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\n7 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$\n8 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$\n9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\n10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\n11 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$\n12 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\\d$\n13 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n14 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n15 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0$\n16 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d*[1-9]\\d*))|0?.0+|0$\n17 正浮点数：^[1-9]\\d.\\d|0.\\d*[1-9]\\d*$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$\n18 负浮点数：^-([1-9]\\d.\\d|0.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$\n19 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d*[1-9]\\d*|0?.0+|0)$\n二、校验字符的表达式\n1 汉字：^[\\u4e00-\\u9fa5]{0,}$\n2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\n3 长度为3-20的所有字符：^.{3,20}$\n4 由26个英文字母组成的字符串：^[A-Za-z]+$\n5 由26个大写英文字母组成的字符串：^[A-Z]+$\n6 由26个小写英文字母组成的字符串：^[a-z]+$\n7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n8 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\n9 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n10 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n11 可以输入含有^%&amp;’,;&#x3D;?$&quot;等字符：[^%&amp;’,;&#x3D;?$\\x22]+\n12 禁止输入含有的字符：[^\\x22]+\n三、特殊需求表达式\n1 Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+).\\w+([-.]\\w+)$\n2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+&#x2F;.?\n3 InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\\s]* 或 ^https:&#x2F;&#x2F;([\\w-]+.)+[\\w-]+(&#x2F;[\\w-.&#x2F;?%&amp;&#x3D;]*)?$\n4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ \n6 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\n7 身份证号：\n​    15或18位身份证：^\\d{15}|\\d{18}$\n​    15位身份证：^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$\n​    18位身份证：^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{4}$\n8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.\\d)(?&#x3D;.[a-z])(?&#x3D;.*[A-Z]).{8,10}$ \n12 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ \n15 钱的输入格式：\n16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ \n17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ \n18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ \n19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ \n20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ \n21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ \n22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ \n23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ \n24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\n25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$\n26 中文字符的正则表达式：[\\u4e00-\\u9fa5]\n27 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n28 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)\n29 HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]&gt;.?|&lt;.*? &#x2F;&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n30 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)\n32 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)\n33 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用)\n","slug":"正则表达式","date":"2023-11-25T17:20:00.000Z","categories_index":"正则表达式","tags_index":"Java","author_index":"白"},{"id":"9828133175dbd4abfb8bc2b5ec3d15b8","title":"满汉楼小作业","content":"Mysql满汉楼小作业简要说明技术要求: java + jdbc(druid) + mysql\n项目目标: 训练对mysql和jdbc的能力\n1、去掉界面和事件处理，使用控制台界面\n2、完成 登陆、订座、点餐和结账、查看账单等功能\n怎么开始: 根据程序框架图从底层到业务层逐步构建。\n程序框架图\n\n\n\n1、准备工具类Utility搭建项目的整体结构\n1、新建项目mhl\n2、将整体结构搭建出来。dao包，domain包，service包，utils包，view包\n准备工具类Utility\n1、将三个jar包导入。分别是mysql，druid，Apache-DBUtils相关的jar包。\n2、将JDBCUtilsByDruid，Utility类导入utils包中。(Utility类负责控制输入，JDBCUtilsByDruid类负责连接druid连接池)。\n3、将配置文件druid.properties导入src目录下。!!!注意修改配置文件中的参数,确保数据库正确。\n4、测试Utility类和JDBCUtilsByDruid类。(从其他地方导入可能会出现问题)\nBasicDAO\n针对表进行的操作。\ndml方法-&gt;update\n返回多行结果-&gt;queryMulti\n返回单行结果-&gt;querySingle\n返回单个对象-&gt;queryScaler\njava/**\n * 开发BasicDAO,是其他DAO的父类\n */\npublic class BasicDAO&lt;T&gt; &#123; //泛型指定具体类型\n    private QueryRunner qr = new QueryRunner();\n    //开发通用dml方法，针对任意的表\n    public int update(String sql, Object... parameters) &#123; //sql语句， 参数\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            //返回受影响的行数\n            int update = qr.update(connection, sql, parameters);\n            return update;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //返回多个对象(即查询的结果是多行),针对任意表\n    /**\n     * @param sql sql语句,可以有?\n     * @param clazz 传入一个类的Class对象,比如Actor.class\n     * @param parameters 传入?的具体的值,可以是多个\n     * @return 根据Actor.class 返回对应的ArrayList集合\n     */\n    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; clazz, Object...parameters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(clazz), parameters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行结果的通用方法\n    public T querySingle(String sql, Class&lt;T&gt; clazz, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(clazz), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行单列的方法,即返回单值的方法\n    public Object queryScaler(String sql, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new ScalarHandler(), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n&#125;效果如下图\n\n\n2、显示主菜单、二级菜单和退出系统功能1、代码部分略\n2、显示框架如下\n\n\n3、用户登录要求: 用户登陆时输入id和pwd要和用户表进行匹配。匹配成功可以登陆，失败就退出\n1、创建用户表sql--用户表\nCREATE TABLE employee (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增\n    empId VARCHAR(50) UNIQUE NOT NULL DEFAULT &#39;&#39;, #员工号\n    pwd CHAR(32) NOT NULL DEFAULT &#39;&#39;, #密码md5\n    name VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #姓名\n    job VARCHAR(50) NOT NULL DEFAULT &#39;&#39; #岗位\n)CHARSET=utf8;\n\n--添加测试语句\nINSERT INTO employee VALUES(NULL, &#39;6668612&#39;, MD5(&#39;123456&#39;), &#39;张三丰&#39;, &#39;经理&#39;);\nINSERT INTO employee VALUES(NULL, &#39;6668622&#39;, MD5(&#39;123456&#39;), &#39;小龙女&#39;, &#39;服务员&#39;);\nINSERT INTO employee VALUES(NULL, &#39;6668633&#39;, MD5(&#39;123456&#39;), &#39;张无忌&#39;, &#39;收银员&#39;);\nINSERT INTO employee VALUES(NULL, &#39;666666&#39;, MD5(&#39;123456&#39;), &#39;老虎&#39;, &#39;经理&#39;);2、domian包: Employee根据程序框架图要设置一个与mysql表对应的domain类。\n该类是javabean和emoloyeee对应\njavapublic class Employee &#123;\n    private Integer id;\n    private String empId;\n    private String pwd;\n    private String name;\n    private String job; \n    public Employee() &#123; //无参构造器,反射需要\n    &#125;\n    public Employee(Integer id, String empId, String pwd, String name, String job) &#123;\n        this.id = id;\n        this.empId = empId;\n        this.pwd = pwd;\n        this.name = name;\n        this.job = job;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n&#125;3、DAO包: EmployeeDAO根据程序框架图设置一个能操作employee表的类。\n该类继承BasicDAO类\njavapackage com.mhl.dao;\n\nimport com.mhl.domain.Employee;\n\npublic class EmployeeDAO extends BasicDAO&lt;Employee&gt; &#123;\n    //可以写特有的操作\n&#125;4、(业务层)service包: EmployeeService功能: 根据empId和pwd返回一个Employee对象,如果未匹配则返回null\n根据程序框架图设置一个业务层的employeeservice类，负责组织sql语句完成业务需要。\njava/**\n * 该类完成对employee表的各种操作\n * 通过调用EmployeeDAO对象完成\n */\npublic class EmployeeService &#123;\n    //定义一个 EmployeeDAO\n    private EmployeeDAO employeeDAO = new EmployeeDAO();\n\n    //方法，根据empId和pwd返回一个Employee对象\n    public Employee getEmployeeByIdAndPwd(String empId, String pwd) &#123;\n        return employeeDAO.querySingle(&quot;select * from employee where empId=? and pwd=md5(?)&quot;, Employee.class, empId, pwd);\n    &#125;\n&#125;5、MHLView在主菜单界面调用该方法使用: 调用该方法就必须拥有一个该类的对象，因此创建一个该类的对象。\njava//定义EmployeeService 属性\nprivate EmployeeService employeeService = new EmployeeService();效果演示\n\n4、显示餐桌要求: 显示餐桌编号和餐桌当前状态\n1、创建餐桌表sql--创建diningTable 表(id, state, orderName, orderTel ...)\nCREATE TABLE diningTable (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增,表示餐桌编号\n    state VARCHAR(20) NOT NULL DEFAULT &#39;&#39;, #餐桌的状态\n    orderName VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #预定人的名字\n    orderTel VARCHAR(20) NOT NULL DEFAULT &#39;&#39;\n)CHARSET=utf8;\n\n--添加测试语句\nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); \nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); \nINSERT INTO diningTable VALUES(NULL, &#39;空&#39;, &#39;&#39;, &#39;&#39;); 2、domain包:  DiningTablejavabean和diningTable表对应\njavapublic class DiningTable &#123;\n    private Integer id;\n    private String state;\n    private String orderName;\n    private String orderTel;\n\n    public DiningTable() &#123;\n    &#125;\n\n    public DiningTable(Integer id, String state, String orderName, String orderTel) &#123;\n        this.id = id;\n        this.state = state;\n        this.orderName = orderName;\n        this.orderTel = orderTel;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return id + &quot;\\t\\t\\t&quot; + state;\n    &#125;\n&#125;3、DAO包: DiningTableDAOjavapublic class EmployeeDAO extends BasicDAO&lt;Employee&gt; &#123;\n    //可以写特有的操作\n&#125;4、service包: DiningTableService功能: 返回所有的餐桌信息\njavapublic class DiningTableService &#123; //业务层\n    //定义一个DiningTableDAO对象\n    private DiningTableDAO diningTableDAO = new DiningTableDAO();\n    //返回所有餐桌信息\n    public List&lt;DiningTable&gt; list() &#123;\n       return diningTableDAO.queryMulti(&quot;select id, state from diningTable&quot;, DiningTable.class);\n    &#125;\n&#125;5、MHLView在MHLView中封装方法，用于显示所有餐桌的状态。\njava//显示所有餐桌状态\npublic void listDiningTable() &#123;\n    List&lt;DiningTable&gt; list = diningTableService.list();\n    System.out.println(&quot;\\n餐桌编号\\t\\t餐桌状态&quot;);\n    for (DiningTable diningTable : list) &#123;\n        System.out.println(diningTable);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n5、满汉楼订座要求: 实现用户订座，如果座位状态不为空则显示不能订座。\n1、功能分析定制功能建立在diningTable表上，因此订座功能应当在DiningTableService类(针对DiningTable的服务)中实现\n2、DiningTableService扩展扩展两个方法\ngetDiningTableById:  根据传入的id判断餐桌是否存在。若不存在返回null。\norderDiningTable: 根据传入的形参对diningTable表进行更新。成功返回true，失败返回false\njava//根据id, 查询对应的餐桌DiningTable对象\n//如果返回null,表示id编号对应的餐桌不存在\npublic DiningTable getDiningTableById(int id) &#123;\n    //可以直接执行sql语句去测试是否正确\n    return diningTableDAO.querySingle(&quot;select * from diningTable where id = ?&quot;, DiningTable.class, id);\n&#125;\n//如果可以预定,调用方法对diningTable表进行更新\n/**\n * @param id 餐桌id\n * @param orderName 预订人姓名\n * @param orderTel 预订人电话\n * @return\n */\npublic boolean orderDiningTable(int id, String orderName, String orderTel) &#123;\n    int update =\n            diningTableDAO.update(&quot;update diningTable set state=&#39;已经预定&#39;, orderName=?, orderTel=? where id = ?&quot;, orderName, orderTel, id);\n    return update &gt; 0;\n&#125;3、MHLView在MHLView封装方法，实现订座功能。\njava//完成订座\npublic void orderDiningTable() &#123;\n    System.out.println(&quot;==============预定餐桌============&quot;);\n    System.out.print(&quot;请选择要预定的餐桌编号(-1退出): &quot;);\n    int orderId = Utility.readInt();\n    if (orderId == -1) &#123;\n        System.out.println(&quot;==============取消预订餐桌============&quot;);\n        return;\n    &#125;\n    //该方法得到的是 Y 或者 N\n    char key = Utility.readConfirmSelection();\n    if (key == &#39;Y&#39;) &#123;//要预定\n\n        //根据orderId 返回 对应DiningTable对象, 如果为null, 说明该对象不存在\n        DiningTable diningTable = diningTableService.getDiningTableById(orderId);\n        if (diningTable == null) &#123;//\n            System.out.println(&quot;==============预订餐桌不存在============&quot;);\n            return;\n        &#125;\n        //判断该餐桌的状态是否 &quot;空&quot;\n        if (!(&quot;空&quot;.equals(diningTable.getState()))) &#123;//说明当前这个餐桌不是 &quot;空&quot; 状态\n            System.out.println(&quot;==============该餐桌已经预定或者就餐中============&quot;);\n            return;\n        &#125;\n        //接收预定信息\n        System.out.print(&quot;预定人的名字: &quot;);\n        String orderName = Utility.readString(50);\n        System.out.print(&quot;预定人的电话: &quot;);\n        String orderTel = Utility.readString(50);\n\n        //更新餐桌状态\n        if (diningTableService.orderDiningTable(orderId, orderName, orderTel)) &#123;\n            System.out.println(&quot;==============预订餐桌成功============&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;==============预订餐桌失败============&quot;);\n        &#125;\n\n    &#125; else &#123;\n        System.out.println(&quot;==============取消预订餐桌============&quot;);\n    &#125;\n&#125;效果演示\n\n\n6、满汉楼菜单要求: 显示菜单表。\n1、创建菜单表sql--创建menu表(id, name, type, price)\n#菜单\nCREATE TABLE menu (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增,菜单编号\n    name VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #菜名\n    type VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #菜品种类\n    price DOUBLE NOT NULL DEFAULT 0 #价格\n)CHARSET=utf8;\n\n--添加测试数据\nINSERT INTO menu VALUES(NULL, &#39;八宝饭&#39;, &#39;主食&#39;, 10);\nINSERT INTO menu VALUES(NULL, &#39;叉烧包&#39;, &#39;主食&#39;, 20);\nINSERT INTO menu VALUES(NULL, &#39;宫保鸡丁&#39;, &#39;热菜&#39;, 30);\nINSERT INTO menu VALUES(NULL, &#39;山药拔鱼&#39;, &#39;凉菜&#39;, 14);\nINSERT INTO menu VALUES(NULL, &#39;银丝卷&#39;, &#39;甜食&#39;, 9);\nINSERT INTO menu VALUES(NULL, &#39;水煮鱼&#39;, &#39;热菜&#39;, 26);\nINSERT INTO menu VALUES(NULL, &#39;甲鱼汤&#39;, &#39;汤类&#39;, 100);\nINSERT INTO menu VALUES(NULL, &#39;鸡蛋汤&#39;, &#39;汤类&#39;, 16);2、domain包: Menujava/**\n * 该类(javabean)和menu表\n */\npublic class Menu &#123;\n    private Integer id;\n    private String name;\n    private String type;\n    private Double price;\n\n    public Menu() &#123;\n    &#125;\n\n    public Menu(Integer id, String name, String type, Double price) &#123;\n        this.id = id;\n        this.name = name;\n        this.type = type;\n        this.price = price;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return id + &quot;\\t\\t&quot; + name + &quot;\\t\\t&quot; + type + &quot;\\t\\t&quot; + price;\n    &#125;\n&#125;3、DAO包: MenuDAOjavapublic class MenuDAO extends BasicDAO&lt;Menu&gt;&#123;&#125;4、service包: MenuService功能: 返回menu表所有内容\njava/**\n * 完成对menu表的各种操作(通过调用MenuDAO)\n */\npublic class MenuService &#123;\n    //定义MenuDAO属性\n    private MenuDAO menuDAO = new MenuDAO();\n    //返回所有菜品\n    public List&lt;Menu&gt; list() &#123;\n        return menuDAO.queryMulti(&quot;select * from menu&quot;, Menu.class);\n    &#125;\n&#125;5、MHLView在MHLView中封装方法，用于显示所有菜品。\njava//显示所有菜品\npublic void listMenu() &#123;\n    List&lt;Menu&gt; list = menuService.list();\n    System.out.println(&quot;\\n菜品编号\\t\\t菜品名\\t\\t类别\\t\\t价格&quot;);\n    for (Menu menu : list) &#123;\n        System.out.println(menu);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n7、满汉楼点餐要求: 对餐桌号，菜单编号，做合理性校验，如果不合理，给出提示信息。\n思路分析1、餐桌号，菜单编号 校验。\n2、点餐成功，需要修改餐桌状态。\n3、生成账单 -&gt; 创建账单表\n1、创建账单表sql#表bill账单表(id, billId, menuId, nums, billDate, money, state, diningTableId)\nCREATE TABLE bill (\n    id INT PRIMARY KEY AUTO_INCREMENT, #自增主键\n    billId VARCHAR(50) NOT NULL DEFAULT &#39;&#39;, #账单号 可以安装自己规则生成 UUID\n    menuId INT NOT NULL DEFAULT 0, #菜单编号,可以用外键\n    nums INT NOT NULL DEFAULT 0, #份数\n    money DOUBLE NOT NULL DEFAULT 0, #金额\n    diningTableId INT NOT NULL DEFAULT 0, #餐桌\n    billDate DATE NOT NULL, #订单日期\n    state VARCHAR(50) NOT NULL DEFAULT &#39;&#39; #状态 &#39;未结账&#39;, &#39;已结账&#39;, &#39;挂单&#39;\n)CHARSET=utf8;2、domain包: BillBill是javabean和bill表对应\njava/**\n * 该类(javabean)和bill表对应\n */\npublic class Bill &#123;\n    private Integer id;\n    private String billId;\n    private Integer menuId;\n    private Integer nums;\n    private Double money;\n    private Integer diningTableId;\n    private Date billDate;\n    private String state;\n\n    public Bill() &#123; //无参构造器,用于反射\n    &#125;\n\n    public Bill(Integer id, String billId, Integer menuId, Integer nums, Double money, Integer diningTableId, Date billDate, String state) &#123;\n        this.id = id;\n        this.billId = billId;\n        this.menuId = menuId;\n        this.nums = nums;\n        this.money = money;\n        this.diningTableId = diningTableId;\n        this.billDate = billDate;\n        this.state = state;\n    &#125;\n    //get和set方法通过alt+ins生成，略\n    @Override\n    public String toString() &#123;\n        return &quot;Bill&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, billId=&#39;&quot; + billId + &#39;\\&#39;&#39; +\n                &quot;, menuId=&quot; + menuId +\n                &quot;, nums=&quot; + nums +\n                &quot;, money=&quot; + money +\n                &quot;, diningTableId=&quot; + diningTableId +\n                &quot;, billDate=&quot; + billDate +\n                &quot;, state=&#39;&quot; + state + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;3、DAO包: BillDAOjavapublic class BillDAO extends BasicDAO&lt;Bill&gt;&#123;&#125;4、service包: BillService功能: 处理和账单相关的业务逻辑\nBillService类\n1、生成账单\n注意事项: 1、生成账单需要计算金额，因此从MenuService中获取menu对象进而得到金额。\n​\t\t\t\t\t2、当生成订单后需要将餐桌状态更新，因此需要DiningTableService属性改变餐桌状态。\n​\t\t\t\t\t综上,MenuService和DiningTableService需要新增方法。\njava/**\n * 处理和账单相关的业务逻辑\n */\npublic class BillService &#123;\n    //定义BillDAO属性\n    private BillDAO billDAO = new BillDAO();\n    //定义一个MenuService属性\n    private MenuService menuService = new MenuService();\n    //定义一个DiningTableService属性\n    private DiningTableService diningTableService = new DiningTableService();\n    //点餐的方法 成功返回true 失败false\n    //1. 生成账单\n    //2. 更新餐桌状态\n    public boolean orderMenu(int menuId, int nums, int diningTableId) &#123;\n        //生成一个账单号,UUID\n        String billId = UUID.randomUUID().toString();\n\n        //将账单生成到bill表,要求直接计算账单金额\n        int update = billDAO.update(&quot;insert into bill values(null,?,?,?,?,?,now(),&#39;未结账&#39;)&quot;,\n                billId, menuId, nums, (menuService.getMenuById(menuId).getPrice() * nums), diningTableId);\n        if(update &lt;= 0) &#123;\n            return false;\n        &#125;\n        //更新餐桌状态\n        return diningTableService.updateDiningTableState(diningTableId, &quot;就餐中&quot;);\n    &#125;\n&#125;MenuService新增方法\njava//方法,根据id,返回Menu对象\npublic Menu getMenuById(int id) &#123;\n    return menuDAO.querySingle(&quot;select * from menu where id = ?&quot;, Menu.class, id);\n&#125;DiningTableService新增方法\njava//方法,更新餐桌状态的方法\npublic boolean updateDiningTableState(int id, String state) &#123;\n    int update = diningTableDAO.update(&quot;update diningTable set state=? where id=?&quot;, state, id);\n    return update &gt; 0;\n&#125;5、MHLView在MHLView封装方法，实现点餐功能。\n验证餐桌号是否存在: 通过diningTableService.getDiningTableById可以判断餐桌是否存在。\n验证菜品编号: 通过menuService.getMenuById判断此id对应的对象是否存在\n点餐: billService.orderMenu创建账单,创建失败则返回false\njava//完成点餐\npublic void orderMenu() &#123;\n    System.out.println(&quot;==============点餐服务============&quot;);\n    System.out.print(&quot;请输入点餐的桌号(-1退出): &quot;);\n    int orderDiningTableId = Utility.readInt();\n    if (orderDiningTableId == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;请输入点餐的菜品号(-1退出): &quot;);\n    int orderMenuId = Utility.readInt();\n    if (orderMenuId == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;请输入点餐的菜品量(-1退出): &quot;);\n    int orderNums = Utility.readInt();\n    if (orderNums == -1) &#123;\n        System.out.println(&quot;==============取消点餐============&quot;);\n        return;\n    &#125;\n\n    //验证餐桌号是否存在.\n    DiningTable diningTable = diningTableService.getDiningTableById(orderDiningTableId);\n    if (diningTable == null) &#123;\n        System.out.println(&quot;==============餐桌号不存在============&quot;);\n        return;\n    &#125;\n    //验证菜品编号\n    Menu menu = menuService.getMenuById(orderMenuId);\n    if (menu == null) &#123;\n        System.out.println(&quot;==============菜品号不存在============&quot;);\n        return;\n    &#125;\n\n    //点餐\n    if (orderMenu(orderMenuId, orderNums, orderDiningTableId)) &#123;\n        System.out.println(&quot;==============点餐成功============&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;==============点餐失败============&quot;);\n    &#125;\n&#125;效果演示\n\n\n8、满汉楼显示账单要求: 显示所有账单\n1、BillService新增功能java//返回所有账单\npublic List&lt;Bill&gt; list() &#123;\n    return billDAO.queryMulti(&quot;select * from bill&quot;, Bill.class);\n&#125;2、MHLViewjava//显示账单信息\npublic void listBill() &#123;\n    List&lt;Bill&gt; bills = billService.list();\n    System.out.println(&quot;\\n编号\\t\\t菜品号\\t\\t菜品量\\t\\t金额\\t\\t桌号\\t\\t日期\\t\\t\\t\\t\\t\\t\\t状态&quot;);\n    for (Bill bill : bills) &#123;\n        System.out.println(bill);\n    &#125;\n    System.out.println(&quot;==============显示完毕============&quot;);\n&#125;效果演示\n\n\n9、满汉楼结账要求: 实现满汉楼结账\n思路分析1、对餐桌号进行校验\n2、修改bill表的state\n3、修改diningTable信息，结完账就清空\n4、不需要增加新表，不需要增加新类，需要增加方法\n1、BillService新增功能hasPayBillByDiningTableId: 查看未结账账单\npayBill: 完成结账[如果餐桌存在，并且该餐桌有未结账的账单]\njava//查看某个餐桌是否有未结账的账单\npublic boolean hasPayBillByDiningTableId(int diningTableId) &#123;\n\n    Bill bill =\n            billDAO.querySingle(&quot;SELECT * FROM bill WHERE diningTableId=? AND state = &#39;未结账&#39; LIMIT 0, 1&quot;, Bill.class, diningTableId);\n    return bill != null;\n&#125;\n//完成结账[如果餐桌存在，并且该餐桌有未结账的账单]\n//如果成功，返回true, 失败返回 false\npublic boolean payBill(int diningTableId, String payMode) &#123;\n    //如果这里使用事务的话，需要用ThreadLocal来解决 , 框架中比如mybatis 提供了事务支持\n    //1. 修改bill表\n    int update = billDAO.update(&quot;update bill set state=? where diningTableId=? and state=&#39;未结账&#39;&quot;, payMode, diningTableId);\n\n    if(update &lt;= 0) &#123; //如果更新没有成功，则表示失败...\n        return false;\n    &#125;\n    //2. 修改diningTable表\n    //注意：不要直接在这里操作，而应该调用DiningTableService 方法,完成更新，体现各司其职\n    if(!diningTableService.updateDiningTableToFree(diningTableId, &quot;空&quot;)) &#123;\n        return false;\n    &#125;\n    return true;\n&#125;2、DiningTableService新增功能updateDiningTableToFree: 将餐桌设置为空闲状态\njava//提供方法，将指定的餐桌设置为空闲状态\npublic boolean updateDiningTableToFree(int id, String state) &#123;\n    int update = diningTableDAO.update(&quot;update diningTable set state=?,orderName=&#39;&#39;,orderTel=&#39;&#39; where id=?&quot;, state, id);\n    return update &gt; 0;\n&#125;3、MHLViewMHLView封装方法完成结账\n1、判断餐桌是否存在: diningTableService.getDiningTableById\n2、判断该餐桌是否有需要结账的账单: billService.hasPayBillByDiningTableId\n3、完成结账: 调用payBill方法完成结账\njava//完成结账\npublic void payBill() &#123;\n    System.out.println(&quot;==============结账服务============&quot;);\n    System.out.print(&quot;请选择要结账的餐桌编号(-1退出): &quot;);\n    int diningTableId = Utility.readInt();\n    if (diningTableId == -1) &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n        return;\n    &#125;\n    //验证餐桌是否存在\n    DiningTable diningTable = diningTableService.getDiningTableById(diningTableId);\n    if (diningTable == null) &#123;\n        System.out.println(&quot;=============结账的餐桌不存在============&quot;);\n        return;\n    &#125;\n    //验证餐桌是否有需要结账的账单\n    if (!billService.hasPayBillByDiningTableId(diningTableId)) &#123;\n        System.out.println(&quot;=============该餐位没有未结账账单============&quot;);\n        return;\n    &#125;\n    System.out.print(&quot;结账方式(现金/支付宝/微信)回车表示退出: &quot;);\n    String payMode = Utility.readString(20, &quot;&quot;);//说明如果回车，就是返回 &quot;&quot;\n    if (&quot;&quot;.equals(payMode)) &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n        return;\n    &#125;\n    char key = Utility.readConfirmSelection();\n    if (key == &#39;Y&#39;) &#123; //结账\n\n        //调用我们写的方法\n        if (billService.payBill(diningTableId, payMode)) &#123;\n            System.out.println(&quot;=============完成结账============&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;=============结账失败============&quot;);\n        &#125;\n\n    &#125; else &#123;\n        System.out.println(&quot;=============取消结账============&quot;);\n    &#125;\n&#125;效果演示\n\n10、多表查询注意事项:  1、domain构建MultiTableBean类，属性是通过反射调用set方法赋值，因此无参构造器是必须的。\n​\t\t\t\t\t 2、不查询price值的话，price的值为null，不会对程序造成影响。\n​\t\t\t\t \t3、属性名是否一定要和表的列名保持一致。可以不一致，但是需要sql做相应的修改, 规范需要保持一致.\n细节:  如果sql语句写出如下形式，那么会通过反射找setName2方法来给MultiTableBean类中的属性赋值。因此如果两个表设计到重复名字的话，可以设置别名区分。\n例如: a表设置为name1，b表设置为name2，在MultiTableBean类中分别给name1和name2设置set和get方法就可以区分两个表。\n\n举例:\nMultiTableBean类: private String name2;\nBillSerbvice类: \njava//返回所有的账单并带有菜品名,价格， 提供给View调用\npublic List&lt;MultiTableBean&gt; list2() &#123;\n    return multiTableDAO.queryMulti(&quot;SELECT bill.*, NAME as name2,price &quot; +\n            &quot;FROM bill, menu &quot; +\n            &quot;WHERE bill.menuId = menu.id&quot;, MultiTableBean.class);\n&#125;如果如上设计，那么list2返回的表中name2就不会为null\n1、MultiTableBean类从原先的bill表新增属性，重新设计一个多表类\njavaprivate Integer id;\nprivate String billId;\nprivate Integer menuId;\nprivate Integer nums;\nprivate Double money;\nprivate Integer diningTableId;\nprivate Date billDate;\nprivate String state;\n//增加一个来自menu表的列 name\n//思考 这里的属性名是否一定要和表的列名保持一致.\n//答: 可以不一致，但是需要sql做相应的修改, 规范需要保持一致.\nprivate String name;\n//增加来自menu表的列 price\nprivate Double price;//默认值 nulll2、MultiTableDAO类javapublic class MultiTableDAO extends BasicDAO&lt;MultiTableBean&gt; &#123;&#125;3、BillService类注意:  用String连接mysql语句时要注意空格，否则sql语句不通过\njava//返回所有的账单并带有菜品名,价格， 提供给View调用\npublic List&lt;MultiTableBean&gt; list2() &#123;\n    return multiTableDAO.queryMulti(&quot;SELECT bill.*, NAME,price &quot; +\n            &quot;FROM bill, menu &quot; +\n            &quot;WHERE bill.menuId = menu.id&quot;, MultiTableBean.class);\n&#125;4、MHLView从新建的multiTableBeans类获取list集合，可获得menu表中的name和price值。\nprice值可以为null，不会对程序造成影响。\njava//显示账单信息\n    public void listBill() &#123;\n        List&lt;MultiTableBean&gt; multiTableBeans = billService.list2();\n        System.out.println(&quot;\\n编号\\t\\t菜品号\\t\\t菜品量\\t\\t金额\\t\\t桌号\\t\\t日期\\t\\t\\t\\t\\t\\t\\t状态\\t\\t菜品名\\t\\t价格&quot;);\n        for (MultiTableBean bill : multiTableBeans) &#123;\n            System.out.println(bill);\n        &#125;\n        System.out.println(&quot;==============显示完毕============&quot;);\n    &#125;效果演示\n\n\n总结1、思路路程根据程序框架图从底层开始搭建。\n1、首先设置好utils工具类，druid配置文件\n2、domain层: 例如创建Menu表对应一个domian类-Menu类。Menu类含有无参构造器-&gt;反射需要。含有Menu表该有的属性和tostring方法。\n3、DAO层: 在DAO层构建一个MenuDAO类，负责对Menu表的增删改查和特有的操作。该层的类都会继承BasicDAO类，BasicDAO中是通用的方法。\n4、service层: 构建MenuService类，负责组织sql语句，并调用MenuDAO对象完成综合的需求。\n5、View层: MHLView界面层调用service层的类，得到结果，显示数据。\n","slug":"Mysql章节满汉楼项目","date":"2023-11-24T16:25:00.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"白"},{"id":"fb7466e40a0c693c18329664f28f2eb5","title":"JDBC和数据库连接池","content":"Mysql学习笔记一、Mysql简要说明使用命令行窗口连接 MYSQL 数据库\n\n操作示意图\n\n二、创建数据库txt\\#使用指令创建数据库\n\nCREATE DATABASE hsp_db01;\n\n\\#删除数据库指令\n\nDROP DATABASE hsp_db01\n\n\\#创建一个使用 utf8 字符集的 hsp_db02 数据库\n\nCREATE DATABASE hsp_db02 CHARACTER SET utf8\n\n\\#创建一个使用 utf8 字符集，并带校对规则的 hsp_db03 数据库\n\nCREATE DATABASE hsp_db03 CHARACTER SET utf8 COLLATE utf8_bin\n\n\\#校对规则 utf8_bin 区分大小 默认 utf8_general_ci 不区分大小写\n章节: JDBC和数据库连接池一、JDBC 连接 MySQL准备工作将下载的mysql-connector-java.jar 放入在目录里面的 libs 里面（如果没有就自己创建一个，记得要打包文件）\n右键选中加载到库中\n\n\n二、介绍JDBC1、JDBC的概念 JDBC 是 Java DataBase Connectivity (Java 数据连接)技术的简称，是一种可用于执行 SQL 语句的 Java API。它由一些 java 语言编写的类和接口组成；程序员通过使用 jdbc 可以方便地将 SQL 语句传送给几乎任何一种数据库。\n2、JDBC 的功能(1) 与数据库建立连接。(2) 向数据库发送 SQL 语句并执行这些语句。(3) 处理数据返回的结果。\n3、JDBC 的常用接口和类(1) Driver 接口:加载驱动程序。(2) DriverManager 类:装人所需的 JDBC 驱动程序，编程时调用它的方法来创建连接。(3) Connection 接口:编程时使用该类对象创建 Statement 对象。(4) Statement 接口:编程时使用该类对象得到 ResultSet 对象。(5) ResultSet 类:负责保存 Statement 执行后所产生的查询结果。\n\n三、连接 MySQL小提示：\n1.mysql驱动5.1.6可以无需CLass.forName(“com.mysql.jdbc.Driver”);\n2.从jkd1.5以后使用jdbc4，不再需要显示调用class.forName()注册驱动而是自动调用驱动jar包下META-INF\\services\\java.sql.Driver文本中的类名称去注册\n3.建议还是写上Class.forName(“com.mysql.cj.jdbc.Driver”),更加明确\n\n(1)、注册驱动使用反射加载Driver类\ntxtClass.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);(2)、获取连接方法一:  DriverManager.getConnection() 传入形参 String url ,Properties info\n方法二:  DriverManager.getConnection() 传入形参 String url ,String user, String password\ntxt Connection com = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/hspeducode&quot;, &quot;root&quot;, &quot;123456&quot;);(3)、获取执行者连接txtStatement stat = com.createStatement();(4)、执行 SQL 语句，并接受结果txtString sql = &quot;SELECT * FROM user&quot;;\n\nResultSet rs = stat.executeQuery(sql);(5)、处理结果txtwhile (rs.next())&#123;\n        System.out.println(rs.getInt(&quot;id&quot;) + &quot;\\t&quot; + rs.getString(&quot;name&quot;));\n&#125;(6)、释放资源txtcom.close();\nstat.close();\ncom.close();（重要）通过不同方式连接mysql方式一：映射之后连接mysqljavapublic void connect01() throws ClassNotFoundException, SQLException &#123;\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(&quot;方式一: &quot;+connection);\n&#125;方式二：通过读取配置文件来连接mysql\njavapublic void connect02() throws IOException, ClassNotFoundException, SQLException &#123;\n    //通过Properties对象获取配置文件\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n    //获取相关的值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    String driver = properties.getProperty(&quot;driver&quot;);\n\n    Class.forName(driver);//建议写上\n    Connection connection = DriverManager.getConnection(url, user, password);\n    System.out.println(&quot;方式二: &quot; + connection);\n&#125;\n四、ResultSet[结果集]1.基本介绍1.表示数据库结果集的数据库，通常通过执行查询数据库的语句生成\n2.ResultSet对象保持一个光标指向其当前的数据行。最初，光标位于第一行之前\n3.next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环来遍历结果集\n2.ResultSet图像说明\n3.ResultSet底层\n4.代码举例演示javapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        //1. 加载驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        //创建url和user和password\n        String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n        String user = &quot;root&quot;;\n        String password = &quot;20031214gr&quot;;\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n        //3. 得到Statement\n        Statement statement = connection.createStatement();\n        //4. 组织sql\n        String sql = &quot;select id, name, sex, borndate, phone from actor&quot;;\n        //执行给定的SQL语句,该语句返回单个ResultSet对象\n        ResultSet resultSet = statement.executeQuery(sql);\n        //5. 使用while取出数据\n        while (resultSet.next()) &#123; //让光标向下移动,如果没有更多信息,返回false\n            int id = resultSet.getInt(1); //获取该行的第1列\n            String name = resultSet.getString(2); //获取该行第2列\n            String sex = resultSet.getString(3); //获取该行第3列\n            Date borndate = resultSet.getDate(4); //获取该行第4列\n            String phone = resultSet.getString(5); //获取该行第5列\n\n            System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + borndate + &quot;\\t&quot; + phone);\n        &#125;\n        //6. 关闭连接\n        resultSet.close();\n        connection.close();\n        statement.close();\n    &#125;​\t\t输出演示\ntxt1\t周星驰\t男\t1970-11-11\t110\n2\t刘德华\t男\t1970-11-11\t110\n五、Statement接口1.基本介绍\n2.sql注入​\t\t前置准备\ntxt-- 创建一张表\n\nCREATE TABLE admin ( -- 管理员表\n\nNAME VARCHAR(32) NOT NULL UNIQUE, \n\npwd VARCHAR(32) NOT NULL DEFAULT &#39;&#39;) CHARACTER SET utf8; \n\n-- 添加数据\n\nINSERT INTO admin VALUES(&#39;tom&#39;, &#39;123&#39;);​\t\t正常查询\ntxtSELECT *\n\nFROM admin\n\nWHERE NAME = &#39;tom&#39; AND pwd = &#39;123&#39;​\t\tSQL注入\ntxt-- 输入用户名 为 1&#39; or\n\n-- 输入万能密码 为 or &#39;1&#39;= &#39;1\n\nSELECT *\n\nFROM admin\n\nWHERE NAME = &#39;1&#39; OR&#39; AND pwd = &#39;OR &#39;1&#39;= &#39;1&#39; \n-- &#39;1&#39; = &#39;1&#39;一定成立,因此有隐患\n\nSELECT * FROM admin3.代码举例演示sql注入​\t\t代码内容演示\njavapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n    Scanner scanner = new Scanner(System.in);\n    //next(): 当接收到 空格 或者 &#39; 就是表示结束\n    //nextLine(): 接受到 回车 表示结束\n    System.out.print(&quot;请输入管理员的名字: &quot;);\n    String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n    System.out.print(&quot;请输入管理员的密码: &quot;);\n    String admin_pws = scanner.nextLine();\n    //1. 加载驱动\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    //3. 得到Statement\n    Statement statement = connection.createStatement();\n    //4. 组织sql\n    String sql = &quot;select name, pwd from admin where name = &#39;&quot;\n            + admin_name + &quot;&#39; and pwd = &#39;&quot; +admin_pws+ &quot;&#39;&quot;;\n    //执行给定的SQL语句,该语句返回单个ResultSet对象\n    ResultSet resultSet = statement.executeQuery(sql);\n    //5.查询表\n    if(resultSet.next()) &#123;\n        System.out.println(&quot;恭喜,登陆成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;抱歉,登录失败&quot;);\n    &#125;\n\n    //6. 关闭连接\n    resultSet.close();\n    connection.close();\n    statement.close();\n&#125;​\t\t演示sql注入的结果\n\n\n六、PreparedStatement接口[预处理]1.基本介绍\n​\t\tsql语句编写\ntxtString sql = &quot;SELECT COUNT(*) FROM admin WHERE username =? AND PASSWORD =?&quot;2.预处理的好处 \n3.代码举例演示预处理javapublic static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n    Scanner scanner = new Scanner(System.in);\n    //next(): 当接收到 空格 或者 &#39; 就是表示结束\n    //nextLine(): 接受到 回车 表示结束\n    System.out.print(&quot;请输入管理员的名字: &quot;);\n    String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n    System.out.print(&quot;请输入管理员的密码: &quot;);\n    String admin_pws = scanner.nextLine();\n\n    //1. 加载驱动\n    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n    //创建url和user和password\n    String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n    String user = &quot;root&quot;;\n    String password = &quot;20031214gr&quot;;\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n    //3. 得到PreparedStatement\n    //3.1 组织sql,sql语句的 ?相当于占位符\n    String sql = &quot;select name, pwd from admin where name =? and pwd =?&quot;;\n    //3.2 preparedStatement对象实现了PreparedStatement接口的实现类的对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //3.3 给?赋值\n    preparedStatement.setString(1, admin_name);\n    preparedStatement.setString(2, admin_pws);\n\n    //4. 执行select语句使用 executeQuery\n    //   如果执行的是 dml语句(update, insert, delete) executeUpdate()\n    //   这里执行executeQuery不用再写sql语句,因为已经被PreparedStatement处理过了\n    //\t 除非sql语句不含?,才可以写在executeQuery里面\n    ResultSet resultSet = preparedStatement.executeQuery();\n    //5. 查询表\n    if(resultSet.next()) &#123;\n        System.out.println(&quot;恭喜,登陆成功&quot;);\n    &#125; else &#123;\n        System.out.println(&quot;抱歉,登录失败&quot;);\n    &#125;\n\n    //6. 关闭连接\n    resultSet.close();\n    preparedStatement.close();\n    connection.close();\n&#125;​\t\t演示sql注入的结果\n\n4.演示使用DML语句DML语句(update, insert, delete)使用  executeUpdate()\nselect语句使用 executeQuery()\njavapublic static void main(String[] args) throws Exception &#123;\n    //看 PreparedStatement 类图\n    Scanner scanner = new Scanner(System.in);\n    //让用户输入管理员名和密码\n    System.out.print(&quot;请输删除管理员的名字: &quot;); //next(): 当接收到 空格或者 &#39;就是表示结束\n    String admin_name = scanner.nextLine(); // 老师说明，如果希望看到 SQL 注入，这里需要用 nextLine\n    // System.out.print(&quot;请输入管理员的新密码: &quot;);\n    // String admin_pwd = scanner.nextLine();\n    //通过 Properties 对象获取配置文件的信息\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;javacode\\\\src\\\\mysql.properties&quot;));\n    //获取相关的值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String driver = properties.getProperty(&quot;driver&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    //1. 注册驱动\n    Class.forName(driver);//建议写上\n    //2. 得到连接\n    Connection connection = DriverManager.getConnection(url, user, password);\n***主要部分\n    //3. 得到 PreparedStatement\n    //3.1 组织 SqL , Sql 语句的 ? 就相当于占位符\n    //添加记录\n    //String sql = &quot;insert into admin values(?, ?)&quot;;\n    //String sql = &quot;update admin set pwd = ? where name = ?&quot;; 此刻 setString(1, admin_p)\n    String sql = &quot;delete from admin where name = ?&quot;;\n    //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //3.3 给 ? 赋值 此处要对应?赋正确的值\n    preparedStatement.setString(1, admin_name);\n    //preparedStatement.setString(2, admin_name);\n    //4. 执行 dml 语句使用 executeUpdate\n    int rows = preparedStatement.executeUpdate();\n    System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);\n***    \n    //关闭连接\n    preparedStatement.close();\n    connection.close();\n&#125;\n七、例题练习1、题目要求\n2、问题解析2.使用PreparedStatement添加5条数据javapublic class PreparedStatementwork1 &#123;\n    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;\n        Scanner scanner = new Scanner(System.in);\n        //next(): 当接收到 空格 或者 &#39; 就是表示结束\n        //nextLine(): 接受到 回车 表示结束\n        System.out.print(&quot;请输入管理员的名字: &quot;);\n        String admin_name = scanner.nextLine(); //如果希望看到sql注入,需要使用nextline方法\n        System.out.print(&quot;请输入管理员的密码: &quot;);\n        String admin_pws = scanner.nextLine();\n\n        //1. 加载驱动\n        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n        String url = &quot;jdbc:mysql://localhost:3306/hspeducode&quot;;\n        String user = &quot;root&quot;;\n        String password = &quot;20031214gr&quot;;\n        //2. 得到连接\n        Connection connection = DriverManager.getConnection(url, user, password);\n\n        //3. 得到PreparedStatement\n        //3.1 设置sql语句\n        String sql = &quot;insert into admin values(?, ?)&quot;;\n        //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //3.3 给 ? 赋值\n        preparedStatement.setString(1, admin_name);\n        preparedStatement.setString(2, admin_pws);\n\n        //4. 执行dml 语句使用 executeUpdate\n        int rows = preparedStatement.executeUpdate();\n        System.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);\n\n        //关闭连接\n        preparedStatement.close();\n        connection.close();\n    &#125;\n&#125;3.修改tom的记录, 将username改成 kingjava//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;update admin set name = &#39;king&#39; where name =? &quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n//3.3 给 ? 赋值\npreparedStatement.setString(1, admin_name);\n\n//4. 执行dml 语句使用 executeUpdate\nint rows = preparedStatement.executeUpdate();\nSystem.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);4.删除 一条 记录java//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;delete from admin where name = ?&quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n//3.3 给 ? 赋值\npreparedStatement.setString(1, admin_name);\n\n//4. 执行dml 语句使用 executeUpdate\nint rows = preparedStatement.executeUpdate();\nSystem.out.println(rows &gt; 0 ? &quot;执行成功&quot; : &quot;执行失败&quot;);5.查询全部记录，并显示在控制台使用select语句应该用executeQuery方法, 并且用ResultSet结果集接收, 在末尾要关闭ResultSet\njava//3. 得到PreparedStatement\n//3.1 设置sql语句\nString sql = &quot;select * from admin&quot;;\n//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象\nPreparedStatement preparedStatement = connection.prepareStatement(sql);\n\n//4. 执行select 语句使用 executeQuery\nResultSet resultSet = preparedStatement.executeQuery();\n\n//5. 使用while取出数据\nwhile(resultSet.next()) &#123; //让光标向下移动\n    String name = resultSet.getString(1);\n    String pwd = resultSet.getString(2);\n    System.out.println(name + &quot;\\t&quot; + pwd);\n&#125;\n//关闭连接\npreparedStatement.close();\nresultSet.close();\nconnection.close();\n八、JDBC的API小结\n\n\n九、封装 JDBC[关闭连接,得到连接]1.封装JDBCUtils[关闭连接, 得到连接]说明：在JDBC操作中，获取连接 和 释放资源 是经常使用到的，可以将其封装JDBC连接到的工具类 JDBCUtils\nJDBCUtils代码：\njavapackage com.JDBC.utils;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * 这是一个工具类,完成mysql的连接和关闭资源\n */\npublic class JDBCUtils &#123;\n    //定义相关属性(4个),只需要一份,做成static\n    private static String user; //用户名\n    private static String password; //密码\n    private static String url; //url\n    private static String driver; //驱动名\n\n    //在static代码块去初始化\n    static &#123;\n        try &#123;\n            Properties properties = new Properties();\n            properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n            //获取相关的属性值\n            user = properties.getProperty(&quot;user&quot;);\n            password = properties.getProperty(&quot;password&quot;);\n            url = properties.getProperty(&quot;url&quot;);\n            driver = properties.getProperty(&quot;driver&quot;);\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n\n    //连接数据库,返回Connection\n    public static Connection getConnection() &#123;\n        try &#123;\n            return DriverManager.getConnection(url, user, password);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    //关闭相关资源\n    /*\n        1. ResultSet 结果集\n        2. Statement 或者 PreparedStatement\n        3. Connection\n        4. 如果关闭资源,就传入对象,否则传入null\n     */\n    public static void close(ResultSet set, Statement statement, Connection connection) &#123;\n        //判断是否为null\n        try &#123;\n            if(set != null) &#123;\n                set.close();\n            &#125;\n            if(statement != null) &#123;\n                statement.close();\n            &#125;\n            if(connection != null) &#123;\n                connection.close();\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;2.演示如何使用JDBCUtils类1、使用JDBCUtils执行DML语句javapublic void testDML() &#123; //insert, update, delete\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update actor set name = ? where id = ?&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null; //为了在finally关闭资源,扩大作用域\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        preparedStatement = connection.prepareStatement(sql);\n        //给占位符赋值\n        preparedStatement.setString(1, &quot;蘑菇&quot;);\n        preparedStatement.setInt(2, 1);\n        //执行sql语句 update属于 dml语句\n        preparedStatement.executeUpdate();\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        //关闭资源\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;2、使用JDBCUtils执行select语句javapublic void testSelect() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql语句\n    String sql = &quot;select * from actor&quot;;\n    //3. 创建一个PreparedStament 对象\n    PreparedStatement preparedStatement = null;\n    ResultSet resultSet = null;\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句返回一个ResultSet结果集\n        resultSet = preparedStatement.executeQuery();\n        //通过while循环取出resultSet\n        while (resultSet.next()) &#123;\n            int id = resultSet.getInt(1);\n            String name = resultSet.getString(2);\n            String sex = resultSet.getString(3);\n            Date borndate = resultSet.getDate(4);\n            String phone = resultSet.getString(5);\n            System.out.println(id + &quot;\\t&quot; + name + &quot;\\t&quot; + sex + &quot;\\t&quot; + borndate + &quot;\\t&quot; + phone);\n        &#125;\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        JDBCUtils.close(resultSet, preparedStatement, connection);\n    &#125;\n&#125;\n十、事务1.简要说明\n2.应用实例: 模拟经典的转账业务1.模拟数据库txt-- 创建案例表\ncreate table account(\n    id int primary key auto_increment,\n    name varchar(32) not null default &#39;&#39;,\n    balance double not null default 0)\n    character set utf8;\n-- 插入数据\ninsert into account values(null, &#39;马云&#39;, 3000);\ninsert into account values(null, &#39;马化腾&#39;, 10000);2.不使用事务可能出现的问题模拟​\t在默认情况下,connection会自动提交。当执行到 int i &#x3D; 1&#x2F;0的时候,抛出异常,则不会继续执行try块后面的内容,就会使甲方转出了钱，但是乙方没有收到钱，这显然是不合理的，因此需要使用事务处理。\njavapublic void noTransaction() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update account set balance = balance - 100 where id = 1&quot;;\n    String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null;\n    try &#123;\n        connection = JDBCUtils.getConnection(); //在默认情况下,connection会自动提交\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句\n        preparedStatement.executeUpdate();\n\n        int i = 1/0; //抛出异常\n        //执行sql2语句\n        preparedStatement = connection.prepareStatement(sql2);\n        preparedStatement.executeUpdate();\n    &#125; catch (SQLException e) &#123;\n        throw new RuntimeException(e);\n    &#125; finally &#123;\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;3.使用事务解决上述问题​\t首先，先将connection设置为不自动提交，当设置后就表示开启了事务。如果发生异常就要回滚，所以在catch块中设置connection.rollback() 该方法默认回滚到事务开始的地方。在语句全部执行完后才提交事务connection.commit()。\njavapublic void userTransaction() &#123;\n    //1. 得到连接\n    Connection connection = null;\n    //2. 组织一个sql\n    String sql = &quot;update account set balance = balance - 100 where id = 1&quot;;\n    String sql2 = &quot;update account set balance = balance + 100 where id = 2&quot;;\n    //3. 创建一个PreparedStatement 对象\n    PreparedStatement preparedStatement = null;\n    try &#123;\n        connection = JDBCUtils.getConnection();\n        //将connection设置为不自动提交\n        connection.setAutoCommit(false); //开启了事务\n\n        preparedStatement = connection.prepareStatement(sql);\n        //执行sql语句\n        preparedStatement.executeUpdate();\n\n        //int i = 1/0; //抛出异常\n        //执行sql2语句\n        preparedStatement = connection.prepareStatement(sql2);\n        preparedStatement.executeUpdate();\n        //提交事务\n        connection.commit();\n\n    &#125; catch (SQLException e) &#123;\n        //在这里进行回滚，即撤销执行sql\n        System.out.println(&quot;执行发生了异常,撤销执行的sql语句&quot;);\n        try &#123;\n            connection.rollback(); //默认回滚到事务开始的地方\n        &#125; catch (SQLException ex) &#123;\n            throw new RuntimeException(ex);\n        &#125;\n        e.printStackTrace();\n    &#125; finally &#123;\n        JDBCUtils.close(null, preparedStatement, connection);\n    &#125;\n&#125;\n十一、批处理1.基本介绍\n2.批处理底层实际上是一个集合存储sql语句，满了之后扩容。  |  扩容之后如下。\n\n3.源码分析将 sql 语句加入到批处理包中 -&gt; 看源码\n1、第一就创建 ArrayList - elementData &#x3D;&gt; Object[]\n2、elementData &#x3D;&gt; Object[] 就会存放我们预处理的 sql 语句\n3、当 elementData 满后,就按照 1.5 倍扩容\n4、当添加到指定的值后，就 executeBatch\n5、批量处理会减少我们发送 sql 语句的网络开销，而且减少编译次数，因此效率提高\njavapublic void addBatch() throws SQLException &#123;\n    synchronized(this.checkClosed().getConnectionMutex()) &#123;\n    if (this.batchedArgs == null) &#123;\n        this.batchedArgs = new ArrayList();\n    &#125;\n    for(int i = 0; i &lt; this.parameterValues.length; ++i) &#123;\n        this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);\n    &#125;\n    this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));\n    &#125;\n&#125;4.使用批处理一定要在url中加入参数 ?rewriteBatchedStatements&#x3D;true\n配置文件内容:\ntxtuser=root\npassword=20031214gr\nurl=jdbc:mysql://localhost:3306/hspeducode?rewriteBatchedStatements=true\ndriver=com.mysql.cj.jdbc.Driver代码实现批处理操作sql语句\njavapublic void batch() throws SQLException &#123;\n    Connection connection = JDBCUtils.getConnection();\n    String sql = &quot;insert into admin2 values(null, ?, ?)&quot;;\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    System.out.println(&quot;开始执行&quot;);\n    long start = System.currentTimeMillis(); //开始时间\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        preparedStatement.setString(1, &quot;jack&quot;+i);\n        preparedStatement.setString(2, &quot;123&quot;);\n        //将sql语句加入到批处理包中\n        preparedStatement.addBatch();\n        //当有1000条时，再批量执行\n        if((i + 1) % 1000 == 0) &#123;\n            preparedStatement.executeBatch();\n            //清空语句\n            preparedStatement.clearBatch();\n        &#125;\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;批量处理 耗时时间: &quot; + (end - start));\n    //关闭连接\n    JDBCUtils.close(null, preparedStatement, connection);\n&#125;\n十二、数据库连接池1.提出问题问题：java程序频繁的连接数据库，需要得到多次连接\n传统连接数据库：\n\n多次连接数据库：\n\n传统方式连接mysql5000次代码模拟\njava//连接 mysql 5000 次\npublic void testCon() &#123;\n    //看看连接-关闭 connection 会耗用多久\n    long start = System.currentTimeMillis();\n    System.out.println(&quot;开始连接.....&quot;);\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //使用传统的 jdbc 方式，得到连接\n        Connection connection = JDBCUtils.getConnection();\n        //做一些工作，比如得到 PreparedStatement ，发送 sql\n        //.......... //关闭\n        JDBCUtils.close(null, null, connection);\n    &#125;\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;传统方式 5000 次 耗时=&quot; + (end - start));//传统方式 5000 次 耗时=7099\n    &#125;\n&#125;2.传统获取Connection问题分析\n3.数据库连接池基本介绍\n4.数据库连接池示意图1、当连接被占用时进入等待队列，等待连接可用。如果连接没有被占用，则可以直接获得连接，不需要等待。\n2、放回连接池是指把连接的引用断开，连接对象任然还在。\n\n5.数据库连接池的种类\n\nC3P0数据库连接池1.使用C3P0数据库连接池的准备工作添加jar包并且添加到库里。\n\n2.使用C3P0数据库连接池(代码实现)方式一: 在程序中指定user, url, password等java//方式一: 相关参数，在程序中指定user, url, password等\npublic void testC3P0_01() throws Exception &#123;\n    //1. 创建一个数据源对象\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();\n    //2. 通过配置文件(mysql.properties)获取相关连接的信息\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\mysql.properties&quot;));\n    //读取相关属性值\n    String user = properties.getProperty(&quot;user&quot;);\n    String password = properties.getProperty(&quot;password&quot;);\n    String url = properties.getProperty(&quot;url&quot;);\n    String diver = properties.getProperty(&quot;diver&quot;);\n\n    //给数据源 comboPooledDataSource 设置相关参数\n    //注意: 连接管理是由 comboPooledDataSource 来管理\n    comboPooledDataSource.setDriverClass(diver);\n    comboPooledDataSource.setJdbcUrl(url);\n    comboPooledDataSource.setUser(user);\n    comboPooledDataSource.setPassword(password);\n\n    //设置初始化连接数\n    comboPooledDataSource.setInitialPoolSize(10);\n    //设置最大连接数\n    comboPooledDataSource.setMaxPoolSize(50);\n    //测试连接池的效率、测试对mysql 5000次操作\n    long start = System.currentTimeMillis(); //开始时间\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //得到连接池的连接\n        Connection connection = comboPooledDataSource.getConnection(); //从DataSource接口实现的连接\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;C3P0 5000次连接mysql耗时: &quot; + (end- start)); //C3P0 5000次连接mysql耗时: 509\n&#125;方式二: 使用配置文件模板来完成1、将C3P0提供的c3p0.config.xml文件拷贝到src目录下\n2、该文件指定了连接数据库和连接池的相关参数\n3、在xml中配置好参数\njava//方式二: 使用配置文件模板来完成\n//1. 将c3p0提供的c3p0.config.xml拷贝到src目录下\n//2. 该文件指定了连接数据库和连接池的相关参数\npublic void testC3P0_02() throws SQLException &#123;\n    ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(&quot;hsp_edu&quot;);\n    long start = System.currentTimeMillis(); //开始时间\n    //测试5000次连接mysql\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //直接连接\n        Connection connection = comboPooledDataSource.getConnection();\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis(); //结束时间\n    System.out.println(&quot;C3P0方式二 5000次连接mysql耗时: &quot; + (end -start)); //C3P0方式二 5000次连接mysql耗时: 461\n&#125;\nDruid(德鲁伊)数据库连接池1.使用Druid数据库连接池的准备工作1.添加jar包并且添加到库里。 加入配置文件druid.properties文件到src目录下\n2.配置druid.properties的参数\n2.使用Druid数据库连接池(代码实现)javapublic void testDruid() throws Exception &#123;\n    //1. 加入Druid jar包\n    //2. 加入配置文件 druid.properties, 将该文件拷贝项目的src目录\n    //3. 创建Properties对象,读取配置文件\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));\n    //4. 创建一个指定参数的数据库连接池, Druid连接池\n    DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n    long start = System.currentTimeMillis();\n    for (int i = 0; i &lt; 5000; i++) &#123;\n        //获取连接\n        Connection connection = dataSource.getConnection();\n        //System.out.println(&quot;连接成功&quot;);\n        connection.close();\n    &#125;\n    long end = System.currentTimeMillis();\n    System.out.println(&quot;Druid连接池的耗时: &quot; + (end - start)); //Druid连接池的耗时: 603\n&#125;\nApache-DBUtils1.问题提出:1、关闭connection后，resultSet结果集无法使用\n2、resultSet不利于数据的管理\n3、示意图 \n因此将结果集记录封装到ArrayList&lt;&gt;集合中方便数据的管理和使用\n\n2.基本介绍\n3.准备工作略: 引入commons-dbutils-1.3.jar包到libs目录下并添加到库中\n4.代码实现​\t(要确保mysql中设置的类型和Actor类中对象类型保持一致,否则会报错)\n1、查询多行记录(返回ArrayList集合)​\t\t使用的是new BeanListHandler&lt;&gt;(Actor.class)\n​\t\t解读queryRunner.query\n(1) query方法就是执行一个sql语句得到一个resultset –封装到 –&gt; ArrayList集合中(2) 返回集合(3) connection: 连接(4) sql: 执行的sql语句(5) new BeanListHandler&lt;&gt;(Actor.class): 将resultset -取出-&gt; Actor对象 -封装-&gt; ArraryList集合.底层使用反射机制 去获取Actor类的属性,然后封装(6) 1: 就是给sql中的?赋值,可以有多个值(例如1,2,3) 因为是可变参数Object… params(7) 底层得到的resultset,会在query方法关闭,还会关闭PreparedStatement\njava//使用apache-DBUtils工具类 + druid完成对表的crud操作\npublic void testQueryMany() throws SQLException &#123; //返回结果是多行的情况\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 就可以执行相关的方法,返回ArrayList 结果集\n    String sql = &quot;select * from actor where id &gt;= 1&quot;;\n    //解读:\n    //(1) query方法就是执行一个sql语句得到一个resultset --封装到 --&gt; ArrayList集合中\n    //(2) 返回集合\n    //(3) connection: 连接\n    //(4) sql: 执行的sql语句\n    //(5) new BeanListHandler&lt;&gt;(Actor.class): 将resultset -取出-&gt; Actor对象 -封装-&gt; ArraryList集合\n    //    底层使用反射机制 去获取Actor类的属性,然后封装\n    //(6) 1: 就是给sql中的?赋值,可以有多个值(例如1,2,3) 因为是可变参数Object... params\n    //(7) 底层得到的resultset,会在query方法关闭,还会关闭PreparedStatement\n    List&lt;Actor&gt; list =\n            queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(Actor.class));\n    //迭代器遍历\n    System.out.println(&quot;输出集合的信息&quot;);\n    for (Actor actor : list) &#123;\n        System.out.println(actor);\n    &#125;\n    \n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;​\t\t输出结果\ntxt输出集合的信息\nActor&#123;id=1, name=&#39;蘑菇&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;\nActor&#123;id=2, name=&#39;刘德华&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;2、查询单行记录(返回单个对象)​\t\t使用的是new BeanHandler&lt;&gt;(Actor.class) \n​\t\t如果没有查到的话，输出actor返回的是 null\njava//演示apache-dbutils + druid 完成 返回的结果是单行记录(单个对象)\npublic void testQuerySingle() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 执行相关方法,返回单个对象\n    String sql = &quot;select * from actor where id = ?&quot;;\n    //解读:\n    //因为返回的是单行记录&lt;--&gt;单个对象, 使用的是Handler 是BeanHandler\n    Actor actor = queryRunner.query(connection, sql, new BeanHandler&lt;&gt;(Actor.class), 1);\n    System.out.println(actor);\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;​\t\t输出结果\ntxtActor&#123;id=1, name=&#39;蘑菇&#39;, sex=&#39;男&#39;, borndate=1970-11-11, phone=&#39;110&#39;&#125;3、查询单行单列(返回Object)​\t\t使用的是new ScalarHandler()\t输出结果:略\njava//演示apache-dbutils + druid 完成查询结果是单行单列-返回的是object\npublic void testScalar() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n    //4. 执行相关方法,返回单行单列,返回的是object\n    String sql = &quot;select name from actor where id = ?&quot;;\n    //解读: 因为返回的是一个对象, 使用的handler 是 ScalarHandler\n    Object object = queryRunner.query(connection, sql, new ScalarHandler(), 1);\n    System.out.println(object);\n\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;4、DML语句操作​\t\t使用的是queryRunner.update()\n​\t\t注意事项: “小明”, 1 是用来替换 sql 中的 ? \njava//演示apache-dbutils + druid 完成 dml (update, insert, delete)\npublic void testDML() throws SQLException &#123;\n    //1. 得到连接(druid)\n    Connection connection = JDBCUtilsByDruid.getConnection();\n    //2. 使用DBUtils类和接口,先引入DBUtils相关的jar文件,加入到本Project\n    //3. 创建QueryRunner\n    QueryRunner queryRunner = new QueryRunner();\n\n    //4. 这里组织sql 完成 updatae, insert, delete(此处只演示update)\n    String sql = &quot;update actor set name = ? where id = ?&quot;;\n    //解读:\n    //(1) 执行dml 操作是queryRunner.update()\n    //(2) 返回的值是受影响的行数\n    int affectedRow = queryRunner.update(connection, sql, &quot;小明&quot;, 1);\n    System.out.println(affectedRow &gt; 0 ? &quot;执行成功&quot; : &quot;执行sql没有影响到表&quot;);\n\n    //释放资源\n    JDBCUtilsByDruid.close(null, null, connection);\n&#125;\n表和JavaBean类型的映射关系\n\nBasicDaoDAO和增删改查的通用方法-BasicDao\n1.问题提出apache-dbutils+Druid简化了JDBC开发，但还有不足:\n1、SQL语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查。\n2、对应select操作，如果有返回值，返回类型不能固定，需要使用泛型。\n3、将来的表很多，业务需求复杂，不可能只靠一个java类完成。\n4、引出&#x3D;》 BasicDAO\n2.简单的BasicDAO示意图\n\n3.基本说明1、DAO: data access object数据访问对象\n2、这样的通用类，称为BasicDao，是专门和数据库交互的，即完成对数据库(表)的crud操作。\n3、在BaiscDao的基础上，实现一张表对应一个Dao，更好的完成功能。(比如Cusromer表-下面是代码演示)\n4.代码实现1、简单设计1.com.dao_.utils &#x2F;&#x2F;工具类\n2.com.dao_.domain &#x2F;&#x2F;javabean\n3.com.dao_.dao &#x2F;&#x2F;存放XxxDAO 和BasicDAO\n4.com.dao_.test &#x2F;&#x2F;写测试类\n2、utils包​\t\t使用了druid数据库连接池\njavapackage com.dao_.utils;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\n/**\n * 基于druid数据库连接池的工具类\n */\npublic class JDBCUtilsByDruid &#123;\n    private static DataSource ds;\n    //在静态代码块完成ds的初始化\n    static &#123;\n        Properties properties = new Properties();\n        try &#123;\n            properties.load(new FileInputStream(&quot;src\\\\druid.properties&quot;));\n            ds = DruidDataSourceFactory.createDataSource(properties);\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n    //编写getConnection方法\n    public static Connection getConnection() throws SQLException &#123;\n        return ds.getConnection();\n    &#125;\n    //关闭连接  在数据库连接池中,close方法不是真正断掉连接\n    // 而是把使用的Connection对象放回连接池\n    public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;\n        try &#123;\n            if(resultSet != null) &#123;\n                resultSet.close();\n            &#125;\n            if(statement != null) &#123;\n                statement.close();\n            &#125;\n            if(connection != null) &#123;\n                connection.close();\n            &#125;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;\n&#125;3、domain包javapackage com.dao_.domain;\n\nimport java.util.Date;\n\n/**\n * Actor对象和actor表的记录对应\n */\npublic class Actor &#123; //Javaben, POJO, Domain对象\n    private Integer id;\n    private String name;\n    private String sex;\n    private Date borndate;\n    private String phone;\n\n    public Actor() &#123; //一定要给一个无参构造器[反射需要]\n    &#125;\n\n    public Actor(Integer id, String name, String sex, Date borndate, String phone) &#123;\n        this.id = id;\n        this.name = name;\n        this.sex = sex;\n        this.borndate = borndate;\n        this.phone = phone;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public String getSex() &#123;\n        return sex;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    public Date getBorndate() &#123;\n        return borndate;\n    &#125;\n\n    public void setBorndate(Date borndate) &#123;\n        this.borndate = borndate;\n    &#125;\n\n    public String getPhone() &#123;\n        return phone;\n    &#125;\n\n    public void setPhone(String phone) &#123;\n        this.phone = phone;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Actor&#123;&quot; +\n                &quot;id=&quot; + id +\n                &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, sex=&#39;&quot; + sex + &#39;\\&#39;&#39; +\n                &quot;, borndate=&quot; + borndate +\n                &quot;, phone=&#39;&quot; + phone + &#39;\\&#39;&#39; +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;4、dao包注意: 每个方法中返回不同类型的值所调用的API不同\n​\t\tBasicDAO类: 是其他DAO的父类 \njavapackage com.dao_.dao;\n\nimport com.JDBC.utils.JDBCUtilsByDruid;\nimport org.apache.commons.dbutils.QueryRunner;\nimport org.apache.commons.dbutils.handlers.BeanHandler;\nimport org.apache.commons.dbutils.handlers.BeanListHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.List;\n\n/**\n * 开发BasicDAO,是其他DAO的父类\n */\npublic class BasicDAO&lt;T&gt; &#123; //泛型指定具体类型\n    private QueryRunner qr = new QueryRunner();\n    //开发通用dml方法，针对任意的表\n    public int update(String sql, Object... parameters) &#123; //sql语句， 参数\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            //返回受影响的行数\n            int update = qr.update(connection, sql, parameters);\n            return update;\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //返回多个对象(即查询的结果是多行),针对任意表\n    /**\n     * @param sql sql语句,可以有?\n     * @param clazz 传入一个类的Class对象,比如Actor.class\n     * @param parameters 传入?的具体的值,可以是多个\n     * @return 根据Actor.class 返回对应的ArrayList集合\n     */\n    public List&lt;T&gt; queryMulti(String sql, Class&lt;T&gt; clazz, Object...parameters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanListHandler&lt;T&gt;(clazz), parameters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行结果的通用方法\n    public T querySingle(String sql, Class&lt;T&gt; clazz, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new BeanHandler&lt;T&gt;(clazz), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n    //查询单行单列的方法,即返回单值的方法\n    public Object queryScaler(String sql, Object...paramenters) &#123;\n        Connection connection = null;\n        try &#123;\n            connection = JDBCUtilsByDruid.getConnection();\n            return qr.query(connection, sql, new ScalarHandler(), paramenters);\n        &#125; catch (SQLException e) &#123;\n            throw new RuntimeException(e);\n        &#125; finally &#123;\n            JDBCUtilsByDruid.close(null, null, connection);\n        &#125;\n    &#125;\n&#125;​\t\tActorDAO类: 继承BasicDAO类\njavapackage com.dao_.dao;\n\nimport com.dao_.domain.Actor;\n\npublic class ActorDAO extends BasicDAO&lt;Actor&gt; &#123;\n    //1. 继承拥有BasicDAO的方法\n    //2. 根据业务需要，可以编写特有的方法\n&#125;5、testdao包在DAO包底层会自动把连接关闭 JDBCUtilsByDruid.close(null, null, connection);\n​\t\tTestDAO类: 演示如何使用ActorDAO对actor表进行crud操作\njavapackage com.dao_.test;\n\nimport com.dao_.dao.ActorDAO;\nimport com.dao_.domain.Actor;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\npublic class TestDAO &#123;\n    @Test\n    //测试ActorDAO 对actor表的crud操作\n    public void testActorDAO() &#123;\n        ActorDAO actorDAO = new ActorDAO();\n        //1. 查询\n        List&lt;Actor&gt; actors = actorDAO.queryMulti(&quot;select * from actor where id &gt;= ?&quot;, Actor.class, 1);\n        System.out.println(&quot;==查询结果==&quot;);\n        for (Actor actor : actors) &#123;\n            System.out.println(actor);\n        &#125;\n        //2. 查询单行记录\n        Actor actor = actorDAO.querySingle(&quot;select * from actor where id = ?&quot;, Actor.class, 2);\n        System.out.println(&quot;==查询单行结果==&quot;);\n        System.out.println(actor);\n        //3. 查询单行单列\n        Object object = actorDAO.queryScaler(&quot;select name from actor where id = ?&quot;, 1);\n        System.out.println(&quot;==查询单行单列结果==&quot;);\n        System.out.println(object);\n        //4. dml操作 insert,update, delete\n        int update = actorDAO.update(&quot;insert into actor values(null, ?, ?, ?, ?)&quot;, &quot;张飞&quot;, &quot;男&quot;, &quot;2000-11-11&quot;, &quot;9999&quot;);\n        System.out.println(update &gt; 0 ? &quot;执行成功&quot; : &quot;执行没有影响表&quot;);\n    &#125;\n&#125;","slug":"Mysql章节JDBC和数据库连接池","date":"2023-11-23T15:28:20.000Z","categories_index":"Mysql","tags_index":"Mysql","author_index":"白"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deploy\nMore info: Deployment\n\n\n\n\n\n\n\n\n\n引用\n\n 任务列表\n\n\n有序列表\n3\n\n\n无须列表\n1\n\n[^脚注]: \n[链接引用]: \n[TOC]\n","slug":"hello-world","date":"2023-11-21T11:10:22.100Z","categories_index":"","tags_index":"","author_index":"白"}]